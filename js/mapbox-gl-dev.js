(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.mapboxgl = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

var featureFilter = require('feature-filter');

var StyleDeclarationSet = require('../style/style_declaration_set');
var LayoutProperties = require('../style/layout_properties');
var ElementGroups = require('./element_groups');
var Buffer = require('./buffer');

module.exports = Bucket;

/**
 * Instantiate the appropriate subclass of `Bucket` for `options`.
 * @private
 * @param options See `Bucket` constructor options
 * @returns {Bucket}
 */
Bucket.create = function(options) {
    var Classes = {
        fill: require('./fill_bucket'),
        line: require('./line_bucket'),
        circle: require('./circle_bucket'),
        symbol: require('./symbol_bucket')
    };
    return new Classes[options.layer.type](options);
};

Bucket.AttributeType = Buffer.AttributeType;

/**
 * The `Bucket` class builds a set of `Buffer`s for a set of vector tile
 * features.
 *
 * `Bucket` is an abstract class. A subclass exists for each Mapbox GL
 * style spec layer type. Because `Bucket` is an abstract class,
 * instances should be created via the `Bucket.create` method.
 *
 * For performance reasons, `Bucket` creates its "add"s methods at
 * runtime using `new Function(...)`.
 *
 * @class Bucket
 * @private
 * @param options
 * @param {number} options.zoom Zoom level of the buffers being built. May be
 *     a fractional zoom level.
 * @param options.layer A Mapbox GL style layer object
 * @param {Object.<string, Buffer>} options.buffers The set of `Buffer`s being
 *     built for this tile. This object facilitates sharing of `Buffer`s be
       between `Bucket`s.
 */
function Bucket(options) {
    this.layer = options.layer;
    this.zoom = options.zoom;

    this.layers = [this.layer.id];
    this.type = this.layer.type;
    this.features = [];
    this.id = this.layer.id;
    this['source-layer'] = this.layer['source-layer'];
    this.interactive = this.layer.interactive;
    this.minZoom = this.layer.minzoom;
    this.maxZoom = this.layer.maxzoom;
    this.filter = featureFilter(this.layer.filter);

    this.layoutProperties = createLayoutProperties(this.layer, this.zoom);

    this.resetBuffers(options.buffers);

    for (var shaderName in this.shaders) {
        var shader = this.shaders[shaderName];
        this[this.getAddMethodName(shaderName, 'vertex')] = createVertexAddMethod(
            shaderName,
            shader,
            this.getBufferName(shaderName, 'vertex')
        );
    }
}

/**
 * Build the buffers! Features are set directly to the `features` property.
 * @private
 */
Bucket.prototype.addFeatures = function() {
    for (var i = 0; i < this.features.length; i++) {
        this.addFeature(this.features[i]);
    }
};

/**
 * Check if there is enough space available in the current element group for
 * `vertexLength` vertices. If not, append a new elementGroup. Should be called
 * by `addFeatures` and its callees.
 * @private
 * @param {string} shaderName the name of the shader associated with the buffer that will receive the vertices
 * @param {number} vertexLength The number of vertices that will be inserted to the buffer.
 */
Bucket.prototype.makeRoomFor = function(shaderName, vertexLength) {
    return this.elementGroups[shaderName].makeRoomFor(vertexLength);
};

/**
 * Start using a new shared `buffers` object and recreate instances of `Buffer`
 * as necessary.
 * @private
 * @param {Object.<string, Buffer>} buffers
 */
Bucket.prototype.resetBuffers = function(buffers) {
    this.buffers = buffers;
    this.elementGroups = {};

    for (var shaderName in this.shaders) {
        var shader = this.shaders[shaderName];

        var vertexBufferName = this.getBufferName(shaderName, 'vertex');
        if (shader.vertexBuffer && !buffers[vertexBufferName]) {
            buffers[vertexBufferName] = new Buffer({
                type: Buffer.BufferType.VERTEX,
                attributes: shader.attributes
            });
        }

        if (shader.elementBuffer) {
            var elementBufferName = this.getBufferName(shaderName, 'element');
            if (!buffers[elementBufferName]) {
                buffers[elementBufferName] = createElementBuffer(shader.elementBufferComponents);
            }
            this[this.getAddMethodName(shaderName, 'element')] = createElementAddMethod(this.buffers[elementBufferName]);
        }

        if (shader.secondElementBuffer) {
            var secondElementBufferName = this.getBufferName(shaderName, 'secondElement');
            if (!buffers[secondElementBufferName]) {
                buffers[secondElementBufferName] = createElementBuffer(shader.secondElementBufferComponents);
            }
            this[this.getAddMethodName(shaderName, 'secondElement')] = createElementAddMethod(this.buffers[secondElementBufferName]);
        }

        this.elementGroups[shaderName] = new ElementGroups(
            buffers[this.getBufferName(shaderName, 'vertex')],
            buffers[this.getBufferName(shaderName, 'element')],
            buffers[this.getBufferName(shaderName, 'secondElement')]
        );
    }
};

/**
 * Get the name of the method used to add an item to a buffer.
 * @param {string} shaderName The name of the shader that will use the buffer
 * @param {string} type One of "vertex", "element", or "secondElement"
 * @returns {string}
 */
Bucket.prototype.getAddMethodName = function(shaderName, type) {
    return 'add' + capitalize(shaderName) + capitalize(type);
};

/**
 * Get the name of a buffer.
 * @param {string} shaderName The name of the shader that will use the buffer
 * @param {string} type One of "vertex", "element", or "secondElement"
 * @returns {string}
 */
Bucket.prototype.getBufferName = function(shaderName, type) {
    return shaderName + capitalize(type);
};

function createLayoutProperties(layer, zoom) {
    var values = new StyleDeclarationSet('layout', layer.type, layer.layout, {}).values();
    var fakeZoomHistory = { lastIntegerZoom: Infinity, lastIntegerZoomTime: 0, lastZoom: 0 };

    var layout = {};
    for (var k in values) {
        layout[k] = values[k].calculate(zoom, fakeZoomHistory);
    }

    if (layer.type === 'symbol') {
        // To reduce the number of labels that jump around when zooming we need
        // to use a text-size value that is the same for all zoom levels.
        // This calculates text-size at a high zoom level so that all tiles can
        // use the same value when calculating anchor positions.
        if (values['text-size']) {
            layout['text-max-size'] = values['text-size'].calculate(18, fakeZoomHistory);
            layout['text-size'] = values['text-size'].calculate(zoom + 1, fakeZoomHistory);
        }
        if (values['icon-size']) {
            layout['icon-max-size'] = values['icon-size'].calculate(18, fakeZoomHistory);
            layout['icon-size'] = values['icon-size'].calculate(zoom + 1, fakeZoomHistory);
        }
    }

    return new LayoutProperties[layer.type](layout);
}

var createVertexAddMethodCache = {};
function createVertexAddMethod(shaderName, shader, bufferName) {
    var pushArgs = [];
    for (var i = 0; i < shader.attributes.length; i++) {
        pushArgs = pushArgs.concat(shader.attributes[i].value);
    }

    var body = 'return this.buffers.' + bufferName + '.push(' + pushArgs.join(', ') + ');';

    if (!createVertexAddMethodCache[body]) {
        createVertexAddMethodCache[body] = new Function(shader.attributeArgs, body);
    }

    return createVertexAddMethodCache[body];
}

function createElementAddMethod(buffer) {
    return function(one, two, three) {
        return buffer.push(one, two, three);
    };
}

function createElementBuffer(components) {
    return new Buffer({
        type: Buffer.BufferType.ELEMENT,
        attributes: [{
            name: 'vertices',
            components: components || 3,
            type: Buffer.ELEMENT_ATTRIBUTE_TYPE
        }]
    });
}

function capitalize(string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
}

},{"../style/layout_properties":42,"../style/style_declaration_set":48,"./buffer":2,"./circle_bucket":3,"./element_groups":4,"./fill_bucket":6,"./line_bucket":7,"./symbol_bucket":8,"feature-filter":102}],2:[function(require,module,exports){
'use strict';

// Note: all "sizes" are measured in bytes

var assert = require('assert');

/**
 * The `Buffer` class is responsible for managing one instance of `ArrayBuffer`. `ArrayBuffer`s
 * provide low-level read/write access to a chunk of memory. `ArrayBuffer`s are populated with
 * per-vertex data, uploaded to the GPU, and used in rendering.
 *
 * `Buffer` provides an abstraction over `ArrayBuffer`, making it behave like an array of
 * statically typed structs. A buffer is comprised of items. An item is comprised of a set of
 * attributes. Attributes are defined when the class is constructed.
 *
 * @class Buffer
 * @private
 * @param options
 * @param {BufferType} options.type
 * @param {Array.<BufferAttribute>} options.attributes
 */
function Buffer(options) {

    this.type = options.type;

    // Clone an existing Buffer
    if (options.arrayBuffer) {

        this.capacity = options.capacity;
        this.arrayBuffer = options.arrayBuffer;
        this.attributes = options.attributes;
        this.itemSize = options.itemSize;
        this.length = options.length;

    // Create a new Buffer
    } else {

        this.capacity = align(Buffer.CAPACITY_DEFAULT, Buffer.CAPACITY_ALIGNMENT);
        this.arrayBuffer = new ArrayBuffer(this.capacity);
        this.attributes = [];
        this.itemSize = 0;
        this.length = 0;

        // Vertex buffer attributes must be aligned to word boundaries but
        // element buffer attributes do not need to be aligned.
        var attributeAlignment = this.type === Buffer.BufferType.VERTEX ? Buffer.VERTEX_ATTRIBUTE_ALIGNMENT : 1;

        this.attributes = options.attributes.map(function(attributeOptions) {
            var attribute = {};

            attribute.name = attributeOptions.name;
            attribute.components = attributeOptions.components || 1;
            attribute.type = attributeOptions.type || Buffer.AttributeType.UNSIGNED_BYTE;
            attribute.size = attribute.type.size * attribute.components;
            attribute.offset = this.itemSize;

            this.itemSize = align(attribute.offset + attribute.size, attributeAlignment);

            assert(!isNaN(this.itemSize));
            assert(!isNaN(attribute.size));
            assert(attribute.type.name in Buffer.AttributeType);

            return attribute;
        }, this);

        // These are expensive calls. Because we only push things to buffers in
        // the worker thread, we can skip in the "clone an existing buffer" case.
        this._createPushMethod();
        this._refreshViews();
    }
}

/**
 * Bind this buffer to a WebGL context.
 * @private
 * @param gl The WebGL context
 */
Buffer.prototype.bind = function(gl) {
    var type = gl[this.type];

    if (!this.buffer) {
        this.buffer = gl.createBuffer();
        gl.bindBuffer(type, this.buffer);
        gl.bufferData(type, this.arrayBuffer.slice(0, this.length * this.itemSize), gl.STATIC_DRAW);

        // dump array buffer once it's bound to gl
        this.arrayBuffer = null;
    } else {
        gl.bindBuffer(type, this.buffer);
    }
};

/**
 * Destroy the GL buffer bound to the given WebGL context
 * @private
 * @param gl The WebGL context
 */
Buffer.prototype.destroy = function(gl) {
    if (this.buffer) {
        gl.deleteBuffer(this.buffer);
    }
};

/**
 * Set the attribute pointers in a WebGL context according to the buffer's attribute layout
 * @private
 * @param gl The WebGL context
 * @param shader The active WebGL shader
 * @param {number} offset The offset of the attribute data in the currently bound GL buffer.
 */
Buffer.prototype.setAttribPointers = function(gl, shader, offset) {
    for (var i = 0; i < this.attributes.length; i++) {
        var attrib = this.attributes[i];

        gl.vertexAttribPointer(
            shader['a_' + attrib.name], attrib.components, gl[attrib.type.name],
            false, this.itemSize, offset + attrib.offset);
    }
};

/**
 * Get an item from the `ArrayBuffer`. Only used for debugging.
 * @private
 * @param {number} index The index of the item to get
 * @returns {Object.<string, Array.<number>>}
 */
Buffer.prototype.get = function(index) {
    this._refreshViews();

    var item = {};
    var offset = index * this.itemSize;

    for (var i = 0; i < this.attributes.length; i++) {
        var attribute = this.attributes[i];
        var values = item[attribute.name] = [];

        for (var j = 0; j < attribute.components; j++) {
            var componentOffset = ((offset + attribute.offset) / attribute.type.size) + j;
            values.push(this.views[attribute.type.name][componentOffset]);
        }
    }
    return item;
};

/**
 * Check that a buffer item is well formed and throw an error if not. Only
 * used for debugging.
 * @private
 * @param {number} args The "arguments" object from Buffer::push
 */
Buffer.prototype.validate = function(args) {
    var argIndex = 0;
    for (var i = 0; i < this.attributes.length; i++) {
        for (var j = 0; j < this.attributes[i].components; j++) {
            assert(!isNaN(args[argIndex++]));
        }
    }
    assert(argIndex === args.length);
};

Buffer.prototype._resize = function(capacity) {
    var old = this.views.UNSIGNED_BYTE;
    this.capacity = align(capacity, Buffer.CAPACITY_ALIGNMENT);
    this.arrayBuffer = new ArrayBuffer(this.capacity);
    this._refreshViews();
    this.views.UNSIGNED_BYTE.set(old);
};

Buffer.prototype._refreshViews = function() {
    this.views = {
        UNSIGNED_BYTE:  new Uint8Array(this.arrayBuffer),
        BYTE:           new Int8Array(this.arrayBuffer),
        UNSIGNED_SHORT: new Uint16Array(this.arrayBuffer),
        SHORT:          new Int16Array(this.arrayBuffer)
    };
};

var createPushMethodCache = {};
Buffer.prototype._createPushMethod = function() {
    var body = '';
    var argNames = [];

    body += 'var i = this.length++;\n';
    body += 'var o = i * ' + this.itemSize + ';\n';
    body += 'if (o + ' + this.itemSize + ' > this.capacity) { this._resize(this.capacity * 1.5); }\n';

    for (var i = 0; i < this.attributes.length; i++) {
        var attribute = this.attributes[i];
        var offsetId = 'o' + i;

        body += '\nvar ' + offsetId + ' = (o + ' + attribute.offset + ') / ' + attribute.type.size + ';\n';

        for (var j = 0; j < attribute.components; j++) {
            var rvalue = 'v' + argNames.length;
            var lvalue = 'this.views.' + attribute.type.name + '[' + offsetId + ' + ' + j + ']';
            body += lvalue + ' = ' + rvalue + ';\n';
            argNames.push(rvalue);
        }
    }

    body += '\nreturn i;\n';

    if (!createPushMethodCache[body]) {
        createPushMethodCache[body] = new Function(argNames, body);
    }

    this.push = createPushMethodCache[body];
};

/**
 * @typedef BufferAttribute
 * @private
 * @property {string} name
 * @property {number} components
 * @property {BufferAttributeType} type
 * @property {number} size
 * @property {number} offset
 */

/**
 * @enum {string} BufferType
 * @private
 * @readonly
 */
Buffer.BufferType = {
    VERTEX: 'ARRAY_BUFFER',
    ELEMENT: 'ELEMENT_ARRAY_BUFFER'
};

/**
 * @enum {{size: number, name: string}} BufferAttributeType
 * @private
 * @readonly
 */
Buffer.AttributeType = {
    BYTE:           { size: 1, name: 'BYTE' },
    UNSIGNED_BYTE:  { size: 1, name: 'UNSIGNED_BYTE' },
    SHORT:          { size: 2, name: 'SHORT' },
    UNSIGNED_SHORT: { size: 2, name: 'UNSIGNED_SHORT' }
};

/**
 * An `BufferType.ELEMENT` buffer holds indicies of a corresponding `BufferType.VERTEX` buffer.
 * These indicies are stored in the `BufferType.ELEMENT` buffer as `UNSIGNED_SHORT`s.
 *
 * @property {BufferAttributeType}
 * @private
 * @readonly
 */
Buffer.ELEMENT_ATTRIBUTE_TYPE = Buffer.AttributeType.UNSIGNED_SHORT;

/**
 * @property {number}
 * @private
 * @readonly
 */
Buffer.CAPACITY_DEFAULT = 8192;

/**
 * WebGL performs best if buffer sizes are aligned to 2 byte boundaries.
 * @property {number}
 * @private
 * @readonly
 */
Buffer.CAPACITY_ALIGNMENT = 2;

/**
 * WebGL performs best if vertex attribute offsets are aligned to 4 byte boundaries.
 * @property {number}
 * @private
 * @readonly
 */
Buffer.VERTEX_ATTRIBUTE_ALIGNMENT = 4;

function align(value, alignment) {
    alignment = alignment || 1;
    var remainder = value % alignment;
    if (alignment !== 1 && remainder !== 0) {
        value += (alignment - remainder);
    }
    return value;
}

module.exports = Buffer;

},{"assert":95}],3:[function(require,module,exports){
'use strict';

var Bucket = require('./bucket');
var util = require('../util/util');

module.exports = CircleBucket;

var EXTENT = 4096;

/**
 * Circles are represented by two triangles.
 *
 * Each corner has a pos that is the center of the circle and an extrusion
 * vector that is where it points.
 * @private
 */
function CircleBucket() {
    Bucket.apply(this, arguments);
}

CircleBucket.prototype = util.inherit(Bucket, {});

CircleBucket.prototype.shaders = {
    circle: {
        vertexBuffer: true,
        elementBuffer: true,

        attributeArgs: ['x', 'y', 'extrudeX', 'extrudeY'],

        attributes: [{
            name: 'pos',
            components: 2,
            type: Bucket.AttributeType.SHORT,
            value: [
                '(x * 2) + ((extrudeX + 1) / 2)',
                '(y * 2) + ((extrudeY + 1) / 2)'
            ]
        }]
    }
};

CircleBucket.prototype.addFeature = function(feature) {

    var geometries = feature.loadGeometry()[0];
    for (var j = 0; j < geometries.length; j++) {
        var group = this.makeRoomFor('circle', 4);

        var x = geometries[j].x;
        var y = geometries[j].y;

        // Do not include points that are outside the tile boundaries.
        if (x < 0 || x >= EXTENT || y < 0 || y >= EXTENT) continue;

        // this geometry will be of the Point type, and we'll derive
        // two triangles from it.
        //
        // ┌─────────┐
        // │ 3     2 │
        // │         │
        // │ 0     1 │
        // └─────────┘

        var index = this.addCircleVertex(x, y, -1, -1) - group.vertexStartIndex;
        this.addCircleVertex(x, y, 1, -1);
        this.addCircleVertex(x, y, 1, 1);
        this.addCircleVertex(x, y, -1, 1);
        group.vertexLength += 4;

        this.addCircleElement(index, index + 1, index + 2);
        this.addCircleElement(index, index + 3, index + 2);
        group.elementLength += 2;
    }

};

},{"../util/util":94,"./bucket":1}],4:[function(require,module,exports){
'use strict';

module.exports = ElementGroups;

function ElementGroups(vertexBuffer, elementBuffer, secondElementBuffer) {

    this.vertexBuffer = vertexBuffer;
    this.elementBuffer = elementBuffer;
    this.secondElementBuffer = secondElementBuffer;
    this.groups = [];
}

ElementGroups.prototype.makeRoomFor = function(numVertices) {
    if (!this.current || this.current.vertexLength + numVertices > 65535) {
        this.current = new ElementGroup(this.vertexBuffer.length,
                this.elementBuffer && this.elementBuffer.length,
                this.secondElementBuffer && this.secondElementBuffer.length);
        this.groups.push(this.current);
    }
    return this.current;
};

function ElementGroup(vertexStartIndex, elementStartIndex, secondElementStartIndex) {
    // the offset into the vertex buffer of the first vertex in this group
    this.vertexStartIndex = vertexStartIndex;
    this.elementStartIndex = elementStartIndex;
    this.secondElementStartIndex = secondElementStartIndex;
    this.elementLength = 0;
    this.vertexLength = 0;
    this.secondElementLength = 0;
}

},{}],5:[function(require,module,exports){
'use strict';

var rbush = require('rbush');
var Point = require('point-geometry');
var vt = require('vector-tile');
var util = require('../util/util');

module.exports = FeatureTree;

function FeatureTree(coord, overscaling) {
    this.x = coord.x;
    this.y = coord.y;
    this.z = coord.z - Math.log(overscaling) / Math.LN2;
    this.rtree = rbush(9);
    this.toBeInserted = [];
}

FeatureTree.prototype.insert = function(bbox, layers, feature) {
    bbox.layers = layers;
    bbox.feature = feature;
    this.toBeInserted.push(bbox);
};

// bulk insert into tree
FeatureTree.prototype._load = function() {
    this.rtree.load(this.toBeInserted);
    this.toBeInserted = [];
};

// Finds features in this tile at a particular position.
FeatureTree.prototype.query = function(args, callback) {
    if (this.toBeInserted.length) this._load();

    var params = args.params || {},
        x = args.x,
        y = args.y,
        result = [];

    var radius, bounds;
    if (typeof x !== 'undefined' && typeof y !== 'undefined') {
        // a point (or point+radius) query
        radius = (params.radius || 0) * (args.tileExtent || 4096) / args.scale;
        bounds = [x - radius, y - radius, x + radius, y + radius];
    } else {
        // a rectangle query
        bounds = [ args.minX, args.minY, args.maxX, args.maxY ];
    }

    var matching = this.rtree.search(bounds);
    for (var i = 0; i < matching.length; i++) {
        var feature = matching[i].feature,
            layers = matching[i].layers,
            type = vt.VectorTileFeature.types[feature.type];

        if (params.$type && type !== params.$type)
            continue;
        if (radius && !geometryContainsPoint(feature.loadGeometry(), type, new Point(x, y), radius))
            continue;
        else if (!geometryIntersectsBox(feature.loadGeometry(), type, bounds))
            continue;

        var geoJSON = feature.toGeoJSON(this.x, this.y, this.z);

        if (!params.includeGeometry) {
            geoJSON.geometry = null;
        }

        for (var l = 0; l < layers.length; l++) {
            var layer = layers[l];

            if (params.layerIds && params.layerIds.indexOf(layer) < 0)
                continue;

            result.push(util.extend({layer: layer}, geoJSON));
        }
    }
    callback(null, result);
};

function geometryIntersectsBox(rings, type, bounds) {
    return type === 'Point' ? pointIntersectsBox(rings, bounds) :
           type === 'LineString' ? lineIntersectsBox(rings, bounds) :
           type === 'Polygon' ? polyIntersectsBox(rings, bounds) || lineIntersectsBox(rings, bounds) : false;
}

// Tests whether any of the four corners of the bbox are contained in the
// interior of the polygon.  Otherwise, defers to lineIntersectsBox.
function polyIntersectsBox(rings, bounds) {
    if (polyContainsPoint(rings, new Point(bounds[0], bounds[1])) ||
        polyContainsPoint(rings, new Point(bounds[0], bounds[3])) ||
        polyContainsPoint(rings, new Point(bounds[2], bounds[1])) ||
        polyContainsPoint(rings, new Point(bounds[2], bounds[3])))
        return true;

    return lineIntersectsBox(rings, bounds);
}

// Only needs to cover the case where the line crosses the bbox boundary.
// Otherwise, pointIntersectsBox should have us covered.
function lineIntersectsBox(rings, bounds) {
    for (var k = 0; k < rings.length; k++) {
        var ring = rings[k];
        for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {
            var p0 = ring[i];
            var p1 = ring[j];

            // invert the segment so as to reuse segmentCrossesHorizontal for
            // checking whether it crosses the vertical sides of the bbox.
            var i0 = new Point(p0.y, p0.x);
            var i1 = new Point(p1.y, p1.x);

            if (segmentCrossesHorizontal(p0, p1, bounds[0], bounds[2], bounds[1]) ||
                segmentCrossesHorizontal(p0, p1, bounds[0], bounds[2], bounds[3]) ||
                segmentCrossesHorizontal(i0, i1, bounds[1], bounds[3], bounds[0]) ||
                segmentCrossesHorizontal(i0, i1, bounds[1], bounds[3], bounds[2]))
                return true;
        }
    }

    return pointIntersectsBox(rings, bounds);
}

/*
 * Answer whether segment p1-p2 intersects with (x1, y)-(x2, y)
 * Assumes x2 >= x1
 */
function segmentCrossesHorizontal(p0, p1, x1, x2, y) {
    if (p1.y === p0.y)
        return p1.y === y &&
            Math.min(p0.x, p1.x) <= x2 &&
            Math.max(p0.x, p1.x) >= x1;

    var r = (y - p0.y) / (p1.y - p0.y);
    var x = p0.x + r * (p1.x - p0.x);
    return (x >= x1 && x <= x2 && r <= 1 && r >= 0);
}

function pointIntersectsBox(rings, bounds) {
    for (var i = 0; i < rings.length; i++) {
        var ring = rings[i];
        for (var j = 0; j < ring.length; j++) {
            if (ring[j].x >= bounds[0] &&
                ring[j].y >= bounds[1] &&
                ring[j].x <= bounds[2] &&
                ring[j].y <= bounds[3]) return true;
        }
    }
    return false;
}

function geometryContainsPoint(rings, type, p, radius) {
    return type === 'Point' ? pointContainsPoint(rings, p, radius) :
           type === 'LineString' ? lineContainsPoint(rings, p, radius) :
           type === 'Polygon' ? polyContainsPoint(rings, p) || lineContainsPoint(rings, p, radius) : false;
}

// Code from http://stackoverflow.com/a/1501725/331379.
function distToSegmentSquared(p, v, w) {
    var l2 = v.distSqr(w);
    if (l2 === 0) return p.distSqr(v);
    var t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
    if (t < 0) return p.distSqr(v);
    if (t > 1) return p.distSqr(w);
    return p.distSqr(w.sub(v)._mult(t)._add(v));
}

function lineContainsPoint(rings, p, radius) {
    var r = radius * radius;

    for (var i = 0; i < rings.length; i++) {
        var ring = rings[i];
        for (var j = 1; j < ring.length; j++) {
            // Find line segments that have a distance <= radius^2 to p
            // In that case, we treat the line as "containing point p".
            var v = ring[j - 1], w = ring[j];
            if (distToSegmentSquared(p, v, w) < r) return true;
        }
    }
    return false;
}

// point in polygon ray casting algorithm
function polyContainsPoint(rings, p) {
    var c = false,
        ring, p1, p2;

    for (var k = 0; k < rings.length; k++) {
        ring = rings[k];
        for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {
            p1 = ring[i];
            p2 = ring[j];
            if (((p1.y > p.y) !== (p2.y > p.y)) && (p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x)) {
                c = !c;
            }
        }
    }
    return c;
}

function pointContainsPoint(rings, p, radius) {
    var r = radius * radius;

    for (var i = 0; i < rings.length; i++) {
        var ring = rings[i];
        for (var j = 0; j < ring.length; j++) {
            if (ring[j].distSqr(p) <= r) return true;
        }
    }
    return false;
}

},{"../util/util":94,"point-geometry":130,"rbush":131,"vector-tile":134}],6:[function(require,module,exports){
'use strict';

var Bucket = require('./bucket');
var util = require('../util/util');

module.exports = FillBucket;

function FillBucket() {
    Bucket.apply(this, arguments);
}

FillBucket.prototype = util.inherit(Bucket, {});

FillBucket.prototype.shaders = {
    fill: {
        vertexBuffer: true,
        elementBuffer: true,
        secondElementBuffer: true,
        secondElementBufferComponents: 2,

        attributeArgs: ['x', 'y'],

        attributes: [{
            name: 'pos',
            components: 2,
            type: Bucket.AttributeType.SHORT,
            value: ['x', 'y']
        }]
    }
};

FillBucket.prototype.addFeature = function(feature) {
    var lines = feature.loadGeometry();
    for (var i = 0; i < lines.length; i++) {
        this.addFill(lines[i]);
    }
};

FillBucket.prototype.addFill = function(vertices) {
    if (vertices.length < 3) {
        //console.warn('a fill must have at least three vertices');
        return;
    }

    // Calculate the total number of vertices we're going to produce so that we
    // can resize the buffer beforehand, or detect whether the current line
    // won't fit into the buffer anymore.
    // In order to be able to use the vertex buffer for drawing the antialiased
    // outlines, we separate all polygon vertices with a degenerate (out-of-
    // viewplane) vertex.

    var len = vertices.length;

    // Expand this geometry buffer to hold all the required vertices.
    var group = this.makeRoomFor('fill', len + 1);

    // We're generating triangle fans, so we always start with the first coordinate in this polygon.
    var firstIndex, prevIndex;
    for (var i = 0; i < vertices.length; i++) {
        var currentVertex = vertices[i];

        var currentIndex = this.addFillVertex(currentVertex.x, currentVertex.y) - group.vertexStartIndex;
        group.vertexLength++;
        if (i === 0) firstIndex = currentIndex;

        // Only add triangles that have distinct vertices.
        if (i >= 2 && (currentVertex.x !== vertices[0].x || currentVertex.y !== vertices[0].y)) {
            this.addFillElement(firstIndex, prevIndex, currentIndex);
            group.elementLength++;
        }

        if (i >= 1) {
            this.addFillSecondElement(prevIndex, currentIndex);
            group.secondElementLength++;
        }

        prevIndex = currentIndex;
    }
};

},{"../util/util":94,"./bucket":1}],7:[function(require,module,exports){
'use strict';

var Bucket = require('./bucket');
var util = require('../util/util');

// NOTE ON EXTRUDE SCALE:
// scale the extrusion vector so that the normal length is this value.
// contains the "texture" normals (-1..1). this is distinct from the extrude
// normals for line joins, because the x-value remains 0 for the texture
// normal array, while the extrude normal actually moves the vertex to create
// the acute/bevelled line join.
var EXTRUDE_SCALE = 63;

module.exports = LineBucket;

function LineBucket() {
    Bucket.apply(this, arguments);
}

LineBucket.prototype = util.inherit(Bucket, {});

LineBucket.prototype.shaders = {
    line: {
        vertexBuffer: true,
        elementBuffer: true,

        attributeArgs: ['point', 'extrude', 'tx', 'ty', 'dir', 'linesofar'],

        attributes: [{
            name: 'pos',
            components: 2,
            type: Bucket.AttributeType.SHORT,
            value: [
                '(point.x << 1) | tx',
                '(point.y << 1) | ty'
            ]
        }, {
            name: 'data',
            components: 4,
            type: Bucket.AttributeType.BYTE,
            value: [
                'Math.round(' + EXTRUDE_SCALE + ' * extrude.x)',
                'Math.round(' + EXTRUDE_SCALE + ' * extrude.y)',

                // Encode the -1/0/1 direction value into .zw coordinates of a_data, which is normally covered
                // by linesofar, so we need to merge them.
                // The z component's first bit, as well as the sign bit is reserved for the direction,
                // so we need to shift the linesofar.
                '((dir < 0) ? -1 : 1) * ((dir ? 1 : 0) | ((linesofar << 1) & 0x7F))',
                '(linesofar >> 6) & 0x7F'
            ]
        }]
    }
};

LineBucket.prototype.addFeature = function(feature) {
    var lines = feature.loadGeometry();
    var layoutProperties = this.layoutProperties;
    for (var i = 0; i < lines.length; i++) {
        this.addLine(
            lines[i],
            layoutProperties['line-join'],
            layoutProperties['line-cap'],
            layoutProperties['line-miter-limit'],
            layoutProperties['line-round-limit']
        );
    }
};

LineBucket.prototype.addLine = function(vertices, join, cap, miterLimit, roundLimit) {

    var len = vertices.length;
    // If the line has duplicate vertices at the end, adjust length to remove them.
    while (len > 2 && vertices[len - 1].equals(vertices[len - 2])) {
        len--;
    }

    if (vertices.length < 2) {
        //console.warn('a line must have at least two vertices');
        return;
    }

    if (join === 'bevel') miterLimit = 1.05;

    var firstVertex = vertices[0],
        lastVertex = vertices[len - 1],
        closed = firstVertex.equals(lastVertex);

    // we could be more precise, but it would only save a negligible amount of space
    this.makeRoomFor('line', len * 10);

    if (len === 2 && closed) {
        // console.warn('a line may not have coincident points');
        return;
    }

    var beginCap = cap,
        endCap = closed ? 'butt' : cap,
        flip = 1,
        distance = 0,
        startOfLine = true,
        currentVertex, prevVertex, nextVertex, prevNormal, nextNormal, offsetA, offsetB;

    // the last three vertices added
    this.e1 = this.e2 = this.e3 = -1;

    if (closed) {
        currentVertex = vertices[len - 2];
        nextNormal = firstVertex.sub(currentVertex)._unit()._perp();
    }

    for (var i = 0; i < len; i++) {

        nextVertex = closed && i === len - 1 ?
            vertices[1] : // if the line is closed, we treat the last vertex like the first
            vertices[i + 1]; // just the next vertex

        // if two consecutive vertices exist, skip the current one
        if (nextVertex && vertices[i].equals(nextVertex)) continue;

        if (nextNormal) prevNormal = nextNormal;
        if (currentVertex) prevVertex = currentVertex;

        currentVertex = vertices[i];

        // Calculate how far along the line the currentVertex is
        if (prevVertex) distance += currentVertex.dist(prevVertex);

        // Calculate the normal towards the next vertex in this line. In case
        // there is no next vertex, pretend that the line is continuing straight,
        // meaning that we are just using the previous normal.
        nextNormal = nextVertex ? nextVertex.sub(currentVertex)._unit()._perp() : prevNormal;

        // If we still don't have a previous normal, this is the beginning of a
        // non-closed line, so we're doing a straight "join".
        prevNormal = prevNormal || nextNormal;

        // Determine the normal of the join extrusion. It is the angle bisector
        // of the segments between the previous line and the next line.
        var joinNormal = prevNormal.add(nextNormal)._unit();

        /*  joinNormal     prevNormal
         *             ↖      ↑
         *                .________. prevVertex
         *                |
         * nextNormal  ←  |  currentVertex
         *                |
         *     nextVertex !
         *
         */

        // Calculate the length of the miter (the ratio of the miter to the width).
        // Find the cosine of the angle between the next and join normals
        // using dot product. The inverse of that is the miter length.
        var cosHalfAngle = joinNormal.x * nextNormal.x + joinNormal.y * nextNormal.y;
        var miterLength = 1 / cosHalfAngle;

        // The join if a middle vertex, otherwise the cap.
        var middleVertex = prevVertex && nextVertex;
        var currentJoin = middleVertex ? join : nextVertex ? beginCap : endCap;

        if (middleVertex && currentJoin === 'round') {
            if (miterLength < roundLimit) {
                currentJoin = 'miter';
            } else if (miterLength <= 2) {
                currentJoin = 'fakeround';
            }
        }

        if (currentJoin === 'miter' && miterLength > miterLimit) {
            currentJoin = 'bevel';
        }

        if (currentJoin === 'bevel') {
            // The maximum extrude length is 128 / 63 = 2 times the width of the line
            // so if miterLength >= 2 we need to draw a different type of bevel where.
            if (miterLength > 2) currentJoin = 'flipbevel';

            // If the miterLength is really small and the line bevel wouldn't be visible,
            // just draw a miter join to save a triangle.
            if (miterLength < miterLimit) currentJoin = 'miter';
        }

        if (currentJoin === 'miter') {

            joinNormal._mult(miterLength);
            this.addCurrentVertex(currentVertex, flip, distance, joinNormal, 0, 0, false);

        } else if (currentJoin === 'flipbevel') {
            // miter is too big, flip the direction to make a beveled join

            if (miterLength > 100) {
                // Almost parallel lines
                joinNormal = nextNormal.clone();

            } else {
                var direction = prevNormal.x * nextNormal.y - prevNormal.y * nextNormal.x > 0 ? -1 : 1;
                var bevelLength = miterLength * prevNormal.add(nextNormal).mag() / prevNormal.sub(nextNormal).mag();
                joinNormal._perp()._mult(bevelLength * direction);
            }
            this.addCurrentVertex(currentVertex, flip, distance, joinNormal, 0, 0, false);
            this.addCurrentVertex(currentVertex, -flip, distance, joinNormal, 0, 0, false);

        } else if (currentJoin === 'bevel' || currentJoin === 'fakeround') {
            var lineTurnsLeft = flip * (prevNormal.x * nextNormal.y - prevNormal.y * nextNormal.x) > 0;
            var offset = -Math.sqrt(miterLength * miterLength - 1);
            if (lineTurnsLeft) {
                offsetB = 0;
                offsetA = offset;
            } else {
                offsetA = 0;
                offsetB = offset;
            }

            // Close previous segment with a bevel
            if (!startOfLine) {
                this.addCurrentVertex(currentVertex, flip, distance, prevNormal, offsetA, offsetB, false);
            }

            if (currentJoin === 'fakeround') {
                // The join angle is sharp enough that a round join would be visible.
                // Bevel joins fill the gap between segments with a single pie slice triangle.
                // Create a round join by adding multiple pie slices. The join isn't actually round, but
                // it looks like it is at the sizes we render lines at.

                // Add more triangles for sharper angles.
                // This math is just a good enough approximation. It isn't "correct".
                var n = Math.floor((0.5 - (cosHalfAngle - 0.5)) * 8);
                var approxFractionalJoinNormal;

                for (var m = 0; m < n; m++) {
                    approxFractionalJoinNormal = nextNormal.mult((m + 1) / (n + 1))._add(prevNormal)._unit();
                    this.addPieSliceVertex(currentVertex, flip, distance, approxFractionalJoinNormal, lineTurnsLeft);
                }

                this.addPieSliceVertex(currentVertex, flip, distance, joinNormal, lineTurnsLeft);

                for (var k = n - 1; k >= 0; k--) {
                    approxFractionalJoinNormal = prevNormal.mult((k + 1) / (n + 1))._add(nextNormal)._unit();
                    this.addPieSliceVertex(currentVertex, flip, distance, approxFractionalJoinNormal, lineTurnsLeft);
                }
            }

            // Start next segment
            if (nextVertex) {
                this.addCurrentVertex(currentVertex, flip, distance, nextNormal, -offsetA, -offsetB, false);
            }

        } else if (currentJoin === 'butt') {
            if (!startOfLine) {
                // Close previous segment with a butt
                this.addCurrentVertex(currentVertex, flip, distance, prevNormal, 0, 0, false);
            }

            // Start next segment with a butt
            if (nextVertex) {
                this.addCurrentVertex(currentVertex, flip, distance, nextNormal, 0, 0, false);
            }

        } else if (currentJoin === 'square') {

            if (!startOfLine) {
                // Close previous segment with a square cap
                this.addCurrentVertex(currentVertex, flip, distance, prevNormal, 1, 1, false);

                // The segment is done. Unset vertices to disconnect segments.
                this.e1 = this.e2 = -1;
                flip = 1;
            }

            // Start next segment
            if (nextVertex) {
                this.addCurrentVertex(currentVertex, flip, distance, nextNormal, -1, -1, false);
            }

        } else if (currentJoin === 'round') {

            if (!startOfLine) {
                // Close previous segment with butt
                this.addCurrentVertex(currentVertex, flip, distance, prevNormal, 0, 0, false);

                // Add round cap or linejoin at end of segment
                this.addCurrentVertex(currentVertex, flip, distance, prevNormal, 1, 1, true);

                // The segment is done. Unset vertices to disconnect segments.
                this.e1 = this.e2 = -1;
                flip = 1;
            }


            // Start next segment with a butt
            if (nextVertex) {
                // Add round cap before first segment
                this.addCurrentVertex(currentVertex, flip, distance, nextNormal, -1, -1, true);

                this.addCurrentVertex(currentVertex, flip, distance, nextNormal, 0, 0, false);
            }
        }

        startOfLine = false;
    }

};

/**
 * Add two vertices to the buffers.
 *
 * @param {Object} currentVertex the line vertex to add buffer vertices for
 * @param {number} flip -1 if the vertices should be flipped, 1 otherwise
 * @param {number} distance the distance from the beginning of the line to the vertex
 * @param {number} endLeft extrude to shift the left vertex along the line
 * @param {number} endRight extrude to shift the left vertex along the line
 * @param {boolean} round whether this is a round cap
 * @private
 */
LineBucket.prototype.addCurrentVertex = function(currentVertex, flip, distance, normal, endLeft, endRight, round) {
    var tx = round ? 1 : 0;
    var extrude;
    var group = this.elementGroups.line.current;
    group.vertexLength += 2;

    extrude = normal.mult(flip);
    if (endLeft) extrude._sub(normal.perp()._mult(endLeft));
    this.e3 = this.addLineVertex(currentVertex, extrude, tx, 0, endLeft, distance) - group.vertexStartIndex;
    if (this.e1 >= 0 && this.e2 >= 0) {
        this.addLineElement(this.e1, this.e2, this.e3);
        group.elementLength++;
    }
    this.e1 = this.e2;
    this.e2 = this.e3;

    extrude = normal.mult(-flip);
    if (endRight) extrude._sub(normal.perp()._mult(endRight));
    this.e3 = this.addLineVertex(currentVertex, extrude, tx, 1, -endRight, distance) - group.vertexStartIndex;
    if (this.e1 >= 0 && this.e2 >= 0) {
        this.addLineElement(this.e1, this.e2, this.e3);
        group.elementLength++;
    }
    this.e1 = this.e2;
    this.e2 = this.e3;
};

/**
 * Add a single new vertex and a triangle using two previous vertices.
 * This adds a pie slice triangle near a join to simulate round joins
 *
 * @param {Object} currentVertex the line vertex to add buffer vertices for
 * @param {number} flip -1 if the vertices should be flipped, 1 otherwise
 * @param {number} distance the distance from the beggining of the line to the vertex
 * @param {Object} extrude the offset of the new vertex from the currentVertex
 * @param {boolean} whether the line is turning left or right at this angle
 * @private
 */
LineBucket.prototype.addPieSliceVertex = function(currentVertex, flip, distance, extrude, lineTurnsLeft) {
    var ty = lineTurnsLeft ? 1 : 0;
    extrude = extrude.mult(flip * (lineTurnsLeft ? -1 : 1));
    var group = this.elementGroups.line.current;

    this.e3 = this.addLineVertex(currentVertex, extrude, 0, ty, 0, distance) - group.vertexStartIndex;
    group.vertexLength++;

    if (this.e1 >= 0 && this.e2 >= 0) {
        this.addLineElement(this.e1, this.e2, this.e3);
        group.elementLength++;
    }

    if (lineTurnsLeft) {
        this.e2 = this.e3;
    } else {
        this.e1 = this.e3;
    }
};

},{"../util/util":94,"./bucket":1}],8:[function(require,module,exports){
'use strict';

var Point = require('point-geometry');

var Bucket = require('./bucket');
var ElementGroups = require('./element_groups');
var Anchor = require('../symbol/anchor');
var getAnchors = require('../symbol/get_anchors');
var resolveTokens = require('../util/token');
var Quads = require('../symbol/quads');
var Shaping = require('../symbol/shaping');
var resolveText = require('../symbol/resolve_text');
var mergeLines = require('../symbol/mergelines');
var shapeText = Shaping.shapeText;
var shapeIcon = Shaping.shapeIcon;
var getGlyphQuads = Quads.getGlyphQuads;
var getIconQuads = Quads.getIconQuads;
var clipLine = require('../symbol/clip_line');
var util = require('../util/util');

var CollisionFeature = require('../symbol/collision_feature');

module.exports = SymbolBucket;

function SymbolBucket(options) {
    Bucket.apply(this, arguments);
    this.collisionDebug = options.collisionDebug;
    this.overscaling = options.overscaling;
}

SymbolBucket.prototype = util.inherit(Bucket, {});

var shaderAttributeArgs = ['x', 'y', 'ox', 'oy', 'tx', 'ty', 'minzoom', 'maxzoom', 'labelminzoom'];

var shaderAttributes = [{
    name: 'pos',
    components: 2,
    type: Bucket.AttributeType.SHORT,
    value: ['x', 'y']
}, {
    name: 'offset',
    components: 2,
    type: Bucket.AttributeType.SHORT,
    value: [
        'Math.round(ox * 64)', // use 1/64 pixels for placement
        'Math.round(oy * 64)'
    ]
}, {
    name: 'data1',
    components: 4,
    type: Bucket.AttributeType.UNSIGNED_BYTE,
    value: [
        'tx / 4',                   // tex
        'ty / 4',                   // tex
        '(labelminzoom || 0) * 10', // labelminzoom
        '0'
    ]
}, {
    name: 'data2',
    components: 2,
    type: Bucket.AttributeType.UNSIGNED_BYTE,
    value: [
        '(minzoom || 0) * 10',             // minzoom
        'Math.min(maxzoom || 25, 25) * 10' // minzoom
    ]
}];

SymbolBucket.prototype.shaders = {

    glyph: {
        vertexBuffer: true,
        elementBuffer: true,
        attributeArgs: shaderAttributeArgs,
        attributes: shaderAttributes
    },

    icon: {
        vertexBuffer: true,
        elementBuffer: true,
        attributeArgs: shaderAttributeArgs,
        attributes: shaderAttributes
    },

    collisionBox: {
        vertexBuffer: 'collisionBoxVertex',

        attributeArgs: ['point', 'extrude', 'maxZoom', 'placementZoom'],

        attributes: [{
            name: 'pos',
            components: 2,
            type: Bucket.AttributeType.SHORT,
            value: [ 'point.x', 'point.y' ]
        }, {
            name: 'extrude',
            components: 2,
            type: Bucket.AttributeType.SHORT,
            value: [
                'Math.round(extrude.x)',
                'Math.round(extrude.y)'
            ]
        }, {
            name: 'data',
            components: 2,
            type: Bucket.AttributeType.UNSIGNED_BYTE,
            value: [
                'maxZoom * 10',
                'placementZoom * 10'
            ]
        }]
    }
};

SymbolBucket.prototype.addFeatures = function(collisionTile, stacks, icons) {
    var tileSize = 512 * this.overscaling;
    var tileExtent = 4096;
    this.tilePixelRatio = tileExtent / tileSize;
    this.compareText = {};
    this.symbolInstances = [];
    this.iconsNeedLinear = false;

    var layout = this.layoutProperties;
    var features = this.features;
    var textFeatures = this.textFeatures;

    var horizontalAlign = 0.5,
        verticalAlign = 0.5;

    switch (layout['text-anchor']) {
    case 'right':
    case 'top-right':
    case 'bottom-right':
        horizontalAlign = 1;
        break;
    case 'left':
    case 'top-left':
    case 'bottom-left':
        horizontalAlign = 0;
        break;
    }

    switch (layout['text-anchor']) {
    case 'bottom':
    case 'bottom-right':
    case 'bottom-left':
        verticalAlign = 1;
        break;
    case 'top':
    case 'top-right':
    case 'top-left':
        verticalAlign = 0;
        break;
    }

    var justify = layout['text-justify'] === 'right' ? 1 :
        layout['text-justify'] === 'left' ? 0 :
        0.5;

    var oneEm = 24;
    var lineHeight = layout['text-line-height'] * oneEm;
    var maxWidth = layout['symbol-placement'] !== 'line' ? layout['text-max-width'] * oneEm : 0;
    var spacing = layout['text-letter-spacing'] * oneEm;
    var textOffset = [layout['text-offset'][0] * oneEm, layout['text-offset'][1] * oneEm];
    var fontstack = layout['text-font'].join(',');

    var geometries = [];
    for (var g = 0; g < features.length; g++) {
        geometries.push(features[g].loadGeometry());
    }

    if (layout['symbol-placement'] === 'line') {
        // Merge adjacent lines with the same text to improve labelling.
        // It's better to place labels on one long line than on many short segments.
        var merged = mergeLines(features, textFeatures, geometries);

        geometries = merged.geometries;
        features = merged.features;
        textFeatures = merged.textFeatures;
    }

    var shapedText, shapedIcon;

    for (var k = 0; k < features.length; k++) {
        if (!geometries[k]) continue;

        if (textFeatures[k]) {
            shapedText = shapeText(textFeatures[k], stacks[fontstack], maxWidth,
                    lineHeight, horizontalAlign, verticalAlign, justify, spacing, textOffset);
        } else {
            shapedText = null;
        }

        if (layout['icon-image']) {
            var iconName = resolveTokens(features[k].properties, layout['icon-image']);
            var image = icons[iconName];
            shapedIcon = shapeIcon(image, layout);

            if (image) {
                if (this.sdfIcons === undefined) {
                    this.sdfIcons = image.sdf;
                } else if (this.sdfIcons !== image.sdf) {
                    console.warn('Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer');
                }
                if (image.pixelRatio !== 1) {
                    this.iconsNeedLinear = true;
                }
            }
        } else {
            shapedIcon = null;
        }

        if (shapedText || shapedIcon) {
            this.addFeature(geometries[k], shapedText, shapedIcon);
        }
    }

    this.placeFeatures(collisionTile, this.buffers, this.collisionDebug);
};

SymbolBucket.prototype.addFeature = function(lines, shapedText, shapedIcon) {
    var layout = this.layoutProperties;

    var glyphSize = 24;

    var fontScale = layout['text-size'] / glyphSize,
        textMaxSize = layout['text-max-size'] !== undefined ? layout['text-max-size'] : layout['text-size'],
        textBoxScale = this.tilePixelRatio * fontScale,
        textMaxBoxScale = this.tilePixelRatio * textMaxSize / glyphSize,
        iconBoxScale = this.tilePixelRatio * layout['icon-size'],
        symbolMinDistance = this.tilePixelRatio * layout['symbol-spacing'],
        avoidEdges = layout['symbol-avoid-edges'],
        textPadding = layout['text-padding'] * this.tilePixelRatio,
        iconPadding = layout['icon-padding'] * this.tilePixelRatio,
        textMaxAngle = layout['text-max-angle'] / 180 * Math.PI,
        textAlongLine = layout['text-rotation-alignment'] === 'map' && layout['symbol-placement'] === 'line',
        iconAlongLine = layout['icon-rotation-alignment'] === 'map' && layout['symbol-placement'] === 'line',
        mayOverlap = layout['text-allow-overlap'] || layout['icon-allow-overlap'] ||
            layout['text-ignore-placement'] || layout['icon-ignore-placement'],
        isLine = layout['symbol-placement'] === 'line',
        textRepeatDistance = symbolMinDistance / 2;

    if (isLine) {
        lines = clipLine(lines, 0, 0, 4096, 4096);
    }

    for (var i = 0; i < lines.length; i++) {
        var line = lines[i];

        // Calculate the anchor points around which you want to place labels
        var anchors = isLine ?
            getAnchors(line, symbolMinDistance, textMaxAngle, shapedText, shapedIcon, glyphSize, textMaxBoxScale, this.overscaling) :
            [ new Anchor(line[0].x, line[0].y, 0) ];

        // For each potential label, create the placement features used to check for collisions, and the quads use for rendering.
        for (var j = 0, len = anchors.length; j < len; j++) {
            var anchor = anchors[j];

            if (shapedText && isLine) {
                if (this.anchorIsTooClose(shapedText.text, textRepeatDistance, anchor)) {
                    continue;
                }
            }

            var inside = !(anchor.x < 0 || anchor.x > 4096 || anchor.y < 0 || anchor.y > 4096);

            if (avoidEdges && !inside) continue;

            // Normally symbol layers are drawn across tile boundaries. Only symbols
            // with their anchors within the tile boundaries are added to the buffers
            // to prevent symbols from being drawn twice.
            //
            // Symbols in layers with overlap are sorted in the y direction so that
            // symbols lower on the canvas are drawn on top of symbols near the top.
            // To preserve this order across tile boundaries these symbols can't
            // be drawn across tile boundaries. Instead they need to be included in
            // the buffers for both tiles and clipped to tile boundaries at draw time.
            var addToBuffers = inside || mayOverlap;

            this.symbolInstances.push(new SymbolInstance(anchor, line, shapedText, shapedIcon, layout, addToBuffers,
                        textBoxScale, textPadding, textAlongLine,
                        iconBoxScale, iconPadding, iconAlongLine));
        }
    }
};

SymbolBucket.prototype.anchorIsTooClose = function(text, repeatDistance, anchor) {
    var compareText = this.compareText;
    if (!(text in compareText)) {
        compareText[text] = [];
    } else {
        var otherAnchors = compareText[text];
        for (var k = otherAnchors.length - 1; k >= 0; k--) {
            if (anchor.dist(otherAnchors[k]) < repeatDistance) {
                // If it's within repeatDistance of one anchor, stop looking
                return true;
            }
        }
    }
    // If anchor is not within repeatDistance of any other anchor, add to array
    compareText[text].push(anchor);
    return false;
};

SymbolBucket.prototype.placeFeatures = function(collisionTile, buffers, collisionDebug) {
    // Calculate which labels can be shown and when they can be shown and
    // create the bufers used for rendering.

    this.resetBuffers(buffers);

    var elementGroups = this.elementGroups = {
        glyph: new ElementGroups(buffers.glyphVertex, buffers.glyphElement),
        icon: new ElementGroups(buffers.iconVertex, buffers.iconElement),
        sdfIcons: this.sdfIcons,
        iconsNeedLinear: this.iconsNeedLinear
    };

    var layout = this.layoutProperties;
    var maxScale = collisionTile.maxScale;

    elementGroups.glyph['text-size'] = layout['text-size'];
    elementGroups.glyph['text-font'] = layout['text-font'];
    elementGroups.icon['icon-size'] = layout['icon-size'];

    var textAlongLine = layout['text-rotation-alignment'] === 'map' && layout['symbol-placement'] === 'line';
    var iconAlongLine = layout['icon-rotation-alignment'] === 'map' && layout['symbol-placement'] === 'line';

    var mayOverlap = layout['text-allow-overlap'] || layout['icon-allow-overlap'] ||
        layout['text-ignore-placement'] || layout['icon-ignore-placement'];

    // Sort symbols by their y position on the canvas so that they lower symbols
    // are drawn on top of higher symbols.
    // Don't sort symbols that won't overlap because it isn't necessary and
    // because it causes more labels to pop in and out when rotating.
    if (mayOverlap) {
        var angle = collisionTile.angle;
        var sin = Math.sin(angle),
            cos = Math.cos(angle);

        this.symbolInstances.sort(function(a, b) {
            var aRotated = sin * a.x + cos * a.y;
            var bRotated = sin * b.x + cos * b.y;
            return aRotated - bRotated;
        });
    }

    for (var p = 0; p < this.symbolInstances.length; p++) {
        var symbolInstance = this.symbolInstances[p];
        var hasText = symbolInstance.hasText;
        var hasIcon = symbolInstance.hasIcon;

        var iconWithoutText = layout['text-optional'] || !hasText,
            textWithoutIcon = layout['icon-optional'] || !hasIcon;


        // Calculate the scales at which the text and icon can be placed without collision.

        var glyphScale = hasText && !layout['text-allow-overlap'] ?
            collisionTile.placeCollisionFeature(symbolInstance.textCollisionFeature) :
            collisionTile.minScale;

        var iconScale = hasIcon && !layout['icon-allow-overlap'] ?
            collisionTile.placeCollisionFeature(symbolInstance.iconCollisionFeature) :
            collisionTile.minScale;


        // Combine the scales for icons and text.

        if (!iconWithoutText && !textWithoutIcon) {
            iconScale = glyphScale = Math.max(iconScale, glyphScale);
        } else if (!textWithoutIcon && glyphScale) {
            glyphScale = Math.max(iconScale, glyphScale);
        } else if (!iconWithoutText && iconScale) {
            iconScale = Math.max(iconScale, glyphScale);
        }


        // Insert final placement into collision tree and add glyphs/icons to buffers

        if (hasText) {
            if (!layout['text-ignore-placement']) {
                collisionTile.insertCollisionFeature(symbolInstance.textCollisionFeature, glyphScale);
            }
            if (glyphScale <= maxScale) {
                this.addSymbols('glyph', symbolInstance.glyphQuads, glyphScale, layout['text-keep-upright'], textAlongLine, collisionTile.angle);
            }
        }

        if (hasIcon) {
            if (!layout['icon-ignore-placement']) {
                collisionTile.insertCollisionFeature(symbolInstance.iconCollisionFeature, iconScale);
            }
            if (iconScale <= maxScale) {
                this.addSymbols('icon', symbolInstance.iconQuads, iconScale, layout['icon-keep-upright'], iconAlongLine, collisionTile.angle);
            }
        }

    }

    if (collisionDebug) this.addToDebugBuffers(collisionTile);
};

SymbolBucket.prototype.addSymbols = function(shaderName, quads, scale, keepUpright, alongLine, placementAngle) {

    var group = this.makeRoomFor(shaderName, 4 * quads.length);

    // TODO manual curry
    var addElement = this[this.getAddMethodName(shaderName, 'element')].bind(this);
    var addVertex = this[this.getAddMethodName(shaderName, 'vertex')].bind(this);

    var zoom = this.zoom;
    var placementZoom = Math.max(Math.log(scale) / Math.LN2 + zoom, 0);

    for (var k = 0; k < quads.length; k++) {

        var symbol = quads[k],
            angle = symbol.angle;

        // drop upside down versions of glyphs
        var a = (angle + placementAngle + Math.PI) % (Math.PI * 2);
        if (keepUpright && alongLine && (a <= Math.PI / 2 || a > Math.PI * 3 / 2)) continue;

        var tl = symbol.tl,
            tr = symbol.tr,
            bl = symbol.bl,
            br = symbol.br,
            tex = symbol.tex,
            anchorPoint = symbol.anchorPoint,

            minZoom = Math.max(zoom + Math.log(symbol.minScale) / Math.LN2, placementZoom),
            maxZoom = Math.min(zoom + Math.log(symbol.maxScale) / Math.LN2, 25);

        if (maxZoom <= minZoom) continue;

        // Lower min zoom so that while fading out the label it can be shown outside of collision-free zoom levels
        if (minZoom === placementZoom) minZoom = 0;

        var index = addVertex(anchorPoint.x, anchorPoint.y, tl.x, tl.y, tex.x, tex.y, minZoom, maxZoom, placementZoom) - group.vertexStartIndex;
        addVertex(anchorPoint.x, anchorPoint.y, tr.x, tr.y, tex.x + tex.w, tex.y, minZoom, maxZoom, placementZoom);
        addVertex(anchorPoint.x, anchorPoint.y, bl.x, bl.y, tex.x, tex.y + tex.h, minZoom, maxZoom, placementZoom);
        addVertex(anchorPoint.x, anchorPoint.y, br.x, br.y, tex.x + tex.w, tex.y + tex.h, minZoom, maxZoom, placementZoom);
        group.vertexLength += 4;

        addElement(index, index + 1, index + 2);
        addElement(index + 1, index + 2, index + 3);
        group.elementLength += 2;
    }

};

SymbolBucket.prototype.updateIcons = function(icons) {
    var iconValue = this.layoutProperties['icon-image'];
    if (!iconValue) return;

    for (var i = 0; i < this.features.length; i++) {
        var iconName = resolveTokens(this.features[i].properties, iconValue);
        if (iconName)
            icons[iconName] = true;
    }
};

SymbolBucket.prototype.updateFont = function(stacks) {
    var fontName = this.layoutProperties['text-font'],
        stack = stacks[fontName] = stacks[fontName] || {};

    this.textFeatures = resolveText(this.features, this.layoutProperties, stack);
};

SymbolBucket.prototype.addToDebugBuffers = function(collisionTile) {
    this.elementGroups.collisionBox = new ElementGroups(this.buffers.collisionBoxVertex);
    var group = this.makeRoomFor('collisionBox', 8);
    var angle = -collisionTile.angle;
    var yStretch = collisionTile.yStretch;

    for (var j = 0; j < this.symbolInstances.length; j++) {
        for (var i = 0; i < 2; i++) {
            var feature = this.symbolInstances[j][i === 0 ? 'textCollisionFeature' : 'iconCollisionFeature'];
            if (!feature) continue;
            var boxes = feature.boxes;

            for (var b = 0; b < boxes.length; b++) {
                var box = boxes[b];
                var anchorPoint = box.anchorPoint;

                var tl = new Point(box.x1, box.y1 * yStretch)._rotate(angle);
                var tr = new Point(box.x2, box.y1 * yStretch)._rotate(angle);
                var bl = new Point(box.x1, box.y2 * yStretch)._rotate(angle);
                var br = new Point(box.x2, box.y2 * yStretch)._rotate(angle);

                var maxZoom = Math.max(0, Math.min(25, this.zoom + Math.log(box.maxScale) / Math.LN2));
                var placementZoom = Math.max(0, Math.min(25, this.zoom + Math.log(box.placementScale) / Math.LN2));

                this.addCollisionBoxVertex(anchorPoint, tl, maxZoom, placementZoom);
                this.addCollisionBoxVertex(anchorPoint, tr, maxZoom, placementZoom);
                this.addCollisionBoxVertex(anchorPoint, tr, maxZoom, placementZoom);
                this.addCollisionBoxVertex(anchorPoint, br, maxZoom, placementZoom);
                this.addCollisionBoxVertex(anchorPoint, br, maxZoom, placementZoom);
                this.addCollisionBoxVertex(anchorPoint, bl, maxZoom, placementZoom);
                this.addCollisionBoxVertex(anchorPoint, bl, maxZoom, placementZoom);
                this.addCollisionBoxVertex(anchorPoint, tl, maxZoom, placementZoom);
                group.vertexLength += 8;
            }
        }
    }
};

function SymbolInstance(anchor, line, shapedText, shapedIcon, layout, addToBuffers,
                        textBoxScale, textPadding, textAlongLine,
                        iconBoxScale, iconPadding, iconAlongLine) {

    this.x = anchor.x;
    this.y = anchor.y;
    this.hasText = !!shapedText;
    this.hasIcon = !!shapedIcon;

    if (this.hasText) {
        this.glyphQuads = addToBuffers ? getGlyphQuads(anchor, shapedText, textBoxScale, line, layout, textAlongLine) : [];
        this.textCollisionFeature = new CollisionFeature(line, anchor, shapedText, textBoxScale, textPadding, textAlongLine);
    }

    if (this.hasIcon) {
        this.iconQuads = addToBuffers ? getIconQuads(anchor, shapedIcon, iconBoxScale, line, layout, iconAlongLine) : [];
        this.iconCollisionFeature = new CollisionFeature(line, anchor, shapedIcon, iconBoxScale, iconPadding, iconAlongLine);
    }
}

},{"../symbol/anchor":51,"../symbol/clip_line":54,"../symbol/collision_feature":56,"../symbol/get_anchors":58,"../symbol/mergelines":61,"../symbol/quads":62,"../symbol/resolve_text":63,"../symbol/shaping":64,"../util/token":93,"../util/util":94,"./bucket":1,"./element_groups":4,"point-geometry":130}],9:[function(require,module,exports){
'use strict';

module.exports = Coordinate;

/**
 * A coordinate is a column, row, zoom combination, often used
 * as the data component of a tile.
 *
 * @param {number} column
 * @param {number} row
 * @param {number} zoom
 * @private
 */
function Coordinate(column, row, zoom) {
    this.column = column;
    this.row = row;
    this.zoom = zoom;
}

Coordinate.prototype = {

    /**
     * Create a clone of this coordinate that can be mutated without
     * changing the original coordinate
     *
     * @returns {Coordinate} clone
     * @private
     * var coord = new Coordinate(0, 0, 0);
     * var c2 = coord.clone();
     * // since coord is cloned, modifying a property of c2 does
     * // not modify it.
     * c2.zoom = 2;
     */
    clone: function() {
        return new Coordinate(this.column, this.row, this.zoom);
    },

    /**
     * Zoom this coordinate to a given zoom level. This returns a new
     * coordinate object, not mutating the old one.
     *
     * @param {number} zoom
     * @returns {Coordinate} zoomed coordinate
     * @private
     * @example
     * var coord = new Coordinate(0, 0, 0);
     * var c2 = coord.zoomTo(1);
     * c2 // equals new Coordinate(0, 0, 1);
     */
    zoomTo: function(zoom) { return this.clone()._zoomTo(zoom); },

    /**
     * Subtract the column and row values of this coordinate from those
     * of another coordinate. The other coordinat will be zoomed to the
     * same level as `this` before the subtraction occurs
     *
     * @param {Coordinate} c other coordinate
     * @returns {Coordinate} result
     * @private
     */
    sub: function(c) { return this.clone()._sub(c); },

    _zoomTo: function(zoom) {
        var scale = Math.pow(2, zoom - this.zoom);
        this.column *= scale;
        this.row *= scale;
        this.zoom = zoom;
        return this;
    },

    _sub: function(c) {
        c = c.zoomTo(this.zoom);
        this.column -= c.column;
        this.row -= c.row;
        return this;
    }
};

},{}],10:[function(require,module,exports){
'use strict';

module.exports = LngLat;

var wrap = require('../util/util').wrap;

/**
 * Create a longitude, latitude object from a given longitude and latitude pair in degrees.
 * Mapbox GL uses Longitude, Latitude coordinate order to match GeoJSON.
 *
 * Note that any Mapbox GL method that accepts a `LngLat` object can also accept an
 * `Array` and will perform an implicit conversion.  The following lines are equivalent:
 ```
 map.setCenter([-73.9749, 40.7736]);
 map.setCenter( new mapboxgl.LngLat(-73.9749, 40.7736) );
 ```
 *
 * @class LngLat
 * @classdesc A representation of a longitude, latitude point, in degrees.
 * @param {number} lng longitude
 * @param {number} lat latitude
 * @example
 * var ll = new mapboxgl.LngLat(-73.9749, 40.7736);
 */
function LngLat(lng, lat) {
    if (isNaN(lng) || isNaN(lat)) {
        throw new Error('Invalid LngLat object: (' + lng + ', ' + lat + ')');
    }
    this.lng = +lng;
    this.lat = +lat;
    if (this.lat > 90 || this.lat < -90) {
        throw new Error('Invalid LngLat latitude value: must be between -90 and 90');
    }
}

/**
 * Return a new `LngLat` object whose longitude is wrapped to the range (-180, 180).
 *
 * @returns {LngLat} wrapped LngLat object
 * @example
 * var ll = new mapboxgl.LngLat(286.0251, 40.7736);
 * var wrapped = ll.wrap();
 * wrapped.lng; // = -73.9749
 */
LngLat.prototype.wrap = function () {
    return new LngLat(wrap(this.lng, -180, 180), this.lat);
};

/**
 * Return a `LngLat` as an array
 *
 * @returns {array} [lng, lat]
 * @example
 * var ll = new mapboxgl.LngLat(-73.9749, 40.7736);
 * ll.toArray(); // = [-73.9749, 40.7736]
 */
LngLat.prototype.toArray = function () {
    return [this.lng, this.lat];
};

/**
 * Return a `LngLat` as a string
 *
 * @returns {string} "LngLat(lng, lat)"
 * @example
 * var ll = new mapboxgl.LngLat(-73.9749, 40.7736);
 * ll.toString(); // = "LngLat(-73.9749, 40.7736)"
 */
LngLat.prototype.toString = function () {
    return 'LngLat(' + this.lng + ', ' + this.lat + ')';
};

/**
 * Convert an array to a `LngLat` object, or return an existing `LngLat` object
 * unchanged.
 *
 * @param {Array<number>|LngLat} input `input` to convert
 * @returns {LngLat} LngLat object or original input
 * @example
 * var arr = [-73.9749, 40.7736];
 * var ll = mapboxgl.LngLat.convert(arr);
 * ll;   // = LngLat {lng: -73.9749, lat: 40.7736}
 */
LngLat.convert = function (input) {
    if (input instanceof LngLat) {
        return input;
    }
    if (Array.isArray(input)) {
        return new LngLat(input[0], input[1]);
    }
    return input;
};

},{"../util/util":94}],11:[function(require,module,exports){
'use strict';

module.exports = LngLatBounds;

var LngLat = require('./lng_lat');

/**
 * Creates a bounding box from the given pair of points. If parameteres are omitted, a `null` bounding box is created.
 *
 * @class LngLatBounds
 * @classdesc A representation of rectangular box on the earth, defined by its southwest and northeast points in longitude and latitude.
 * @param {LngLat} sw southwest
 * @param {LngLat} ne northeast
 * @example
 * var sw = new mapboxgl.LngLat(-73.9876, 40.7661);
 * var ne = new mapboxgl.LngLat(-73.9397, 40.8002);
 * var llb = new mapboxgl.LngLatBounds(sw, ne);
 */
function LngLatBounds(sw, ne) {
    if (!sw) {
        return;
    } else if (ne) {
        this.extend(sw).extend(ne);
    } else if (sw.length === 4) {
        this.extend([sw[0], sw[1]]).extend([sw[2], sw[3]]);
    } else {
        this.extend(sw[0]).extend(sw[1]);
    }
}

LngLatBounds.prototype = {

    /**
     * Extend the bounds to include a given LngLat or LngLatBounds.
     *
     * @param {LngLat|LngLatBounds} obj object to extend to
     * @returns {LngLatBounds} `this`
     */
    extend: function(obj) {
        var sw = this._sw,
            ne = this._ne,
            sw2, ne2;

        if (obj instanceof LngLat) {
            sw2 = obj;
            ne2 = obj;

        } else if (obj instanceof LngLatBounds) {
            sw2 = obj._sw;
            ne2 = obj._ne;

            if (!sw2 || !ne2) return this;

        } else {
            return obj ? this.extend(LngLat.convert(obj) || LngLatBounds.convert(obj)) : this;
        }

        if (!sw && !ne) {
            this._sw = new LngLat(sw2.lng, sw2.lat);
            this._ne = new LngLat(ne2.lng, ne2.lat);

        } else {
            sw.lng = Math.min(sw2.lng, sw.lng);
            sw.lat = Math.min(sw2.lat, sw.lat);
            ne.lng = Math.max(ne2.lng, ne.lng);
            ne.lat = Math.max(ne2.lat, ne.lat);
        }

        return this;
    },

    /**
     * Get the point equidistant from this box's corners
     * @returns {LngLat} centerpoint
     * @example
     * var llb = new mapboxgl.LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);
     * llb.getCenter(); // = LngLat {lng: -73.96365, lat: 40.78315}
     */
    getCenter: function() {
        return new LngLat((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
    },

    /**
     * Get southwest corner
     * @returns {LngLat} southwest
     */
    getSouthWest: function() { return this._sw; },

    /**
     * Get northeast corner
     * @returns {LngLat} northeast
     */
    getNorthEast: function() { return this._ne; },

    /**
     * Get northwest corner
     * @returns {LngLat} northwest
     */
    getNorthWest: function() { return new LngLat(this.getWest(), this.getNorth()); },

    /**
     * Get southeast corner
     * @returns {LngLat} southeast
     */
    getSouthEast: function() { return new LngLat(this.getEast(), this.getSouth()); },

    /**
     * Get west edge longitude
     * @returns {number} west
     */
    getWest:  function() { return this._sw.lng; },

    /**
     * Get south edge latitude
     * @returns {number} south
     */
    getSouth: function() { return this._sw.lat; },

    /**
     * Get east edge longitude
     * @returns {number} east
     */
    getEast:  function() { return this._ne.lng; },

    /**
     * Get north edge latitude
     * @returns {number} north
     */
    getNorth: function() { return this._ne.lat; },

    /**
     * Return a `LngLatBounds` as an array
     *
     * @returns {array} [lng, lat]
     * @example
     * var llb = new mapboxgl.LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);
     * llb.toArray(); // = [[-73.9876, 40.7661], [-73.9397, 40.8002]]
     */
    toArray: function () {
        return [this._sw.toArray(), this._ne.toArray()];
    },

    /**
     * Return a `LngLatBounds` as a string
     *
     * @returns {string} "LngLatBounds(LngLat(lng, lat), LngLat(lng, lat))"
     * @example
     * var llb = new mapboxgl.LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);
     * llb.toString(); // = "LngLatBounds(LngLat(-73.9876, 40.7661), LngLat(-73.9397, 40.8002))"
     */
    toString: function () {
        return 'LngLatBounds(' + this._sw.toString() + ', ' + this._ne.toString() + ')';
    }
};

/**
 * Convert an array to a `LngLatBounds` object, or return an existing
 * `LngLatBounds` object unchanged.
 *
 * Calls `LngLat#convert` internally to convert arrays as `LngLat` values.
 *
 * @param {LngLatBounds|Array<number>|Array<Array<number>>} input input to convert to a LngLatBounds
 * @returns {LngLatBounds} LngLatBounds object or original input
 * @example
 * var arr = [[-73.9876, 40.7661], [-73.9397, 40.8002]];
 * var llb = mapboxgl.LngLatBounds.convert(arr);
 * llb;   // = LngLatBounds {_sw: LngLat {lng: -73.9876, lat: 40.7661}, _ne: LngLat {lng: -73.9397, lat: 40.8002}}
 */
LngLatBounds.convert = function (input) {
    if (!input || input instanceof LngLatBounds) return input;
    return new LngLatBounds(input);
};

},{"./lng_lat":10}],12:[function(require,module,exports){
'use strict';

var LngLat = require('./lng_lat'),
    Point = require('point-geometry'),
    Coordinate = require('./coordinate'),
    wrap = require('../util/util').wrap,
    interp = require('../util/interpolate'),
    glmatrix = require('gl-matrix');

var vec4 = glmatrix.vec4,
    mat4 = glmatrix.mat4,
    mat2 = glmatrix.mat2;

module.exports = Transform;

/*
 * A single transform, generally used for a single tile to be
 * scaled, rotated, and zoomed.
 *
 * @param {number} minZoom
 * @param {number} maxZoom
 * @private
 */
function Transform(minZoom, maxZoom) {
    this.tileSize = 512; // constant

    this._minZoom = minZoom || 0;
    this._maxZoom = maxZoom || 22;

    this.latRange = [-85.05113, 85.05113];

    this.width = 0;
    this.height = 0;
    this._center = new LngLat(0, 0);
    this.zoom = 0;
    this.angle = 0;
    this._altitude = 1.5;
    this._pitch = 0;
    this._unmodified = true;
}

Transform.prototype = {
    get minZoom() { return this._minZoom; },
    set minZoom(zoom) {
        if (this._minZoom === zoom) return;
        this._minZoom = zoom;
        this.zoom = Math.max(this.zoom, zoom);
    },

    get maxZoom() { return this._maxZoom; },
    set maxZoom(zoom) {
        if (this._maxZoom === zoom) return;
        this._maxZoom = zoom;
        this.zoom = Math.min(this.zoom, zoom);
    },

    get worldSize() {
        return this.tileSize * this.scale;
    },

    get centerPoint() {
        return this.size._div(2);
    },

    get size() {
        return new Point(this.width, this.height);
    },

    get bearing() {
        return -this.angle / Math.PI * 180;
    },
    set bearing(bearing) {
        var b = -wrap(bearing, -180, 180) * Math.PI / 180;
        if (this.angle === b) return;
        this._unmodified = false;
        this.angle = b;
        this._calcProjMatrix();

        // 2x2 matrix for rotating points
        this.rotationMatrix = mat2.create();
        mat2.rotate(this.rotationMatrix, this.rotationMatrix, this.angle);
    },

    get pitch() {
        return this._pitch / Math.PI * 180;
    },
    set pitch(pitch) {
        var p = Math.min(60, pitch) / 180 * Math.PI;
        if (this._pitch === p) return;
        this._unmodified = false;
        this._pitch = p;
        this._calcProjMatrix();
    },

    get altitude() {
        return this._altitude;
    },
    set altitude(altitude) {
        var a = Math.max(0.75, altitude);
        if (this._altitude === a) return;
        this._unmodified = false;
        this._altitude = a;
        this._calcProjMatrix();
    },

    get zoom() { return this._zoom; },
    set zoom(zoom) {
        var z = Math.min(Math.max(zoom, this.minZoom), this.maxZoom);
        if (this._zoom === z) return;
        this._unmodified = false;
        this._zoom = z;
        this.scale = this.zoomScale(z);
        this.tileZoom = Math.floor(z);
        this.zoomFraction = z - this.tileZoom;
        this._calcProjMatrix();
        this._constrain();
    },

    get center() { return this._center; },
    set center(center) {
        if (center.lat === this._center.lat && center.lng === this._center.lng) return;
        this._unmodified = false;
        this._center = center;
        this._calcProjMatrix();
        this._constrain();
    },

    resize: function(width, height) {
        this.width = width;
        this.height = height;

        // The extrusion matrix
        this.exMatrix = mat4.create();
        mat4.ortho(this.exMatrix, 0, width, height, 0, 0, -1);

        this._calcProjMatrix();
        this._constrain();
    },

    get unmodified() { return this._unmodified; },

    zoomScale: function(zoom) { return Math.pow(2, zoom); },
    scaleZoom: function(scale) { return Math.log(scale) / Math.LN2; },

    project: function(lnglat, worldSize) {
        return new Point(
            this.lngX(lnglat.lng, worldSize),
            this.latY(lnglat.lat, worldSize));
    },

    unproject: function(point, worldSize) {
        return new LngLat(
            this.xLng(point.x, worldSize),
            this.yLat(point.y, worldSize));
    },

    get x() { return this.lngX(this.center.lng); },
    get y() { return this.latY(this.center.lat); },

    get point() { return new Point(this.x, this.y); },

    /**
     * latitude to absolute x coord
     * @param {number} lon
     * @param {number} [worldSize=this.worldSize]
     * @returns {number} pixel coordinate
     * @private
     */
    lngX: function(lng, worldSize) {
        return (180 + lng) * (worldSize || this.worldSize) / 360;
    },
    /**
     * latitude to absolute y coord
     * @param {number} lat
     * @param {number} [worldSize=this.worldSize]
     * @returns {number} pixel coordinate
     * @private
     */
    latY: function(lat, worldSize) {
        var y = 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + lat * Math.PI / 360));
        return (180 - y) * (worldSize || this.worldSize) / 360;
    },

    xLng: function(x, worldSize) {
        return x * 360 / (worldSize || this.worldSize) - 180;
    },
    yLat: function(y, worldSize) {
        var y2 = 180 - y * 360 / (worldSize || this.worldSize);
        return 360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90;
    },

    panBy: function(offset) {
        var point = this.centerPoint._add(offset);
        this.center = this.pointLocation(point);
    },

    setLocationAtPoint: function(lnglat, point) {
        var c = this.locationCoordinate(lnglat);
        var coordAtPoint = this.pointCoordinate(point);
        var coordCenter = this.pointCoordinate(this.centerPoint);
        var translate = coordAtPoint._sub(c);
        this._unmodified = false;
        this.center = this.coordinateLocation(coordCenter._sub(translate));
    },

    setZoomAround: function(zoom, center) {
        var p;
        if (center) p = this.locationPoint(center);
        this.zoom = zoom;
        if (center) this.setLocationAtPoint(center, p);
    },

    setBearingAround: function(bearing, center) {
        var p;
        if (center) p = this.locationPoint(center);
        this.bearing = bearing;
        if (center) this.setLocationAtPoint(center, p);
    },

    /**
     * Given a location, return the screen point that corresponds to it
     * @param {LngLat} lnglat location
     * @returns {Point} screen point
     * @private
     */
    locationPoint: function(lnglat) {
        return this.coordinatePoint(this.locationCoordinate(lnglat));
    },

    /**
     * Given a point on screen, return its lnglat
     * @param {Point} p screen point
     * @returns {LngLat} lnglat location
     * @private
     */
    pointLocation: function(p) {
        return this.coordinateLocation(this.pointCoordinate(p));
    },

    /**
     * Given a geographical lnglat, return an unrounded
     * coordinate that represents it at this transform's zoom level and
     * worldsize.
     * @param {LngLat} lnglat
     * @returns {Coordinate}
     * @private
     */
    locationCoordinate: function(lnglat) {
        var k = this.zoomScale(this.tileZoom) / this.worldSize,
            ll = LngLat.convert(lnglat);

        return new Coordinate(
            this.lngX(ll.lng) * k,
            this.latY(ll.lat) * k,
            this.tileZoom);
    },

    /**
     * Given a Coordinate, return its geographical position.
     * @param {Coordinate} coord
     * @returns {LngLat} lnglat
     * @private
     */
    coordinateLocation: function(coord) {
        var worldSize = this.zoomScale(coord.zoom);
        return new LngLat(
            this.xLng(coord.column, worldSize),
            this.yLat(coord.row, worldSize));
    },

    pointCoordinate: function(p, targetZ) {

        if (targetZ === undefined) targetZ = 0;

        var matrix = this.coordinatePointMatrix(this.tileZoom);
        mat4.invert(matrix, matrix);

        if (!matrix) throw new Error("failed to invert matrix");

        // since we don't know the correct projected z value for the point,
        // unproject two points to get a line and then find the point on that
        // line with z=0

        var coord0 = [p.x, p.y, 0, 1];
        var coord1 = [p.x, p.y, 1, 1];

        vec4.transformMat4(coord0, coord0, matrix);
        vec4.transformMat4(coord1, coord1, matrix);

        var w0 = coord0[3];
        var w1 = coord1[3];
        var x0 = coord0[0] / w0;
        var x1 = coord1[0] / w1;
        var y0 = coord0[1] / w0;
        var y1 = coord1[1] / w1;
        var z0 = coord0[2] / w0;
        var z1 = coord1[2] / w1;


        var t = z0 === z1 ? 0 : (targetZ - z0) / (z1 - z0);

        return new Coordinate(
            interp(x0, x1, t),
            interp(y0, y1, t),
            this.tileZoom);
    },

    /**
     * Given a coordinate, return the screen point that corresponds to it
     * @param {Coordinate} coord
     * @returns {Point} screen point
     * @private
     */
    coordinatePoint: function(coord) {
        var matrix = this.coordinatePointMatrix(coord.zoom);
        var p = [coord.column, coord.row, 0, 1];
        vec4.transformMat4(p, p, matrix);
        return new Point(p[0] / p[3], p[1] / p[3]);
    },

    coordinatePointMatrix: function(z) {
        var proj = mat4.copy(new Float64Array(16), this.projMatrix);
        var scale = this.worldSize / this.zoomScale(z);
        mat4.scale(proj, proj, [scale, scale, 1]);
        mat4.multiply(proj, this.getPixelMatrix(), proj);
        return proj;
    },

    /**
     * converts gl coordinates -1..1 to pixels 0..width
     * @returns {Object} matrix
     * @private
     */
    getPixelMatrix: function() {
        var m = mat4.create();
        mat4.scale(m, m, [this.width / 2, -this.height / 2, 1]);
        mat4.translate(m, m, [1, -1, 0]);
        return m;
    },

    _constrain: function() {
        if (!this.center || !this.width || !this.height || this._constraining) return;

        this._constraining = true;

        var minY, maxY, minX, maxX, sy, sx, x2, y2,
            size = this.size,
            unmodified = this._unmodified;

        if (this.latRange) {
            minY = this.latY(this.latRange[1]);
            maxY = this.latY(this.latRange[0]);
            sy = maxY - minY < size.y ? size.y / (maxY - minY) : 0;
        }

        if (this.lngRange) {
            minX = this.lngX(this.lngRange[0]);
            maxX = this.lngX(this.lngRange[1]);
            sx = maxX - minX < size.x ? size.x / (maxX - minX) : 0;
        }

        // how much the map should scale to fit the screen into given latitude/longitude ranges
        var s = Math.max(sx || 0, sy || 0);

        if (s) {
            this.center = this.unproject(new Point(
                sx ? (maxX + minX) / 2 : this.x,
                sy ? (maxY + minY) / 2 : this.y));
            this.zoom += this.scaleZoom(s);
            this._unmodified = unmodified;
            this._constraining = false;
            return;
        }

        if (this.latRange) {
            var y = this.y,
                h2 = size.y / 2;

            if (y - h2 < minY) y2 = minY + h2;
            if (y + h2 > maxY) y2 = maxY - h2;
        }

        if (this.lngRange) {
            var x = this.x,
                w2 = size.x / 2;

            if (x - w2 < minX) x2 = minX + w2;
            if (x + w2 > maxX) x2 = maxX - w2;
        }

        // pan the map if the screen goes off the range
        if (x2 !== undefined || y2 !== undefined) {
            this.center = this.unproject(new Point(
                x2 !== undefined ? x2 : this.x,
                y2 !== undefined ? y2 : this.y));
        }

        this._unmodified = unmodified;
        this._constraining = false;
    },

    _calcProjMatrix: function() {
        var m = new Float64Array(16);

        // Find the distance from the center point to the center top in altitude units using law of sines.
        var halfFov = Math.atan(0.5 / this.altitude);
        var topHalfSurfaceDistance = Math.sin(halfFov) * this.altitude / Math.sin(Math.PI / 2 - this._pitch - halfFov);

        // Calculate z value of the farthest fragment that should be rendered.
        var farZ = Math.cos(Math.PI / 2 - this._pitch) * topHalfSurfaceDistance + this.altitude;

        mat4.perspective(m, 2 * Math.atan((this.height / 2) / this.altitude), this.width / this.height, 0.1, farZ);

        mat4.translate(m, m, [0, 0, -this.altitude]);

        // After the rotateX, z values are in pixel units. Convert them to
        // altitude unites. 1 altitude unit = the screen height.
        mat4.scale(m, m, [1, -1, 1 / this.height]);

        mat4.rotateX(m, m, this._pitch);
        mat4.rotateZ(m, m, this.angle);
        mat4.translate(m, m, [-this.x, -this.y, 0]);

        this.projMatrix = m;
    }
};

},{"../util/interpolate":90,"../util/util":94,"./coordinate":9,"./lng_lat":10,"gl-matrix":110,"point-geometry":130}],13:[function(require,module,exports){
'use strict';

// Font data From Hershey Simplex Font
// http://paulbourke.net/dataformats/hershey/
var simplexFont = {
    " ": [16, []],
    "!": [10, [5, 21, 5, 7, -1, -1, 5, 2, 4, 1, 5, 0, 6, 1, 5, 2]],
    "\"": [16, [4, 21, 4, 14, -1, -1, 12, 21, 12, 14]],
    "#": [21, [11, 25, 4, -7, -1, -1, 17, 25, 10, -7, -1, -1, 4, 12, 18, 12, -1, -1, 3, 6, 17, 6]],
    "$": [20, [8, 25, 8, -4, -1, -1, 12, 25, 12, -4, -1, -1, 17, 18, 15, 20, 12, 21, 8, 21, 5, 20, 3, 18, 3, 16, 4, 14, 5, 13, 7, 12, 13, 10, 15, 9, 16, 8, 17, 6, 17, 3, 15, 1, 12, 0, 8, 0, 5, 1, 3, 3]],
    "%": [24, [21, 21, 3, 0, -1, -1, 8, 21, 10, 19, 10, 17, 9, 15, 7, 14, 5, 14, 3, 16, 3, 18, 4, 20, 6, 21, 8, 21, 10, 20, 13, 19, 16, 19, 19, 20, 21, 21, -1, -1, 17, 7, 15, 6, 14, 4, 14, 2, 16, 0, 18, 0, 20, 1, 21, 3, 21, 5, 19, 7, 17, 7]],
    "&": [26, [23, 12, 23, 13, 22, 14, 21, 14, 20, 13, 19, 11, 17, 6, 15, 3, 13, 1, 11, 0, 7, 0, 5, 1, 4, 2, 3, 4, 3, 6, 4, 8, 5, 9, 12, 13, 13, 14, 14, 16, 14, 18, 13, 20, 11, 21, 9, 20, 8, 18, 8, 16, 9, 13, 11, 10, 16, 3, 18, 1, 20, 0, 22, 0, 23, 1, 23, 2]],
    "'": [10, [5, 19, 4, 20, 5, 21, 6, 20, 6, 18, 5, 16, 4, 15]],
    "(": [14, [11, 25, 9, 23, 7, 20, 5, 16, 4, 11, 4, 7, 5, 2, 7, -2, 9, -5, 11, -7]],
    ")": [14, [3, 25, 5, 23, 7, 20, 9, 16, 10, 11, 10, 7, 9, 2, 7, -2, 5, -5, 3, -7]],
    "*": [16, [8, 21, 8, 9, -1, -1, 3, 18, 13, 12, -1, -1, 13, 18, 3, 12]],
    "+": [26, [13, 18, 13, 0, -1, -1, 4, 9, 22, 9]],
    ",": [10, [6, 1, 5, 0, 4, 1, 5, 2, 6, 1, 6, -1, 5, -3, 4, -4]],
    "-": [26, [4, 9, 22, 9]],
    ".": [10, [5, 2, 4, 1, 5, 0, 6, 1, 5, 2]],
    "/": [22, [20, 25, 2, -7]],
    "0": [20, [9, 21, 6, 20, 4, 17, 3, 12, 3, 9, 4, 4, 6, 1, 9, 0, 11, 0, 14, 1, 16, 4, 17, 9, 17, 12, 16, 17, 14, 20, 11, 21, 9, 21]],
    "1": [20, [6, 17, 8, 18, 11, 21, 11, 0]],
    "2": [20, [4, 16, 4, 17, 5, 19, 6, 20, 8, 21, 12, 21, 14, 20, 15, 19, 16, 17, 16, 15, 15, 13, 13, 10, 3, 0, 17, 0]],
    "3": [20, [5, 21, 16, 21, 10, 13, 13, 13, 15, 12, 16, 11, 17, 8, 17, 6, 16, 3, 14, 1, 11, 0, 8, 0, 5, 1, 4, 2, 3, 4]],
    "4": [20, [13, 21, 3, 7, 18, 7, -1, -1, 13, 21, 13, 0]],
    "5": [20, [15, 21, 5, 21, 4, 12, 5, 13, 8, 14, 11, 14, 14, 13, 16, 11, 17, 8, 17, 6, 16, 3, 14, 1, 11, 0, 8, 0, 5, 1, 4, 2, 3, 4]],
    "6": [20, [16, 18, 15, 20, 12, 21, 10, 21, 7, 20, 5, 17, 4, 12, 4, 7, 5, 3, 7, 1, 10, 0, 11, 0, 14, 1, 16, 3, 17, 6, 17, 7, 16, 10, 14, 12, 11, 13, 10, 13, 7, 12, 5, 10, 4, 7]],
    "7": [20, [17, 21, 7, 0, -1, -1, 3, 21, 17, 21]],
    "8": [20, [8, 21, 5, 20, 4, 18, 4, 16, 5, 14, 7, 13, 11, 12, 14, 11, 16, 9, 17, 7, 17, 4, 16, 2, 15, 1, 12, 0, 8, 0, 5, 1, 4, 2, 3, 4, 3, 7, 4, 9, 6, 11, 9, 12, 13, 13, 15, 14, 16, 16, 16, 18, 15, 20, 12, 21, 8, 21]],
    "9": [20, [16, 14, 15, 11, 13, 9, 10, 8, 9, 8, 6, 9, 4, 11, 3, 14, 3, 15, 4, 18, 6, 20, 9, 21, 10, 21, 13, 20, 15, 18, 16, 14, 16, 9, 15, 4, 13, 1, 10, 0, 8, 0, 5, 1, 4, 3]],
    ":": [10, [5, 14, 4, 13, 5, 12, 6, 13, 5, 14, -1, -1, 5, 2, 4, 1, 5, 0, 6, 1, 5, 2]],
    ";": [10, [5, 14, 4, 13, 5, 12, 6, 13, 5, 14, -1, -1, 6, 1, 5, 0, 4, 1, 5, 2, 6, 1, 6, -1, 5, -3, 4, -4]],
    "<": [24, [20, 18, 4, 9, 20, 0]],
    "=": [26, [4, 12, 22, 12, -1, -1, 4, 6, 22, 6]],
    ">": [24, [4, 18, 20, 9, 4, 0]],
    "?": [18, [3, 16, 3, 17, 4, 19, 5, 20, 7, 21, 11, 21, 13, 20, 14, 19, 15, 17, 15, 15, 14, 13, 13, 12, 9, 10, 9, 7, -1, -1, 9, 2, 8, 1, 9, 0, 10, 1, 9, 2]],
    "@": [27, [18, 13, 17, 15, 15, 16, 12, 16, 10, 15, 9, 14, 8, 11, 8, 8, 9, 6, 11, 5, 14, 5, 16, 6, 17, 8, -1, -1, 12, 16, 10, 14, 9, 11, 9, 8, 10, 6, 11, 5, -1, -1, 18, 16, 17, 8, 17, 6, 19, 5, 21, 5, 23, 7, 24, 10, 24, 12, 23, 15, 22, 17, 20, 19, 18, 20, 15, 21, 12, 21, 9, 20, 7, 19, 5, 17, 4, 15, 3, 12, 3, 9, 4, 6, 5, 4, 7, 2, 9, 1, 12, 0, 15, 0, 18, 1, 20, 2, 21, 3, -1, -1, 19, 16, 18, 8, 18, 6, 19, 5]],
    "A": [18, [9, 21, 1, 0, -1, -1, 9, 21, 17, 0, -1, -1, 4, 7, 14, 7]],
    "B": [21, [4, 21, 4, 0, -1, -1, 4, 21, 13, 21, 16, 20, 17, 19, 18, 17, 18, 15, 17, 13, 16, 12, 13, 11, -1, -1, 4, 11, 13, 11, 16, 10, 17, 9, 18, 7, 18, 4, 17, 2, 16, 1, 13, 0, 4, 0]],
    "C": [21, [18, 16, 17, 18, 15, 20, 13, 21, 9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5]],
    "D": [21, [4, 21, 4, 0, -1, -1, 4, 21, 11, 21, 14, 20, 16, 18, 17, 16, 18, 13, 18, 8, 17, 5, 16, 3, 14, 1, 11, 0, 4, 0]],
    "E": [19, [4, 21, 4, 0, -1, -1, 4, 21, 17, 21, -1, -1, 4, 11, 12, 11, -1, -1, 4, 0, 17, 0]],
    "F": [18, [4, 21, 4, 0, -1, -1, 4, 21, 17, 21, -1, -1, 4, 11, 12, 11]],
    "G": [21, [18, 16, 17, 18, 15, 20, 13, 21, 9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5, 18, 8, -1, -1, 13, 8, 18, 8]],
    "H": [22, [4, 21, 4, 0, -1, -1, 18, 21, 18, 0, -1, -1, 4, 11, 18, 11]],
    "I": [8, [4, 21, 4, 0]],
    "J": [16, [12, 21, 12, 5, 11, 2, 10, 1, 8, 0, 6, 0, 4, 1, 3, 2, 2, 5, 2, 7]],
    "K": [21, [4, 21, 4, 0, -1, -1, 18, 21, 4, 7, -1, -1, 9, 12, 18, 0]],
    "L": [17, [4, 21, 4, 0, -1, -1, 4, 0, 16, 0]],
    "M": [24, [4, 21, 4, 0, -1, -1, 4, 21, 12, 0, -1, -1, 20, 21, 12, 0, -1, -1, 20, 21, 20, 0]],
    "N": [22, [4, 21, 4, 0, -1, -1, 4, 21, 18, 0, -1, -1, 18, 21, 18, 0]],
    "O": [22, [9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5, 19, 8, 19, 13, 18, 16, 17, 18, 15, 20, 13, 21, 9, 21]],
    "P": [21, [4, 21, 4, 0, -1, -1, 4, 21, 13, 21, 16, 20, 17, 19, 18, 17, 18, 14, 17, 12, 16, 11, 13, 10, 4, 10]],
    "Q": [22, [9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5, 19, 8, 19, 13, 18, 16, 17, 18, 15, 20, 13, 21, 9, 21, -1, -1, 12, 4, 18, -2]],
    "R": [21, [4, 21, 4, 0, -1, -1, 4, 21, 13, 21, 16, 20, 17, 19, 18, 17, 18, 15, 17, 13, 16, 12, 13, 11, 4, 11, -1, -1, 11, 11, 18, 0]],
    "S": [20, [17, 18, 15, 20, 12, 21, 8, 21, 5, 20, 3, 18, 3, 16, 4, 14, 5, 13, 7, 12, 13, 10, 15, 9, 16, 8, 17, 6, 17, 3, 15, 1, 12, 0, 8, 0, 5, 1, 3, 3]],
    "T": [16, [8, 21, 8, 0, -1, -1, 1, 21, 15, 21]],
    "U": [22, [4, 21, 4, 6, 5, 3, 7, 1, 10, 0, 12, 0, 15, 1, 17, 3, 18, 6, 18, 21]],
    "V": [18, [1, 21, 9, 0, -1, -1, 17, 21, 9, 0]],
    "W": [24, [2, 21, 7, 0, -1, -1, 12, 21, 7, 0, -1, -1, 12, 21, 17, 0, -1, -1, 22, 21, 17, 0]],
    "X": [20, [3, 21, 17, 0, -1, -1, 17, 21, 3, 0]],
    "Y": [18, [1, 21, 9, 11, 9, 0, -1, -1, 17, 21, 9, 11]],
    "Z": [20, [17, 21, 3, 0, -1, -1, 3, 21, 17, 21, -1, -1, 3, 0, 17, 0]],
    "[": [14, [4, 25, 4, -7, -1, -1, 5, 25, 5, -7, -1, -1, 4, 25, 11, 25, -1, -1, 4, -7, 11, -7]],
    "\\": [14, [0, 21, 14, -3]],
    "]": [14, [9, 25, 9, -7, -1, -1, 10, 25, 10, -7, -1, -1, 3, 25, 10, 25, -1, -1, 3, -7, 10, -7]],
    "^": [16, [6, 15, 8, 18, 10, 15, -1, -1, 3, 12, 8, 17, 13, 12, -1, -1, 8, 17, 8, 0]],
    "_": [16, [0, -2, 16, -2]],
    "`": [10, [6, 21, 5, 20, 4, 18, 4, 16, 5, 15, 6, 16, 5, 17]],
    "a": [19, [15, 14, 15, 0, -1, -1, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],
    "b": [19, [4, 21, 4, 0, -1, -1, 4, 11, 6, 13, 8, 14, 11, 14, 13, 13, 15, 11, 16, 8, 16, 6, 15, 3, 13, 1, 11, 0, 8, 0, 6, 1, 4, 3]],
    "c": [18, [15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],
    "d": [19, [15, 21, 15, 0, -1, -1, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],
    "e": [18, [3, 8, 15, 8, 15, 10, 14, 12, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],
    "f": [12, [10, 21, 8, 21, 6, 20, 5, 17, 5, 0, -1, -1, 2, 14, 9, 14]],
    "g": [19, [15, 14, 15, -2, 14, -5, 13, -6, 11, -7, 8, -7, 6, -6, -1, -1, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],
    "h": [19, [4, 21, 4, 0, -1, -1, 4, 10, 7, 13, 9, 14, 12, 14, 14, 13, 15, 10, 15, 0]],
    "i": [8, [3, 21, 4, 20, 5, 21, 4, 22, 3, 21, -1, -1, 4, 14, 4, 0]],
    "j": [10, [5, 21, 6, 20, 7, 21, 6, 22, 5, 21, -1, -1, 6, 14, 6, -3, 5, -6, 3, -7, 1, -7]],
    "k": [17, [4, 21, 4, 0, -1, -1, 14, 14, 4, 4, -1, -1, 8, 8, 15, 0]],
    "l": [8, [4, 21, 4, 0]],
    "m": [30, [4, 14, 4, 0, -1, -1, 4, 10, 7, 13, 9, 14, 12, 14, 14, 13, 15, 10, 15, 0, -1, -1, 15, 10, 18, 13, 20, 14, 23, 14, 25, 13, 26, 10, 26, 0]],
    "n": [19, [4, 14, 4, 0, -1, -1, 4, 10, 7, 13, 9, 14, 12, 14, 14, 13, 15, 10, 15, 0]],
    "o": [19, [8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3, 16, 6, 16, 8, 15, 11, 13, 13, 11, 14, 8, 14]],
    "p": [19, [4, 14, 4, -7, -1, -1, 4, 11, 6, 13, 8, 14, 11, 14, 13, 13, 15, 11, 16, 8, 16, 6, 15, 3, 13, 1, 11, 0, 8, 0, 6, 1, 4, 3]],
    "q": [19, [15, 14, 15, -7, -1, -1, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],
    "r": [13, [4, 14, 4, 0, -1, -1, 4, 8, 5, 11, 7, 13, 9, 14, 12, 14]],
    "s": [17, [14, 11, 13, 13, 10, 14, 7, 14, 4, 13, 3, 11, 4, 9, 6, 8, 11, 7, 13, 6, 14, 4, 14, 3, 13, 1, 10, 0, 7, 0, 4, 1, 3, 3]],
    "t": [12, [5, 21, 5, 4, 6, 1, 8, 0, 10, 0, -1, -1, 2, 14, 9, 14]],
    "u": [19, [4, 14, 4, 4, 5, 1, 7, 0, 10, 0, 12, 1, 15, 4, -1, -1, 15, 14, 15, 0]],
    "v": [16, [2, 14, 8, 0, -1, -1, 14, 14, 8, 0]],
    "w": [22, [3, 14, 7, 0, -1, -1, 11, 14, 7, 0, -1, -1, 11, 14, 15, 0, -1, -1, 19, 14, 15, 0]],
    "x": [17, [3, 14, 14, 0, -1, -1, 14, 14, 3, 0]],
    "y": [16, [2, 14, 8, 0, -1, -1, 14, 14, 8, 0, 6, -4, 4, -6, 2, -7, 1, -7]],
    "z": [17, [14, 14, 3, 0, -1, -1, 3, 14, 14, 14, -1, -1, 3, 0, 14, 0]],
    "{": [14, [9, 25, 7, 24, 6, 23, 5, 21, 5, 19, 6, 17, 7, 16, 8, 14, 8, 12, 6, 10, -1, -1, 7, 24, 6, 22, 6, 20, 7, 18, 8, 17, 9, 15, 9, 13, 8, 11, 4, 9, 8, 7, 9, 5, 9, 3, 8, 1, 7, 0, 6, -2, 6, -4, 7, -6, -1, -1, 6, 8, 8, 6, 8, 4, 7, 2, 6, 1, 5, -1, 5, -3, 6, -5, 7, -6, 9, -7]],
    "|": [8, [4, 25, 4, -7]],
    "}": [14, [5, 25, 7, 24, 8, 23, 9, 21, 9, 19, 8, 17, 7, 16, 6, 14, 6, 12, 8, 10, -1, -1, 7, 24, 8, 22, 8, 20, 7, 18, 6, 17, 5, 15, 5, 13, 6, 11, 10, 9, 6, 7, 5, 5, 5, 3, 6, 1, 7, 0, 8, -2, 8, -4, 7, -6, -1, -1, 8, 8, 6, 6, 6, 4, 7, 2, 8, 1, 9, -1, 9, -3, 8, -5, 7, -6, 5, -7]],
    "~": [24, [3, 6, 3, 8, 4, 11, 6, 12, 8, 12, 10, 11, 14, 8, 16, 7, 18, 7, 20, 8, 21, 10, -1, -1, 3, 8, 4, 10, 6, 11, 8, 11, 10, 10, 14, 7, 16, 6, 18, 6, 20, 7, 21, 10, 21, 12]]
};

module.exports = function textVertices(text, left, baseline, scale) {
    scale = scale || 1;

    var strokes = [],
        i, len, j, len2, glyph, x, y, prev;

    for (i = 0, len = text.length; i < len; i++) {
        glyph = simplexFont[text[i]];
        if (!glyph) continue;
        prev = null;

        for (j = 0, len2 = glyph[1].length; j < len2; j += 2) {
            if (glyph[1][j] === -1 && glyph[1][j + 1] === -1) {
                prev = null;

            } else {
                x = left + glyph[1][j] * scale;
                y = baseline - glyph[1][j + 1] * scale;
                if (prev) {
                    strokes.push(prev.x, prev.y, x, y);
                }
                prev = {x: x, y: y};
            }
        }
        left += glyph[0] * scale;
    }

    return strokes;
};

},{}],14:[function(require,module,exports){
'use strict';

/**
 * mapboxgl is a A WebGL JavaScript interactive maps library that can render
 * [Mapbox vector tiles](https://www.mapbox.com/blog/vector-tiles/).
 *
 * @module mapboxgl
 * @summary WebGL JavaScript map library
 */

// jshint -W079
var mapboxgl = module.exports = {};

mapboxgl.Map = require('./ui/map');
mapboxgl.Control = require('./ui/control/control');
mapboxgl.Navigation = require('./ui/control/navigation');
mapboxgl.Attribution = require('./ui/control/attribution');
mapboxgl.Popup = require('./ui/popup');

mapboxgl.GeoJSONSource = require('./source/geojson_source');
mapboxgl.VideoSource = require('./source/video_source');
mapboxgl.ImageSource = require('./source/image_source');

mapboxgl.Style = require('./style/style');

mapboxgl.LngLat = require('./geo/lng_lat');
mapboxgl.LngLatBounds = require('./geo/lng_lat_bounds');
mapboxgl.Point = require('point-geometry');

mapboxgl.Evented = require('./util/evented');
mapboxgl.util = require('./util/util');

mapboxgl.supported = require('./util/browser').supported;

var ajax = require('./util/ajax');
mapboxgl.util.getJSON = ajax.getJSON;
mapboxgl.util.getArrayBuffer = ajax.getArrayBuffer;

var config = require('./util/config');
mapboxgl.config = config;

Object.defineProperty(mapboxgl, 'accessToken', {
    get: function() { return config.ACCESS_TOKEN; },
    set: function(token) { config.ACCESS_TOKEN = token; }
});

},{"./geo/lng_lat":10,"./geo/lng_lat_bounds":11,"./source/geojson_source":28,"./source/image_source":30,"./source/video_source":37,"./style/style":45,"./ui/control/attribution":67,"./ui/control/control":68,"./ui/control/navigation":69,"./ui/map":79,"./ui/popup":80,"./util/ajax":82,"./util/browser":83,"./util/config":87,"./util/evented":88,"./util/util":94,"point-geometry":130}],15:[function(require,module,exports){
'use strict';

var TilePyramid = require('../source/tile_pyramid');
var pyramid = new TilePyramid({ tileSize: 512 });

module.exports = drawBackground;

function drawBackground(painter, source, layer) {
    var gl = painter.gl;
    var transform = painter.transform;
    var color = layer.paint['background-color'];
    var image = layer.paint['background-pattern'];
    var opacity = layer.paint['background-opacity'];
    var shader;

    var imagePosA = image ? painter.spriteAtlas.getPosition(image.from, true) : null;
    var imagePosB = image ? painter.spriteAtlas.getPosition(image.to, true) : null;

    painter.setDepthSublayer(0);
    if (imagePosA && imagePosB) {

        if (painter.isOpaquePass) return;

        // Draw texture fill
        shader = painter.patternShader;
        gl.switchShader(shader);
        gl.uniform1i(shader.u_image, 0);
        gl.uniform2fv(shader.u_pattern_tl_a, imagePosA.tl);
        gl.uniform2fv(shader.u_pattern_br_a, imagePosA.br);
        gl.uniform2fv(shader.u_pattern_tl_b, imagePosB.tl);
        gl.uniform2fv(shader.u_pattern_br_b, imagePosB.br);
        gl.uniform1f(shader.u_opacity, opacity);

        gl.uniform1f(shader.u_mix, image.t);

        var factor = (4096 / transform.tileSize) / Math.pow(2, 0);

        gl.uniform2fv(shader.u_patternscale_a, [
            1 / (imagePosA.size[0] * factor * image.fromScale),
            1 / (imagePosA.size[1] * factor * image.fromScale)
        ]);

        gl.uniform2fv(shader.u_patternscale_b, [
            1 / (imagePosB.size[0] * factor * image.toScale),
            1 / (imagePosB.size[1] * factor * image.toScale)
        ]);

        painter.spriteAtlas.bind(gl, true);

    } else {
        // Draw filling rectangle.
        if (painter.isOpaquePass !== (color[3] === 1)) return;

        shader = painter.fillShader;
        gl.switchShader(shader);
        gl.uniform4fv(shader.u_color, color);
    }

    gl.disable(gl.STENCIL_TEST);

    gl.bindBuffer(gl.ARRAY_BUFFER, painter.tileExtentBuffer);
    gl.vertexAttribPointer(shader.a_pos, painter.tileExtentBuffer.itemSize, gl.SHORT, false, 0, 0);

    // We need to draw the background in tiles in order to use calculatePosMatrix
    // which applies the projection matrix (transform.projMatrix). Otherwise
    // the depth and stencil buffers get into a bad state.
    // This can be refactored into a single draw call once earcut lands and
    // we don't have so much going on in the stencil buffer.
    var coords = pyramid.coveringTiles(transform);
    for (var c = 0; c < coords.length; c++) {
        gl.setPosMatrix(painter.calculatePosMatrix(coords[c]));
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, painter.tileExtentBuffer.itemCount);
    }

    gl.enable(gl.STENCIL_TEST);
    gl.stencilMask(0x00);
    gl.stencilFunc(gl.EQUAL, 0x80, 0x80);
}

},{"../source/tile_pyramid":35}],16:[function(require,module,exports){
'use strict';

var browser = require('../util/browser.js');

module.exports = drawCircles;

function drawCircles(painter, source, layer, coords) {
    if (painter.isOpaquePass) return;

    var gl = painter.gl;

    var shader = painter.circleShader;
    painter.gl.switchShader(shader);

    painter.setDepthSublayer(0);
    painter.depthMask(false);

    // Allow circles to be drawn across boundaries, so that
    // large circles are not clipped to tiles
    gl.disable(gl.STENCIL_TEST);

    // antialiasing factor: this is a minimum blur distance that serves as
    // a faux-antialiasing for the circle. since blur is a ratio of the circle's
    // size and the intent is to keep the blur at roughly 1px, the two
    // are inversely related.
    var antialias = 1 / browser.devicePixelRatio / layer.paint['circle-radius'];

    gl.uniform4fv(shader.u_color, layer.paint['circle-color']);
    gl.uniform1f(shader.u_blur, Math.max(layer.paint['circle-blur'], antialias));
    gl.uniform1f(shader.u_size, layer.paint['circle-radius']);

    for (var i = 0; i < coords.length; i++) {
        var coord = coords[i];

        var tile = source.getTile(coord);
        if (!tile.buffers) continue;
        var elementGroups = tile.getElementGroups(layer, 'circle');
        if (!elementGroups) continue;

        var vertex = tile.buffers.circleVertex;
        var elements = tile.buffers.circleElement;

        gl.setPosMatrix(painter.translatePosMatrix(
            painter.calculatePosMatrix(coord, source.maxzoom),
            tile,
            layer.paint['circle-translate'],
            layer.paint['circle-translate-anchor']
        ));
        gl.setExMatrix(painter.transform.exMatrix);

        for (var k = 0; k < elementGroups.groups.length; k++) {
            var group = elementGroups.groups[k];
            var offset = group.vertexStartIndex * vertex.itemSize;

            vertex.bind(gl);
            vertex.setAttribPointers(gl, shader, offset);

            elements.bind(gl);

            var count = group.elementLength * 3;
            var elementOffset = group.elementStartIndex * elements.itemSize;
            gl.drawElements(gl.TRIANGLES, count, gl.UNSIGNED_SHORT, elementOffset);
        }
    }

    gl.enable(gl.STENCIL_TEST);
}

},{"../util/browser.js":83}],17:[function(require,module,exports){
'use strict';

module.exports = drawCollisionDebug;

function drawCollisionDebug(painter, layer, coord, tile) {
    if (!tile.buffers) return;
    var elementGroups = tile.getElementGroups(layer, 'collisionBox');
    if (!elementGroups) return;

    var gl = painter.gl;
    var buffer = tile.buffers.collisionBoxVertex;
    var shader = painter.collisionBoxShader;
    var posMatrix = painter.calculatePosMatrix(coord);

    gl.enable(gl.STENCIL_TEST);
    painter.enableTileClippingMask(coord);

    gl.switchShader(shader, posMatrix);

    buffer.bind(gl);
    buffer.setAttribPointers(gl, shader, 0);

    gl.lineWidth(1);

    gl.uniform1f(shader.u_scale, Math.pow(2, painter.transform.zoom - tile.coord.z));
    gl.uniform1f(shader.u_zoom, painter.transform.zoom * 10);
    gl.uniform1f(shader.u_maxzoom, (tile.coord.z + 1) * 10);

    var begin = elementGroups.groups[0].vertexStartIndex;
    var len = elementGroups.groups[0].vertexLength;
    gl.drawArrays(gl.LINES, begin, len);

    gl.disable(gl.STENCIL_TEST);
}

},{}],18:[function(require,module,exports){
'use strict';

var textVertices = require('../lib/debugtext');
var browser = require('../util/browser');

module.exports = drawDebug;

function drawDebug(painter, coords) {
    if (painter.isOpaquePass) return;
    if (!painter.options.debug) return;

    for (var i = 0; i < coords.length; i++) {
        drawDebugTile(painter, coords[i]);
    }
}

function drawDebugTile(painter, coord) {
    var gl = painter.gl;

    var shader = painter.debugShader;
    gl.switchShader(shader, painter.calculatePosMatrix(coord));

    // draw bounding rectangle
    gl.bindBuffer(gl.ARRAY_BUFFER, painter.debugBuffer);
    gl.vertexAttribPointer(shader.a_pos, painter.debugBuffer.itemSize, gl.SHORT, false, 0, 0);
    gl.uniform4f(shader.u_color, 1, 0, 0, 1);
    gl.lineWidth(4);
    gl.drawArrays(gl.LINE_STRIP, 0, painter.debugBuffer.itemCount);

    var vertices = textVertices(coord.toString(), 50, 200, 5);

    gl.bindBuffer(gl.ARRAY_BUFFER, painter.debugTextBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Int16Array(vertices), gl.STREAM_DRAW);
    gl.vertexAttribPointer(shader.a_pos, painter.debugTextBuffer.itemSize, gl.SHORT, false, 0, 0);
    gl.lineWidth(8 * browser.devicePixelRatio);
    gl.uniform4f(shader.u_color, 1, 1, 1, 1);
    gl.drawArrays(gl.LINES, 0, vertices.length / painter.debugTextBuffer.itemSize);
    gl.lineWidth(2 * browser.devicePixelRatio);
    gl.uniform4f(shader.u_color, 0, 0, 0, 1);
    gl.drawArrays(gl.LINES, 0, vertices.length / painter.debugTextBuffer.itemSize);
}

},{"../lib/debugtext":13,"../util/browser":83}],19:[function(require,module,exports){
'use strict';

var browser = require('../util/browser');

module.exports = draw;

function draw(painter, source, layer, coords) {
    var gl = painter.gl;

    var color = layer.paint['fill-color'];
    var image = layer.paint['fill-pattern'];
    var strokeColor = layer.paint['fill-outline-color'];

    // Draw fill
    if (image ? !painter.isOpaquePass : painter.isOpaquePass === (color[3] === 1)) {
        // Once we switch to earcut drawing we can pull most of the WebGL setup
        // outside of this coords loop.
        for (var i = 0; i < coords.length; i++) {
            drawFill(painter, source, layer, coords[i]);
        }
    }

    // Draw stroke
    if (!painter.isOpaquePass && layer.paint['fill-antialias'] && !(layer.paint['fill-pattern'] && !strokeColor)) {
        gl.switchShader(painter.outlineShader);
        gl.lineWidth(2 * browser.devicePixelRatio * 10);

        if (strokeColor) {
            // If we defined a different color for the fill outline, we are
            // going to ignore the bits in 0x07 and just care about the global
            // clipping mask.
            painter.setDepthSublayer(2);

        } else {
            // Otherwise, we only want to drawFill the antialiased parts that are
            // *outside* the current shape. This is important in case the fill
            // or stroke color is translucent. If we wouldn't clip to outside
            // the current shape, some pixels from the outline stroke overlapped
            // the (non-antialiased) fill.
            painter.setDepthSublayer(0);
        }

        gl.uniform2f(painter.outlineShader.u_world, gl.drawingBufferWidth, gl.drawingBufferHeight);
        gl.uniform4fv(painter.outlineShader.u_color, strokeColor ? strokeColor : color);

        for (var j = 0; j < coords.length; j++) {
            drawStroke(painter, source, layer, coords[j]);
        }
    }
}

function drawFill(painter, source, layer, coord) {
    var tile = source.getTile(coord);
    if (!tile.buffers) return;
    var elementGroups = tile.getElementGroups(layer, 'fill');
    if (!elementGroups) return;

    var gl = painter.gl;

    var color = layer.paint['fill-color'];
    var image = layer.paint['fill-pattern'];
    var opacity = layer.paint['fill-opacity'];

    var posMatrix = painter.calculatePosMatrix(coord, source.maxzoom);
    var translatedPosMatrix = painter.translatePosMatrix(posMatrix, tile, layer.paint['fill-translate'], layer.paint['fill-translate-anchor']);

    // Draw the stencil mask.
    painter.setDepthSublayer(1);

    // We're only drawFilling to the first seven bits (== support a maximum of
    // 8 overlapping polygons in one place before we get rendering errors).
    gl.stencilMask(0x07);
    gl.clear(gl.STENCIL_BUFFER_BIT);

    // Draw front facing triangles. Wherever the 0x80 bit is 1, we are
    // increasing the lower 7 bits by one if the triangle is a front-facing
    // triangle. This means that all visible polygons should be in CCW
    // orientation, while all holes (see below) are in CW orientation.
    painter.enableTileClippingMask(coord);

    // When we do a nonzero fill, we count the number of times a pixel is
    // covered by a counterclockwise polygon, and subtract the number of
    // times it is "uncovered" by a clockwise polygon.
    gl.stencilOpSeparate(gl.FRONT, gl.KEEP, gl.KEEP, gl.INCR_WRAP);
    gl.stencilOpSeparate(gl.BACK, gl.KEEP, gl.KEEP, gl.DECR_WRAP);

    // When drawFilling a shape, we first drawFill all shapes to the stencil buffer
    // and incrementing all areas where polygons are
    gl.colorMask(false, false, false, false);
    painter.depthMask(false);

    // Draw the actual triangle fan into the stencil buffer.
    gl.switchShader(painter.fillShader, translatedPosMatrix);

    // Draw all buffers
    var vertex = tile.buffers.fillVertex;
    vertex.bind(gl);

    var elements = tile.buffers.fillElement;
    elements.bind(gl);

    for (var i = 0; i < elementGroups.groups.length; i++) {
        var group = elementGroups.groups[i];
        var offset = group.vertexStartIndex * vertex.itemSize;
        vertex.setAttribPointers(gl, painter.fillShader, offset);

        var count = group.elementLength * 3;
        var elementOffset = group.elementStartIndex * elements.itemSize;
        gl.drawElements(gl.TRIANGLES, count, gl.UNSIGNED_SHORT, elementOffset);
    }

    // Now that we have the stencil mask in the stencil buffer, we can start
    // writing to the color buffer.
    gl.colorMask(true, true, true, true);
    painter.depthMask(true);

    // From now on, we don't want to update the stencil buffer anymore.
    gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
    gl.stencilMask(0x0);
    var shader;

    if (image) {
        // Draw texture fill
        var imagePosA = painter.spriteAtlas.getPosition(image.from, true);
        var imagePosB = painter.spriteAtlas.getPosition(image.to, true);
        if (!imagePosA || !imagePosB) return;

        shader = painter.patternShader;
        gl.switchShader(shader, posMatrix);
        gl.uniform1i(shader.u_image, 0);
        gl.uniform2fv(shader.u_pattern_tl_a, imagePosA.tl);
        gl.uniform2fv(shader.u_pattern_br_a, imagePosA.br);
        gl.uniform2fv(shader.u_pattern_tl_b, imagePosB.tl);
        gl.uniform2fv(shader.u_pattern_br_b, imagePosB.br);
        gl.uniform1f(shader.u_opacity, opacity);
        gl.uniform1f(shader.u_mix, image.t);

        var scale = Math.pow(2, painter.transform.tileZoom - tile.coord.z);
        var factor = 4096 / tile.tileSize;

        var imageSizeScaledA = [
            (imagePosA.size[0] * image.fromScale) / scale,
            (imagePosA.size[1] * image.fromScale) / scale
        ];
        var imageSizeScaledB = [
            (imagePosB.size[0] * image.toScale) / scale,
            (imagePosB.size[1] * image.toScale) / scale
        ];

        gl.uniform2fv(shader.u_patternscale_a, [
            1 / (imageSizeScaledA[0] * factor),
            1 / (imageSizeScaledA[1] * factor)
        ]);

        gl.uniform2fv(shader.u_patternscale_b, [
            1 / (imageSizeScaledB[0] * factor),
            1 / (imageSizeScaledB[1] * factor)
        ]);

        // shift images to match at tile boundaries
        var offsetAx = ((tile.tileSize % imageSizeScaledA[0]) * (tile.coord.x + coord.w * Math.pow(2, tile.coord.z))) / imageSizeScaledA[0];
        var offsetAy = ((tile.tileSize % imageSizeScaledA[1]) * tile.coord.y) / imageSizeScaledA[1];

        var offsetBx = ((tile.tileSize % imageSizeScaledB[0]) * (tile.coord.x + coord.w * Math.pow(2, tile.coord.z))) / imageSizeScaledB[0];
        var offsetBy = ((tile.tileSize % imageSizeScaledB[1]) * tile.coord.y) / imageSizeScaledB[1];

        gl.uniform2fv(shader.u_offset_a, [offsetAx, offsetAy]);
        gl.uniform2fv(shader.u_offset_b, [offsetBx, offsetBy]);

        painter.spriteAtlas.bind(gl, true);

    } else {
        // Draw filling rectangle.
        shader = painter.fillShader;
        gl.switchShader(shader, posMatrix);
        gl.uniform4fv(shader.u_color, color);
    }

    // Only draw regions that we marked
    gl.stencilFunc(gl.NOTEQUAL, 0x0, 0x07);
    gl.bindBuffer(gl.ARRAY_BUFFER, painter.tileExtentBuffer);
    gl.vertexAttribPointer(shader.a_pos, painter.tileExtentBuffer.itemSize, gl.SHORT, false, 0, 0);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, painter.tileExtentBuffer.itemCount);

    gl.stencilMask(0x00);
}

function drawStroke(painter, source, layer, coord) {
    var tile = source.getTile(coord);
    if (!tile.buffers) return;
    if (!tile.elementGroups[layer.ref || layer.id]) return;

    var gl = painter.gl;
    var elementGroups = tile.elementGroups[layer.ref || layer.id].fill;

    gl.setPosMatrix(painter.translatePosMatrix(
        painter.calculatePosMatrix(coord, source.maxzoom),
        tile,
        layer.paint['fill-translate'],
        layer.paint['fill-translate-anchor']
    ));

    // Draw all buffers
    var vertex = tile.buffers.fillVertex;
    var elements = tile.buffers.fillSecondElement;
    vertex.bind(gl);
    elements.bind(gl);

    painter.enableTileClippingMask(coord);

    for (var k = 0; k < elementGroups.groups.length; k++) {
        var group = elementGroups.groups[k];
        var offset = group.vertexStartIndex * vertex.itemSize;
        vertex.setAttribPointers(gl, painter.outlineShader, offset);

        var count = group.secondElementLength * 2;
        var elementOffset = group.secondElementStartIndex * elements.itemSize;
        gl.drawElements(gl.LINES, count, gl.UNSIGNED_SHORT, elementOffset);
    }
}

},{"../util/browser":83}],20:[function(require,module,exports){
'use strict';

var browser = require('../util/browser');
var mat2 = require('gl-matrix').mat2;

/**
 * Draw a line. Under the hood this will read elements from
 * a tile, dash textures from a lineAtlas, and style properties from a layer.
 * @param {Object} painter
 * @param {Object} layer
 * @param {Object} posMatrix
 * @param {Tile} tile
 * @returns {undefined} draws with the painter
 * @private
 */
module.exports = function drawLine(painter, source, layer, coords) {
    if (painter.isOpaquePass) return;
    painter.setDepthSublayer(0);
    painter.depthMask(false);

    var hasData = coords.some(function(coord) {
        return source.getTile(coord).getElementGroups(layer, 'line');
    });
    if (!hasData) return;

    var gl = painter.gl;

    // don't draw zero-width lines
    if (layer.paint['line-width'] <= 0) return;

    // the distance over which the line edge fades out.
    // Retina devices need a smaller distance to avoid aliasing.
    var antialiasing = 1 / browser.devicePixelRatio;

    var blur = layer.paint['line-blur'] + antialiasing;
    var edgeWidth = layer.paint['line-width'] / 2;
    var inset = -1;
    var offset = 0;
    var shift = 0;

    if (layer.paint['line-gap-width'] > 0) {
        inset = layer.paint['line-gap-width'] / 2 + antialiasing * 0.5;
        edgeWidth = layer.paint['line-width'];

        // shift outer lines half a pixel towards the middle to eliminate the crack
        offset = inset - antialiasing / 2;
    }

    var outset = offset + edgeWidth + antialiasing / 2 + shift;
    var color = layer.paint['line-color'];

    var tr = painter.transform;

    var antialiasingMatrix = mat2.create();
    mat2.scale(antialiasingMatrix, antialiasingMatrix, [1, Math.cos(tr._pitch)]);
    mat2.rotate(antialiasingMatrix, antialiasingMatrix, painter.transform.angle);

    // calculate how much longer the real world distance is at the top of the screen
    // than at the middle of the screen.
    var topedgelength = Math.sqrt(tr.height * tr.height / 4  * (1 + tr.altitude * tr.altitude));
    var x = tr.height / 2 * Math.tan(tr._pitch);
    var extra = (topedgelength + x) / topedgelength - 1;

    var dasharray = layer.paint['line-dasharray'];
    var image = layer.paint['line-pattern'];
    var shader, posA, posB, imagePosA, imagePosB;

    if (dasharray) {
        shader = painter.linesdfpatternShader;
        gl.switchShader(shader);

        gl.uniform2fv(shader.u_linewidth, [ outset, inset ]);
        gl.uniform1f(shader.u_blur, blur);
        gl.uniform4fv(shader.u_color, color);

        posA = painter.lineAtlas.getDash(dasharray.from, layer.layout['line-cap'] === 'round');
        posB = painter.lineAtlas.getDash(dasharray.to, layer.layout['line-cap'] === 'round');
        painter.lineAtlas.bind(gl);

        gl.uniform1f(shader.u_tex_y_a, posA.y);
        gl.uniform1f(shader.u_tex_y_b, posB.y);
        gl.uniform1i(shader.u_image, 0);
        gl.uniform1f(shader.u_mix, dasharray.t);

        gl.uniform1f(shader.u_extra, extra);
        gl.uniform1f(shader.u_offset, -layer.paint['line-offset']);
        gl.uniformMatrix2fv(shader.u_antialiasingmatrix, false, antialiasingMatrix);

    } else if (image) {
        imagePosA = painter.spriteAtlas.getPosition(image.from, true);
        imagePosB = painter.spriteAtlas.getPosition(image.to, true);
        if (!imagePosA || !imagePosB) return;

        painter.spriteAtlas.bind(gl, true);

        shader = painter.linepatternShader;
        gl.switchShader(shader);

        gl.uniform2fv(shader.u_linewidth, [ outset, inset ]);
        gl.uniform1f(shader.u_blur, blur);
        gl.uniform2fv(shader.u_pattern_tl_a, imagePosA.tl);
        gl.uniform2fv(shader.u_pattern_br_a, imagePosA.br);
        gl.uniform2fv(shader.u_pattern_tl_b, imagePosB.tl);
        gl.uniform2fv(shader.u_pattern_br_b, imagePosB.br);
        gl.uniform1f(shader.u_fade, image.t);
        gl.uniform1f(shader.u_opacity, layer.paint['line-opacity']);

        gl.uniform1f(shader.u_extra, extra);
        gl.uniform1f(shader.u_offset, -layer.paint['line-offset']);
        gl.uniformMatrix2fv(shader.u_antialiasingmatrix, false, antialiasingMatrix);

    } else {
        shader = painter.lineShader;
        gl.switchShader(shader);

        gl.uniform2fv(shader.u_linewidth, [ outset, inset ]);
        gl.uniform1f(shader.u_blur, blur);
        gl.uniform1f(shader.u_extra, extra);
        gl.uniform1f(shader.u_offset, -layer.paint['line-offset']);
        gl.uniformMatrix2fv(shader.u_antialiasingmatrix, false, antialiasingMatrix);
        gl.uniform4fv(shader.u_color, color);
    }

    for (var k = 0; k < coords.length; k++) {
        var coord = coords[k];
        var tile = source.getTile(coord);

        var elementGroups = tile.getElementGroups(layer, 'line');
        if (!elementGroups) continue;

        painter.enableTileClippingMask(coord);

        // set uniforms that are different for each tile
        var posMatrix = painter.translatePosMatrix(painter.calculatePosMatrix(coord, source.maxzoom), tile, layer.paint['line-translate'], layer.paint['line-translate-anchor']);

        gl.setPosMatrix(posMatrix);
        gl.setExMatrix(painter.transform.exMatrix);
        var ratio = painter.transform.scale / (1 << coord.z) / (4096 / tile.tileSize);


        if (dasharray) {
            // how much the tile is overscaled by
            var overscaling = tile.tileSize / painter.transform.tileSize;

            var patternratio = Math.pow(2, Math.floor(Math.log(painter.transform.scale) / Math.LN2) - coord.z) / 8 * overscaling;
            var scaleA = [patternratio / posA.width / dasharray.fromScale, -posA.height / 2];
            var gammaA = painter.lineAtlas.width / (dasharray.fromScale * posA.width * 256 * browser.devicePixelRatio) / 2;
            var scaleB = [patternratio / posB.width / dasharray.toScale, -posB.height / 2];
            var gammaB = painter.lineAtlas.width / (dasharray.toScale * posB.width * 256 * browser.devicePixelRatio) / 2;
            gl.uniform1f(shader.u_ratio, ratio);
            gl.uniform2fv(shader.u_patternscale_a, scaleA);
            gl.uniform2fv(shader.u_patternscale_b, scaleB);
            gl.uniform1f(shader.u_sdfgamma, Math.max(gammaA, gammaB));

        } else if (image) {
            var factor = 4096 / tile.tileSize / Math.pow(2, painter.transform.tileZoom - coord.z);
            gl.uniform1f(shader.u_ratio, ratio);
            gl.uniform2fv(shader.u_pattern_size_a, [imagePosA.size[0] * factor * image.fromScale, imagePosB.size[1] ]);
            gl.uniform2fv(shader.u_pattern_size_b, [imagePosB.size[0] * factor * image.toScale, imagePosB.size[1] ]);

        } else {
            gl.uniform1f(shader.u_ratio, ratio);
        }

        var vertex = tile.buffers.lineVertex;
        vertex.bind(gl);
        var element = tile.buffers.lineElement;
        element.bind(gl);

        for (var i = 0; i < elementGroups.groups.length; i++) {
            var group = elementGroups.groups[i];
            var vtxOffset = group.vertexStartIndex * vertex.itemSize;
            gl.vertexAttribPointer(shader.a_pos, 2, gl.SHORT, false, 8, vtxOffset + 0);
            gl.vertexAttribPointer(shader.a_data, 4, gl.BYTE, false, 8, vtxOffset + 4);

            var count = group.elementLength * 3;
            var elementOffset = group.elementStartIndex * element.itemSize;
            gl.drawElements(gl.TRIANGLES, count, gl.UNSIGNED_SHORT, elementOffset);
        }
    }

};

},{"../util/browser":83,"gl-matrix":110}],21:[function(require,module,exports){
'use strict';

var util = require('../util/util');

module.exports = drawRaster;

function drawRaster(painter, source, layer, coords) {
    if (painter.isOpaquePass) return;

    var gl = painter.gl;

    // Change depth function to prevent double drawing in areas where tiles overlap.
    gl.depthFunc(gl.LESS);

    for (var i = coords.length - 1; i >= 0; i--) {
        drawRasterTile(painter, source, layer, coords[i]);
    }

    gl.depthFunc(gl.LEQUAL);
}

function drawRasterTile(painter, source, layer, coord) {

    painter.setDepthSublayer(0);

    var gl = painter.gl;

    gl.disable(gl.STENCIL_TEST);

    var tile = source.getTile(coord);
    var posMatrix = painter.calculatePosMatrix(coord, source.maxzoom);

    var shader = painter.rasterShader;
    gl.switchShader(shader, posMatrix);

    // color parameters
    gl.uniform1f(shader.u_brightness_low, layer.paint['raster-brightness-min']);
    gl.uniform1f(shader.u_brightness_high, layer.paint['raster-brightness-max']);
    gl.uniform1f(shader.u_saturation_factor, saturationFactor(layer.paint['raster-saturation']));
    gl.uniform1f(shader.u_contrast_factor, contrastFactor(layer.paint['raster-contrast']));
    gl.uniform3fv(shader.u_spin_weights, spinWeights(layer.paint['raster-hue-rotate']));

    var parentTile = tile.source && tile.source._pyramid.findLoadedParent(coord, 0, {}),
        opacities = getOpacities(tile, parentTile, layer, painter.transform);

    var parentScaleBy, parentTL;

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, tile.texture);

    if (parentTile) {
        gl.activeTexture(gl.TEXTURE1);
        gl.bindTexture(gl.TEXTURE_2D, parentTile.texture);

        parentScaleBy = Math.pow(2, parentTile.coord.z - tile.coord.z);
        parentTL = [tile.coord.x * parentScaleBy % 1, tile.coord.y * parentScaleBy % 1];
    } else {
        opacities[1] = 0;
    }

    // cross-fade parameters
    gl.uniform2fv(shader.u_tl_parent, parentTL || [0, 0]);
    gl.uniform1f(shader.u_scale_parent, parentScaleBy || 1);
    gl.uniform1f(shader.u_buffer_scale, 1);
    gl.uniform1f(shader.u_opacity0, opacities[0]);
    gl.uniform1f(shader.u_opacity1, opacities[1]);
    gl.uniform1i(shader.u_image0, 0);
    gl.uniform1i(shader.u_image1, 1);

    gl.bindBuffer(gl.ARRAY_BUFFER, tile.boundsBuffer || painter.tileExtentBuffer);

    gl.vertexAttribPointer(shader.a_pos,         2, gl.SHORT, false, 8, 0);
    gl.vertexAttribPointer(shader.a_texture_pos, 2, gl.SHORT, false, 8, 4);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

    gl.enable(gl.STENCIL_TEST);
}

function spinWeights(angle) {
    angle *= Math.PI / 180;
    var s = Math.sin(angle);
    var c = Math.cos(angle);
    return [
        (2 * c + 1) / 3,
        (-Math.sqrt(3) * s - c + 1) / 3,
        (Math.sqrt(3) * s - c + 1) / 3
    ];
}

function contrastFactor(contrast) {
    return contrast > 0 ?
        1 / (1 - contrast) :
        1 + contrast;
}

function saturationFactor(saturation) {
    return saturation > 0 ?
        1 - 1 / (1.001 - saturation) :
        -saturation;
}

function getOpacities(tile, parentTile, layer, transform) {
    var opacity = [1, 0];
    var fadeDuration = layer.paint['raster-fade-duration'];

    if (tile.source && fadeDuration > 0) {
        var now = new Date().getTime();

        var sinceTile = (now - tile.timeAdded) / fadeDuration;
        var sinceParent = parentTile ? (now - parentTile.timeAdded) / fadeDuration : -1;

        var idealZ = tile.source._pyramid.coveringZoomLevel(transform);
        var parentFurther = parentTile ? Math.abs(parentTile.coord.z - idealZ) > Math.abs(tile.coord.z - idealZ) : false;

        if (!parentTile || parentFurther) {
            // if no parent or parent is older
            opacity[0] = util.clamp(sinceTile, 0, 1);
            opacity[1] = 1 - opacity[0];
        } else {
            // parent is younger, zooming out
            opacity[0] = util.clamp(1 - sinceParent, 0, 1);
            opacity[1] = 1 - opacity[0];
        }
    }

    var op = layer.paint['raster-opacity'];
    opacity[0] *= op;
    opacity[1] *= op;

    return opacity;
}

},{"../util/util":94}],22:[function(require,module,exports){
'use strict';

var mat4 = require('gl-matrix').mat4;

var browser = require('../util/browser');
var drawCollisionDebug = require('./draw_collision_debug');

module.exports = drawSymbols;

function drawSymbols(painter, source, layer, coords) {
    if (painter.isOpaquePass) return;

    var drawAcrossEdges = !(layer.layout['text-allow-overlap'] || layer.layout['icon-allow-overlap'] ||
        layer.layout['text-ignore-placement'] || layer.layout['icon-ignore-placement']);

    var gl = painter.gl;

    if (drawAcrossEdges) {
        // Disable the stencil test so that labels aren't clipped to tile boundaries.
        //
        // Layers with features that may be drawn overlapping aren't clipped. These
        // layers are sorted in the y direction, and to draw the correct ordering near
        // tile edges the icons are included in both tiles and clipped when drawing.
        gl.disable(gl.STENCIL_TEST);
    }

    painter.setDepthSublayer(0);
    painter.depthMask(false);
    gl.disable(gl.DEPTH_TEST);

    var tile, elementGroups, posMatrix;

    for (var i = 0; i < coords.length; i++) {
        tile = source.getTile(coords[i]);

        if (!tile.buffers) continue;
        elementGroups = tile.elementGroups[layer.ref || layer.id];
        if (!elementGroups) continue;
        if (!elementGroups.icon.groups.length) continue;

        posMatrix = painter.calculatePosMatrix(coords[i], source.maxzoom);
        painter.enableTileClippingMask(coords[i]);
        drawSymbol(painter, layer, posMatrix, tile, elementGroups.icon, 'icon', elementGroups.sdfIcons, elementGroups.iconsNeedLinear);
    }

    for (var j = 0; j < coords.length; j++) {
        tile = source.getTile(coords[j]);

        if (!tile.buffers) continue;
        elementGroups = tile.elementGroups[layer.ref || layer.id];
        if (!elementGroups) continue;
        if (!elementGroups.glyph.groups.length) continue;

        posMatrix = painter.calculatePosMatrix(coords[j], source.maxzoom);
        painter.enableTileClippingMask(coords[j]);
        drawSymbol(painter, layer, posMatrix, tile, elementGroups.glyph, 'text', true, false);
    }

    for (var k = 0; k < coords.length; k++) {
        tile = source.getTile(coords[k]);
        painter.enableTileClippingMask(coords[k]);
        drawCollisionDebug(painter, layer, coords[k], tile);
    }

    if (drawAcrossEdges) {
        gl.enable(gl.STENCIL_TEST);
    }
    gl.enable(gl.DEPTH_TEST);
}

var defaultSizes = {
    icon: 1,
    text: 24
};

function drawSymbol(painter, layer, posMatrix, tile, elementGroups, prefix, sdf, iconsNeedLinear) {
    var gl = painter.gl;

    posMatrix = painter.translatePosMatrix(posMatrix, tile, layer.paint[prefix + '-translate'], layer.paint[prefix + '-translate-anchor']);

    var tr = painter.transform;
    var alignedWithMap = layer.layout[prefix + '-rotation-alignment'] === 'map';
    var skewed = alignedWithMap;
    var exMatrix, s, gammaScale;

    if (skewed) {
        exMatrix = mat4.create();
        s = tile.tileExtent / tile.tileSize / Math.pow(2, painter.transform.zoom - tile.coord.z);
        gammaScale = 1 / Math.cos(tr._pitch);
    } else {
        exMatrix = mat4.clone(painter.transform.exMatrix);
        s = painter.transform.altitude;
        gammaScale = 1;
    }
    mat4.scale(exMatrix, exMatrix, [s, s, 1]);

    var fontSize = layer.paint[prefix + '-size'];
    var fontScale = fontSize / defaultSizes[prefix];
    mat4.scale(exMatrix, exMatrix, [ fontScale, fontScale, 1 ]);

    // calculate how much longer the real world distance is at the top of the screen
    // than at the middle of the screen.
    var topedgelength = Math.sqrt(tr.height * tr.height / 4  * (1 + tr.altitude * tr.altitude));
    var x = tr.height / 2 * Math.tan(tr._pitch);
    var extra = (topedgelength + x) / topedgelength - 1;

    var text = prefix === 'text';
    var shader, vertex, elements, texsize;

    if (!text && !painter.style.sprite.loaded())
        return;

    gl.activeTexture(gl.TEXTURE0);

    if (sdf) {
        shader = painter.sdfShader;
    } else {
        shader = painter.iconShader;
    }

    if (text) {
        var textfont = elementGroups['text-font'];
        var fontstack = textfont && textfont.join(',');
        var glyphAtlas = fontstack && painter.glyphSource.getGlyphAtlas(fontstack);
        if (!glyphAtlas) return;

        glyphAtlas.updateTexture(gl);
        vertex = tile.buffers.glyphVertex;
        elements = tile.buffers.glyphElement;
        texsize = [glyphAtlas.width / 4, glyphAtlas.height / 4];
    } else {
        var mapMoving = painter.options.rotating || painter.options.zooming;
        var iconScaled = fontScale !== 1 || browser.devicePixelRatio !== painter.spriteAtlas.pixelRatio || iconsNeedLinear;
        var iconTransformed = alignedWithMap || painter.transform.pitch;
        painter.spriteAtlas.bind(gl, sdf || mapMoving || iconScaled || iconTransformed);
        vertex = tile.buffers.iconVertex;
        elements = tile.buffers.iconElement;
        texsize = [painter.spriteAtlas.width / 4, painter.spriteAtlas.height / 4];
    }

    gl.switchShader(shader, posMatrix, exMatrix);
    gl.uniform1i(shader.u_texture, 0);
    gl.uniform2fv(shader.u_texsize, texsize);
    gl.uniform1i(shader.u_skewed, skewed);
    gl.uniform1f(shader.u_extra, extra);

    // adjust min/max zooms for variable font sizes
    var zoomAdjust = Math.log(fontSize / elementGroups[prefix + '-size']) / Math.LN2 || 0;


    gl.uniform1f(shader.u_zoom, (painter.transform.zoom - zoomAdjust) * 10); // current zoom level

    var f = painter.frameHistory.getFadeProperties(300);
    gl.uniform1f(shader.u_fadedist, f.fadedist * 10);
    gl.uniform1f(shader.u_minfadezoom, Math.floor(f.minfadezoom * 10));
    gl.uniform1f(shader.u_maxfadezoom, Math.floor(f.maxfadezoom * 10));
    gl.uniform1f(shader.u_fadezoom, (painter.transform.zoom + f.bump) * 10);

    var group, offset, count, elementOffset;

    elements.bind(gl);

    if (sdf) {
        var sdfPx = 8;
        var blurOffset = 1.19;
        var haloOffset = 6;
        var gamma = 0.105 * defaultSizes[prefix] / fontSize / browser.devicePixelRatio;

        if (layer.paint[prefix + '-halo-width']) {
            // Draw halo underneath the text.
            gl.uniform1f(shader.u_gamma, (layer.paint[prefix + '-halo-blur'] * blurOffset / fontScale / sdfPx + gamma) * gammaScale);
            gl.uniform4fv(shader.u_color, layer.paint[prefix + '-halo-color']);
            gl.uniform1f(shader.u_buffer, (haloOffset - layer.paint[prefix + '-halo-width'] / fontScale) / sdfPx);

            for (var j = 0; j < elementGroups.groups.length; j++) {
                group = elementGroups.groups[j];
                offset = group.vertexStartIndex * vertex.itemSize;
                vertex.bind(gl);
                vertex.setAttribPointers(gl, shader, offset);

                count = group.elementLength * 3;
                elementOffset = group.elementStartIndex * elements.itemSize;
                gl.drawElements(gl.TRIANGLES, count, gl.UNSIGNED_SHORT, elementOffset);
            }
        }

        gl.uniform1f(shader.u_gamma, gamma * gammaScale);
        gl.uniform4fv(shader.u_color, layer.paint[prefix + '-color']);
        gl.uniform1f(shader.u_buffer, (256 - 64) / 256);

        for (var i = 0; i < elementGroups.groups.length; i++) {
            group = elementGroups.groups[i];
            offset = group.vertexStartIndex * vertex.itemSize;
            vertex.bind(gl);
            vertex.setAttribPointers(gl, shader, offset);

            count = group.elementLength * 3;
            elementOffset = group.elementStartIndex * elements.itemSize;
            gl.drawElements(gl.TRIANGLES, count, gl.UNSIGNED_SHORT, elementOffset);
        }

    } else {
        gl.uniform1f(shader.u_opacity, layer.paint['icon-opacity']);
        for (var k = 0; k < elementGroups.groups.length; k++) {
            group = elementGroups.groups[k];
            offset = group.vertexStartIndex * vertex.itemSize;
            vertex.bind(gl);
            vertex.setAttribPointers(gl, shader, offset);

            count = group.elementLength * 3;
            elementOffset = group.elementStartIndex * elements.itemSize;
            gl.drawElements(gl.TRIANGLES, count, gl.UNSIGNED_SHORT, elementOffset);
        }
    }
}

},{"../util/browser":83,"./draw_collision_debug":17,"gl-matrix":110}],23:[function(require,module,exports){
'use strict';

module.exports = FrameHistory;

function FrameHistory() {
    this.frameHistory = [];
}

FrameHistory.prototype.getFadeProperties = function(duration) {
    if (duration === undefined) duration = 300;
    var currentTime = (new Date()).getTime();

    // Remove frames until only one is outside the duration, or until there are only three
    while (this.frameHistory.length > 3 && this.frameHistory[1].time + duration < currentTime) {
        this.frameHistory.shift();
    }

    if (this.frameHistory[1].time + duration < currentTime) {
        this.frameHistory[0].z = this.frameHistory[1].z;
    }

    var frameLen = this.frameHistory.length;
    if (frameLen < 3) console.warn('there should never be less than three frames in the history');

    // Find the range of zoom levels we want to fade between
    var startingZ = this.frameHistory[0].z,
        lastFrame = this.frameHistory[frameLen - 1],
        endingZ = lastFrame.z,
        lowZ = Math.min(startingZ, endingZ),
        highZ = Math.max(startingZ, endingZ);

    // Calculate the speed of zooming, and how far it would zoom in terms of zoom levels in one duration
    var zoomDiff = lastFrame.z - this.frameHistory[1].z,
        timeDiff = lastFrame.time - this.frameHistory[1].time;
    var fadedist = zoomDiff / (timeDiff / duration);

    if (isNaN(fadedist)) console.warn('fadedist should never be NaN');

    // At end of a zoom when the zoom stops changing continue pretending to zoom at that speed
    // bump is how much farther it would have been if it had continued zooming at the same rate
    var bump = (currentTime - lastFrame.time) / duration * fadedist;

    return {
        fadedist: fadedist,
        minfadezoom: lowZ,
        maxfadezoom: highZ,
        bump: bump
    };
};

// Record frame history that will be used to calculate fading params
FrameHistory.prototype.record = function(zoom) {
    var currentTime = (new Date()).getTime();

    // first frame ever
    if (!this.frameHistory.length) {
        this.frameHistory.push({time: 0, z: zoom }, {time: 0, z: zoom });
    }

    if (this.frameHistory.length === 2 || this.frameHistory[this.frameHistory.length - 1].z !== zoom) {
        this.frameHistory.push({
            time: currentTime,
            z: zoom
        });
    }
};

},{}],24:[function(require,module,exports){
'use strict';

var shaders = require('./shaders');
var util = require('../util/util');

exports.extend = function(context) {
    var origLineWidth = context.lineWidth,
        lineWidthRange = context.getParameter(context.ALIASED_LINE_WIDTH_RANGE);

    context.lineWidth = function(width) {
        origLineWidth.call(context, util.clamp(width, lineWidthRange[0], lineWidthRange[1]));
    };

    context.getShader = function(name, type) {
        var kind = type === this.FRAGMENT_SHADER ? 'fragment' : 'vertex';
        if (!shaders[name] || !shaders[name][kind]) {
            throw new Error("Could not find shader " + name);
        }

        var shader = this.createShader(type);
        var shaderSource = shaders[name][kind];

        if (typeof orientation === 'undefined') {
            // only use highp precision on mobile browsers
            shaderSource = shaderSource.replace(/ highp /g, ' ');
        }

        this.shaderSource(shader, shaderSource);
        this.compileShader(shader);
        if (!this.getShaderParameter(shader, this.COMPILE_STATUS)) {
            throw new Error(this.getShaderInfoLog(shader));
        }
        return shader;
    };

    context.initializeShader = function(name, attributes, uniforms) {
        var shader = {
            program: this.createProgram(),
            fragment: this.getShader(name, this.FRAGMENT_SHADER),
            vertex: this.getShader(name, this.VERTEX_SHADER),
            attributes: []
        };
        this.attachShader(shader.program, shader.vertex);
        this.attachShader(shader.program, shader.fragment);
        this.linkProgram(shader.program);

        if (!this.getProgramParameter(shader.program, this.LINK_STATUS)) {
            console.error(this.getProgramInfoLog(shader.program));
        } else {
            for (var i = 0; i < attributes.length; i++) {
                shader[attributes[i]] = this.getAttribLocation(shader.program, attributes[i]);
                shader.attributes.push(shader[attributes[i]]);
            }
            for (var k = 0; k < uniforms.length; k++) {
                shader[uniforms[k]] = this.getUniformLocation(shader.program, uniforms[k]);
            }
        }

        return shader;
    };

    // Switches to a different shader program.
    context.switchShader = function(shader, posMatrix, exMatrix) {
        if (this.currentShader !== shader) {
            this.useProgram(shader.program);

            // Disable all attributes from the existing shader that aren't used in
            // the new shader. Note: attribute indices are *not* program specific!
            var enabled = this.currentShader ? this.currentShader.attributes : [];
            var required = shader.attributes;

            for (var i = 0; i < enabled.length; i++) {
                if (required.indexOf(enabled[i]) < 0) {
                    this.disableVertexAttribArray(enabled[i]);
                }
            }

            // Enable all attributes for the new shader.
            for (var j = 0; j < required.length; j++) {
                if (enabled.indexOf(required[j]) < 0) {
                    this.enableVertexAttribArray(required[j]);
                }
            }

            this.currentShader = shader;
        }

        if (posMatrix !== undefined) context.setPosMatrix(posMatrix);
        if (exMatrix !== undefined) context.setExMatrix(exMatrix);
    };

    // Update the matrices if necessary. Note: This relies on object identity!
    // This means changing the matrix values without the actual matrix object
    // will FAIL to update the matrix properly.
    context.setPosMatrix = function(posMatrix) {
        var shader = this.currentShader;
        if (shader.posMatrix !== posMatrix) {
            this.uniformMatrix4fv(shader.u_matrix, false, posMatrix);
            shader.posMatrix = posMatrix;
        }
    };

    // Update the matrices if necessary. Note: This relies on object identity!
    // This means changing the matrix values without the actual matrix object
    // will FAIL to update the matrix properly.
    context.setExMatrix = function(exMatrix) {
        var shader = this.currentShader;
        if (exMatrix && shader.exMatrix !== exMatrix && shader.u_exmatrix) {
            this.uniformMatrix4fv(shader.u_exmatrix, false, exMatrix);
            shader.exMatrix = exMatrix;
        }
    };

    context.vertexAttrib2fv = function(attribute, values) {
        context.vertexAttrib2f(attribute, values[0], values[1]);
    };

    context.vertexAttrib3fv = function(attribute, values) {
        context.vertexAttrib3f(attribute, values[0], values[1], values[2]);
    };

    context.vertexAttrib4fv = function(attribute, values) {
        context.vertexAttrib4f(attribute, values[0], values[1], values[2], values[3]);
    };

    return context;
};

},{"../util/util":94,"./shaders":27}],25:[function(require,module,exports){
'use strict';

module.exports = LineAtlas;

/**
 * A LineAtlas lets us reuse rendered dashed lines
 * by writing many of them to a texture and then fetching their positions
 * using .getDash.
 *
 * @param {number} width
 * @param {number} height
 * @private
 */
function LineAtlas(width, height) {
    this.width = width;
    this.height = height;
    this.nextRow = 0;

    this.bytes = 4;
    this.data = new Uint8Array(this.width * this.height * this.bytes);

    this.positions = {};
}

LineAtlas.prototype.setSprite = function(sprite) {
    this.sprite = sprite;
};

/**
 * Get or create a dash line pattern.
 *
 * @param {Array<number>} dasharray
 * @param {boolean} round whether to add circle caps in between dash segments
 * @returns {Object} position of dash texture in { y, height, width }
 * @private
 */
LineAtlas.prototype.getDash = function(dasharray, round) {
    var key = dasharray.join(",") + round;

    if (!this.positions[key]) {
        this.positions[key] = this.addDash(dasharray, round);
    }
    return this.positions[key];
};

LineAtlas.prototype.addDash = function(dasharray, round) {

    var n = round ? 7 : 0;
    var height = 2 * n + 1;
    var offset = 128;

    if (this.nextRow + height > this.height) {
        console.warn('LineAtlas out of space');
        return null;
    }

    var length = 0;
    for (var i = 0; i < dasharray.length; i++) {
        length += dasharray[i];
    }

    var stretch = this.width / length;
    var halfWidth = stretch / 2;

    // If dasharray has an odd length, both the first and last parts
    // are dashes and should be joined seamlessly.
    var oddLength = dasharray.length % 2 === 1;

    for (var y = -n; y <= n; y++) {
        var row = this.nextRow + n + y;
        var index = this.width * row;

        var left = oddLength ? -dasharray[dasharray.length - 1] : 0;
        var right = dasharray[0];
        var partIndex = 1;

        for (var x = 0; x < this.width; x++) {

            while (right < x / stretch) {
                left = right;
                right = right + dasharray[partIndex];

                if (oddLength && partIndex === dasharray.length - 1) {
                    right += dasharray[0];
                }

                partIndex++;
            }

            var distLeft = Math.abs(x - left * stretch);
            var distRight = Math.abs(x - right * stretch);
            var dist = Math.min(distLeft, distRight);
            var inside = (partIndex % 2) === 1;
            var signedDistance;

            if (round) {
                // Add circle caps
                var distMiddle = n ? y / n * (halfWidth + 1) : 0;
                if (inside) {
                    var distEdge = halfWidth - Math.abs(distMiddle);
                    signedDistance = Math.sqrt(dist * dist + distEdge * distEdge);
                } else {
                    signedDistance = halfWidth - Math.sqrt(dist * dist + distMiddle * distMiddle);
                }
            } else {
                signedDistance = (inside ? 1 : -1) * dist;
            }

            this.data[3 + (index + x) * 4] = Math.max(0, Math.min(255, signedDistance + offset));
        }
    }

    var pos = {
        y: (this.nextRow + n + 0.5) / this.height,
        height: 2 * n / this.height,
        width: length
    };

    this.nextRow += height;
    this.dirty = true;

    return pos;
};

LineAtlas.prototype.bind = function(gl) {
    if (!this.texture) {
        this.texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.width, this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, this.data);

    } else {
        gl.bindTexture(gl.TEXTURE_2D, this.texture);

        if (this.dirty) {
            this.dirty = false;
            gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, this.width, this.height, gl.RGBA, gl.UNSIGNED_BYTE, this.data);
        }
    }
};

LineAtlas.prototype.debug = function() {

    var canvas = document.createElement('canvas');

    document.body.appendChild(canvas);
    canvas.style.position = 'absolute';
    canvas.style.top = 0;
    canvas.style.left = 0;
    canvas.style.background = '#ff0';

    canvas.width = this.width;
    canvas.height = this.height;

    var ctx = canvas.getContext('2d');
    var data = ctx.getImageData(0, 0, this.width, this.height);
    for (var i = 0; i < this.data.length; i++) {
        if (this.sdf) {
            var k = i * 4;
            data.data[k] = data.data[k + 1] = data.data[k + 2] = 0;
            data.data[k + 3] = this.data[i];
        } else {
            data.data[i] = this.data[i];
        }
    }
    ctx.putImageData(data, 0, 0);
};

},{}],26:[function(require,module,exports){
'use strict';

var glutil = require('./gl_util');
var browser = require('../util/browser');
var mat4 = require('gl-matrix').mat4;
var FrameHistory = require('./frame_history');
var TileCoord = require('../source/tile_coord');

/*
 * Initialize a new painter object.
 *
 * @param {Canvas} gl an experimental-webgl drawing context
 */
module.exports = Painter;
function Painter(gl, transform) {
    this.gl = glutil.extend(gl);
    this.transform = transform;

    this.reusableTextures = {};
    this.preFbos = {};

    this.frameHistory = new FrameHistory();

    this.setup();

    // Within each layer there are 3 distinct z-planes that can be drawn to.
    // This is implemented using the WebGL depth buffer.
    this.numSublayers = 3;
    this.depthEpsilon = 1 / Math.pow(2, 16);
}

/*
 * Update the GL viewport, projection matrix, and transforms to compensate
 * for a new width and height value.
 */
Painter.prototype.resize = function(width, height) {
    var gl = this.gl;

    this.width = width * browser.devicePixelRatio;
    this.height = height * browser.devicePixelRatio;
    gl.viewport(0, 0, this.width, this.height);

};


Painter.prototype.setup = function() {
    var gl = this.gl;

    gl.verbose = true;

    // We are blending the new pixels *behind* the existing pixels. That way we can
    // draw front-to-back and use then stencil buffer to cull opaque pixels early.
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);

    gl.enable(gl.STENCIL_TEST);

    gl.enable(gl.DEPTH_TEST);
    gl.depthFunc(gl.LEQUAL);

    this._depthMask = false;
    gl.depthMask(false);

    // Initialize shaders
    this.debugShader = gl.initializeShader('debug',
        ['a_pos'],
        ['u_matrix', 'u_color']);

    this.rasterShader = gl.initializeShader('raster',
        ['a_pos', 'a_texture_pos'],
        ['u_matrix', 'u_brightness_low', 'u_brightness_high', 'u_saturation_factor', 'u_spin_weights', 'u_contrast_factor', 'u_opacity0', 'u_opacity1', 'u_image0', 'u_image1', 'u_tl_parent', 'u_scale_parent', 'u_buffer_scale']);

    this.circleShader = gl.initializeShader('circle',
        ['a_pos'],
        ['u_matrix', 'u_exmatrix', 'u_blur', 'u_size', 'u_color']);

    this.lineShader = gl.initializeShader('line',
        ['a_pos', 'a_data'],
        ['u_matrix', 'u_linewidth', 'u_color', 'u_ratio', 'u_blur', 'u_extra', 'u_antialiasingmatrix', 'u_offset', 'u_exmatrix']);

    this.linepatternShader = gl.initializeShader('linepattern',
        ['a_pos', 'a_data'],
        ['u_matrix', 'u_linewidth', 'u_ratio', 'u_pattern_size_a', 'u_pattern_size_b', 'u_pattern_tl_a', 'u_pattern_br_a', 'u_pattern_tl_b', 'u_pattern_br_b', 'u_blur', 'u_fade', 'u_opacity', 'u_extra', 'u_antialiasingmatrix', 'u_offset']);

    this.linesdfpatternShader = gl.initializeShader('linesdfpattern',
        ['a_pos', 'a_data'],
        ['u_matrix', 'u_linewidth', 'u_color', 'u_ratio', 'u_blur', 'u_patternscale_a', 'u_tex_y_a', 'u_patternscale_b', 'u_tex_y_b', 'u_image', 'u_sdfgamma', 'u_mix', 'u_extra', 'u_antialiasingmatrix', 'u_offset']);

    this.dotShader = gl.initializeShader('dot',
        ['a_pos'],
        ['u_matrix', 'u_size', 'u_color', 'u_blur']);

    this.sdfShader = gl.initializeShader('sdf',
        ['a_pos', 'a_offset', 'a_data1', 'a_data2'],
        ['u_matrix', 'u_exmatrix', 'u_texture', 'u_texsize', 'u_color', 'u_gamma', 'u_buffer', 'u_zoom', 'u_fadedist', 'u_minfadezoom', 'u_maxfadezoom', 'u_fadezoom', 'u_skewed', 'u_extra']);

    this.iconShader = gl.initializeShader('icon',
        ['a_pos', 'a_offset', 'a_data1', 'a_data2'],
        ['u_matrix', 'u_exmatrix', 'u_texture', 'u_texsize', 'u_zoom', 'u_fadedist', 'u_minfadezoom', 'u_maxfadezoom', 'u_fadezoom', 'u_opacity', 'u_skewed', 'u_extra']);

    this.outlineShader = gl.initializeShader('outline',
        ['a_pos'],
        ['u_matrix', 'u_color', 'u_world']
    );

    this.patternShader = gl.initializeShader('pattern',
        ['a_pos'],
        ['u_matrix', 'u_pattern_tl_a', 'u_pattern_br_a', 'u_pattern_tl_b', 'u_pattern_br_b', 'u_mix', 'u_patternscale_a', 'u_patternscale_b', 'u_opacity', 'u_image', 'u_offset_a', 'u_offset_b']
    );

    this.fillShader = gl.initializeShader('fill',
        ['a_pos'],
        ['u_matrix', 'u_color']
    );

    this.collisionBoxShader = gl.initializeShader('collisionbox',
        ['a_pos', 'a_extrude', 'a_data'],
        ['u_matrix', 'u_scale', 'u_zoom', 'u_maxzoom']
    );

    this.identityMatrix = mat4.create();

    // The backgroundBuffer is used when drawing to the full *canvas*
    this.backgroundBuffer = gl.createBuffer();
    this.backgroundBuffer.itemSize = 2;
    this.backgroundBuffer.itemCount = 4;
    gl.bindBuffer(gl.ARRAY_BUFFER, this.backgroundBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Int16Array([-1, -1, 1, -1, -1, 1, 1, 1]), gl.STATIC_DRAW);

    this.setExtent(4096);

    // The debugTextBuffer is used to draw tile IDs for debugging
    this.debugTextBuffer = gl.createBuffer();
    this.debugTextBuffer.itemSize = 2;
};

/**
 * Rebind the necessary buffers to render at a different extent than
 * the current one. No-ops if the extent is not changing.
 *
 * @param {number} newExtent
 * @example
 * this.setExtent(4096);
 * @private
 */
Painter.prototype.setExtent = function(newExtent) {
    if (!newExtent || newExtent === this.tileExtent) return;

    this.tileExtent = newExtent;

    var gl = this.gl;

    // The tileExtentBuffer is used when drawing to a full *tile*
    this.tileExtentBuffer = gl.createBuffer();
    this.tileExtentBuffer.itemSize = 4;
    this.tileExtentBuffer.itemCount = 4;
    gl.bindBuffer(gl.ARRAY_BUFFER, this.tileExtentBuffer);
    gl.bufferData(
        gl.ARRAY_BUFFER,
        new Int16Array([
            // tile coord x, tile coord y, texture coord x, texture coord y
            0, 0, 0, 0,
            this.tileExtent, 0, 32767, 0,
            0, this.tileExtent, 0, 32767,
            this.tileExtent, this.tileExtent,  32767, 32767
        ]),
        gl.STATIC_DRAW);

    // The debugBuffer is used to draw tile outlines for debugging
    this.debugBuffer = gl.createBuffer();
    this.debugBuffer.itemSize = 2;
    this.debugBuffer.itemCount = 5;
    gl.bindBuffer(gl.ARRAY_BUFFER, this.debugBuffer);
    gl.bufferData(
        gl.ARRAY_BUFFER,
        new Int16Array([
            0, 0, this.tileExtent - 1, 0, this.tileExtent - 1, this.tileExtent - 1, 0, this.tileExtent - 1, 0, 0]),
        gl.STATIC_DRAW);
};

/*
 * Reset the color buffers of the drawing canvas.
 */
Painter.prototype.clearColor = function() {
    var gl = this.gl;
    gl.clearColor(0, 0, 0, 0);
    gl.clear(gl.COLOR_BUFFER_BIT);
};

/*
 * Reset the drawing canvas by clearing the stencil buffer so that we can draw
 * new tiles at the same location, while retaining previously drawn pixels.
 */
Painter.prototype.clearStencil = function() {
    var gl = this.gl;
    gl.clearStencil(0x0);
    gl.stencilMask(0xFF);
    gl.clear(gl.STENCIL_BUFFER_BIT);
};

Painter.prototype.clearDepth = function() {
    var gl = this.gl;
    gl.clearDepth(1);
    this.depthMask(true);
    gl.clear(gl.DEPTH_BUFFER_BIT);
};

Painter.prototype._renderTileClippingMasks = function(coords, sourceMaxZoom) {
    var gl = this.gl;
    gl.colorMask(false, false, false, false);
    this.depthMask(false);
    gl.disable(gl.DEPTH_TEST);

    // Only write clipping IDs to the last 5 bits. The first three are used for drawing fills.
    gl.stencilMask(0xF8);
    // Tests will always pass, and ref value will be written to stencil buffer.
    gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);

    var idNext = 1;
    this._tileClippingMaskIDs = {};
    for (var i = 0; i < coords.length; i++) {
        var coord = coords[i];
        var id = this._tileClippingMaskIDs[coord.id] = (idNext++) << 3;

        gl.stencilFunc(gl.ALWAYS, id, 0xF8);

        gl.switchShader(this.fillShader, this.calculatePosMatrix(coord, sourceMaxZoom));

        // Draw the clipping mask
        gl.bindBuffer(gl.ARRAY_BUFFER, this.tileExtentBuffer);
        gl.vertexAttribPointer(this.fillShader.a_pos, this.tileExtentBuffer.itemSize, gl.SHORT, false, 8, 0);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, this.tileExtentBuffer.itemCount);
    }

    gl.stencilMask(0x00);
    gl.colorMask(true, true, true, true);
    this.depthMask(true);
    gl.enable(gl.DEPTH_TEST);
};

Painter.prototype.enableTileClippingMask = function(coord) {
    var gl = this.gl;
    gl.stencilFunc(gl.EQUAL, this._tileClippingMaskIDs[coord.id], 0xF8);
};

// Overridden by headless tests.
Painter.prototype.prepareBuffers = function() {};
Painter.prototype.bindDefaultFramebuffer = function() {
    var gl = this.gl;
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
};

var draw = {
    symbol: require('./draw_symbol'),
    circle: require('./draw_circle'),
    line: require('./draw_line'),
    fill: require('./draw_fill'),
    raster: require('./draw_raster'),
    background: require('./draw_background'),
    debug: require('./draw_debug')
};

Painter.prototype.render = function(style, options) {
    this.style = style;
    this.options = options;

    this.lineAtlas = style.lineAtlas;

    this.spriteAtlas = style.spriteAtlas;
    this.spriteAtlas.setSprite(style.sprite);

    this.glyphSource = style.glyphSource;

    this.frameHistory.record(this.transform.zoom);

    this.prepareBuffers();
    this.clearColor();
    this.clearDepth();

    this.depthRange = (style._order.length + 2) * this.numSublayers * this.depthEpsilon;

    this.renderPass({isOpaquePass: true});
    this.renderPass({isOpaquePass: false});
};

Painter.prototype.renderPass = function(options) {
    var groups = this.style._groups;
    var isOpaquePass = options.isOpaquePass;
    this.currentLayer = isOpaquePass ? this.style._order.length : -1;

    for (var i = 0; i < groups.length; i++) {
        var group = groups[isOpaquePass ? groups.length - 1 - i : i];
        var source = this.style.sources[group.source];

        var coords = [];
        if (source) {
            coords = source.getVisibleCoordinates();
            this.clearStencil();
            if (source.prepare) source.prepare();
            if (source.isTileClipped) {
                this._renderTileClippingMasks(coords, source.maxzoom);
            }
        }

        if (isOpaquePass) {
            this.gl.disable(this.gl.BLEND);
            this.isOpaquePass = true;
        } else {
            this.gl.enable(this.gl.BLEND);
            this.isOpaquePass = false;
            coords.reverse();
        }

        for (var j = 0; j < group.length; j++) {
            var layer = group[isOpaquePass ? group.length - 1 - j : j];
            this.currentLayer += isOpaquePass ? -1 : 1;
            this.renderLayer(this, source, layer, coords);
        }

        draw.debug(this, coords);
    }
};

Painter.prototype.depthMask = function(mask) {
    if (mask !== this._depthMask) {
        this._depthMask = mask;
        this.gl.depthMask(mask);
    }
};

Painter.prototype.renderLayer = function(painter, source, layer, coords) {
    if (layer.hidden) return;
    if (layer.type !== 'background' && !coords.length) return;
    draw[layer.type](painter, source, layer, coords);
};

// Draws non-opaque areas. This is for debugging purposes.
Painter.prototype.drawStencilBuffer = function() {
    var gl = this.gl;
    gl.switchShader(this.fillShader, this.identityMatrix);

    gl.stencilMask(0x00);
    gl.stencilFunc(gl.EQUAL, 0x80, 0x80);

    // Drw the filling quad where the stencil buffer isn't set.
    gl.bindBuffer(gl.ARRAY_BUFFER, this.backgroundBuffer);
    gl.vertexAttribPointer(this.fillShader.a_pos, this.backgroundBuffer.itemSize, gl.SHORT, false, 0, 0);

    gl.uniform4fv(this.fillShader.u_color, [0, 0, 0, 0.5]);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, this.tileExtentBuffer.itemCount);
};

Painter.prototype.setDepthSublayer = function(n) {
    var farDepth = 1 - ((1 + this.currentLayer) * this.numSublayers + n) * this.depthEpsilon;
    var nearDepth = farDepth - 1 + this.depthRange;
    this.gl.depthRange(nearDepth, farDepth);
};

Painter.prototype.translatePosMatrix = function(matrix, tile, translate, anchor) {
    if (!translate[0] && !translate[1]) return matrix;

    if (anchor === 'viewport') {
        var sinA = Math.sin(-this.transform.angle);
        var cosA = Math.cos(-this.transform.angle);
        translate = [
            translate[0] * cosA - translate[1] * sinA,
            translate[0] * sinA + translate[1] * cosA
        ];
    }

    var tilePixelRatio = this.transform.scale / (1 << tile.coord.z) / (tile.tileExtent / tile.tileSize);
    var translation = [
        translate[0] / tilePixelRatio,
        translate[1] / tilePixelRatio,
        0
    ];

    var translatedMatrix = new Float32Array(16);
    mat4.translate(translatedMatrix, matrix, translation);
    return translatedMatrix;
};

/**
 * Calculate the posMatrix that this tile uses to display itself in a map,
 * given a coordinate as (z, x, y) and a transform
 * @param {Object} transform
 * @private
 */
Painter.prototype.calculatePosMatrix = function(coord, maxZoom) {
    var tileExtent = 4096;
    if (coord instanceof TileCoord) {
        coord = coord.toCoordinate();
    }
    var transform = this.transform;

    if (maxZoom === undefined) maxZoom = Infinity;

    // Initialize model-view matrix that converts from the tile coordinates
    // to screen coordinates.

    // if z > maxzoom then the tile is actually a overscaled maxzoom tile,
    // so calculate the matrix the maxzoom tile would use.
    var z = Math.min(coord.zoom, maxZoom);
    var x = coord.column;
    var y = coord.row;

    var scale = transform.worldSize / Math.pow(2, z);

    // The position matrix
    var posMatrix = new Float64Array(16);

    mat4.identity(posMatrix);
    mat4.translate(posMatrix, posMatrix, [x * scale, y * scale, 0]);
    mat4.scale(posMatrix, posMatrix, [ scale / tileExtent, scale / tileExtent, 1 ]);
    mat4.multiply(posMatrix, transform.projMatrix, posMatrix);

    return new Float32Array(posMatrix);
};

Painter.prototype.saveTexture = function(texture) {
    var textures = this.reusableTextures[texture.size];
    if (!textures) {
        this.reusableTextures[texture.size] = [texture];
    } else {
        textures.push(texture);
    }
};


Painter.prototype.getTexture = function(size) {
    var textures = this.reusableTextures[size];
    return textures && textures.length > 0 ? textures.pop() : null;
};

},{"../source/tile_coord":34,"../util/browser":83,"./draw_background":15,"./draw_circle":16,"./draw_debug":18,"./draw_fill":19,"./draw_line":20,"./draw_raster":21,"./draw_symbol":22,"./frame_history":23,"./gl_util":24,"gl-matrix":110}],27:[function(require,module,exports){
'use strict';


var path = require('path');

// Must be written out long-form for brfs.
module.exports = {
    debug: {
        fragment: "precision mediump float;\n\nuniform vec4 u_color;\n\nvoid main() {\n    gl_FragColor = u_color;\n}\n",
        vertex: "precision mediump float;\n\nattribute vec2 a_pos;\n\nuniform highp mat4 u_matrix;\n\nvoid main() {\n    gl_Position = u_matrix * vec4(a_pos, step(32767.0, a_pos.x), 1);\n}\n"
    },
    dot: {
        fragment: "precision mediump float;\n\nuniform vec4 u_color;\nuniform float u_blur;\n\nvoid main() {\n    float dist = length(gl_PointCoord - 0.5);\n    float t = smoothstep(0.5, 0.5 - u_blur, dist);\n\n    gl_FragColor = u_color * t;\n}\n",
        vertex: "precision mediump float;\n\nuniform highp mat4 u_matrix;\nuniform float u_size;\n\nattribute vec2 a_pos;\n\nvoid main(void) {\n    gl_Position = u_matrix * vec4(a_pos, 0, 1);\n    gl_PointSize = u_size;\n}\n"
    },
    fill: {
        fragment: "precision mediump float;\n\nuniform vec4 u_color;\n\nvoid main() {\n    gl_FragColor = u_color;\n}\n",
        vertex: "precision mediump float;\n\nattribute vec2 a_pos;\nuniform highp mat4 u_matrix;\n\nvoid main() {\n    gl_Position = u_matrix * vec4(a_pos, 0, 1);\n}\n"
    },
    circle: {
        fragment: "precision mediump float;\n\nuniform vec4 u_color;\nuniform float u_blur;\nuniform float u_size;\n\nvarying vec2 v_extrude;\n\nvoid main() {\n    float t = smoothstep(1.0 - u_blur, 1.0, length(v_extrude));\n    gl_FragColor = u_color * (1.0 - t);\n}\n",
        vertex: "precision mediump float;\n\n// set by gl_util\nuniform float u_size;\n\nattribute vec2 a_pos;\n\nuniform highp mat4 u_matrix;\nuniform mat4 u_exmatrix;\n\nvarying vec2 v_extrude;\n\nvoid main(void) {\n    // unencode the extrusion vector that we snuck into the a_pos vector\n    v_extrude = vec2(mod(a_pos, 2.0) * 2.0 - 1.0);\n\n    vec4 extrude = u_exmatrix * vec4(v_extrude * u_size, 0, 0);\n    // multiply a_pos by 0.5, since we had it * 2 in order to sneak\n    // in extrusion data\n    gl_Position = u_matrix * vec4(floor(a_pos * 0.5), 0, 1);\n\n    // gl_Position is divided by gl_Position.w after this shader runs.\n    // Multiply the extrude by it so that it isn't affected by it.\n    gl_Position += extrude * gl_Position.w;\n}\n"
    },
    line: {
        fragment: "precision mediump float;\n\nuniform vec2 u_linewidth;\nuniform vec4 u_color;\nuniform float u_blur;\n\nvarying vec2 v_normal;\nvarying float v_linesofar;\nvarying float v_gamma_scale;\n\nvoid main() {\n    // Calculate the distance of the pixel from the line in pixels.\n    float dist = length(v_normal) * u_linewidth.s;\n\n    // Calculate the antialiasing fade factor. This is either when fading in\n    // the line in case of an offset line (v_linewidth.t) or when fading out\n    // (v_linewidth.s)\n    float blur = u_blur * v_gamma_scale;\n    float alpha = clamp(min(dist - (u_linewidth.t - blur), u_linewidth.s - dist) / blur, 0.0, 1.0);\n\n    gl_FragColor = u_color * alpha;\n}\n",
        vertex: "precision mediump float;\n\n// floor(127 / 2) == 63.0\n// the maximum allowed miter limit is 2.0 at the moment. the extrude normal is\n// stored in a byte (-128..127). we scale regular normals up to length 63, but\n// there are also \"special\" normals that have a bigger length (of up to 126 in\n// this case).\n// #define scale 63.0\n#define scale 0.015873016\n\nattribute vec2 a_pos;\nattribute vec4 a_data;\n\nuniform highp mat4 u_matrix;\nuniform float u_ratio;\nuniform vec2 u_linewidth;\nuniform float u_extra;\nuniform mat2 u_antialiasingmatrix;\nuniform float u_offset;\n\nvarying vec2 v_normal;\nvarying float v_linesofar;\nvarying float v_gamma_scale;\n\nvoid main() {\n    vec2 a_extrude = a_data.xy;\n    float a_direction = sign(a_data.z) * mod(a_data.z, 2.0);\n\n    // We store the texture normals in the most insignificant bit\n    // transform y so that 0 => -1 and 1 => 1\n    // In the texture normal, x is 0 if the normal points straight up/down and 1 if it's a round cap\n    // y is 1 if the normal points up, and -1 if it points down\n    vec2 normal = mod(a_pos, 2.0);\n    normal.y = sign(normal.y - 0.5);\n    v_normal = normal;\n\n    // Scale the extrusion vector down to a normal and then up by the line width\n    // of this vertex.\n    vec4 dist = vec4(u_linewidth.s * a_extrude * scale, 0.0, 0.0);\n\n    // Calculate the offset when drawing a line that is to the side of the actual line.\n    // We do this by creating a vector that points towards the extrude, but rotate\n    // it when we're drawing round end points (a_direction = -1 or 1) since their\n    // extrude vector points in another direction.\n    float u = 0.5 * a_direction;\n    float t = 1.0 - abs(u);\n    vec2 offset = u_offset * a_extrude * scale * normal.y * mat2(t, -u, u, t);\n\n    // Remove the texture normal bit of the position before scaling it with the\n    // model/view matrix.\n    gl_Position = u_matrix * vec4(floor(a_pos * 0.5) + (offset + dist.xy) / u_ratio, 0.0, 1.0);\n\n    // position of y on the screen\n    float y = gl_Position.y / gl_Position.w;\n\n    // how much features are squished in the y direction by the tilt\n    float squish_scale = length(a_extrude) / length(u_antialiasingmatrix * a_extrude);\n\n    // how much features are squished in all directions by the perspectiveness\n    float perspective_scale = 1.0 / (1.0 - min(y * u_extra, 0.9));\n\n    v_gamma_scale = perspective_scale * squish_scale;\n}\n"
    },
    linepattern: {
        fragment: "precision mediump float;\n\nuniform vec2 u_linewidth;\nuniform float u_point;\nuniform float u_blur;\n\nuniform vec2 u_pattern_size_a;\nuniform vec2 u_pattern_size_b;\nuniform vec2 u_pattern_tl_a;\nuniform vec2 u_pattern_br_a;\nuniform vec2 u_pattern_tl_b;\nuniform vec2 u_pattern_br_b;\nuniform float u_fade;\nuniform float u_opacity;\n\nuniform sampler2D u_image;\n\nvarying vec2 v_normal;\nvarying float v_linesofar;\nvarying float v_gamma_scale;\n\nvoid main() {\n    // Calculate the distance of the pixel from the line in pixels.\n    float dist = length(v_normal) * u_linewidth.s;\n\n    // Calculate the antialiasing fade factor. This is either when fading in\n    // the line in case of an offset line (v_linewidth.t) or when fading out\n    // (v_linewidth.s)\n    float blur = u_blur * v_gamma_scale;\n    float alpha = clamp(min(dist - (u_linewidth.t - blur), u_linewidth.s - dist) / blur, 0.0, 1.0);\n\n    float x_a = mod(v_linesofar / u_pattern_size_a.x, 1.0);\n    float x_b = mod(v_linesofar / u_pattern_size_b.x, 1.0);\n    float y_a = 0.5 + (v_normal.y * u_linewidth.s / u_pattern_size_a.y);\n    float y_b = 0.5 + (v_normal.y * u_linewidth.s / u_pattern_size_b.y);\n    vec2 pos = mix(u_pattern_tl_a, u_pattern_br_a, vec2(x_a, y_a));\n    vec2 pos2 = mix(u_pattern_tl_b, u_pattern_br_b, vec2(x_b, y_b));\n\n    vec4 color = mix(texture2D(u_image, pos), texture2D(u_image, pos2), u_fade);\n\n    alpha *= u_opacity;\n\n    gl_FragColor = color * alpha;\n}\n",
        vertex: "precision mediump float;\n\n// floor(127 / 2) == 63.0\n// the maximum allowed miter limit is 2.0 at the moment. the extrude normal is\n// stored in a byte (-128..127). we scale regular normals up to length 63, but\n// there are also \"special\" normals that have a bigger length (of up to 126 in\n// this case).\n// #define scale 63.0\n#define scale 0.015873016\n\nattribute vec2 a_pos;\nattribute vec4 a_data;\n\nuniform highp mat4 u_matrix;\nuniform float u_ratio;\nuniform vec2 u_linewidth;\nuniform vec4 u_color;\nuniform float u_extra;\nuniform mat2 u_antialiasingmatrix;\nuniform float u_offset;\n\nvarying vec2 v_normal;\nvarying float v_linesofar;\nvarying float v_gamma_scale;\n\nvoid main() {\n    vec2 a_extrude = a_data.xy;\n    float a_direction = sign(a_data.z) * mod(a_data.z, 2.0);\n    float a_linesofar = abs(floor(a_data.z / 2.0)) + a_data.w * 64.0;\n\n    // We store the texture normals in the most insignificant bit\n    // transform y so that 0 => -1 and 1 => 1\n    // In the texture normal, x is 0 if the normal points straight up/down and 1 if it's a round cap\n    // y is 1 if the normal points up, and -1 if it points down\n    vec2 normal = mod(a_pos, 2.0);\n    normal.y = sign(normal.y - 0.5);\n    v_normal = normal;\n\n    // Scale the extrusion vector down to a normal and then up by the line width\n    // of this vertex.\n    vec2 extrude = a_extrude * scale;\n    vec2 dist = u_linewidth.s * extrude;\n\n    // Calculate the offset when drawing a line that is to the side of the actual line.\n    // We do this by creating a vector that points towards the extrude, but rotate\n    // it when we're drawing round end points (a_direction = -1 or 1) since their\n    // extrude vector points in another direction.\n    float u = 0.5 * a_direction;\n    float t = 1.0 - abs(u);\n    vec2 offset = u_offset * a_extrude * scale * normal.y * mat2(t, -u, u, t);\n\n    // Remove the texture normal bit of the position before scaling it with the\n    // model/view matrix.\n    gl_Position = u_matrix * vec4(floor(a_pos * 0.5) + (offset + dist.xy) / u_ratio, 0.0, 1.0);\n    v_linesofar = a_linesofar;\n\n    // position of y on the screen\n    float y = gl_Position.y / gl_Position.w;\n\n    // how much features are squished in the y direction by the tilt\n    float squish_scale = length(a_extrude) / length(u_antialiasingmatrix * a_extrude);\n\n    // how much features are squished in all directions by the perspectiveness\n    float perspective_scale = 1.0 / (1.0 - min(y * u_extra, 0.9));\n\n    v_gamma_scale = perspective_scale * squish_scale;\n}\n"
    },
    linesdfpattern: {
        fragment: "precision mediump float;\n\nuniform vec2 u_linewidth;\nuniform vec4 u_color;\nuniform float u_blur;\nuniform sampler2D u_image;\nuniform float u_sdfgamma;\nuniform float u_mix;\n\nvarying vec2 v_normal;\nvarying vec2 v_tex_a;\nvarying vec2 v_tex_b;\nvarying float v_gamma_scale;\n\nvoid main() {\n    // Calculate the distance of the pixel from the line in pixels.\n    float dist = length(v_normal) * u_linewidth.s;\n\n    // Calculate the antialiasing fade factor. This is either when fading in\n    // the line in case of an offset line (v_linewidth.t) or when fading out\n    // (v_linewidth.s)\n    float blur = u_blur * v_gamma_scale;\n    float alpha = clamp(min(dist - (u_linewidth.t - blur), u_linewidth.s - dist) / blur, 0.0, 1.0);\n\n    float sdfdist_a = texture2D(u_image, v_tex_a).a;\n    float sdfdist_b = texture2D(u_image, v_tex_b).a;\n    float sdfdist = mix(sdfdist_a, sdfdist_b, u_mix);\n    alpha *= smoothstep(0.5 - u_sdfgamma, 0.5 + u_sdfgamma, sdfdist);\n\n    gl_FragColor = u_color * alpha;\n}\n",
        vertex: "precision mediump float;\n\n// floor(127 / 2) == 63.0\n// the maximum allowed miter limit is 2.0 at the moment. the extrude normal is\n// stored in a byte (-128..127). we scale regular normals up to length 63, but\n// there are also \"special\" normals that have a bigger length (of up to 126 in\n// this case).\n// #define scale 63.0\n#define scale 0.015873016\n\nattribute vec2 a_pos;\nattribute vec4 a_data;\n\nuniform highp mat4 u_matrix;\nuniform vec2 u_linewidth;\nuniform float u_ratio;\nuniform vec2 u_patternscale_a;\nuniform float u_tex_y_a;\nuniform vec2 u_patternscale_b;\nuniform float u_tex_y_b;\nuniform float u_extra;\nuniform mat2 u_antialiasingmatrix;\nuniform float u_offset;\n\nvarying vec2 v_normal;\nvarying vec2 v_tex_a;\nvarying vec2 v_tex_b;\nvarying float v_gamma_scale;\n\nvoid main() {\n    vec2 a_extrude = a_data.xy;\n    float a_direction = sign(a_data.z) * mod(a_data.z, 2.0);\n    float a_linesofar = abs(floor(a_data.z / 2.0)) + a_data.w * 64.0;\n\n    // We store the texture normals in the most insignificant bit\n    // transform y so that 0 => -1 and 1 => 1\n    // In the texture normal, x is 0 if the normal points straight up/down and 1 if it's a round cap\n    // y is 1 if the normal points up, and -1 if it points down\n    vec2 normal = mod(a_pos, 2.0);\n    normal.y = sign(normal.y - 0.5);\n    v_normal = normal;\n\n    // Scale the extrusion vector down to a normal and then up by the line width\n    // of this vertex.\n    vec4 dist = vec4(u_linewidth.s * a_extrude * scale, 0.0, 0.0);\n\n    // Calculate the offset when drawing a line that is to the side of the actual line.\n    // We do this by creating a vector that points towards the extrude, but rotate\n    // it when we're drawing round end points (a_direction = -1 or 1) since their\n    // extrude vector points in another direction.\n    float u = 0.5 * a_direction;\n    float t = 1.0 - abs(u);\n    vec2 offset = u_offset * a_extrude * scale * normal.y * mat2(t, -u, u, t);\n\n    // Remove the texture normal bit of the position before scaling it with the\n    // model/view matrix.\n    gl_Position = u_matrix * vec4(floor(a_pos * 0.5) + (offset + dist.xy) / u_ratio, 0.0, 1.0);\n\n    v_tex_a = vec2(a_linesofar * u_patternscale_a.x, normal.y * u_patternscale_a.y + u_tex_y_a);\n    v_tex_b = vec2(a_linesofar * u_patternscale_b.x, normal.y * u_patternscale_b.y + u_tex_y_b);\n\n    // position of y on the screen\n    float y = gl_Position.y / gl_Position.w;\n\n    // how much features are squished in the y direction by the tilt\n    float squish_scale = length(a_extrude) / length(u_antialiasingmatrix * a_extrude);\n\n    // how much features are squished in all directions by the perspectiveness\n    float perspective_scale = 1.0 / (1.0 - min(y * u_extra, 0.9));\n\n    v_gamma_scale = perspective_scale * squish_scale;\n}\n"
    },
    outline: {
        fragment: "precision mediump float;\n\nuniform vec4 u_color;\n\nvarying vec2 v_pos;\n\nvoid main() {\n    float dist = length(v_pos - gl_FragCoord.xy);\n    float alpha = smoothstep(1.0, 0.0, dist);\n    gl_FragColor = u_color * alpha;\n}\n",
        vertex: "precision mediump float;\n\nattribute vec2 a_pos;\n\nuniform highp mat4 u_matrix;\nuniform vec2 u_world;\n\nvarying vec2 v_pos;\n\nvoid main() {\n    gl_Position = u_matrix * vec4(a_pos, 0, 1);\n    v_pos = (gl_Position.xy/gl_Position.w + 1.0) / 2.0 * u_world;\n}\n"
    },
    pattern: {
        fragment: "precision mediump float;\n\nuniform float u_opacity;\nuniform vec2 u_pattern_tl_a;\nuniform vec2 u_pattern_br_a;\nuniform vec2 u_pattern_tl_b;\nuniform vec2 u_pattern_br_b;\nuniform float u_mix;\n\nuniform sampler2D u_image;\n\nvarying vec2 v_pos_a;\nvarying vec2 v_pos_b;\n\nvoid main() {\n\n    vec2 imagecoord = mod(v_pos_a, 1.0);\n    vec2 pos = mix(u_pattern_tl_a, u_pattern_br_a, imagecoord);\n    vec4 color1 = texture2D(u_image, pos);\n\n    vec2 imagecoord_b = mod(v_pos_b, 1.0);\n    vec2 pos2 = mix(u_pattern_tl_b, u_pattern_br_b, imagecoord_b);\n    vec4 color2 = texture2D(u_image, pos2);\n\n    gl_FragColor = mix(color1, color2, u_mix) * u_opacity;\n}\n",
        vertex: "precision mediump float;\n\nuniform highp mat4 u_matrix;\nuniform vec2 u_patternscale_a;\nuniform vec2 u_patternscale_b;\nuniform vec2 u_offset_a;\nuniform vec2 u_offset_b;\n\nattribute vec2 a_pos;\n\nvarying vec2 v_pos_a;\nvarying vec2 v_pos_b;\n\nvoid main() {\n    gl_Position = u_matrix * vec4(a_pos, 0, 1);\n    v_pos_a = u_patternscale_a * a_pos + u_offset_a;\n    v_pos_b = u_patternscale_b * a_pos + u_offset_b;\n}\n"
    },
    raster: {
        fragment: "precision mediump float;\n\nuniform float u_opacity0;\nuniform float u_opacity1;\nuniform sampler2D u_image0;\nuniform sampler2D u_image1;\nvarying vec2 v_pos0;\nvarying vec2 v_pos1;\n\nuniform float u_brightness_low;\nuniform float u_brightness_high;\n\nuniform float u_saturation_factor;\nuniform float u_contrast_factor;\nuniform vec3 u_spin_weights;\n\nvoid main() {\n\n    // read and cross-fade colors from the main and parent tiles\n    vec4 color0 = texture2D(u_image0, v_pos0);\n    vec4 color1 = texture2D(u_image1, v_pos1);\n    vec4 color = color0 * u_opacity0 + color1 * u_opacity1;\n    vec3 rgb = color.rgb;\n\n    // spin\n    rgb = vec3(\n        dot(rgb, u_spin_weights.xyz),\n        dot(rgb, u_spin_weights.zxy),\n        dot(rgb, u_spin_weights.yzx));\n\n    // saturation\n    float average = (color.r + color.g + color.b) / 3.0;\n    rgb += (average - rgb) * u_saturation_factor;\n\n    // contrast\n    rgb = (rgb - 0.5) * u_contrast_factor + 0.5;\n\n    // brightness\n    vec3 u_high_vec = vec3(u_brightness_low, u_brightness_low, u_brightness_low);\n    vec3 u_low_vec = vec3(u_brightness_high, u_brightness_high, u_brightness_high);\n\n    gl_FragColor = vec4(mix(u_high_vec, u_low_vec, rgb), color.a);\n}\n",
        vertex: "precision mediump float;\n\nuniform highp mat4 u_matrix;\nuniform vec2 u_tl_parent;\nuniform float u_scale_parent;\nuniform float u_buffer_scale;\n\nattribute vec2 a_pos;\nattribute vec2 a_texture_pos;\n\nvarying vec2 v_pos0;\nvarying vec2 v_pos1;\n\nvoid main() {\n    gl_Position = u_matrix * vec4(a_pos, 0, 1);\n    v_pos0 = (((a_texture_pos / 32767.0) - 0.5) / u_buffer_scale ) + 0.5;\n    v_pos1 = (v_pos0 * u_scale_parent) + u_tl_parent;\n}\n"
    },
    icon: {
        fragment: "precision mediump float;\n\nuniform sampler2D u_texture;\n\nvarying vec2 v_tex;\nvarying float v_alpha;\n\nvoid main() {\n    gl_FragColor = texture2D(u_texture, v_tex) * v_alpha;\n}\n",
        vertex: "precision mediump float;\n\nattribute vec2 a_pos;\nattribute vec2 a_offset;\nattribute vec4 a_data1;\nattribute vec4 a_data2;\n\n\n// matrix is for the vertex position, exmatrix is for rotating and projecting\n// the extrusion vector.\nuniform highp mat4 u_matrix;\nuniform mat4 u_exmatrix;\nuniform float u_zoom;\nuniform float u_fadedist;\nuniform float u_minfadezoom;\nuniform float u_maxfadezoom;\nuniform float u_fadezoom;\nuniform float u_opacity;\nuniform bool u_skewed;\nuniform float u_extra;\n\nuniform vec2 u_texsize;\n\nvarying vec2 v_tex;\nvarying float v_alpha;\n\nvoid main() {\n    vec2 a_tex = a_data1.xy;\n    float a_labelminzoom = a_data1[2];\n    vec2 a_zoom = a_data2.st;\n    float a_minzoom = a_zoom[0];\n    float a_maxzoom = a_zoom[1];\n\n    float a_fadedist = 10.0;\n\n    // u_zoom is the current zoom level adjusted for the change in font size\n    float z = 2.0 - step(a_minzoom, u_zoom) - (1.0 - step(a_maxzoom, u_zoom));\n\n    // fade out labels\n    float alpha = clamp((u_fadezoom - a_labelminzoom) / u_fadedist, 0.0, 1.0);\n\n    if (u_fadedist >= 0.0) {\n        v_alpha = alpha;\n    } else {\n        v_alpha = 1.0 - alpha;\n    }\n    if (u_maxfadezoom < a_labelminzoom) {\n        v_alpha = 0.0;\n    }\n    if (u_minfadezoom >= a_labelminzoom) {\n        v_alpha = 1.0;\n    }\n\n    // if label has been faded out, clip it\n    z += step(v_alpha, 0.0);\n\n    if (u_skewed) {\n        vec4 extrude = u_exmatrix * vec4(a_offset / 64.0, 0, 0);\n        gl_Position = u_matrix * vec4(a_pos + extrude.xy, 0, 1);\n        gl_Position.z += z * gl_Position.w;\n    } else {\n        vec4 extrude = u_exmatrix * vec4(a_offset / 64.0, z, 0);\n        gl_Position = u_matrix * vec4(a_pos, 0, 1) + extrude;\n    }\n\n    v_tex = a_tex / u_texsize;\n\n    v_alpha *= u_opacity;\n}\n"
    },
    sdf: {
        fragment: "precision mediump float;\n\nuniform sampler2D u_texture;\nuniform vec4 u_color;\nuniform float u_buffer;\nuniform float u_gamma;\n\nvarying vec2 v_tex;\nvarying float v_alpha;\nvarying float v_gamma_scale;\n\nvoid main() {\n    float gamma = u_gamma * v_gamma_scale;\n    float dist = texture2D(u_texture, v_tex).a;\n    float alpha = smoothstep(u_buffer - gamma, u_buffer + gamma, dist) * v_alpha;\n    gl_FragColor = u_color * alpha;\n}\n",
        vertex: "precision mediump float;\n\nattribute vec2 a_pos;\nattribute vec2 a_offset;\nattribute vec4 a_data1;\nattribute vec4 a_data2;\n\n\n// matrix is for the vertex position, exmatrix is for rotating and projecting\n// the extrusion vector.\nuniform highp mat4 u_matrix;\nuniform mat4 u_exmatrix;\n\nuniform float u_zoom;\nuniform float u_fadedist;\nuniform float u_minfadezoom;\nuniform float u_maxfadezoom;\nuniform float u_fadezoom;\nuniform bool u_skewed;\nuniform float u_extra;\n\nuniform vec2 u_texsize;\n\nvarying vec2 v_tex;\nvarying float v_alpha;\nvarying float v_gamma_scale;\n\nvoid main() {\n    vec2 a_tex = a_data1.xy;\n    float a_labelminzoom = a_data1[2];\n    vec2 a_zoom = a_data2.st;\n    float a_minzoom = a_zoom[0];\n    float a_maxzoom = a_zoom[1];\n\n    // u_zoom is the current zoom level adjusted for the change in font size\n    float z = 2.0 - step(a_minzoom, u_zoom) - (1.0 - step(a_maxzoom, u_zoom));\n\n    // fade out labels\n    float alpha = clamp((u_fadezoom - a_labelminzoom) / u_fadedist, 0.0, 1.0);\n\n    if (u_fadedist >= 0.0) {\n        v_alpha = alpha;\n    } else {\n        v_alpha = 1.0 - alpha;\n    }\n    if (u_maxfadezoom < a_labelminzoom) {\n        v_alpha = 0.0;\n    }\n    if (u_minfadezoom >= a_labelminzoom) {\n        v_alpha = 1.0;\n    }\n\n    // if label has been faded out, clip it\n    z += step(v_alpha, 0.0);\n\n    if (u_skewed) {\n        vec4 extrude = u_exmatrix * vec4(a_offset / 64.0, 0, 0);\n        gl_Position = u_matrix * vec4(a_pos + extrude.xy, 0, 1);\n        gl_Position.z += z * gl_Position.w;\n    } else {\n        vec4 extrude = u_exmatrix * vec4(a_offset / 64.0, z, 0);\n        gl_Position = u_matrix * vec4(a_pos, 0, 1) + extrude;\n    }\n\n    // position of y on the screen\n    float y = gl_Position.y / gl_Position.w;\n    // how much features are squished in all directions by the perspectiveness\n    float perspective_scale = 1.0 / (1.0 - y * u_extra);\n    v_gamma_scale = perspective_scale;\n\n    v_tex = a_tex / u_texsize;\n}\n"
    },
    collisionbox: {
        fragment: "precision mediump float;\n\nuniform float u_zoom;\nuniform float u_maxzoom;\n\nvarying float v_max_zoom;\nvarying float v_placement_zoom;\n\nvoid main() {\n\n    float alpha = 0.5;\n\n    gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0) * alpha;\n\n    if (v_placement_zoom > u_zoom) {\n        gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0) * alpha;\n    }\n\n    if (u_zoom >= v_max_zoom) {\n        gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0) * alpha * 0.25;\n    }\n\n    if (v_placement_zoom >= u_maxzoom) {\n        gl_FragColor = vec4(0.0, 0.0, 1.0, 1.0) * alpha * 0.2;\n    }\n}\n",
        vertex: "precision mediump float;\n\nattribute vec2 a_pos;\nattribute vec2 a_extrude;\nattribute vec2 a_data;\n\nuniform highp mat4 u_matrix;\nuniform float u_scale;\n\nvarying float v_max_zoom;\nvarying float v_placement_zoom;\n\nvoid main() {\n     gl_Position = u_matrix * vec4(a_pos + a_extrude / u_scale, 0.0, 1.0);\n\n     v_max_zoom = a_data.x;\n     v_placement_zoom = a_data.y;\n}\n"
    }
};

},{"path":97}],28:[function(require,module,exports){
'use strict';

var util = require('../util/util');
var Evented = require('../util/evented');
var TilePyramid = require('./tile_pyramid');
var Source = require('./source');
var urlResolve = require('resolve-url');

module.exports = GeoJSONSource;

/**
 * Create a GeoJSON data source instance given an options object
 * @class GeoJSONSource
 * @param {Object} [options]
 * @param {Object|string} options.data A GeoJSON data object or URL to it. The latter is preferable in case of large GeoJSON files.
 * @param {number} [options.maxzoom=14] Maximum zoom to preserve detail at.
 * @param {number} [options.buffer] Tile buffer on each side.
 * @param {number} [options.tolerance] Simplification tolerance (higher means simpler).
 * @example
 * var sourceObj = new mapboxgl.GeoJSONSource({
 *    data: {
 *        "type": "FeatureCollection",
 *        "features": [{
 *            "type": "Feature",
 *            "geometry": {
 *                "type": "Point",
 *                "coordinates": [
 *                    -76.53063297271729,
 *                    39.18174077994108
 *                ]
 *            }
 *        }]
 *    }
 * });
 * map.addSource('some id', sourceObj); // add
 * map.removeSource('some id');  // remove
 */
function GeoJSONSource(options) {
    options = options || {};

    this._data = options.data;

    if (options.maxzoom !== undefined) this.maxzoom = options.maxzoom;

    this.geojsonVtOptions = { maxZoom: this.maxzoom };
    if (options.buffer !== undefined) this.geojsonVtOptions.buffer = options.buffer;
    if (options.tolerance !== undefined) this.geojsonVtOptions.tolerance = options.tolerance;

    this._pyramid = new TilePyramid({
        tileSize: 512,
        minzoom: this.minzoom,
        maxzoom: this.maxzoom,
        cacheSize: 20,
        load: this._loadTile.bind(this),
        abort: this._abortTile.bind(this),
        unload: this._unloadTile.bind(this),
        add: this._addTile.bind(this),
        remove: this._removeTile.bind(this),
        redoPlacement: this._redoTilePlacement.bind(this)
    });
}

GeoJSONSource.prototype = util.inherit(Evented, /** @lends GeoJSONSource.prototype */{
    minzoom: 0,
    maxzoom: 14,
    _dirty: true,
    isTileClipped: true,

    /**
     * Update source geojson data and rerender map
     *
     * @param {Object|string} data A GeoJSON data object or URL to it. The latter is preferable in case of large GeoJSON files.
     * @returns {GeoJSONSource} this
     */
    setData: function(data) {
        this._data = data;
        this._dirty = true;

        this.fire('change');

        if (this.map)
            this.update(this.map.transform);

        return this;
    },

    onAdd: function(map) {
        this.map = map;
    },

    loaded: function() {
        return this._loaded && this._pyramid.loaded();
    },

    update: function(transform) {
        if (this._dirty) {
            this._updateData();
        }

        if (this._loaded) {
            this._pyramid.update(this.used, transform);
        }
    },

    reload: function() {
        if (this._loaded) {
            this._pyramid.reload();
        }
    },

    getVisibleCoordinates: Source._getVisibleCoordinates,
    getTile: Source._getTile,

    featuresAt: Source._vectorFeaturesAt,
    featuresIn: Source._vectorFeaturesIn,

    _updateData: function() {
        this._dirty = false;
        var data = this._data;
        if (typeof data === 'string' && typeof window != 'undefined') {
            data = urlResolve(window.location.href, data);
        }
        this.workerID = this.dispatcher.send('parse geojson', {
            data: data,
            tileSize: 512,
            source: this.id,
            geojsonVtOptions: this.geojsonVtOptions
        }, function(err) {
            this._loaded = true;
            if (err) {
                this.fire('error', {error: err});
            } else {
                this._pyramid.reload();
                this.fire('change');
            }

        }.bind(this));
    },

    _loadTile: function(tile) {
        var overscaling = tile.coord.z > this.maxzoom ? Math.pow(2, tile.coord.z - this.maxzoom) : 1;
        var params = {
            uid: tile.uid,
            coord: tile.coord,
            zoom: tile.coord.z,
            maxZoom: this.maxzoom,
            tileSize: 512,
            source: this.id,
            overscaling: overscaling,
            angle: this.map.transform.angle,
            pitch: this.map.transform.pitch,
            collisionDebug: this.map.collisionDebug
        };

        tile.workerID = this.dispatcher.send('load geojson tile', params, function(err, data) {

            tile.unloadVectorData(this.map.painter);

            if (tile.aborted)
                return;

            if (err) {
                this.fire('tile.error', {tile: tile});
                return;
            }

            tile.loadVectorData(data);

            if (tile.redoWhenDone) {
                tile.redoWhenDone = false;
                tile.redoPlacement(this);
            }

            this.fire('tile.load', {tile: tile});

        }.bind(this), this.workerID);
    },

    _abortTile: function(tile) {
        tile.aborted = true;
    },

    _addTile: function(tile) {
        this.fire('tile.add', {tile: tile});
    },

    _removeTile: function(tile) {
        this.fire('tile.remove', {tile: tile});
    },

    _unloadTile: function(tile) {
        tile.unloadVectorData(this.map.painter);
        this.dispatcher.send('remove tile', { uid: tile.uid, source: this.id }, null, tile.workerID);
    },

    redoPlacement: Source.redoPlacement,

    _redoTilePlacement: function(tile) {
        tile.redoPlacement(this);
    }
});

},{"../util/evented":88,"../util/util":94,"./source":32,"./tile_pyramid":35,"resolve-url":132}],29:[function(require,module,exports){
'use strict';

var Point = require('point-geometry');
var VectorTileFeature = require('vector-tile').VectorTileFeature;

module.exports = GeoJSONWrapper;

// conform to vectortile api
function GeoJSONWrapper(features) {
    this.features = features;
    this.length = features.length;
}

GeoJSONWrapper.prototype.feature = function(i) {
    return new FeatureWrapper(this.features[i]);
};

function FeatureWrapper(feature) {
    this.type = feature.type;
    this.rawGeometry = feature.type === 1 ? [feature.geometry] : feature.geometry;
    this.properties = feature.tags;
    this.extent = 4096;
}

FeatureWrapper.prototype.loadGeometry = function() {
    var rings = this.rawGeometry;
    this.geometry = [];

    for (var i = 0; i < rings.length; i++) {
        var ring = rings[i],
            newRing = [];
        for (var j = 0; j < ring.length; j++) {
            newRing.push(new Point(ring[j][0], ring[j][1]));
        }
        this.geometry.push(newRing);
    }
    return this.geometry;
};

FeatureWrapper.prototype.bbox = function() {
    if (!this.geometry) this.loadGeometry();

    var rings = this.geometry,
        x1 = Infinity,
        x2 = -Infinity,
        y1 = Infinity,
        y2 = -Infinity;

    for (var i = 0; i < rings.length; i++) {
        var ring = rings[i];

        for (var j = 0; j < ring.length; j++) {
            var coord = ring[j];

            x1 = Math.min(x1, coord.x);
            x2 = Math.max(x2, coord.x);
            y1 = Math.min(y1, coord.y);
            y2 = Math.max(y2, coord.y);
        }
    }

    return [x1, y1, x2, y2];
};

FeatureWrapper.prototype.toGeoJSON = VectorTileFeature.prototype.toGeoJSON;

},{"point-geometry":130,"vector-tile":134}],30:[function(require,module,exports){
'use strict';

var util = require('../util/util');
var Tile = require('./tile');
var LngLat = require('../geo/lng_lat');
var Point = require('point-geometry');
var Evented = require('../util/evented');
var ajax = require('../util/ajax');

module.exports = ImageSource;

/**
 * Create an Image source instance given an options object
 * @class ImageSource
 * @param {Object} [options]
 * @param {string} options.url A string URL of an image file
 * @param {Array} options.coordinates lng, lat coordinates in order clockwise
 * starting at the top left: tl, tr, br, bl
 * @example
 * var sourceObj = new mapboxgl.ImageSource({
 *    url: 'https://www.mapbox.com/images/foo.png',
 *    coordinates: [
 *        [-76.54335737228394, 39.18579907229748],
 *        [-76.52803659439087, 39.1838364847587],
 *        [-76.5295386314392, 39.17683392507606],
 *        [-76.54520273208618, 39.17876344106642]
 *    ]
 * });
 * map.addSource('some id', sourceObj); // add
 * map.removeSource('some id');  // remove
 */
function ImageSource(options) {
    ajax.getImage(options.url, function(err, image) {
        // @TODO handle errors via event.
        if (err) return;

        this.image = image;

        this.image.addEventListener('load', function() {
            this.map._rerender();
        }.bind(this));

        this._loaded = true;

        if (this.map) {
            this.createTile(options.coordinates);
            this.fire('change');
        }
    }.bind(this));
}

ImageSource.prototype = util.inherit(Evented, {
    onAdd: function(map) {
        this.map = map;
        if (this.image) {
            this.createTile();
        }
    },

    /**
     * Calculate which mercator tile is suitable for rendering the image in
     * and create a buffer with the corner coordinates. These coordinates
     * may be outside the tile, because raster tiles aren't clipped when rendering.
     * @private
     */
    createTile: function(cornerGeoCoords) {
        var map = this.map;
        var cornerZ0Coords = cornerGeoCoords.map(function(coord) {
            return map.transform.locationCoordinate(LngLat.convert(coord)).zoomTo(0);
        });

        var centerCoord = this.centerCoord = util.getCoordinatesCenter(cornerZ0Coords);

        var tileExtent = 4096;
        var tileCoords = cornerZ0Coords.map(function(coord) {
            var zoomedCoord = coord.zoomTo(centerCoord.zoom);
            return new Point(
                Math.round((zoomedCoord.column - centerCoord.column) * tileExtent),
                Math.round((zoomedCoord.row - centerCoord.row) * tileExtent));
        });

        var gl = map.painter.gl;
        var maxInt16 = 32767;
        var array = new Int16Array([
            tileCoords[0].x, tileCoords[0].y, 0, 0,
            tileCoords[1].x, tileCoords[1].y, maxInt16, 0,
            tileCoords[3].x, tileCoords[3].y, 0, maxInt16,
            tileCoords[2].x, tileCoords[2].y, maxInt16, maxInt16
        ]);

        this.tile = new Tile();
        this.tile.buckets = {};

        this.tile.boundsBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this.tile.boundsBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, array, gl.STATIC_DRAW);
    },

    loaded: function() {
        return this.image && this.image.complete;
    },

    update: function() {
        // noop
    },

    reload: function() {
        // noop
    },

    prepare: function() {
        if (!this._loaded || !this.loaded()) return;

        var painter = this.map.painter;
        var gl = painter.gl;

        if (!this.tile.texture) {
            this.tile.texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, this.tile.texture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.image);
        } else {
            gl.bindTexture(gl.TEXTURE_2D, this.tile.texture);
            gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, gl.RGBA, gl.UNSIGNED_BYTE, this.image);
        }
    },

    getVisibleCoordinates: function() {
        if (this.centerCoord) return [this.centerCoord];
        else return [];
    },

    getTile: function() {
        return this.tile;
    },

    /**
     * An ImageSource doesn't have any vector features that could
     * be selectable, so always return an empty array.
     * @private
     */
    featuresAt: function(point, params, callback) {
        return callback(null, []);
    },

    featuresIn: function(bbox, params, callback) {
        return callback(null, []);
    }
});

},{"../geo/lng_lat":10,"../util/ajax":82,"../util/evented":88,"../util/util":94,"./tile":33,"point-geometry":130}],31:[function(require,module,exports){
'use strict';

var util = require('../util/util');
var ajax = require('../util/ajax');
var Evented = require('../util/evented');
var Source = require('./source');
var normalizeURL = require('../util/mapbox').normalizeTileURL;

module.exports = RasterTileSource;

function RasterTileSource(options) {
    util.extend(this, util.pick(options, ['url', 'tileSize']));

    Source._loadTileJSON.call(this, options);
}

RasterTileSource.prototype = util.inherit(Evented, {
    minzoom: 0,
    maxzoom: 22,
    roundZoom: true,
    tileSize: 512,
    _loaded: false,

    onAdd: function(map) {
        this.map = map;
    },

    loaded: function() {
        return this._pyramid && this._pyramid.loaded();
    },

    update: function(transform) {
        if (this._pyramid) {
            this._pyramid.update(this.used, transform, this.map.style.rasterFadeDuration);
        }
    },

    reload: function() {
        // noop
    },

    getVisibleCoordinates: Source._getVisibleCoordinates,
    getTile: Source._getTile,

    _loadTile: function(tile) {
        var url = normalizeURL(tile.coord.url(this.tiles), this.url);

        tile.request = ajax.getImage(url, done.bind(this));

        function done(err, img) {
            delete tile.request;

            if (tile.aborted)
                return;

            if (err) {
                tile.errored = true;
                this.fire('tile.error', {tile: tile, error: err});
                return;
            }

            var gl = this.map.painter.gl;
            tile.texture = this.map.painter.getTexture(img.width);
            if (tile.texture) {
                gl.bindTexture(gl.TEXTURE_2D, tile.texture);
                gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, gl.RGBA, gl.UNSIGNED_BYTE, img);
            } else {
                tile.texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, tile.texture);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
                tile.texture.size = img.width;
            }
            gl.generateMipmap(gl.TEXTURE_2D);

            tile.timeAdded = new Date().getTime();
            this.map.animationLoop.set(this.style.rasterFadeDuration);

            tile.source = this;
            tile.loaded = true;

            this.fire('tile.load', {tile: tile});
        }
    },

    _abortTile: function(tile) {
        tile.aborted = true;

        if (tile.request) {
            tile.request.abort();
            delete tile.request;
        }
    },

    _addTile: function(tile) {
        this.fire('tile.add', {tile: tile});
    },

    _removeTile: function(tile) {
        this.fire('tile.remove', {tile: tile});
    },

    _unloadTile: function(tile) {
        if (tile.texture) this.map.painter.saveTexture(tile.texture);
    },

    featuresAt: function(point, params, callback) {
        callback(null, []);
    },

    featuresIn: function(bbox, params, callback) {
        callback(null, []);
    }
});

},{"../util/ajax":82,"../util/evented":88,"../util/mapbox":91,"../util/util":94,"./source":32}],32:[function(require,module,exports){
'use strict';

var util = require('../util/util');
var ajax = require('../util/ajax');
var browser = require('../util/browser');
var TilePyramid = require('./tile_pyramid');
var normalizeURL = require('../util/mapbox').normalizeSourceURL;
var TileCoord = require('./tile_coord');

exports._loadTileJSON = function(options) {
    var loaded = function(err, tileJSON) {
        if (err) {
            this.fire('error', {error: err});
            return;
        }

        util.extend(this, util.pick(tileJSON,
            ['tiles', 'minzoom', 'maxzoom', 'attribution']));

        if (tileJSON.vector_layers) {
            this.vectorLayers = tileJSON.vector_layers;
            this.vectorLayerIds = this.vectorLayers.map(function(layer) { return layer.id; });
        }

        this._pyramid = new TilePyramid({
            tileSize: this.tileSize,
            cacheSize: 20,
            minzoom: this.minzoom,
            maxzoom: this.maxzoom,
            roundZoom: this.roundZoom,
            reparseOverscaled: this.reparseOverscaled,
            load: this._loadTile.bind(this),
            abort: this._abortTile.bind(this),
            unload: this._unloadTile.bind(this),
            add: this._addTile.bind(this),
            remove: this._removeTile.bind(this),
            redoPlacement: this._redoTilePlacement ? this._redoTilePlacement.bind(this) : undefined
        });

        this.fire('load');
    }.bind(this);

    if (options.url) {
        ajax.getJSON(normalizeURL(options.url), loaded);
    } else {
        browser.frame(loaded.bind(this, null, options));
    }
};

exports.redoPlacement = function() {
    if (!this._pyramid) {
        return;
    }

    var ids = this._pyramid.orderedIDs();
    for (var i = 0; i < ids.length; i++) {
        var tile = this._pyramid.getTile(ids[i]);
        this._redoTilePlacement(tile);
    }
};

exports._getTile = function(coord) {
    return this._pyramid.getTile(coord.id);
};

exports._getVisibleCoordinates = function() {
    if (!this._pyramid) return [];
    else return this._pyramid.renderedIDs().map(TileCoord.fromID);
};

exports._vectorFeaturesAt = function(coord, params, callback) {
    if (!this._pyramid)
        return callback(null, []);

    var result = this._pyramid.tileAt(coord);
    if (!result)
        return callback(null, []);

    this.dispatcher.send('query features', {
        uid: result.tile.uid,
        x: result.x,
        y: result.y,
        tileExtent: result.tile.tileExtent,
        scale: result.scale,
        source: this.id,
        params: params
    }, callback, result.tile.workerID);
};


exports._vectorFeaturesIn = function(bounds, params, callback) {
    if (!this._pyramid)
        return callback(null, []);

    var results = this._pyramid.tilesIn(bounds);
    if (!results)
        return callback(null, []);

    util.asyncAll(results, function queryTile(result, cb) {
        this.dispatcher.send('query features', {
            uid: result.tile.uid,
            source: this.id,
            minX: result.minX,
            maxX: result.maxX,
            minY: result.minY,
            maxY: result.maxY,
            params: params
        }, cb, result.tile.workerID);
    }.bind(this), function done(err, features) {
        callback(err, Array.prototype.concat.apply([], features));
    });
};

/*
 * Create a tiled data source instance given an options object
 *
 * @param {Object} options
 * @param {string} options.type Either `raster` or `vector`.
 * @param {string} options.url A tile source URL. This should either be `mapbox://{mapid}` or a full `http[s]` url that points to a TileJSON endpoint.
 * @param {Array} options.tiles An array of tile sources. If `url` is not specified, `tiles` can be used instead to specify tile sources, as in the TileJSON spec. Other TileJSON keys such as `minzoom` and `maxzoom` can be specified in a source object if `tiles` is used.
 * @param {string} options.id An optional `id` to assign to the source
 * @param {number} [options.tileSize=512] Optional tile size (width and height in pixels, assuming tiles are square). This option is only configurable for raster sources
 * @param {number} options.cacheSize Optional max number of tiles to cache at any given time
 * @example
 * var sourceObj = new mapboxgl.Source.create({
 *    type: 'vector',
 *    url: 'mapbox://mapbox.mapbox-streets-v5'
 * });
 * map.addSource('some id', sourceObj); // add
 * map.removeSource('some id');  // remove
 */
exports.create = function(source) {
    // This is not at file scope in order to avoid a circular require.
    var sources = {
        vector: require('./vector_tile_source'),
        raster: require('./raster_tile_source'),
        geojson: require('./geojson_source'),
        video: require('./video_source'),
        image: require('./image_source')
    };

    for (var type in sources) {
        if (source instanceof sources[type]) {
            return source;
        }
    }

    return new sources[source.type](source);
};

},{"../util/ajax":82,"../util/browser":83,"../util/mapbox":91,"../util/util":94,"./geojson_source":28,"./image_source":30,"./raster_tile_source":31,"./tile_coord":34,"./tile_pyramid":35,"./vector_tile_source":36,"./video_source":37}],33:[function(require,module,exports){
'use strict';

var util = require('../util/util');
var Buffer = require('../data/buffer');

module.exports = Tile;

/**
 * A tile object is the combination of a Coordinate, which defines
 * its place, as well as a unique ID and data tracking for its content
 *
 * @param {Coordinate} coord
 * @param {number} size
 * @private
 */
function Tile(coord, size, sourceMaxZoom) {
    this.coord = coord;
    this.uid = util.uniqueId();
    this.loaded = false;
    this.uses = 0;
    this.tileSize = size;
    this.sourceMaxZoom = sourceMaxZoom;
}

Tile.prototype = {
    // todo unhardcode
    tileExtent: 4096,

    /**
     * Given a coordinate position, zoom that coordinate to my zoom and
     * scale and return a position in x, y, scale
     * @param {Coordinate} coord
     * @returns {Object} position
     * @private
     */
    positionAt: function(coord) {
        var zoomedCoord = coord.zoomTo(Math.min(this.coord.z, this.sourceMaxZoom));
        return {
            x: (zoomedCoord.column - this.coord.x) * this.tileExtent,
            y: (zoomedCoord.row - this.coord.y) * this.tileExtent
        };
    },

    /**
     * Given a data object with a 'buffers' property, load it into
     * this tile's elementGroups and buffers properties and set loaded
     * to true. If the data is null, like in the case of an empty
     * GeoJSON tile, no-op but still set loaded to true.
     * @param {Object} data
     * @returns {undefined}
     * @private
     */
    loadVectorData: function(data) {
        this.loaded = true;

        // empty GeoJSON tile
        if (!data) return;

        this.buffers = unserializeBuffers(data.buffers);
        this.elementGroups = data.elementGroups;
        this.tileExtent = data.extent;
    },

    /**
     * given a data object and a GL painter, destroy and re-create
     * all of its buffers.
     * @param {Object} data
     * @param {Object} painter
     * @returns {undefined}
     * @private
     */
    reloadSymbolData: function(data, painter) {

        if (!this.buffers) {
            // the tile has been destroyed
            return;
        }

        if (this.buffers.glyphVertex) this.buffers.glyphVertex.destroy(painter.gl);
        if (this.buffers.glyphElement) this.buffers.glyphElement.destroy(painter.gl);
        if (this.buffers.iconVertex) this.buffers.iconVertex.destroy(painter.gl);
        if (this.buffers.iconElement) this.buffers.iconElement.destroy(painter.gl);
        if (this.buffers.collisionBoxVertex) this.buffers.collisionBoxVertex.destroy(painter.gl);

        var buffers = unserializeBuffers(data.buffers);
        this.buffers.glyphVertex = buffers.glyphVertex;
        this.buffers.glyphElement = buffers.glyphElement;
        this.buffers.iconVertex = buffers.iconVertex;
        this.buffers.iconElement = buffers.iconElement;
        this.buffers.collisionBoxVertex = buffers.collisionBoxVertex;

        for (var id in data.elementGroups) {
            this.elementGroups[id] = data.elementGroups[id];
        }
    },

    /**
     * Make sure that this tile doesn't own any data within a given
     * painter, so that it doesn't consume any memory or maintain
     * any references to the painter.
     * @param {Object} painter gl painter object
     * @returns {undefined}
     * @private
     */
    unloadVectorData: function(painter) {
        for (var b in this.buffers) {
            if (this.buffers[b]) this.buffers[b].destroy(painter.gl);
        }
        this.buffers = null;
    },

    redoPlacement: function(source) {
        if (!this.loaded || this.redoingPlacement) {
            this.redoWhenDone = true;
            return;
        }

        this.redoingPlacement = true;

        source.dispatcher.send('redo placement', {
            uid: this.uid,
            source: source.id,
            angle: source.map.transform.angle,
            pitch: source.map.transform.pitch,
            collisionDebug: source.map.collisionDebug
        }, done.bind(this), this.workerID);

        function done(_, data) {
            this.reloadSymbolData(data, source.map.painter);
            source.fire('tile.load', {tile: this});

            this.redoingPlacement = false;
            if (this.redoWhenDone) {
                this.redoPlacement(source);
                this.redoWhenDone = false;
            }
        }
    },

    getElementGroups: function(layer, shaderName) {
        return this.elementGroups && this.elementGroups[layer.ref || layer.id] && this.elementGroups[layer.ref || layer.id][shaderName];
    }
};

function unserializeBuffers(input) {
    var output = {};
    for (var k in input) {
        output[k] = new Buffer(input[k]);
    }
    return output;
}

},{"../data/buffer":2,"../util/util":94}],34:[function(require,module,exports){
'use strict';

var assert = require('assert');
var Coordinate = require('../geo/coordinate');

module.exports = TileCoord;

function TileCoord(z, x, y, w) {
    assert(!isNaN(z) && z >= 0 && z % 1 === 0);
    assert(!isNaN(x) && x >= 0 && x % 1 === 0);
    assert(!isNaN(y) && y >= 0 && y % 1 === 0);

    if (isNaN(w)) w = 0;

    this.z = +z;
    this.x = +x;
    this.y = +y;
    this.w = +w;

    // calculate id
    w *= 2;
    if (w < 0) w = w * -1 - 1;
    var dim = 1 << this.z;
    this.id = ((dim * dim * w + dim * this.y + this.x) * 32) + this.z;
}

TileCoord.prototype.toString = function() {
    return this.z + "/" + this.x + "/" + this.y;
};

TileCoord.prototype.toCoordinate = function() {
    var zoom = this.z;
    var tileScale = Math.pow(2, zoom);
    var row = this.y;
    var column = this.x + tileScale * this.w;
    return new Coordinate(column, row, zoom);
};

// Parse a packed integer id into a TileCoord object
TileCoord.fromID = function(id) {
    var z = id % 32, dim = 1 << z;
    var xy = ((id - z) / 32);
    var x = xy % dim, y = ((xy - x) / dim) % dim;
    var w = Math.floor(xy / (dim * dim));
    if (w % 2 !== 0) w = w * -1 - 1;
    w /= 2;
    return new TileCoord(z, x, y, w);
};

// given a list of urls, choose a url template and return a tile URL
TileCoord.prototype.url = function(urls, sourceMaxZoom) {
    return urls[(this.x + this.y) % urls.length]
        .replace('{prefix}', (this.x % 16).toString(16) + (this.y % 16).toString(16))
        .replace('{z}', Math.min(this.z, sourceMaxZoom || this.z))
        .replace('{x}', this.x)
        .replace('{y}', this.y);
};

// Return the coordinate of the parent tile
TileCoord.prototype.parent = function(sourceMaxZoom) {
    if (this.z === 0) return null;

    // the id represents an overscaled tile, return the same coordinates with a lower z
    if (this.z > sourceMaxZoom) {
        return new TileCoord(this.z - 1, this.x, this.y, this.w);
    }

    return new TileCoord(this.z - 1, Math.floor(this.x / 2), Math.floor(this.y / 2), this.w);
};

TileCoord.prototype.wrapped = function() {
    return new TileCoord(this.z, this.x, this.y, 0);
};

// Return the coordinates of the tile's children
TileCoord.prototype.children = function(sourceMaxZoom) {

    if (this.z >= sourceMaxZoom) {
        // return a single tile coord representing a an overscaled tile
        return [new TileCoord(this.z + 1, this.x, this.y, this.w)];
    }

    var z = this.z + 1;
    var x = this.x * 2;
    var y = this.y * 2;
    return [
        new TileCoord(z, x, y, this.w),
        new TileCoord(z, x + 1, y, this.w),
        new TileCoord(z, x, y + 1, this.w),
        new TileCoord(z, x + 1, y + 1, this.w)
    ];
};

// Taken from polymaps src/Layer.js
// https://github.com/simplegeo/polymaps/blob/master/src/Layer.js#L333-L383

function edge(a, b) {
    if (a.row > b.row) { var t = a; a = b; b = t; }
    return {
        x0: a.column,
        y0: a.row,
        x1: b.column,
        y1: b.row,
        dx: b.column - a.column,
        dy: b.row - a.row
    };
}

function scanSpans(e0, e1, ymin, ymax, scanLine) {
    var y0 = Math.max(ymin, Math.floor(e1.y0));
    var y1 = Math.min(ymax, Math.ceil(e1.y1));

    // sort edges by x-coordinate
    if ((e0.x0 === e1.x0 && e0.y0 === e1.y0) ?
            (e0.x0 + e1.dy / e0.dy * e0.dx < e1.x1) :
            (e0.x1 - e1.dy / e0.dy * e0.dx < e1.x0)) {
        var t = e0; e0 = e1; e1 = t;
    }

    // scan lines!
    var m0 = e0.dx / e0.dy;
    var m1 = e1.dx / e1.dy;
    var d0 = e0.dx > 0; // use y + 1 to compute x0
    var d1 = e1.dx < 0; // use y + 1 to compute x1
    for (var y = y0; y < y1; y++) {
        var x0 = m0 * Math.max(0, Math.min(e0.dy, y + d0 - e0.y0)) + e0.x0;
        var x1 = m1 * Math.max(0, Math.min(e1.dy, y + d1 - e1.y0)) + e1.x0;
        scanLine(Math.floor(x1), Math.ceil(x0), y);
    }
}

function scanTriangle(a, b, c, ymin, ymax, scanLine) {
    var ab = edge(a, b),
        bc = edge(b, c),
        ca = edge(c, a);

    var t;

    // sort edges by y-length
    if (ab.dy > bc.dy) { t = ab; ab = bc; bc = t; }
    if (ab.dy > ca.dy) { t = ab; ab = ca; ca = t; }
    if (bc.dy > ca.dy) { t = bc; bc = ca; ca = t; }

    // scan span! scan span!
    if (ab.dy) scanSpans(ca, ab, ymin, ymax, scanLine);
    if (bc.dy) scanSpans(ca, bc, ymin, ymax, scanLine);
}

TileCoord.cover = function(z, bounds, actualZ) {
    var tiles = 1 << z;
    var t = {};

    function scanLine(x0, x1, y) {
        var x, wx, coord;
        if (y >= 0 && y <= tiles) {
            for (x = x0; x < x1; x++) {
                wx = (x % tiles + tiles) % tiles;
                coord = new TileCoord(actualZ, wx, y, Math.floor(x / tiles));
                t[coord.id] = coord;
            }
        }
    }

    // Divide the screen up in two triangles and scan each of them:
    // +---/
    // | / |
    // /---+
    scanTriangle(bounds[0], bounds[1], bounds[2], 0, tiles, scanLine);
    scanTriangle(bounds[2], bounds[3], bounds[0], 0, tiles, scanLine);

    return Object.keys(t).map(function(id) {
        return t[id];
    });
};

},{"../geo/coordinate":9,"assert":95}],35:[function(require,module,exports){
'use strict';

var Tile = require('./tile');
var TileCoord = require('./tile_coord');
var Point = require('point-geometry');
var Cache = require('../util/mru_cache');
var util = require('../util/util');

module.exports = TilePyramid;

/**
 * A tile pyramid is a specialized cache and datastructure
 * that contains tiles. It's used by sources to manage their
 * data.
 *
 * @param {Object} options
 * @param {number} options.tileSize
 * @param {number} options.minzoom
 * @param {number} options.maxzoom
 * @private
 */
function TilePyramid(options) {
    this.tileSize = options.tileSize;
    this.minzoom = options.minzoom;
    this.maxzoom = options.maxzoom;
    this.roundZoom = options.roundZoom;
    this.reparseOverscaled = options.reparseOverscaled;

    this._load = options.load;
    this._abort = options.abort;
    this._unload = options.unload;
    this._add = options.add;
    this._remove = options.remove;
    this._redoPlacement = options.redoPlacement;

    this._tiles = {};
    this._cache = new Cache(options.cacheSize, function(tile) { return this._unload(tile); }.bind(this));

    this._filterRendered = this._filterRendered.bind(this);
}

TilePyramid.prototype = {
    /**
     * Confirm that every tracked tile is loaded.
     * @returns {boolean} whether all tiles are loaded.
     * @private
     */
    loaded: function() {
        for (var t in this._tiles) {
            if (!this._tiles[t].loaded && !this._tiles[t].errored)
                return false;
        }
        return true;
    },

    /**
     * Return all tile ids ordered with z-order, and cast to numbers
     * @returns {Array<number>} ids
     * @private
     */
    orderedIDs: function() {
        return Object.keys(this._tiles).map(Number).sort(compareKeyZoom);
    },

    renderedIDs: function() {
        return this.orderedIDs().filter(this._filterRendered);
    },

    _filterRendered: function(id) {
        return this._tiles[id].loaded && !this._coveredTiles[id];
    },

    reload: function() {
        this._cache.reset();
        for (var i in this._tiles) {
            this._load(this._tiles[i]);
        }
    },

    /**
     * Get a specific tile by id
     * @param {string|number} id tile id
     * @returns {Object} tile
     * @private
     */
    getTile: function(id) {
        return this._tiles[id];
    },

    /**
     * get the zoom level adjusted for the difference in map and source tilesizes
     * @param {Object} transform
     * @returns {number} zoom level
     * @private
     */
    getZoom: function(transform) {
        return transform.zoom + Math.log(transform.tileSize / this.tileSize) / Math.LN2;
    },

    /**
     * Return a zoom level that will cover all tiles in a given transform
     * @param {Object} transform
     * @returns {number} zoom level
     * @private
     */
    coveringZoomLevel: function(transform) {
        return (this.roundZoom ? Math.round : Math.floor)(this.getZoom(transform));
    },

    /**
     * Given a transform, return all coordinates that could cover that
     * transform for a covering zoom level.
     * @param {Object} transform
     * @returns {Array<Tile>} tiles
     * @private
     */
    coveringTiles: function(transform) {
        var z = this.coveringZoomLevel(transform);
        var actualZ = z;

        if (z < this.minzoom) return [];
        if (z > this.maxzoom) z = this.maxzoom;

        var tr = transform,
            tileCenter = tr.locationCoordinate(tr.center)._zoomTo(z),
            centerPoint = new Point(tileCenter.column - 0.5, tileCenter.row - 0.5);

        return TileCoord.cover(z, [
            tr.pointCoordinate(new Point(0, 0))._zoomTo(z),
            tr.pointCoordinate(new Point(tr.width, 0))._zoomTo(z),
            tr.pointCoordinate(new Point(tr.width, tr.height))._zoomTo(z),
            tr.pointCoordinate(new Point(0, tr.height))._zoomTo(z)
        ], this.reparseOverscaled ? actualZ : z).sort(function(a, b) {
            return centerPoint.dist(a) - centerPoint.dist(b);
        });
    },

    /**
     * Recursively find children of the given tile (up to maxCoveringZoom) that are already loaded;
     * adds found tiles to retain object; returns true if any child is found.
     *
     * @param {Coordinate} coord
     * @param {number} maxCoveringZoom
     * @param {boolean} retain
     * @returns {boolean} whether the operation was complete
     * @private
     */
    findLoadedChildren: function(coord, maxCoveringZoom, retain) {
        var found = false;

        for (var id in this._tiles) {
            var tile = this._tiles[id];

            // only consider loaded tiles on higher zoom levels (up to maxCoveringZoom)
            if (retain[id] || !tile.loaded || tile.coord.z <= coord.z || tile.coord.z > maxCoveringZoom) continue;

            // disregard tiles that are not descendants of the given tile coordinate
            var z2 = Math.pow(2, Math.min(tile.coord.z, this.maxzoom) - Math.min(coord.z, this.maxzoom));
            if (Math.floor(tile.coord.x / z2) !== coord.x ||
                Math.floor(tile.coord.y / z2) !== coord.y)
                continue;

            // found loaded child
            retain[id] = true;
            found = true;

            // loop through parents; retain the topmost loaded one if found
            while (tile && tile.coord.z - 1 > coord.z) {
                var parentId = tile.coord.parent(this.maxzoom).id;
                tile = this._tiles[parentId];

                if (tile && tile.loaded) {
                    delete retain[id];
                    retain[parentId] = true;
                }
            }
        }
        return found;
    },

    /**
     * Find a loaded parent of the given tile (up to minCoveringZoom);
     * adds the found tile to retain object and returns the tile if found
     *
     * @param {Coordinate} coord
     * @param {number} minCoveringZoom
     * @param {boolean} retain
     * @returns {Tile} tile object
     * @private
     */
    findLoadedParent: function(coord, minCoveringZoom, retain) {
        for (var z = coord.z - 1; z >= minCoveringZoom; z--) {
            coord = coord.parent(this.maxzoom);
            var tile = this._tiles[coord.id];
            if (tile && tile.loaded) {
                retain[coord.id] = true;
                return tile;
            }
        }
    },

    /**
     * Removes tiles that are outside the viewport and adds new tiles that
     * are inside the viewport.
     * @private
     */
    update: function(used, transform, fadeDuration) {
        var i;
        var coord;
        var tile;

        // Determine the overzooming/underzooming amounts.
        var zoom = (this.roundZoom ? Math.round : Math.floor)(this.getZoom(transform));
        var minCoveringZoom = Math.max(zoom - 10, this.minzoom);
        var maxCoveringZoom = Math.max(zoom + 3,  this.minzoom);

        // Retain is a list of tiles that we shouldn't delete, even if they are not
        // the most ideal tile for the current viewport. This may include tiles like
        // parent or child tiles that are *already* loaded.
        var retain = {};
        var now = new Date().getTime();

        // Covered is a list of retained tiles who's areas are full covered by other,
        // better, retained tiles. They are not drawn separately.
        this._coveredTiles = {};

        var required = used ? this.coveringTiles(transform) : [];
        for (i = 0; i < required.length; i++) {
            coord = required[i];
            tile = this.addTile(coord);

            retain[coord.id] = true;

            if (tile.loaded)
                continue;

            // The tile we require is not yet loaded.
            // Retain child or parent tiles that cover the same area.
            if (!this.findLoadedChildren(coord, maxCoveringZoom, retain)) {
                this.findLoadedParent(coord, minCoveringZoom, retain);
            }
        }

        var parentsForFading = {};

        var ids = Object.keys(retain);
        for (var k = 0; k < ids.length; k++) {
            var id = ids[k];
            coord = TileCoord.fromID(id);
            tile = this._tiles[id];
            if (tile && tile.timeAdded > now - (fadeDuration || 0)) {
                // This tile is still fading in. Find tiles to cross-fade with it.
                if (this.findLoadedChildren(coord, maxCoveringZoom, retain)) {
                    retain[id] = true;
                }
                this.findLoadedParent(coord, minCoveringZoom, parentsForFading);
            }
        }

        var fadedParent;
        for (fadedParent in parentsForFading) {
            if (!retain[fadedParent]) {
                // If a tile is only needed for fading, mark it as covered so that it isn't rendered on it's own.
                this._coveredTiles[fadedParent] = true;
            }
        }
        for (fadedParent in parentsForFading) {
            retain[fadedParent] = true;
        }

        // Remove the tiles we don't need anymore.
        var remove = util.keysDifference(this._tiles, retain);
        for (i = 0; i < remove.length; i++) {
            this.removeTile(+remove[i]);
        }

        this.transform = transform;
    },

    /**
     * Add a tile, given its coordinate, to the pyramid.
     * @param {Coordinate} coord
     * @returns {Coordinate} the coordinate.
     * @private
     */
    addTile: function(coord) {
        var tile = this._tiles[coord.id];
        if (tile)
            return tile;

        var wrapped = coord.wrapped();
        tile = this._tiles[wrapped.id];

        if (!tile) {
            tile = this._cache.get(wrapped.id);
            if (tile && this._redoPlacement) {
                this._redoPlacement(tile);
            }
        }

        if (!tile) {
            var zoom = coord.z;
            var overscaling = zoom > this.maxzoom ? Math.pow(2, zoom - this.maxzoom) : 1;
            tile = new Tile(wrapped, this.tileSize * overscaling, this.maxzoom);
            this._load(tile);
        }

        tile.uses++;
        this._tiles[coord.id] = tile;
        this._add(tile, coord);

        return tile;
    },

    /**
     * Remove a tile, given its id, from the pyramid
     * @param {string|number} id tile id
     * @returns {undefined} nothing
     * @private
     */
    removeTile: function(id) {
        var tile = this._tiles[id];
        if (!tile)
            return;

        tile.uses--;
        delete this._tiles[id];
        this._remove(tile);

        if (tile.uses > 0)
            return;

        if (tile.loaded) {
            this._cache.add(tile.coord.wrapped().id, tile);
        } else {
            this._abort(tile);
            this._unload(tile);
        }
    },

    /**
     * Remove all tiles from this pyramid
     * @private
     */
    clearTiles: function() {
        for (var id in this._tiles)
            this.removeTile(id);
        this._cache.reset();
    },

    /**
     * For a given coordinate, search through our current tiles and attempt
     * to find a tile at that point
     * @param {Coordinate} coord
     * @returns {Object} tile
     * @private
     */
    tileAt: function(coord) {
        var ids = this.orderedIDs();
        for (var i = 0; i < ids.length; i++) {
            var tile = this._tiles[ids[i]];
            var pos = tile.positionAt(coord);
            if (pos && pos.x >= 0 && pos.x < tile.tileExtent && pos.y >= 0 && pos.y < tile.tileExtent) {
                // The click is within the viewport. There is only ever one tile in
                // a layer that has this property.
                return {
                    tile: tile,
                    x: pos.x,
                    y: pos.y,
                    scale: this.transform.worldSize / Math.pow(2, tile.coord.z)
                };
            }
        }
    },

    /**
     * Search through our current tiles and attempt to find the tiles that
     * cover the given bounds.
     * @param {Array<Coordinate>} bounds [minxminy, maxxmaxy] coordinates of the corners of bounding rectangle
     * @returns {Array<Object>} result items have {tile, minX, maxX, minY, maxY}, where min/max bounding values are the given bounds transformed in into the coordinate space of this tile.
     * @private
     */
    tilesIn: function(bounds) {
        var result = [];
        var ids = this.orderedIDs();

        for (var i = 0; i < ids.length; i++) {
            var tile = this._tiles[ids[i]];
            var tileSpaceBounds = [
                tile.positionAt(bounds[0]),
                tile.positionAt(bounds[1])
            ];
            if (tileSpaceBounds[0].x < tile.tileExtent && tileSpaceBounds[0].y < tile.tileExtent &&
                tileSpaceBounds[1].x >= 0 && tileSpaceBounds[1].y >= 0) {
                result.push({
                    tile: tile,
                    minX: tileSpaceBounds[0].x,
                    maxX: tileSpaceBounds[1].x,
                    minY: tileSpaceBounds[0].y,
                    maxY: tileSpaceBounds[1].y
                });
            }
        }

        return result;
    }
};

function compareKeyZoom(a, b) {
    return (b % 32) - (a % 32);
}

},{"../util/mru_cache":92,"../util/util":94,"./tile":33,"./tile_coord":34,"point-geometry":130}],36:[function(require,module,exports){
'use strict';

var util = require('../util/util');
var Evented = require('../util/evented');
var Source = require('./source');
var normalizeURL = require('../util/mapbox').normalizeTileURL;

module.exports = VectorTileSource;

function VectorTileSource(options) {
    util.extend(this, util.pick(options, ['url', 'tileSize']));

    if (this.tileSize !== 512) {
        throw new Error('vector tile sources must have a tileSize of 512');
    }

    Source._loadTileJSON.call(this, options);
}

VectorTileSource.prototype = util.inherit(Evented, {
    minzoom: 0,
    maxzoom: 22,
    tileSize: 512,
    reparseOverscaled: true,
    _loaded: false,
    isTileClipped: true,

    onAdd: function(map) {
        this.map = map;
    },

    loaded: function() {
        return this._pyramid && this._pyramid.loaded();
    },

    update: function(transform) {
        if (this._pyramid) {
            this._pyramid.update(this.used, transform);
        }
    },

    reload: function() {
        if (this._pyramid) {
            this._pyramid.reload();
        }
    },

    getVisibleCoordinates: Source._getVisibleCoordinates,
    getTile: Source._getTile,

    featuresAt: Source._vectorFeaturesAt,
    featuresIn: Source._vectorFeaturesIn,

    _loadTile: function(tile) {
        var overscaling = tile.coord.z > this.maxzoom ? Math.pow(2, tile.coord.z - this.maxzoom) : 1;
        var params = {
            url: normalizeURL(tile.coord.url(this.tiles, this.maxzoom), this.url),
            uid: tile.uid,
            coord: tile.coord,
            zoom: tile.coord.z,
            tileSize: this.tileSize * overscaling,
            source: this.id,
            overscaling: overscaling,
            angle: this.map.transform.angle,
            pitch: this.map.transform.pitch,
            collisionDebug: this.map.collisionDebug
        };

        if (tile.workerID) {
            this.dispatcher.send('reload tile', params, this._tileLoaded.bind(this, tile), tile.workerID);
        } else {
            tile.workerID = this.dispatcher.send('load tile', params, this._tileLoaded.bind(this, tile));
        }
    },

    _tileLoaded: function(tile, err, data) {
        if (tile.aborted)
            return;

        if (err) {
            this.fire('tile.error', {tile: tile, error: err});
            return;
        }

        tile.loadVectorData(data);

        if (tile.redoWhenDone) {
            tile.redoWhenDone = false;
            tile.redoPlacement(this);
        }

        this.fire('tile.load', {tile: tile});
        this.fire('tile.stats', data.bucketStats);
    },

    _abortTile: function(tile) {
        tile.aborted = true;
        this.dispatcher.send('abort tile', { uid: tile.uid, source: this.id }, null, tile.workerID);
    },

    _addTile: function(tile) {
        this.fire('tile.add', {tile: tile});
    },

    _removeTile: function(tile) {
        this.fire('tile.remove', {tile: tile});
    },

    _unloadTile: function(tile) {
        tile.unloadVectorData(this.map.painter);
        this.dispatcher.send('remove tile', { uid: tile.uid, source: this.id }, null, tile.workerID);
    },

    redoPlacement: Source.redoPlacement,

    _redoTilePlacement: function(tile) {
        tile.redoPlacement(this);
    }
});

},{"../util/evented":88,"../util/mapbox":91,"../util/util":94,"./source":32}],37:[function(require,module,exports){
'use strict';

var util = require('../util/util');
var Tile = require('./tile');
var LngLat = require('../geo/lng_lat');
var Point = require('point-geometry');
var Evented = require('../util/evented');
var ajax = require('../util/ajax');

module.exports = VideoSource;

/**
 * Create a Video data source instance given an options object
 * @class VideoSource
 * @param {Object} [options]
 * @param {Array<string>} options.urls An array of URLs to video files
 * @param {Array} options.coordinates lng, lat coordinates in order clockwise starting at the top left: tl, tr, br, bl
 * @example
 * var sourceObj = new mapboxgl.VideoSource({
 *    url: [
 *        'https://www.mapbox.com/videos/baltimore-smoke.mp4',
 *        'https://www.mapbox.com/videos/baltimore-smoke.webm'
 *    ],
 *    coordinates: [
 *        [-76.54335737228394, 39.18579907229748],
 *        [-76.52803659439087, 39.1838364847587],
 *        [-76.5295386314392, 39.17683392507606],
 *        [-76.54520273208618, 39.17876344106642]
 *    ]
 * });
 * map.addSource('some id', sourceObj); // add
 * map.removeSource('some id');  // remove
 */
function VideoSource(options) {
    ajax.getVideo(options.urls, function(err, video) {
        // @TODO handle errors via event.
        if (err) return;

        this.video = video;
        this.video.loop = true;

        var loopID;

        // start repainting when video starts playing
        this.video.addEventListener('playing', function() {
            loopID = this.map.style.animationLoop.set(Infinity);
            this.map._rerender();
        }.bind(this));

        // stop repainting when video stops
        this.video.addEventListener('pause', function() {
            this.map.style.animationLoop.cancel(loopID);
        }.bind(this));

        this._loaded = true;

        if (this.map) {
            this.video.play();
            this.createTile(options.coordinates);
            this.fire('change');
        }
    }.bind(this));
}

VideoSource.prototype = util.inherit(Evented, /** @lends VideoSource.prototype */{
    roundZoom: true,

    /**
     * Return the HTML video element.
     *
     * @returns {Object}
     */
    getVideo: function() {
        return this.video;
    },

    onAdd: function(map) {
        this.map = map;
        if (this.video) {
            this.video.play();
            this.createTile();
        }
    },

    createTile: function(cornerGeoCoords) {
        /*
         * Calculate which mercator tile is suitable for rendering the video in
         * and create a buffer with the corner coordinates. These coordinates
         * may be outside the tile, because raster tiles aren't clipped when rendering.
         */
        var map = this.map;
        var cornerZ0Coords = cornerGeoCoords.map(function(coord) {
            return map.transform.locationCoordinate(LngLat.convert(coord)).zoomTo(0);
        });

        var centerCoord = this.centerCoord = util.getCoordinatesCenter(cornerZ0Coords);

        var tileExtent = 4096;
        var tileCoords = cornerZ0Coords.map(function(coord) {
            var zoomedCoord = coord.zoomTo(centerCoord.zoom);
            return new Point(
                Math.round((zoomedCoord.column - centerCoord.column) * tileExtent),
                Math.round((zoomedCoord.row - centerCoord.row) * tileExtent));
        });

        var gl = map.painter.gl;
        var maxInt16 = 32767;
        var array = new Int16Array([
            tileCoords[0].x, tileCoords[0].y, 0, 0,
            tileCoords[1].x, tileCoords[1].y, maxInt16, 0,
            tileCoords[3].x, tileCoords[3].y, 0, maxInt16,
            tileCoords[2].x, tileCoords[2].y, maxInt16, maxInt16
        ]);

        this.tile = new Tile();
        this.tile.buckets = {};

        this.tile.boundsBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this.tile.boundsBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, array, gl.STATIC_DRAW);
    },

    loaded: function() {
        return this.video && this.video.readyState >= 2;
    },

    update: function() {
        // noop
    },

    reload: function() {
        // noop
    },

    prepare: function() {
        if (!this._loaded) return;
        if (this.video.readyState < 2) return; // not enough data for current position

        var gl = this.map.painter.gl;
        if (!this.tile.texture) {
            this.tile.texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, this.tile.texture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.video);
        } else {
            gl.bindTexture(gl.TEXTURE_2D, this.tile.texture);
            gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, gl.RGBA, gl.UNSIGNED_BYTE, this.video);
        }

        this._currentTime = this.video.currentTime;
    },

    getVisibleCoordinates: function() {
        if (this.centerCoord) return [this.centerCoord];
        else return [];
    },

    getTile: function() {
        return this.tile;
    },

    featuresAt: function(point, params, callback) {
        return callback(null, []);
    },

    featuresIn: function(bbox, params, callback) {
        return callback(null, []);
    }
});

},{"../geo/lng_lat":10,"../util/ajax":82,"../util/evented":88,"../util/util":94,"./tile":33,"point-geometry":130}],38:[function(require,module,exports){
'use strict';

var Actor = require('../util/actor');
var WorkerTile = require('./worker_tile');
var util = require('../util/util');
var ajax = require('../util/ajax');
var vt = require('vector-tile');
var Protobuf = require('pbf');

var geojsonvt = require('geojson-vt');
var GeoJSONWrapper = require('./geojson_wrapper');

module.exports = function(self) {
    return new Worker(self);
};

function Worker(self) {
    this.self = self;
    this.actor = new Actor(self, this);
    this.loading = {};

    this.loaded = {};
    this.layers = [];
    this.geoJSONIndexes = {};
}

util.extend(Worker.prototype, {
    'set layers': function(layers) {
        this.layers = layers;
    },

    'load tile': function(params, callback) {
        var source = params.source,
            uid = params.uid;

        if (!this.loading[source])
            this.loading[source] = {};


        var tile = this.loading[source][uid] = new WorkerTile(params);

        tile.xhr = ajax.getArrayBuffer(params.url, done.bind(this));

        function done(err, data) {
            delete this.loading[source][uid];

            // If the tile was not found, it's probably not acutally
            // an error. There should be a better way of handing this
            // though.
            if (err && err.message === 'Not Found') return callback();

            // Otherwise, treat it like an error.
            if (err) return callback(err);

            tile.data = new vt.VectorTile(new Protobuf(new Uint8Array(data)));
            tile.parse(tile.data, this.layers, this.actor, callback);

            this.loaded[source] = this.loaded[source] || {};
            this.loaded[source][uid] = tile;
        }
    },

    'reload tile': function(params, callback) {
        var loaded = this.loaded[params.source],
            uid = params.uid;
        if (loaded && loaded[uid]) {
            var tile = loaded[uid];
            tile.parse(tile.data, this.layers, this.actor, callback);
        }
    },

    'abort tile': function(params) {
        var loading = this.loading[params.source],
            uid = params.uid;
        if (loading && loading[uid]) {
            loading[uid].xhr.abort();
            delete loading[uid];
        }
    },

    'remove tile': function(params) {
        var loaded = this.loaded[params.source],
            uid = params.uid;
        if (loaded && loaded[uid]) {
            delete loaded[uid];
        }
    },

    'redo placement': function(params, callback) {
        var loaded = this.loaded[params.source],
            loading = this.loading[params.source],
            uid = params.uid;

        if (loaded && loaded[uid]) {
            var tile = loaded[uid];
            var result = tile.redoPlacement(params.angle, params.pitch, params.collisionDebug);

            if (result.result) {
                callback(null, result.result, result.transferables);
            }

        } else if (loading && loading[uid]) {
            loading[uid].angle = params.angle;
        }
    },

    'parse geojson': function(params, callback) {
        var indexData = function(err, data) {
            if (err) return callback(err);
            if (typeof data != 'object') {
                return callback(new Error("Input data is not a valid GeoJSON object."));
            }
            try {
                this.geoJSONIndexes[params.source] = geojsonvt(data, params.geojsonVtOptions);
            } catch (err) {
                return callback(err);
            }
            callback(null);
        }.bind(this);

        // TODO accept params.url for urls instead

        // Not, because of same origin issues, urls must either include an
        // explicit origin or absolute path.
        // ie: /foo/bar.json or http://example.com/bar.json
        // but not ../foo/bar.json
        if (typeof params.data === 'string') {
            ajax.getJSON(params.data, indexData);
        }
        else indexData(null, params.data);
    },

    'load geojson tile': function(params, callback) {
        var source = params.source,
            coord = params.coord;

        if (!this.geoJSONIndexes[source]) return callback(null, null); // we couldn't load the file

        // console.time('tile ' + coord.z + ' ' + coord.x + ' ' + coord.y);

        var geoJSONTile = this.geoJSONIndexes[source].getTile(coord.z, coord.x, coord.y);

        // console.timeEnd('tile ' + coord.z + ' ' + coord.x + ' ' + coord.y);

        // if (!geoJSONTile) console.log('not found', this.geoJSONIndexes[source], coord);

        if (!geoJSONTile) return callback(null, null); // nothing in the given tile

        var tile = new WorkerTile(params);
        tile.parse(new GeoJSONWrapper(geoJSONTile.features), this.layers, this.actor, callback);

        this.loaded[source] = this.loaded[source] || {};
        this.loaded[source][params.uid] = tile;
    },

    'query features': function(params, callback) {
        var tile = this.loaded[params.source] && this.loaded[params.source][params.uid];
        if (tile) {
            tile.featureTree.query(params, callback);
        } else {
            callback(null, []);
        }
    }
});

},{"../util/actor":81,"../util/ajax":82,"../util/util":94,"./geojson_wrapper":29,"./worker_tile":39,"geojson-vt":105,"pbf":128,"vector-tile":134}],39:[function(require,module,exports){
'use strict';

var FeatureTree = require('../data/feature_tree');
var CollisionTile = require('../symbol/collision_tile');
var Bucket = require('../data/bucket');

module.exports = WorkerTile;

function WorkerTile(params) {
    this.coord = params.coord;
    this.uid = params.uid;
    this.zoom = params.zoom;
    this.tileSize = params.tileSize;
    this.source = params.source;
    this.overscaling = params.overscaling;
    this.angle = params.angle;
    this.pitch = params.pitch;
    this.collisionDebug = params.collisionDebug;
}

WorkerTile.prototype.parse = function(data, layers, actor, callback) {

    this.status = 'parsing';

    this.featureTree = new FeatureTree(this.coord, this.overscaling);

    var stats = { _total: 0 };

    var tile = this,
        buffers = {},
        collisionTile = new CollisionTile(this.angle, this.pitch),
        bucketsById = {},
        bucketsBySourceLayer = {},
        i, layer, sourceLayerId, bucket;

    // Map non-ref layers to buckets.
    for (i = 0; i < layers.length; i++) {
        layer = layers[i];

        if (layer.source !== this.source ||
                layer.ref ||
                layer.minzoom && this.zoom < layer.minzoom ||
                layer.maxzoom && this.zoom >= layer.maxzoom ||
                layer.layout.visibility === 'none')
            continue;

        bucket = Bucket.create({
            layer: layer,
            buffers: buffers,
            zoom: this.zoom,
            overscaling: this.overscaling,
            collisionDebug: this.collisionDebug
        });
        bucket.layers = [layer.id];

        bucketsById[layer.id] = bucket;

        if (data.layers) { // vectortile
            sourceLayerId = layer['source-layer'];
            bucketsBySourceLayer[sourceLayerId] = bucketsBySourceLayer[sourceLayerId] || {};
            bucketsBySourceLayer[sourceLayerId][layer.id] = bucket;
        }
    }

    // Index ref layers.
    for (i = 0; i < layers.length; i++) {
        layer = layers[i];
        if (layer.source === this.source && layer.ref && bucketsById[layer.ref]) {
            bucketsById[layer.ref].layers.push(layer.id);
        }
    }

    var extent = 4096;

    // read each layer, and sort its features into buckets
    if (data.layers) { // vectortile
        for (sourceLayerId in bucketsBySourceLayer) {
            layer = data.layers[sourceLayerId];
            if (!layer) continue;
            if (layer.extent) extent = layer.extent;
            sortLayerIntoBuckets(layer, bucketsBySourceLayer[sourceLayerId]);
        }
    } else { // geojson
        sortLayerIntoBuckets(data, bucketsById);
    }

    function sortLayerIntoBuckets(layer, buckets) {
        for (var i = 0; i < layer.length; i++) {
            var feature = layer.feature(i);
            for (var id in buckets) {
                if (buckets[id].filter(feature))
                    buckets[id].features.push(feature);
            }
        }
    }

    var buckets = [],
        symbolBuckets = this.symbolBuckets = [],
        otherBuckets = [];

    for (var id in bucketsById) {
        bucket = bucketsById[id];
        if (bucket.features.length === 0) continue;

        buckets.push(bucket);

        if (bucket.type === 'symbol')
            symbolBuckets.push(bucket);
        else
            otherBuckets.push(bucket);
    }

    var icons = {},
        stacks = {};

    if (symbolBuckets.length > 0) {

        // Get dependencies for symbol buckets
        for (i = symbolBuckets.length - 1; i >= 0; i--) {
            symbolBuckets[i].updateIcons(icons);
            symbolBuckets[i].updateFont(stacks);
        }

        for (var fontName in stacks) {
            stacks[fontName] = Object.keys(stacks[fontName]).map(Number);
        }
        icons = Object.keys(icons);

        var deps = 0;

        actor.send('get glyphs', {uid: this.uid, stacks: stacks}, function(err, newStacks) {
            stacks = newStacks;
            gotDependency(err);
        });

        if (icons.length) {
            actor.send('get icons', {icons: icons}, function(err, newIcons) {
                icons = newIcons;
                gotDependency(err);
            });
        } else {
            gotDependency();
        }
    }

    // immediately parse non-symbol buckets (they have no dependencies)
    for (i = otherBuckets.length - 1; i >= 0; i--) {
        parseBucket(this, otherBuckets[i]);
    }

    if (symbolBuckets.length === 0)
        return done();

    function gotDependency(err) {
        if (err) return callback(err);
        deps++;
        if (deps === 2) {
            // all symbol bucket dependencies fetched; parse them in proper order
            for (var i = symbolBuckets.length - 1; i >= 0; i--) {
                parseBucket(tile, symbolBuckets[i]);
            }
            done();
        }
    }

    function parseBucket(tile, bucket) {
        var now = Date.now();
        bucket.addFeatures(collisionTile, stacks, icons);
        var time = Date.now() - now;

        if (bucket.interactive) {
            for (var i = 0; i < bucket.features.length; i++) {
                var feature = bucket.features[i];
                tile.featureTree.insert(feature.bbox(), bucket.layers, feature);
            }
        }

        bucket.features = null;

        stats._total += time;
        stats[bucket.id] = (stats[bucket.id] || 0) + time;
    }

    function done() {
        tile.status = 'done';

        if (tile.redoPlacementAfterDone) {
            var result = tile.redoPlacement(tile.angle, tile.pitch).result;
            buffers.glyphVertex = result.buffers.glyphVertex;
            buffers.iconVertex = result.buffers.iconVertex;
            buffers.collisionBoxVertex = result.buffers.collisionBoxVertex;
            tile.redoPlacementAfterDone = false;
        }

        callback(null, {
            elementGroups: getElementGroups(buckets),
            buffers: buffers,
            extent: extent,
            bucketStats: stats
        }, getTransferables(buffers));
    }
};

WorkerTile.prototype.redoPlacement = function(angle, pitch, collisionDebug) {

    if (this.status !== 'done') {
        this.redoPlacementAfterDone = true;
        this.angle = angle;
        return {};
    }

    var buffers = {},
        collisionTile = new CollisionTile(angle, pitch);

    for (var i = this.symbolBuckets.length - 1; i >= 0; i--) {
        this.symbolBuckets[i].placeFeatures(collisionTile, buffers, collisionDebug);
    }

    return {
        result: {
            elementGroups: getElementGroups(this.symbolBuckets),
            buffers: buffers
        },
        transferables: getTransferables(buffers)
    };
};

function getElementGroups(buckets) {
    var elementGroups = {};

    for (var i = 0; i < buckets.length; i++) {
        elementGroups[buckets[i].id] = buckets[i].elementGroups;
    }
    return elementGroups;
}

function getTransferables(buffers) {
    var transferables = [];

    for (var k in buffers) {
        transferables.push(buffers[k].arrayBuffer);

        // The Buffer::push method is generated with "new Function(...)" and not transferrable.
        buffers[k].push = null;
    }
    return transferables;
}

},{"../data/bucket":1,"../data/feature_tree":5,"../symbol/collision_tile":57}],40:[function(require,module,exports){
'use strict';

module.exports = AnimationLoop;

function AnimationLoop() {
    this.n = 0;
    this.times = [];
}

// Are all animations done?
AnimationLoop.prototype.stopped = function() {
    this.times = this.times.filter(function(t) {
        return t.time >= (new Date()).getTime();
    });
    return !this.times.length;
};

// Add a new animation that will run t milliseconds
// Returns an id that can be used to cancel it layer
AnimationLoop.prototype.set = function(t) {
    this.times.push({ id: this.n, time: t + (new Date()).getTime() });
    return this.n++;
};

// Cancel an animation
AnimationLoop.prototype.cancel = function(n) {
    this.times = this.times.filter(function(t) {
        return t.id !== n;
    });
};

},{}],41:[function(require,module,exports){
'use strict';

var Evented = require('../util/evented');
var ajax = require('../util/ajax');
var browser = require('../util/browser');
var normalizeURL = require('../util/mapbox').normalizeSpriteURL;

module.exports = ImageSprite;

function ImageSprite(base) {
    this.base = base;
    this.retina = browser.devicePixelRatio > 1;

    var format = this.retina ? '@2x' : '';

    ajax.getJSON(normalizeURL(base, format, '.json'), function(err, data) {
        if (err) {
            this.fire('error', {error: err});
            return;
        }

        this.data = data;
        if (this.img) this.fire('load');
    }.bind(this));

    ajax.getImage(normalizeURL(base, format, '.png'), function(err, img) {
        if (err) {
            this.fire('error', {error: err});
            return;
        }

        // premultiply the sprite
        var data = img.getData();
        var newdata = img.data = new Uint8Array(data.length);
        for (var i = 0; i < data.length; i += 4) {
            var alpha = data[i + 3] / 255;
            newdata[i + 0] = data[i + 0] * alpha;
            newdata[i + 1] = data[i + 1] * alpha;
            newdata[i + 2] = data[i + 2] * alpha;
            newdata[i + 3] = data[i + 3];
        }

        this.img = img;
        if (this.data) this.fire('load');
    }.bind(this));
}

ImageSprite.prototype = Object.create(Evented);

ImageSprite.prototype.toJSON = function() {
    return this.base;
};

ImageSprite.prototype.loaded = function() {
    return !!(this.data && this.img);
};

ImageSprite.prototype.resize = function(/*gl*/) {
    if (browser.devicePixelRatio > 1 !== this.retina) {
        var newSprite = new ImageSprite(this.base);
        newSprite.on('load', function() {
            this.img = newSprite.img;
            this.data = newSprite.data;
            this.retina = newSprite.retina;
        }.bind(this));
    }
};

function SpritePosition() {}
SpritePosition.prototype = { x: 0, y: 0, width: 0, height: 0, pixelRatio: 1, sdf: false };

ImageSprite.prototype.getSpritePosition = function(name) {
    if (!this.loaded()) return new SpritePosition();

    var pos = this.data && this.data[name];
    if (pos && this.img) return pos;

    return new SpritePosition();
};

},{"../util/ajax":82,"../util/browser":83,"../util/evented":88,"../util/mapbox":91}],42:[function(require,module,exports){
'use strict';

var reference = require('./reference');

module.exports = {};

reference.layout.forEach(function(className) {
    var Properties = function(props) {
        for (var p in props) {
            this[p] = props[p];
        }
    };

    var properties = reference[className];
    for (var prop in properties) {
        if (properties[prop].default === undefined) continue;
        Properties.prototype[prop] = properties[prop].default;
    }
    module.exports[className.replace('layout_', '')] = Properties;
});

},{"./reference":44}],43:[function(require,module,exports){
'use strict';

var reference = require('./reference');
var parseCSSColor = require('csscolorparser').parseCSSColor;

module.exports = {};

reference.paint.forEach(function(className) {
    var Calculated = function() {};

    var properties = reference[className];
    for (var p in properties) {
        var prop = properties[p],
            value = prop.default;

        if (value === undefined) continue;
        if (prop.type === 'color') {
            value = parseCSSColor(value);
        }

        Calculated.prototype[p] = value;
    }

    Calculated.prototype.hidden = false;
    module.exports[className.replace('paint_', '')] = Calculated;
});

},{"./reference":44,"csscolorparser":101}],44:[function(require,module,exports){
'use strict';
module.exports = require('mapbox-gl-style-spec/reference/latest');

},{"mapbox-gl-style-spec/reference/latest":123}],45:[function(require,module,exports){
'use strict';

var Evented = require('../util/evented');
var styleBatch = require('./style_batch');
var StyleLayer = require('./style_layer');
var ImageSprite = require('./image_sprite');
var GlyphSource = require('../symbol/glyph_source');
var SpriteAtlas = require('../symbol/sprite_atlas');
var LineAtlas = require('../render/line_atlas');
var util = require('../util/util');
var ajax = require('../util/ajax');
var normalizeURL = require('../util/mapbox').normalizeStyleURL;
var browser = require('../util/browser');
var Dispatcher = require('../util/dispatcher');
var AnimationLoop = require('./animation_loop');
var validate = require('mapbox-gl-style-spec/lib/validate/latest');

module.exports = Style;

function Style(stylesheet, animationLoop) {
    this.animationLoop = animationLoop || new AnimationLoop();
    this.dispatcher = new Dispatcher(Math.max(browser.hardwareConcurrency - 1, 1), this);
    this.spriteAtlas = new SpriteAtlas(512, 512);
    this.lineAtlas = new LineAtlas(256, 512);

    this._layers = {};
    this._order  = [];
    this._groups = [];
    this.sources = {};

    this.zoomHistory = {};

    util.bindAll([
        '_forwardSourceEvent',
        '_forwardTileEvent',
        '_redoPlacement'
    ], this);

    var loaded = function(err, stylesheet) {
        if (err) {
            this.fire('error', {error: err});
            return;
        }

        var valid = validate(stylesheet);
        if (valid.length) {
            for (var i = 0; i < valid.length; i++) {
                this.fire('error', { error: new Error(valid[i].message) });
            }
            return;
        }

        this._loaded = true;
        this.stylesheet = stylesheet;

        var sources = stylesheet.sources;
        for (var id in sources) {
            this.addSource(id, sources[id]);
        }

        if (stylesheet.sprite) {
            this.sprite = new ImageSprite(stylesheet.sprite);
            this.sprite.on('load', this.fire.bind(this, 'change'));
        }

        this.glyphSource = new GlyphSource(stylesheet.glyphs);
        this._resolve();
        this.fire('load');
    }.bind(this);

    if (typeof stylesheet === 'string') {
        ajax.getJSON(normalizeURL(stylesheet), loaded);
    } else {
        browser.frame(loaded.bind(this, null, stylesheet));
    }

    this.on('source.load', function(event) {
        var source = event.source;
        if (source && source.vectorLayerIds) {
            for (var layerId in this._layers) {
                var layer = this._layers[layerId];
                if (layer.source === source.id) {
                    this._validateLayer(layer);
                }
            }
        }
    });
}

Style.prototype = util.inherit(Evented, {
    _loaded: false,

    _validateLayer: function(layer) {
        var source = this.sources[layer.source];

        if (!layer['source-layer']) return;
        if (!source) return;
        if (!source.vectorLayerIds) return;

        if (source.vectorLayerIds.indexOf(layer['source-layer']) === -1) {
            this.fire('error', {
                error: new Error(
                    'Source layer "' + layer['source-layer'] + '" ' +
                    'does not exist on source "' + source.id + '" ' +
                    'as specified by style layer "' + layer.id + '"'
                )
            });
        }
    },

    loaded: function() {
        if (!this._loaded)
            return false;

        for (var id in this.sources)
            if (!this.sources[id].loaded())
                return false;

        if (this.sprite && !this.sprite.loaded())
            return false;

        return true;
    },

    _resolve: function() {
        var id, layer;

        this._layers = {};
        this._order  = [];

        for (var i = 0; i < this.stylesheet.layers.length; i++) {
            layer = new StyleLayer(this.stylesheet.layers[i]);
            this._layers[layer.id] = layer;
            this._order.push(layer.id);
        }

        // Resolve layout properties.
        for (id in this._layers) {
            this._layers[id].resolveLayout();
        }

        // Resolve reference and paint properties.
        for (id in this._layers) {
            this._layers[id].resolveReference(this._layers);
            this._layers[id].resolvePaint();
        }

        this._groupLayers();
        this._broadcastLayers();
    },

    _groupLayers: function() {
        var group;

        this._groups = [];

        // Split into groups of consecutive top-level layers with the same source.
        for (var i = 0; i < this._order.length; ++i) {
            var layer = this._layers[this._order[i]];

            if (!group || layer.source !== group.source) {
                group = [];
                group.source = layer.source;
                this._groups.push(group);
            }

            group.push(layer);
        }
    },

    _broadcastLayers: function() {
        this.dispatcher.broadcast('set layers', this._order.map(function(id) {
            return this._layers[id].json();
        }, this));
    },

    _cascade: function(classes, options) {
        if (!this._loaded) return;

        options = options || {
            transition: true
        };

        for (var id in this._layers) {
            this._layers[id].cascade(classes, options,
                this.stylesheet.transition || {},
                this.animationLoop);
        }

        this.fire('change');
    },

    _recalculate: function(z) {
        for (var id in this.sources)
            this.sources[id].used = false;

        this._updateZoomHistory(z);

        this.rasterFadeDuration = 300;
        for (id in this._layers) {
            var layer = this._layers[id];

            if (layer.recalculate(z, this.zoomHistory) && layer.source) {
                this.sources[layer.source].used = true;
            }
        }

        var maxZoomTransitionDuration = 300;
        if (Math.floor(this.z) !== Math.floor(z)) {
            this.animationLoop.set(maxZoomTransitionDuration);
        }

        this.z = z;
        this.fire('zoom');
    },

    _updateZoomHistory: function(z) {

        var zh = this.zoomHistory;

        if (zh.lastIntegerZoom === undefined) {
            // first time
            zh.lastIntegerZoom = Math.floor(z);
            zh.lastIntegerZoomTime = 0;
            zh.lastZoom = z;
        }

        // check whether an integer zoom level as passed since the last frame
        // and if yes, record it with the time. Used for transitioning patterns.
        if (Math.floor(zh.lastZoom) < Math.floor(z)) {
            zh.lastIntegerZoom = Math.floor(z);
            zh.lastIntegerZoomTime = Date.now();

        } else if (Math.floor(zh.lastZoom) > Math.floor(z)) {
            zh.lastIntegerZoom = Math.floor(z + 1);
            zh.lastIntegerZoomTime = Date.now();
        }

        zh.lastZoom = z;
    },

    /**
     * Apply multiple style mutations in a batch
     * @param {function} work Function which accepts the StyleBatch interface
     * @private
     */
    batch: function(work) {
        styleBatch(this, work);
    },

    addSource: function(id, source) {
        this.batch(function(batch) {
            batch.addSource(id, source);
        });

        return this;
    },

    /**
     * Remove a source from this stylesheet, given its id.
     * @param {string} id id of the source to remove
     * @returns {Style} this style
     * @throws {Error} if no source is found with the given ID
     * @private
     */
    removeSource: function(id) {
        this.batch(function(batch) {
            batch.removeSource(id);
        });

        return this;
    },

    /**
     * Get a source by id.
     * @param {string} id id of the desired source
     * @returns {Object} source
     * @private
     */
    getSource: function(id) {
        return this.sources[id];
    },

    /**
     * Add a layer to the map style. The layer will be inserted before the layer with
     * ID `before`, or appended if `before` is omitted.
     * @param {StyleLayer|Object} layer
     * @param {string=} before  ID of an existing layer to insert before
     * @fires layer.add
     * @returns {Style} `this`
     * @private
     */
    addLayer: function(layer, before) {
        this.batch(function(batch) {
            batch.addLayer(layer, before);
        });

        return this;
    },

    /**
     * Remove a layer from this stylesheet, given its id.
     * @param {string} id id of the layer to remove
     * @returns {Style} this style
     * @throws {Error} if no layer is found with the given ID
     * @private
     */
    removeLayer: function(id) {
        this.batch(function(batch) {
            batch.removeLayer(id);
        });

        return this;
    },

    /**
     * Return the style layer object with the given `id`.
     *
     * @param {string} id - id of the desired layer
     * @returns {?Object} a layer, if one with the given `id` exists
     * @private
     */
    getLayer: function(id) {
        return this._layers[id];
    },

    /**
     * If a layer has a `ref` property that makes it derive some values
     * from another layer, return that referent layer. Otherwise,
     * returns the layer itself.
     * @param {string} id the layer's id
     * @returns {Layer} the referent layer or the layer itself
     * @private
     */
    getReferentLayer: function(id) {
        var layer = this.getLayer(id);
        if (layer.ref) {
            layer = this.getLayer(layer.ref);
        }
        return layer;
    },

    setFilter: function(layer, filter) {
        this.batch(function(batch) {
            batch.setFilter(layer, filter);
        });

        return this;
    },

    setLayerZoomRange: function(layerId, minzoom, maxzoom) {
        this.batch(function(batch) {
            batch.setLayerZoomRange(layerId, minzoom, maxzoom);
        });

        return this;
    },

    /**
     * Get a layer's filter object
     * @param {string} layer the layer to inspect
     * @returns {*} the layer's filter, if any
     * @private
     */
    getFilter: function(layer) {
        return this.getReferentLayer(layer).filter;
    },

    /**
     * Get a layout property's value from a given layer
     * @param {string} layer the layer to inspect
     * @param {string} name the name of the layout property
     * @returns {*} the property value
     * @private
     */
    getLayoutProperty: function(layer, name) {
        return this.getReferentLayer(layer).getLayoutProperty(name);
    },

    getPaintProperty: function(layer, name, klass) {
        return this.getLayer(layer).getPaintProperty(name, klass);
    },

    featuresAt: function(coord, params, callback) {
        this._queryFeatures('featuresAt', coord, params, callback);
    },

    featuresIn: function(bbox, params, callback) {
        this._queryFeatures('featuresIn', bbox, params, callback);
    },

    _queryFeatures: function(queryType, bboxOrCoords, params, callback) {
        var features = [];
        var error = null;

        if (params.layer) {
            params.layerIds = Array.isArray(params.layer) ? params.layer : [params.layer];
        }

        util.asyncAll(Object.keys(this.sources), function(id, callback) {
            var source = this.sources[id];
            source[queryType](bboxOrCoords, params, function(err, result) {
                if (result) features = features.concat(result);
                if (err) error = err;
                callback();
            });
        }.bind(this), function() {
            if (error) return callback(error);

            callback(null, features
                .filter(function(feature) {
                    return this._layers[feature.layer] !== undefined;
                }.bind(this))
                .map(function(feature) {
                    feature.layer = this._layers[feature.layer].json();
                    return feature;
                }.bind(this)));
        }.bind(this));
    },

    _remove: function() {
        this.dispatcher.remove();
    },

    _reloadSource: function(id) {
        this.sources[id].reload();
    },

    _updateSources: function(transform) {
        for (var id in this.sources) {
            this.sources[id].update(transform);
        }
    },

    _redoPlacement: function() {
        for (var id in this.sources) {
            if (this.sources[id].redoPlacement) this.sources[id].redoPlacement();
        }
    },

    _forwardSourceEvent: function(e) {
        this.fire('source.' + e.type, util.extend({source: e.target}, e));
    },

    _forwardTileEvent: function(e) {
        this.fire(e.type, util.extend({source: e.target}, e));
    },

    // Callbacks from web workers

    'get sprite json': function(params, callback) {
        var sprite = this.sprite;
        if (sprite.loaded()) {
            callback(null, { sprite: sprite.data, retina: sprite.retina });
        } else {
            sprite.on('load', function() {
                callback(null, { sprite: sprite.data, retina: sprite.retina });
            });
        }
    },

    'get icons': function(params, callback) {
        var sprite = this.sprite;
        var spriteAtlas = this.spriteAtlas;
        if (sprite.loaded()) {
            spriteAtlas.setSprite(sprite);
            spriteAtlas.addIcons(params.icons, callback);
        } else {
            sprite.on('load', function() {
                spriteAtlas.setSprite(sprite);
                spriteAtlas.addIcons(params.icons, callback);
            });
        }
    },

    'get glyphs': function(params, callback) {
        var stacks = params.stacks,
            remaining = Object.keys(stacks).length,
            allGlyphs = {};

        for (var fontName in stacks) {
            this.glyphSource.getSimpleGlyphs(fontName, stacks[fontName], params.uid, done);
        }

        function done(err, glyphs, fontName) {
            if (err) console.error(err);

            allGlyphs[fontName] = glyphs;
            remaining--;

            if (remaining === 0)
                callback(null, allGlyphs);
        }
    }
});

},{"../render/line_atlas":25,"../symbol/glyph_source":60,"../symbol/sprite_atlas":65,"../util/ajax":82,"../util/browser":83,"../util/dispatcher":85,"../util/evented":88,"../util/mapbox":91,"../util/util":94,"./animation_loop":40,"./image_sprite":41,"./style_batch":46,"./style_layer":49,"mapbox-gl-style-spec/lib/validate/latest":121}],46:[function(require,module,exports){
'use strict';

var Source = require('../source/source');
var StyleLayer = require('./style_layer');

function styleBatch(style, work) {
    if (!style._loaded) {
        throw new Error('Style is not done loading');
    }

    var batch = Object.create(styleBatch.prototype);

    batch._style = style;
    batch._groupLayers = false;
    batch._broadcastLayers = false;
    batch._reloadSources = {};
    batch._events = [];
    batch._change = false;

    work(batch);

    if (batch._groupLayers) {
        batch._style._groupLayers();
    }

    if (batch._broadcastLayers) {
        batch._style._broadcastLayers();
    }

    Object.keys(batch._reloadSources).forEach(function(sourceId) {
        batch._style._reloadSource(sourceId);
    });

    batch._events.forEach(function(args) {
        batch._style.fire.apply(batch._style, args);
    });

    if (batch._change) {
        batch._style.fire('change');
    }
}

styleBatch.prototype = {

    addLayer: function(layer, before) {
        if (this._style._layers[layer.id] !== undefined) {
            throw new Error('There is already a layer with this ID');
        }
        if (!(layer instanceof StyleLayer)) {
            layer = new StyleLayer(layer);
        }
        this._style._validateLayer(layer);
        this._style._layers[layer.id] = layer;
        this._style._order.splice(before ? this._style._order.indexOf(before) : Infinity, 0, layer.id);
        layer.resolveLayout();
        layer.resolveReference(this._style._layers);
        layer.resolvePaint();

        this._groupLayers = true;
        this._broadcastLayers = true;
        if (layer.source) {
            this._reloadSources[layer.source] = true;
        }
        this._events.push(['layer.add', {layer: layer}]);
        this._change = true;

        return this;
    },

    removeLayer: function(id) {
        var layer = this._style._layers[id];
        if (layer === undefined) {
            throw new Error('There is no layer with this ID');
        }
        for (var i in this._style._layers) {
            if (this._style._layers[i].ref === id) {
                this.removeLayer(i);
            }
        }
        delete this._style._layers[id];
        this._style._order.splice(this._style._order.indexOf(id), 1);

        this._groupLayers = true;
        this._broadcastLayers = true;
        this._events.push(['layer.remove', {layer: layer}]);
        this._change = true;

        return this;
    },

    setPaintProperty: function(layer, name, value, klass) {
        this._style.getLayer(layer).setPaintProperty(name, value, klass);
        this._change = true;

        return this;
    },

    setLayoutProperty: function(layer, name, value) {
        layer = this._style.getReferentLayer(layer);
        layer.setLayoutProperty(name, value);

        this._broadcastLayers = true;
        if (layer.source) {
            this._reloadSources[layer.source] = true;
        }
        this._change = true;

        return this;
    },

    setFilter: function(layer, filter) {
        layer = this._style.getReferentLayer(layer);
        layer.filter = filter;

        this._broadcastLayers = true;
        if (layer.source) {
            this._reloadSources[layer.source] = true;
        }
        this._change = true;

        return this;
    },

    setLayerZoomRange: function(layerId, minzoom, maxzoom) {
        var layer = this._style.getReferentLayer(layerId);
        if (minzoom != null) {
            layer.minzoom = minzoom;
        }
        if (maxzoom != null) {
            layer.maxzoom = maxzoom;
        }

        this._broadcastLayers = true;
        if (layer.source) {
            this._reloadSources[layer.source] = true;
        }
        this._change = true;

        return this;
    },

    addSource: function(id, source) {
        if (!this._style._loaded) {
            throw new Error('Style is not done loading');
        }
        if (this._style.sources[id] !== undefined) {
            throw new Error('There is already a source with this ID');
        }
        source = Source.create(source);
        this._style.sources[id] = source;
        source.id = id;
        source.style = this._style;
        source.dispatcher = this._style.dispatcher;
        source
            .on('load', this._style._forwardSourceEvent)
            .on('error', this._style._forwardSourceEvent)
            .on('change', this._style._forwardSourceEvent)
            .on('tile.add', this._style._forwardTileEvent)
            .on('tile.load', this._style._forwardTileEvent)
            .on('tile.error', this._style._forwardTileEvent)
            .on('tile.remove', this._style._forwardTileEvent)
            .on('tile.stats', this._style._forwardTileEvent);

        this._events.push(['source.add', {source: source}]);
        this._change = true;

        return this;
    },

    removeSource: function(id) {
        if (this._style.sources[id] === undefined) {
            throw new Error('There is no source with this ID');
        }
        var source = this._style.sources[id];
        delete this._style.sources[id];
        source
            .off('load', this._style._forwardSourceEvent)
            .off('error', this._style._forwardSourceEvent)
            .off('change', this._style._forwardSourceEvent)
            .off('tile.add', this._style._forwardTileEvent)
            .off('tile.load', this._style._forwardTileEvent)
            .off('tile.error', this._style._forwardTileEvent)
            .off('tile.remove', this._style._forwardTileEvent)
            .off('tile.stats', this._style._forwardTileEvent);

        this._events.push(['source.remove', {source: source}]);
        this._change = true;

        return this;
    }
};

module.exports = styleBatch;

},{"../source/source":32,"./style_layer":49}],47:[function(require,module,exports){
'use strict';

var parseCSSColor = require('csscolorparser').parseCSSColor;
var MapboxGLFunction = require('mapbox-gl-function');
var util = require('../util/util');

module.exports = StyleDeclaration;

function StyleDeclaration(reference, value) {
    this.type = reference.type;
    this.transitionable = reference.transition;

    if (value == null) {
        value = reference.default;
    }

    // immutable representation of value. used for comparison
    this.json = JSON.stringify(value);

    if (this.type === 'color') {
        this.value = parseColor(value);
    } else {
        this.value = value;
    }

    if (reference.function === 'interpolated') {
        this.calculate = MapboxGLFunction.interpolated(this.value);
    } else {
        this.calculate = MapboxGLFunction['piecewise-constant'](this.value);
        if (reference.transition) {
            this.calculate = transitioned(this.calculate);
        }
    }
}

function transitioned(calculate) {
    return function(z, zh, duration) {
        var fraction = z % 1;
        var t = Math.min((Date.now() - zh.lastIntegerZoomTime) / duration, 1);
        var fromScale = 1;
        var toScale = 1;
        var mix, from, to;

        if (z > zh.lastIntegerZoom) {
            mix = fraction + (1 - fraction) * t;
            fromScale *= 2;
            from = calculate(z - 1);
            to = calculate(z);
        } else {
            mix = 1 - (1 - t) * fraction;
            to = calculate(z);
            from = calculate(z + 1);
            fromScale /= 2;
        }

        return {
            from: from,
            fromScale: fromScale,
            to: to,
            toScale: toScale,
            t: mix
        };
    };
}

var colorCache = {};

function parseColor(input) {

    if (colorCache[input]) {
        return colorCache[input];

    // RGBA array
    } else if (Array.isArray(input)) {
        return input;

    // GL function
    } else if (input && input.stops) {
        return util.extend({}, input, {
            stops: input.stops.map(function(step) {
                return [step[0], parseColor(step[1])];
            })
        });

    // Color string
    } else if (typeof input === 'string') {
        var output = colorDowngrade(parseCSSColor(input));
        colorCache[input] = output;
        return output;

    } else {
        throw new Error('Invalid color ' + input);
    }

}

function colorDowngrade(color) {
    return [color[0] / 255, color[1] / 255, color[2] / 255, color[3] / 1];
}

},{"../util/util":94,"csscolorparser":101,"mapbox-gl-function":120}],48:[function(require,module,exports){
'use strict';

var util = require('../util/util');
var reference = require('./reference');
var StyleDeclaration = require('./style_declaration');

var lookup = {
    paint: {},
    layout: {}
};

reference.layer.type.values.forEach(function(type) {
    lookup.paint[type] = makeConstructor(reference['paint_' + type]);
    lookup.layout[type] = makeConstructor(reference['layout_' + type]);
});

function makeConstructor(reference) {
    function StyleDeclarationSet(properties) {
        this._values = {};
        this._transitions = {};

        for (var k in properties) {
            this[k] = properties[k];
        }
    }

    Object.keys(reference).forEach(function(k) {
        var property = reference[k];

        Object.defineProperty(StyleDeclarationSet.prototype, k, {
            set: function(v) {
                this._values[k] = new StyleDeclaration(property, v);
            },
            get: function() {
                return this._values[k].value;
            }
        });

        if (property.transition) {
            Object.defineProperty(StyleDeclarationSet.prototype, k + '-transition', {
                set: function(v) {
                    this._transitions[k] = v;
                },
                get: function() {
                    return this._transitions[k];
                }
            });
        }
    });

    StyleDeclarationSet.prototype.values = function() {
        return this._values;
    };

    StyleDeclarationSet.prototype.transition = function(k, global) {
        var t = this._transitions[k] || {};
        return {
            duration: util.coalesce(t.duration, global.duration, 300),
            delay: util.coalesce(t.delay, global.delay, 0)
        };
    };

    StyleDeclarationSet.prototype.json = function() {
        var result = {};

        for (var v in this._values) {
            result[v] = this._values[v].value;
        }

        for (var t in this._transitions) {
            result[t + '-transition'] = this._transitions[v];
        }

        return result;
    };

    return StyleDeclarationSet;
}

module.exports = function(renderType, layerType, properties) {
    return new lookup[renderType][layerType](properties);
};

},{"../util/util":94,"./reference":44,"./style_declaration":47}],49:[function(require,module,exports){
'use strict';

var util = require('../util/util');
var StyleTransition = require('./style_transition');
var StyleDeclarationSet = require('./style_declaration_set');
var LayoutProperties = require('./layout_properties');
var PaintProperties = require('./paint_properties');

module.exports = StyleLayer;

function StyleLayer(layer) {
    this._layer = layer;

    this.id = layer.id;
    this.ref = layer.ref;

    // Resolved and cascaded paint properties.
    this._resolved = {}; // class name -> StyleDeclarationSet
    this._cascaded = {}; // property name -> StyleTransition

    this.assign(layer);
}

StyleLayer.prototype = {
    resolveLayout: function() {
        if (!this.ref) {
            this.layout = new LayoutProperties[this.type](this._layer.layout);

            if (this.layout['symbol-placement'] === 'line') {
                if (!this.layout.hasOwnProperty('text-rotation-alignment')) {
                    this.layout['text-rotation-alignment'] = 'map';
                }
                if (!this.layout.hasOwnProperty('icon-rotation-alignment')) {
                    this.layout['icon-rotation-alignment'] = 'map';
                }
                this.layout['symbol-avoid-edges'] = true;
            }
        }
    },

    setLayoutProperty: function(name, value) {
        if (value == null) {
            delete this.layout[name];
        } else {
            this.layout[name] = value;
        }
    },

    getLayoutProperty: function(name) {
        return this.layout[name];
    },

    resolveReference: function(layers) {
        if (this.ref) {
            this.assign(layers[this.ref]);
        }
    },

    resolvePaint: function() {
        for (var p in this._layer) {
            var match = p.match(/^paint(?:\.(.*))?$/);
            if (!match)
                continue;
            this._resolved[match[1] || ''] =
                new StyleDeclarationSet('paint', this.type, this._layer[p]);
        }
    },

    setPaintProperty: function(name, value, klass) {
        var declarations = this._resolved[klass || ''];
        if (!declarations) {
            declarations = this._resolved[klass || ''] =
                new StyleDeclarationSet('paint', this.type, {});
        }
        declarations[name] = value;
    },

    getPaintProperty: function(name, klass) {
        var declarations = this._resolved[klass || ''];
        if (!declarations)
            return undefined;
        return declarations[name];
    },

    cascade: function(classes, options, globalTrans, animationLoop) {
        for (var klass in this._resolved) {
            if (klass !== "" && !classes[klass])
                continue;

            var declarations = this._resolved[klass],
                values = declarations.values();

            for (var k in values) {
                var newDeclaration = values[k];
                var oldTransition = options.transition ? this._cascaded[k] : undefined;

                // Only create a new transition if the declaration changed
                if (!oldTransition || oldTransition.declaration.json !== newDeclaration.json) {
                    var newStyleTrans = declarations.transition(k, globalTrans);
                    var newTransition = this._cascaded[k] =
                        new StyleTransition(newDeclaration, oldTransition, newStyleTrans);

                    // Run the animation loop until the end of the transition
                    if (!newTransition.instant()) {
                        newTransition.loopID = animationLoop.set(newTransition.endTime - (new Date()).getTime());
                    }

                    if (oldTransition) {
                        animationLoop.cancel(oldTransition.loopID);
                    }
                }
            }
        }

        // the -size properties are used both as layout and paint.
        // In the spec they are layout properties. This adds them
        // as internal paint properties.
        if (this.type === 'symbol') {
            var resolvedLayout = new StyleDeclarationSet('layout', this.type, this.layout);
            this._cascaded['text-size'] = new StyleTransition(resolvedLayout.values()['text-size'], undefined, globalTrans);
            this._cascaded['icon-size'] = new StyleTransition(resolvedLayout.values()['icon-size'], undefined, globalTrans);
        }
    },

    recalculate: function(z, zoomHistory) {
        var type = this.type,
            calculated = this.paint = new PaintProperties[type]();

        for (var k in this._cascaded) {
            calculated[k] = this._cascaded[k].at(z, zoomHistory);
        }

        this.hidden = (this.minzoom && z < this.minzoom) ||
                      (this.maxzoom && z >= this.maxzoom) ||
                      // include visibility check for non-bucketed background layers
                      (this.layout.visibility === 'none');

        if (type === 'symbol') {
            if ((calculated['text-opacity'] === 0 || !this.layout['text-field']) &&
                (calculated['icon-opacity'] === 0 || !this.layout['icon-image'])) {
                this.hidden = true;
            } else {
                premultiplyLayer(calculated, 'text');
                premultiplyLayer(calculated, 'icon');
            }

        } else if (calculated[type + '-opacity'] === 0) {
            this.hidden = true;
        } else {
            premultiplyLayer(calculated, type);
        }

        if (this._cascaded['line-dasharray']) {
            // If the line is dashed, scale the dash lengths by the line
            // width at the previous round zoom level.
            var dashArray = calculated['line-dasharray'];
            var lineWidth = this._cascaded['line-width'] ?
                this._cascaded['line-width'].at(Math.floor(z), Infinity) :
                calculated['line-width'];

            dashArray.fromScale *= lineWidth;
            dashArray.toScale *= lineWidth;
        }

        return !this.hidden;
    },

    assign: function(layer) {
        util.extend(this, util.pick(layer,
            ['type', 'source', 'source-layer',
            'minzoom', 'maxzoom', 'filter',
            'layout']));
    },

    json: function() {
        return util.extend({},
            this._layer,
            util.pick(this,
                ['type', 'source', 'source-layer',
                'minzoom', 'maxzoom', 'filter',
                'layout', 'paint']));
    }
};

function premultiplyLayer(layer, type) {
    var colorProp = type + '-color',
        haloProp = type + '-halo-color',
        outlineProp = type + '-outline-color',
        color = layer[colorProp],
        haloColor = layer[haloProp],
        outlineColor = layer[outlineProp],
        opacity = layer[type + '-opacity'];

    var colorOpacity = color && (opacity * color[3]);
    var haloOpacity = haloColor && (opacity * haloColor[3]);
    var outlineOpacity = outlineColor && (opacity * outlineColor[3]);

    if (colorOpacity !== undefined && colorOpacity < 1) {
        layer[colorProp] = util.premultiply([color[0], color[1], color[2], colorOpacity]);
    }
    if (haloOpacity !== undefined && haloOpacity < 1) {
        layer[haloProp] = util.premultiply([haloColor[0], haloColor[1], haloColor[2], haloOpacity]);
    }
    if (outlineOpacity !== undefined && outlineOpacity < 1) {
        layer[outlineProp] = util.premultiply([outlineColor[0], outlineColor[1], outlineColor[2], outlineOpacity]);
    }
}

},{"../util/util":94,"./layout_properties":42,"./paint_properties":43,"./style_declaration_set":48,"./style_transition":50}],50:[function(require,module,exports){
'use strict';

var util = require('../util/util');
var interpolate = require('../util/interpolate');

module.exports = StyleTransition;

/*
 * Represents a transition between two declarations
 */
function StyleTransition(declaration, oldTransition, value) {

    this.declaration = declaration;
    this.startTime = this.endTime = (new Date()).getTime();

    var type = declaration.type;
    if ((type === 'string' || type === 'array') && declaration.transitionable) {
        this.interp = interpZoomTransitioned;
    } else {
        this.interp = interpolate[type];
    }

    this.oldTransition = oldTransition;
    this.duration = value.duration || 0;
    this.delay = value.delay || 0;

    if (!this.instant()) {
        this.endTime = this.startTime + this.duration + this.delay;
        this.ease = util.easeCubicInOut;
    }

    if (oldTransition && oldTransition.endTime <= this.startTime) {
        // Old transition is done running, so we can
        // delete its reference to its old transition.

        delete oldTransition.oldTransition;
    }
}

StyleTransition.prototype.instant = function() {
    return !this.oldTransition || !this.interp || (this.duration === 0 && this.delay === 0);
};

/*
 * Return the value of the transitioning property at zoom level `z` and optional time `t`
 */
StyleTransition.prototype.at = function(z, zoomHistory, t) {

    var value = this.declaration.calculate(z, zoomHistory, this.duration);

    if (this.instant()) return value;

    t = t || Date.now();

    if (t < this.endTime) {
        var oldValue = this.oldTransition.at(z, zoomHistory, this.startTime);
        var eased = this.ease((t - this.startTime - this.delay) / this.duration);
        value = this.interp(oldValue, value, eased);
    }

    return value;

};

function interpZoomTransitioned(from, to, t) {
    return {
        from: from.to,
        fromScale: from.toScale,
        to: to.to,
        toScale: to.toScale,
        t: t
    };
}

},{"../util/interpolate":90,"../util/util":94}],51:[function(require,module,exports){
'use strict';

var Point = require('point-geometry');

module.exports = Anchor;

function Anchor(x, y, angle, segment) {
    this.x = x;
    this.y = y;
    this.angle = angle;

    if (segment !== undefined) {
        this.segment = segment;
    }
}

Anchor.prototype = Object.create(Point.prototype);

Anchor.prototype.clone = function() {
    return new Anchor(this.x, this.y, this.angle, this.segment);
};

},{"point-geometry":130}],52:[function(require,module,exports){
'use strict';

module.exports = BinPack;

/**
 * Simple Bin Packing
 * Uses the Shelf Best Height Fit algorithm from
 * http://clb.demon.fi/files/RectangleBinPack.pdf
 * @private
 */
function BinPack(width, height) {
    this.width = width;
    this.height = height;
    this.shelves = [];
    this.stats = {};
    this.count = function(h) {
        this.stats[h] = (this.stats[h] | 0) + 1;
    };
}

BinPack.prototype.allocate = function(reqWidth, reqHeight) {
    var y = 0,
        best = { shelf: -1, waste: Infinity },
        shelf, waste;

    // find shelf
    for (var i = 0; i < this.shelves.length; i++) {
        shelf = this.shelves[i];
        y += shelf.height;

        // exactly the right height with width to spare, pack it..
        if (reqHeight === shelf.height && reqWidth <= shelf.free) {
            this.count(reqHeight);
            return shelf.alloc(reqWidth, reqHeight);
        }
        // not enough height or width, skip it..
        if (reqHeight > shelf.height || reqWidth > shelf.free) {
            continue;
        }
        // maybe enough height or width, minimize waste..
        if (reqHeight < shelf.height && reqWidth <= shelf.free) {
            waste = shelf.height - reqHeight;
            if (waste < best.waste) {
                best.waste = waste;
                best.shelf = i;
            }
        }
    }

    if (best.shelf !== -1) {
        shelf = this.shelves[best.shelf];
        this.count(reqHeight);
        return shelf.alloc(reqWidth, reqHeight);
    }

    // add shelf
    if (reqHeight <= (this.height - y) && reqWidth <= this.width) {
        shelf = new Shelf(y, this.width, reqHeight);
        this.shelves.push(shelf);
        this.count(reqHeight);
        return shelf.alloc(reqWidth, reqHeight);
    }

    // no more space
    return {x: -1, y: -1};
};


BinPack.prototype.resize = function(reqWidth, reqHeight) {
    if (reqWidth < this.width || reqHeight < this.height) { return false; }
    this.height = reqHeight;
    this.width = reqWidth;
    for (var i = 0; i < this.shelves.length; i++) {
        this.shelves[i].resize(reqWidth);
    }
    return true;
};


function Shelf(y, width, height) {
    this.y = y;
    this.x = 0;
    this.width = this.free = width;
    this.height = height;
}

Shelf.prototype = {
    alloc: function(reqWidth, reqHeight) {
        if (reqWidth > this.free || reqHeight > this.height) {
            return {x: -1, y: -1};
        }
        var x = this.x;
        this.x += reqWidth;
        this.free -= reqWidth;
        return {x: x, y: this.y, w: reqWidth, h: reqHeight};
    },

    resize: function(reqWidth) {
        if (reqWidth < this.width) { return false; }
        this.free += (reqWidth - this.width);
        this.width = reqWidth;
        return true;
    }
};


},{}],53:[function(require,module,exports){
'use strict';

module.exports = checkMaxAngle;

/**
 * Labels placed around really sharp angles aren't readable. Check if any
 * part of the potential label has a combined angle that is too big.
 *
 * @param {Array<Point>} line
 * @param {Anchor} anchor The point on the line around which the label is anchored.
 * @param {number} labelLength The length of the label in geometry units.
 * @param {number} windowSize The check fails if the combined angles within a part of the line that is `windowSize` long is too big.
 * @param {number} maxAngle The maximum combined angle that any window along the label is allowed to have.
 *
 * @returns {boolean} whether the label should be placed
 * @private
 */
function checkMaxAngle(line, anchor, labelLength, windowSize, maxAngle) {

    // horizontal labels always pass
    if (anchor.segment === undefined) return true;

    var p = anchor;
    var index = anchor.segment + 1;
    var anchorDistance = 0;

    // move backwards along the line to the first segment the label appears on
    while (anchorDistance > -labelLength / 2) {
        index--;

        // there isn't enough room for the label after the beginning of the line
        if (index < 0) return false;

        anchorDistance -= line[index].dist(p);
        p = line[index];
    }

    anchorDistance += line[index].dist(line[index + 1]);
    index++;

    // store recent corners and their total angle difference
    var recentCorners = [];
    var recentAngleDelta = 0;

    // move forwards by the length of the label and check angles along the way
    while (anchorDistance < labelLength / 2) {
        var prev = line[index - 1];
        var current = line[index];
        var next = line[index + 1];

        // there isn't enough room for the label before the end of the line
        if (!next) return false;

        var angleDelta = prev.angleTo(current) - current.angleTo(next);
        // restrict angle to -pi..pi range
        angleDelta = ((angleDelta + 3 * Math.PI) % (Math.PI * 2)) - Math.PI;

        recentCorners.push({
            distance: anchorDistance,
            angleDelta: angleDelta
        });
        recentAngleDelta += angleDelta;

        // remove corners that are far enough away from the list of recent anchors
        while (anchorDistance - recentCorners[0].distance > windowSize) {
            recentAngleDelta -= recentCorners.shift().angleDelta;
        }

        // the sum of angles within the window area exceeds the maximum allowed value. check fails.
        if (Math.abs(recentAngleDelta) > maxAngle) return false;

        index++;
        anchorDistance += current.dist(next);
    }

    // no part of the line had an angle greater than the maximum allowed. check passes.
    return true;
}

},{}],54:[function(require,module,exports){
'use strict';

var Point = require('point-geometry');

module.exports = clipLine;

/**
 * Returns the part of a multiline that intersects with the provided rectangular box.
 *
 * @param {Array<Array<Point>>} lines
 * @param {number} x1 the left edge of the box
 * @param {number} y1 the top edge of the box
 * @param {number} x2 the right edge of the box
 * @param {number} y2 the bottom edge of the box
 * @returns {Array<Array<Point>>} lines
 * @private
 */
function clipLine(lines, x1, y1, x2, y2) {
    var clippedLines = [];

    for (var l = 0; l < lines.length; l++) {
        var line = lines[l];
        var clippedLine;

        for (var i = 0; i < line.length - 1; i++) {
            var p0 = line[i];
            var p1 = line[i + 1];


            if (p0.x < x1 && p1.x < x1) {
                continue;
            } else if (p0.x < x1) {
                p0 = new Point(x1, p0.y + (p1.y - p0.y) * ((x1 - p0.x) / (p1.x - p0.x)));
            } else if (p1.x < x1) {
                p1 = new Point(x1, p0.y + (p1.y - p0.y) * ((x1 - p0.x) / (p1.x - p0.x)));
            }

            if (p0.y < y1 && p1.y < y1) {
                continue;
            } else if (p0.y < y1) {
                p0 = new Point(p0.x + (p1.x - p0.x) * ((y1 - p0.y) / (p1.y - p0.y)), y1);
            } else if (p1.y < y1) {
                p1 = new Point(p0.x + (p1.x - p0.x) * ((y1 - p0.y) / (p1.y - p0.y)), y1);
            }

            if (p0.x >= x2 && p1.x >= x2) {
                continue;
            } else if (p0.x >= x2) {
                p0 = new Point(x2, p0.y + (p1.y - p0.y) * ((x2 - p0.x) / (p1.x - p0.x)));
            } else if (p1.x >= x2) {
                p1 = new Point(x2, p0.y + (p1.y - p0.y) * ((x2 - p0.x) / (p1.x - p0.x)));
            }

            if (p0.y >= y2 && p1.y >= y2) {
                continue;
            } else if (p0.y >= y2) {
                p0 = new Point(p0.x + (p1.x - p0.x) * ((y2 - p0.y) / (p1.y - p0.y)), y2);
            } else if (p1.y >= y2) {
                p1 = new Point(p0.x + (p1.x - p0.x) * ((y2 - p0.y) / (p1.y - p0.y)), y2);
            }

            if (!clippedLine || !p0.equals(clippedLine[clippedLine.length - 1])) {
                clippedLine = [p0];
                clippedLines.push(clippedLine);
            }

            clippedLine.push(p1);
        }
    }

    return clippedLines;
}

},{"point-geometry":130}],55:[function(require,module,exports){
'use strict';

module.exports = CollisionBox;

/**
 * A collision box represents an area of the map that that is covered by a
 * label. CollisionFeature uses one or more of these collision boxes to
 * represent all the area covered by a single label. They are used to
 * prevent collisions between labels.
 *
 * A collision box actually represents a 3d volume. The first two dimensions,
 * x and y, are specified with `anchor` along with `x1`, `y1`, `x2`, `y2`.
 * The third dimension, zoom, is limited by `maxScale` which determines
 * how far in the z dimensions the box extends.
 *
 * As you zoom in on a map, all points on the map get further and further apart
 * but labels stay roughly the same size. Labels cover less real world area on
 * the map at higher zoom levels than they do at lower zoom levels. This is why
 * areas are are represented with an anchor point and offsets from that point
 * instead of just using four absolute points.
 *
 * Line labels are represented by a set of these boxes spaced out along a line.
 * When you zoom in, line labels cover less real world distance along the line
 * than they used to. Collision boxes near the edges that used to cover label
 * no longer do. If a box doesn't cover the label anymore it should be ignored
 * when doing collision checks. `maxScale` is how much you can scale the map
 * before the label isn't within the box anymore.
 * For example
 * lower zoom:
 * https://cloud.githubusercontent.com/assets/1421652/8060094/4d975f76-0e91-11e5-84b1-4edeb30a5875.png
 * slightly higher zoom:
 * https://cloud.githubusercontent.com/assets/1421652/8060061/26ae1c38-0e91-11e5-8c5a-9f380bf29f0a.png
 * In the zoomed in image the two grey boxes on either side don't cover the
 * label anymore. Their maxScale is smaller than the current scale.
 *
 *
 * @class CollisionBox
 * @param {Point} anchorPoint The anchor point the box is centered around.
 * @param {number} x1 The distance from the anchor to the left edge.
 * @param {number} y1 The distance from the anchor to the top edge.
 * @param {number} x2 The distance from the anchor to the right edge.
 * @param {number} y2 The distance from the anchor to the bottom edge.
 * @param {number} maxScale The maximum scale this box can block other boxes at.
 * @private
 */
function CollisionBox(anchorPoint, x1, y1, x2, y2, maxScale) {
    // the box is centered around the anchor point
    this.anchorPoint = anchorPoint;

    // distances to the edges from the anchor
    this.x1 = x1;
    this.y1 = y1;
    this.x2 = x2;
    this.y2 = y2;

    // the box is only valid for scales < maxScale.
    // The box does not block other boxes at scales >= maxScale;
    this.maxScale = maxScale;

    // the scale at which the label can first be shown
    this.placementScale = 0;

    // rotated and scaled bbox used for indexing
    this[0] = this[1] = this[2] = this[3] = 0;
}

},{}],56:[function(require,module,exports){
'use strict';

var CollisionBox = require('./collision_box');
var Point = require('point-geometry');

module.exports = CollisionFeature;

/**
 * A CollisionFeature represents the area of the tile covered by a single label.
 * It is used with CollisionTile to check if the label overlaps with any
 * previous labels. A CollisionFeature is mostly just a set of CollisionBox
 * objects.
 *
 * @class CollisionFeature
 * @param {Array<Point>} line The geometry the label is placed on.
 * @param {Anchor} anchor The point along the line around which the label is anchored.
 * @param {Object} shaped The text or icon shaping results.
 * @param {number} boxScale A magic number used to convert from glyph metrics units to geometry units.
 * @param {number} padding The amount of padding to add around the label edges.
 * @param {boolean} alignLine Whether the label is aligned with the line or the viewport.
 *
 * @private
 */
function CollisionFeature(line, anchor, shaped, boxScale, padding, alignLine) {

    var y1 = shaped.top * boxScale - padding;
    var y2 = shaped.bottom * boxScale + padding;
    var x1 = shaped.left * boxScale - padding;
    var x2 = shaped.right * boxScale + padding;

    this.boxes = [];

    if (alignLine) {

        var height = y2 - y1;
        var length = x2 - x1;

        if (height <= 0) return;

        // set minimum box height to avoid very many small labels
        height = Math.max(10 * boxScale, height);

        this._addLineCollisionBoxes(line, anchor, length, height);

    } else {
        this.boxes.push(new CollisionBox(new Point(anchor.x, anchor.y), x1, y1, x2, y2, Infinity));
    }
}

/**
 * Create a set of CollisionBox objects for a line.
 *
 * @param {Array<Point>} line
 * @param {Anchor} anchor
 * @param {number} labelLength The length of the label in geometry units.
 * @param {number} boxSize The size of the collision boxes that will be created.
 *
 * @private
 */
CollisionFeature.prototype._addLineCollisionBoxes = function(line, anchor, labelLength, boxSize) {
    var step = boxSize / 2;
    var nBoxes = Math.floor(labelLength / step);

    // offset the center of the first box by half a box so that the edge of the
    // box is at the edge of the label.
    var firstBoxOffset = -boxSize / 2;

    var bboxes = this.boxes;

    var p = anchor;
    var index = anchor.segment + 1;
    var anchorDistance = firstBoxOffset;

    // move backwards along the line to the first segment the label appears on
    do {
        index--;

        // there isn't enough room for the label after the beginning of the line
        // checkMaxAngle should have already caught this
        if (index < 0) return bboxes;

        anchorDistance -= line[index].dist(p);
        p = line[index];
    } while (anchorDistance > -labelLength / 2);

    var segmentLength = line[index].dist(line[index + 1]);

    for (var i = 0; i < nBoxes; i++) {
        // the distance the box will be from the anchor
        var boxDistanceToAnchor = -labelLength / 2 + i * step;

        // the box is not on the current segment. Move to the next segment.
        while (anchorDistance + segmentLength < boxDistanceToAnchor) {
            anchorDistance += segmentLength;
            index++;

            // There isn't enough room before the end of the line.
            if (index + 1 >= line.length) return bboxes;

            segmentLength = line[index].dist(line[index + 1]);
        }

        // the distance the box will be from the beginning of the segment
        var segmentBoxDistance = boxDistanceToAnchor - anchorDistance;

        var p0 = line[index];
        var p1 = line[index + 1];
        var boxAnchorPoint = p1.sub(p0)._unit()._mult(segmentBoxDistance)._add(p0);

        var distanceToInnerEdge = Math.max(Math.abs(boxDistanceToAnchor - firstBoxOffset) - step / 2, 0);
        var maxScale = labelLength / 2 / distanceToInnerEdge;

        bboxes.push(new CollisionBox(boxAnchorPoint, -boxSize / 2, -boxSize / 2, boxSize / 2, boxSize / 2, maxScale));
    }

    return bboxes;
};

},{"./collision_box":55,"point-geometry":130}],57:[function(require,module,exports){
'use strict';

var rbush = require('rbush');

module.exports = CollisionTile;

/**
 * A collision tile used to prevent symbols from overlapping. It keep tracks of
 * where previous symbols have been placed and is used to check if a new
 * symbol overlaps with any previously added symbols.
 *
 * @class CollisionTile
 * @param {number} angle
 * @param {number} pitch
 * @private
 */
function CollisionTile(angle, pitch) {
    this.tree = rbush();
    this.angle = angle;

    var sin = Math.sin(angle),
        cos = Math.cos(angle);
    this.rotationMatrix = [cos, -sin, sin, cos];

    // Stretch boxes in y direction to account for the map tilt.
    this.yStretch = 1 / Math.cos(pitch / 180 * Math.PI);

    // The amount the map is squished depends on the y position.
    // Sort of account for this by making all boxes a bit bigger.
    this.yStretch = Math.pow(this.yStretch, 1.3);
}

CollisionTile.prototype.minScale = 0.25;
CollisionTile.prototype.maxScale = 2;


/**
 * Find the scale at which the collisionFeature can be shown without
 * overlapping with other features.
 *
 * @param {CollisionFeature} collisionFeature
 * @returns {number} placementScale
 * @private
 */
CollisionTile.prototype.placeCollisionFeature = function(collisionFeature) {

    var minPlacementScale = this.minScale;
    var rotationMatrix = this.rotationMatrix;
    var yStretch = this.yStretch;

    for (var b = 0; b < collisionFeature.boxes.length; b++) {

        var box = collisionFeature.boxes[b];

        var anchorPoint = box.anchorPoint.matMult(rotationMatrix);
        var x = anchorPoint.x;
        var y = anchorPoint.y;

        box[0] = x + box.x1;
        box[1] = y + box.y1 * yStretch;
        box[2] = x + box.x2;
        box[3] = y + box.y2 * yStretch;

        var blockingBoxes = this.tree.search(box);

        for (var i = 0; i < blockingBoxes.length; i++) {
            var blocking = blockingBoxes[i];
            var blockingAnchorPoint = blocking.anchorPoint.matMult(rotationMatrix);

            // Find the lowest scale at which the two boxes can fit side by side without overlapping.
            // Original algorithm:
            var s1 = (blocking.x1 - box.x2) / (x - blockingAnchorPoint.x); // scale at which new box is to the left of old box
            var s2 = (blocking.x2 - box.x1) / (x - blockingAnchorPoint.x); // scale at which new box is to the right of old box
            var s3 = (blocking.y1 - box.y2) * yStretch / (y - blockingAnchorPoint.y); // scale at which new box is to the top of old box
            var s4 = (blocking.y2 - box.y1) * yStretch / (y - blockingAnchorPoint.y); // scale at which new box is to the bottom of old box

            if (isNaN(s1) || isNaN(s2)) s1 = s2 = 1;
            if (isNaN(s3) || isNaN(s4)) s3 = s4 = 1;

            var collisionFreeScale = Math.min(Math.max(s1, s2), Math.max(s3, s4));

            if (collisionFreeScale > blocking.maxScale) {
                // After a box's maxScale the label has shrunk enough that the box is no longer needed to cover it,
                // so unblock the new box at the scale that the old box disappears.
                collisionFreeScale = blocking.maxScale;
            }

            if (collisionFreeScale > box.maxScale) {
                // If the box can only be shown after it is visible, then the box can never be shown.
                // But the label can be shown after this box is not visible.
                collisionFreeScale = box.maxScale;
            }

            if (collisionFreeScale > minPlacementScale &&
                    collisionFreeScale >= blocking.placementScale) {
                // If this collision occurs at a lower scale than previously found collisions
                // and the collision occurs while the other label is visible

                // this this is the lowest scale at which the label won't collide with anything
                minPlacementScale = collisionFreeScale;
            }

            if (minPlacementScale >= this.maxScale) return minPlacementScale;
        }
    }

    return minPlacementScale;
};

/**
 * Remember this collisionFeature and what scale it was placed at to block
 * later features from overlapping with it.
 *
 * @param {CollisionFeature} collisionFeature
 * @param {number} minPlacementScale
 * @private
 */
CollisionTile.prototype.insertCollisionFeature = function(collisionFeature, minPlacementScale) {

    var boxes = collisionFeature.boxes;
    for (var k = 0; k < boxes.length; k++) {
        boxes[k].placementScale = minPlacementScale;
    }

    if (minPlacementScale < this.maxScale) {
        this.tree.load(boxes);
    }
};

},{"rbush":131}],58:[function(require,module,exports){
'use strict';

var interpolate = require('../util/interpolate');
var Anchor = require('../symbol/anchor');
var checkMaxAngle = require('./check_max_angle');

module.exports = getAnchors;

function getAnchors(line, spacing, maxAngle, shapedText, shapedIcon, glyphSize, boxScale, overscaling) {

    // Resample a line to get anchor points for labels and check that each
    // potential label passes text-max-angle check and has enough froom to fit
    // on the line.

    var angleWindowSize = shapedText ?
        3 / 5 * glyphSize * boxScale :
        0;

    var labelLength = Math.max(
        shapedText ? shapedText.right - shapedText.left : 0,
        shapedIcon ? shapedIcon.right - shapedIcon.left : 0);

    // Is the line continued from outside the tile boundary?
    if (line[0].x === 0 || line[0].x === 4096 || line[0].y === 0 || line[0].y === 4096) {
        var continuedLine = true;
    }

    // Is the label long, relative to the spacing?
    // If so, adjust the spacing so there is always a minimum space of `spacing / 4` between label edges.
    if (spacing - labelLength * boxScale  < spacing / 4) {
        spacing = labelLength * boxScale + spacing / 4;
    }

    // Offset the first anchor by:
    // Either half the label length plus a fixed extra offset if the line is not continued
    // Or half the spacing if the line is continued.

    // For non-continued lines, add a bit of fixed extra offset to avoid collisions at T intersections.
    var fixedExtraOffset = glyphSize * 2;

    var offset = !continuedLine ?
        ((labelLength / 2 + fixedExtraOffset) * boxScale * overscaling) % spacing :
        (spacing / 2 * overscaling) % spacing;

    return resample(line, offset, spacing, angleWindowSize, maxAngle, labelLength * boxScale, continuedLine, false);
}


function resample(line, offset, spacing, angleWindowSize, maxAngle, labelLength, continuedLine, placeAtMiddle) {

    var distance = 0,
        markedDistance = offset - spacing;

    var anchors = [];

    for (var i = 0; i < line.length - 1; i++) {

        var a = line[i],
            b = line[i + 1];

        var segmentDist = a.dist(b),
            angle = b.angleTo(a);

        while (markedDistance + spacing < distance + segmentDist) {
            markedDistance += spacing;

            var t = (markedDistance - distance) / segmentDist,
                x = interpolate(a.x, b.x, t),
                y = interpolate(a.y, b.y, t);

            if (x >= 0 && x < 4096 && y >= 0 && y < 4096) {
                x = Math.round(x);
                y = Math.round(y);
                var anchor = new Anchor(x, y, angle, i);

                if (!angleWindowSize || checkMaxAngle(line, anchor, labelLength, angleWindowSize, maxAngle)) {
                    anchors.push(anchor);
                }
            }
        }

        distance += segmentDist;
    }

    if (!placeAtMiddle && !anchors.length && !continuedLine) {
        // The first attempt at finding anchors at which labels can be placed failed.
        // Try again, but this time just try placing one anchor at the middle of the line.
        // This has the most effect for short lines in overscaled tiles, since the
        // initial offset used in overscaled tiles is calculated to align labels with positions in
        // parent tiles instead of placing the label as close to the beginning as possible.
        anchors = resample(line, distance / 2, spacing, angleWindowSize, maxAngle, labelLength, continuedLine, true);
    }

    return anchors;
}

},{"../symbol/anchor":51,"../util/interpolate":90,"./check_max_angle":53}],59:[function(require,module,exports){
'use strict';

var BinPack = require('./bin_pack');

module.exports = GlyphAtlas;
function GlyphAtlas(width, height) {
    this.width = width;
    this.height = height;

    this.bin = new BinPack(width, height);
    this.index = {};
    this.ids = {};
    this.data = new Uint8Array(width * height);
}

GlyphAtlas.prototype = {
    get debug() {
        return 'canvas' in this;
    },
    set debug(value) {
        if (value && !this.canvas) {
            this.canvas = document.createElement('canvas');
            this.canvas.width = this.width;
            this.canvas.height = this.height;
            document.body.appendChild(this.canvas);
            this.ctx = this.canvas.getContext('2d');
        } else if (!value && this.canvas) {
            this.canvas.parentNode.removeChild(this.canvas);
            delete this.ctx;
            delete this.canvas;
        }
    }
};

GlyphAtlas.prototype.getGlyphs = function() {
    var glyphs = {},
        split,
        name,
        id;

    for (var key in this.ids) {
        split = key.split('#');
        name = split[0];
        id = split[1];

        if (!glyphs[name]) glyphs[name] = [];
        glyphs[name].push(id);
    }

    return glyphs;
};

GlyphAtlas.prototype.getRects = function() {
    var rects = {},
        split,
        name,
        id;

    for (var key in this.ids) {
        split = key.split('#');
        name = split[0];
        id = split[1];

        if (!rects[name]) rects[name] = {};
        rects[name][id] = this.index[key];
    }

    return rects;
};


GlyphAtlas.prototype.addGlyph = function(id, name, glyph, buffer) {
    if (!glyph) {
        // console.warn('missing glyph', code, String.fromCharCode(code));
        return null;
    }
    var key = name + "#" + glyph.id;

    // The glyph is already in this texture.
    if (this.index[key]) {
        if (this.ids[key].indexOf(id) < 0) {
            this.ids[key].push(id);
        }
        return this.index[key];
    }

    // The glyph bitmap has zero width.
    if (!glyph.bitmap) {
        return null;
    }

    var bufferedWidth = glyph.width + buffer * 2;
    var bufferedHeight = glyph.height + buffer * 2;

    // Add a 1px border around every image.
    var padding = 1;
    var packWidth = bufferedWidth + 2 * padding;
    var packHeight = bufferedHeight + 2 * padding;

    // Increase to next number divisible by 4, but at least 1.
    // This is so we can scale down the texture coordinates and pack them
    // into 2 bytes rather than 4 bytes.
    packWidth += (4 - packWidth % 4);
    packHeight += (4 - packHeight % 4);

    var rect = this.bin.allocate(packWidth, packHeight);
    if (rect.x < 0) {
        this.resize();
        rect = this.bin.allocate(packWidth, packHeight);
    }
    if (rect.x < 0) {
        console.warn('glyph bitmap overflow');
        return { glyph: glyph, rect: null };
    }

    this.index[key] = rect;
    this.ids[key] = [id];

    var target = this.data;
    var source = glyph.bitmap;
    for (var y = 0; y < bufferedHeight; y++) {
        var y1 = this.width * (rect.y + y + padding) + rect.x + padding;
        var y2 = bufferedWidth * y;
        for (var x = 0; x < bufferedWidth; x++) {
            target[y1 + x] = source[y2 + x];
        }
    }

    this.dirty = true;

    return rect;
};

GlyphAtlas.prototype.resize = function() {
    var origw = this.width,
        origh = this.height;

    // For now, don't grow the atlas beyond 1024x1024 because of how
    // texture coords pack into unsigned byte in symbol bucket.
    if (origw > 512 || origh > 512) return;

    if (this.texture) {
        if (this.gl) {
            this.gl.deleteTexture(this.texture);
        }
        this.texture = null;
    }

    this.width *= 2;
    this.height *= 2;
    this.bin.resize(this.width, this.height);

    var buf = new ArrayBuffer(this.width * this.height),
        src, dst;
    for (var i = 0; i < origh; i++) {
        src = new Uint8Array(this.data.buffer, origh * i, origw);
        dst = new Uint8Array(buf, origh * i * 2, origw);
        dst.set(src);
    }
    this.data = new Uint8Array(buf);
};

GlyphAtlas.prototype.bind = function(gl) {
    this.gl = gl;
    if (!this.texture) {
        this.texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.ALPHA, this.width, this.height, 0, gl.ALPHA, gl.UNSIGNED_BYTE, null);

    } else {
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
    }
};

GlyphAtlas.prototype.updateTexture = function(gl) {
    this.bind(gl);
    if (this.dirty) {

        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, this.width, this.height, gl.ALPHA, gl.UNSIGNED_BYTE, this.data);

        // DEBUG
        if (this.ctx) {
            var data = this.ctx.getImageData(0, 0, this.width, this.height);
            for (var i = 0, j = 0; i < this.data.length; i++, j += 4) {
                data.data[j] = this.data[i];
                data.data[j + 1] = this.data[i];
                data.data[j + 2] = this.data[i];
                data.data[j + 3] = 255;
            }
            this.ctx.putImageData(data, 0, 0);

            this.ctx.strokeStyle = 'red';
            for (var k = 0; k < this.bin.free.length; k++) {
                var free = this.bin.free[k];
                this.ctx.strokeRect(free.x, free.y, free.w, free.h);
            }
        }
        // END DEBUG

        this.dirty = false;
    }
};

},{"./bin_pack":52}],60:[function(require,module,exports){
'use strict';

var normalizeURL = require('../util/mapbox').normalizeGlyphsURL;
var getArrayBuffer = require('../util/ajax').getArrayBuffer;
var Glyphs = require('../util/glyphs');
var GlyphAtlas = require('../symbol/glyph_atlas');
var Protobuf = require('pbf');

module.exports = GlyphSource;

/**
 * A glyph source has a URL from which to load new glyphs and manages
 * GlyphAtlases in which to store glyphs used by the requested fontstacks
 * and ranges.
 *
 * @param {string} url glyph template url
 * @private
 */
function GlyphSource(url) {
    this.url = url && normalizeURL(url);
    this.atlases = {};
    this.stacks = {};
    this.loading = {};
}

GlyphSource.prototype.getSimpleGlyphs = function(fontstack, glyphIDs, uid, callback) {
    if (this.stacks[fontstack] === undefined) {
        this.stacks[fontstack] = {};
    }
    if (this.atlases[fontstack] === undefined) {
        this.atlases[fontstack] = new GlyphAtlas(128, 128);
    }

    var glyphs = {};
    var stack = this.stacks[fontstack];
    var atlas = this.atlases[fontstack];

    // the number of pixels the sdf bitmaps are padded by
    var buffer = 3;

    var missing = {};
    var remaining = 0;
    var range;

    for (var i = 0; i < glyphIDs.length; i++) {
        var glyphID = glyphIDs[i];
        range = Math.floor(glyphID / 256);

        if (stack[range]) {
            var glyph = stack[range].glyphs[glyphID];
            var rect  = atlas.addGlyph(uid, fontstack, glyph, buffer);
            if (glyph) glyphs[glyphID] = new SimpleGlyph(glyph, rect, buffer);
        } else {
            if (missing[range] === undefined) {
                missing[range] = [];
                remaining++;
            }
            missing[range].push(glyphID);
        }
    }

    if (!remaining) callback(undefined, glyphs, fontstack);

    var onRangeLoaded = function(err, range, data) {
        // TODO not be silent about errors
        if (!err) {
            var stack = this.stacks[fontstack][range] = data.stacks[0];
            for (var i = 0; i < missing[range].length; i++) {
                var glyphID = missing[range][i];
                var glyph = stack.glyphs[glyphID];
                var rect  = atlas.addGlyph(uid, fontstack, glyph, buffer);
                if (glyph) glyphs[glyphID] = new SimpleGlyph(glyph, rect, buffer);
            }
        }
        remaining--;
        if (!remaining) callback(undefined, glyphs, fontstack);
    }.bind(this);

    for (var r in missing) {
        this.loadRange(fontstack, r, onRangeLoaded);
    }
};

// A simplified representation of the glyph containing only the properties needed for shaping.
function SimpleGlyph(glyph, rect, buffer) {
    var padding = 1;
    this.advance = glyph.advance;
    this.left = glyph.left - buffer - padding;
    this.top = glyph.top + buffer + padding;
    this.rect = rect;
}

GlyphSource.prototype.loadRange = function(fontstack, range, callback) {
    if (range * 256 > 65535) return callback('glyphs > 65535 not supported');

    if (this.loading[fontstack] === undefined) {
        this.loading[fontstack] = {};
    }
    var loading = this.loading[fontstack];

    if (loading[range]) {
        loading[range].push(callback);
    } else {
        loading[range] = [callback];

        var rangeName = (range * 256) + '-' + (range * 256 + 255);
        var url = glyphUrl(fontstack, rangeName, this.url);

        getArrayBuffer(url, function(err, data) {
            var glyphs = !err && new Glyphs(new Protobuf(new Uint8Array(data)));
            for (var i = 0; i < loading[range].length; i++) {
                loading[range][i](err, range, glyphs);
            }
            delete loading[range];
        });
    }
};

GlyphSource.prototype.getGlyphAtlas = function(fontstack) {
    return this.atlases[fontstack];
};

/**
 * Use CNAME sharding to load a specific glyph range over a randomized
 * but consistent subdomain.
 * @param {string} fontstack comma-joined fonts
 * @param {string} range comma-joined range
 * @param {url} url templated url
 * @param {string} [subdomains=abc] subdomains as a string where each letter is one.
 * @returns {string} a url to load that section of glyphs
 * @private
 */
function glyphUrl(fontstack, range, url, subdomains) {
    subdomains = subdomains || 'abc';

    return url
        .replace('{s}', subdomains[fontstack.length % subdomains.length])
        .replace('{fontstack}', fontstack)
        .replace('{range}', range);
}

},{"../symbol/glyph_atlas":59,"../util/ajax":82,"../util/glyphs":89,"../util/mapbox":91,"pbf":128}],61:[function(require,module,exports){
'use strict';

module.exports = function (features, textFeatures, geometries) {

    var leftIndex = {},
        rightIndex = {},
        mergedFeatures = [],
        mergedGeom = [],
        mergedTexts = [],
        mergedIndex = 0,
        k;

    function add(k) {
        mergedFeatures.push(features[k]);
        mergedGeom.push(geometries[k]);
        mergedTexts.push(textFeatures[k]);
        mergedIndex++;
    }

    function mergeFromRight(leftKey, rightKey, geom) {
        var i = rightIndex[leftKey];
        delete rightIndex[leftKey];
        rightIndex[rightKey] = i;

        mergedGeom[i][0].pop();
        mergedGeom[i][0] = mergedGeom[i][0].concat(geom[0]);
        return i;
    }

    function mergeFromLeft(leftKey, rightKey, geom) {
        var i = leftIndex[rightKey];
        delete leftIndex[rightKey];
        leftIndex[leftKey] = i;

        mergedGeom[i][0].shift();
        mergedGeom[i][0] = geom[0].concat(mergedGeom[i][0]);
        return i;
    }

    function getKey(text, geom, onRight) {
        var point = onRight ? geom[0][geom[0].length - 1] : geom[0][0];
        return text + ':' + point.x + ':' + point.y;
    }

    for (k = 0; k < features.length; k++) {
        var geom = geometries[k],
            text = textFeatures[k];

        if (!text) {
            add(k);
            continue;
        }

        var leftKey = getKey(text, geom),
            rightKey = getKey(text, geom, true);

        if ((leftKey in rightIndex) && (rightKey in leftIndex) && (rightIndex[leftKey] !== leftIndex[rightKey])) {
            // found lines with the same text adjacent to both ends of the current line, merge all three
            var j = mergeFromLeft(leftKey, rightKey, geom);
            var i = mergeFromRight(leftKey, rightKey, mergedGeom[j]);

            delete leftIndex[leftKey];
            delete rightIndex[rightKey];

            rightIndex[getKey(text, mergedGeom[i], true)] = i;
            mergedGeom[j] = null;

        } else if (leftKey in rightIndex) {
            // found mergeable line adjacent to the start of the current line, merge
            mergeFromRight(leftKey, rightKey, geom);

        } else if (rightKey in leftIndex) {
            // found mergeable line adjacent to the end of the current line, merge
            mergeFromLeft(leftKey, rightKey, geom);

        } else {
            // no adjacent lines, add as a new item
            add(k);
            leftIndex[leftKey] = mergedIndex - 1;
            rightIndex[rightKey] = mergedIndex - 1;
        }
    }

    return {
        features: mergedFeatures,
        textFeatures: mergedTexts,
        geometries: mergedGeom
    };
};

},{}],62:[function(require,module,exports){
'use strict';

var Point = require('point-geometry');

module.exports = {
    getIconQuads: getIconQuads,
    getGlyphQuads: getGlyphQuads
};

var minScale = 0.5; // underscale by 1 zoom level

/**
 * A textured quad for rendering a single icon or glyph.
 *
 * The zoom range the glyph can be shown is defined by minScale and maxScale.
 *
 * @param {Point} anchorPoint the point the symbol is anchored around
 * @param {Point} tl The offset of the top left corner from the anchor.
 * @param {Point} tr The offset of the top right corner from the anchor.
 * @param {Point} bl The offset of the bottom left corner from the anchor.
 * @param {Point} br The offset of the bottom right corner from the anchor.
 * @param {Object} tex The texture coordinates.
 * @param {number} angle The angle of the label at it's center, not the angle of this quad.
 * @param {number} minScale The minimum scale, relative to the tile's intended scale, that the glyph can be shown at.
 * @param {number} maxScale The maximum scale, relative to the tile's intended scale, that the glyph can be shown at.
 *
 * @class SymbolQuad
 * @private
 */
function SymbolQuad(anchorPoint, tl, tr, bl, br, tex, angle, minScale, maxScale) {
    this.anchorPoint = anchorPoint;
    this.tl = tl;
    this.tr = tr;
    this.bl = bl;
    this.br = br;
    this.tex = tex;
    this.angle = angle;
    this.minScale = minScale;
    this.maxScale = maxScale;
}

/**
 * Create the quads used for rendering an icon.
 *
 * @param {Anchor} anchor
 * @param {PositionedIcon} shapedIcon
 * @param {number} boxScale A magic number for converting glyph metric units to geometry units.
 * @param {Array<Array<Point>>} line
 * @param {LayoutProperties} layout
 * @param {boolean} alongLine Whether the icon should be placed along the line.
 * @returns {Array<SymbolQuad>}
 * @private
 */
function getIconQuads(anchor, shapedIcon, boxScale, line, layout, alongLine) {

    var rect = shapedIcon.image.rect;

    var border = 1;
    var left = shapedIcon.left - border;
    var right = left + rect.w / shapedIcon.image.pixelRatio;
    var top = shapedIcon.top - border;
    var bottom = top + rect.h / shapedIcon.image.pixelRatio;
    var tl = new Point(left, top);
    var tr = new Point(right, top);
    var br = new Point(right, bottom);
    var bl = new Point(left, bottom);

    var angle = layout['icon-rotate'] * Math.PI / 180;
    if (alongLine) {
        var prev = line[anchor.segment];
        if (anchor.y === prev.y && anchor.x === prev.x && anchor.segment + 1 < line.length) {
            var next = line[anchor.segment + 1];
            angle += Math.atan2(anchor.y - next.y, anchor.x - next.x) + Math.PI;
        } else {
            angle += Math.atan2(anchor.y - prev.y, anchor.x - prev.x);
        }
    }

    if (angle) {
        var sin = Math.sin(angle),
            cos = Math.cos(angle),
            matrix = [cos, -sin, sin, cos];

        tl = tl.matMult(matrix);
        tr = tr.matMult(matrix);
        bl = bl.matMult(matrix);
        br = br.matMult(matrix);
    }

    return [new SymbolQuad(new Point(anchor.x, anchor.y), tl, tr, bl, br, shapedIcon.image.rect, 0, minScale, Infinity)];
}

/**
 * Create the quads used for rendering a text label.
 *
 * @param {Anchor} anchor
 * @param {Shaping} shaping
 * @param {number} boxScale A magic number for converting from glyph metric units to geometry units.
 * @param {Array<Array<Point>>} line
 * @param {LayoutProperties} layout
 * @param {boolean} alongLine Whether the label should be placed along the line.
 * @returns {Array<SymbolQuad>}
 * @private
 */
function getGlyphQuads(anchor, shaping, boxScale, line, layout, alongLine) {

    var textRotate = layout['text-rotate'] * Math.PI / 180;
    var keepUpright = layout['text-keep-upright'];

    var positionedGlyphs = shaping.positionedGlyphs;
    var quads = [];

    for (var k = 0; k < positionedGlyphs.length; k++) {
        var positionedGlyph = positionedGlyphs[k];
        var glyph = positionedGlyph.glyph;
        var rect = glyph.rect;

        if (!rect) continue;

        var centerX = (positionedGlyph.x + glyph.advance / 2) * boxScale;

        var glyphInstances;
        var labelMinScale = minScale;
        if (alongLine) {
            glyphInstances = [];
            labelMinScale = getSegmentGlyphs(glyphInstances, anchor, centerX, line, anchor.segment, true);
            if (keepUpright) {
                labelMinScale = Math.min(labelMinScale, getSegmentGlyphs(glyphInstances, anchor, centerX, line, anchor.segment, false));
            }

        } else {
            glyphInstances = [{
                anchorPoint: new Point(anchor.x, anchor.y),
                offset: 0,
                angle: 0,
                maxScale: Infinity,
                minScale: minScale
            }];
        }

        var x1 = positionedGlyph.x + glyph.left,
            y1 = positionedGlyph.y - glyph.top,
            x2 = x1 + rect.w,
            y2 = y1 + rect.h,

            otl = new Point(x1, y1),
            otr = new Point(x2, y1),
            obl = new Point(x1, y2),
            obr = new Point(x2, y2);

        for (var i = 0; i < glyphInstances.length; i++) {

            var instance = glyphInstances[i],
                tl = otl,
                tr = otr,
                bl = obl,
                br = obr,
                angle = instance.angle + textRotate;

            if (angle) {
                var sin = Math.sin(angle),
                    cos = Math.cos(angle),
                    matrix = [cos, -sin, sin, cos];

                tl = tl.matMult(matrix);
                tr = tr.matMult(matrix);
                bl = bl.matMult(matrix);
                br = br.matMult(matrix);
            }

            // Prevent label from extending past the end of the line
            var glyphMinScale = Math.max(instance.minScale, labelMinScale);

            var glyphAngle = (anchor.angle + textRotate + instance.offset + 2 * Math.PI) % (2 * Math.PI);
            quads.push(new SymbolQuad(instance.anchorPoint, tl, tr, bl, br, rect, glyphAngle, glyphMinScale, instance.maxScale));

        }
    }

    return quads;
}

/**
 * We can only render glyph quads that slide along a straight line. To draw
 * curved lines we need an instance of a glyph for each segment it appears on.
 * This creates all the instances of a glyph that are necessary to render a label.
 *
 * We need a
 * @param {Array<Object>} glyphInstances An empty array that glyphInstances are added to.
 * @param {Anchor} anchor
 * @param {number} offset The glyph's offset from the center of the label.
 * @param {Array<Point>} line
 * @param {number} segment The index of the segment of the line on which the anchor exists.
 * @param {boolean} forward If true get the glyphs that come later on the line, otherwise get the glyphs that come earlier.
 *
 * @returns {Array<Object>} glyphInstances
 * @private
 */
function getSegmentGlyphs(glyphs, anchor, offset, line, segment, forward) {
    var upsideDown = !forward;

    if (offset < 0) forward = !forward;

    if (forward) segment++;

    var newAnchorPoint = new Point(anchor.x, anchor.y);
    var end = line[segment];
    var prevScale = Infinity;

    offset = Math.abs(offset);

    var placementScale = minScale;

    while (true) {
        var distance = newAnchorPoint.dist(end);
        var scale = offset / distance;

        // Get the angle of the line segment
        var angle = Math.atan2(end.y - newAnchorPoint.y, end.x - newAnchorPoint.x);
        if (!forward) angle += Math.PI;
        if (upsideDown) angle += Math.PI;

        glyphs.push({
            anchorPoint: newAnchorPoint,
            offset: upsideDown ? Math.PI : 0,
            minScale: scale,
            maxScale: prevScale,
            angle: (angle + 2 * Math.PI) % (2 * Math.PI)
        });

        if (scale <= placementScale) break;

        newAnchorPoint = end;

        // skip duplicate nodes
        while (newAnchorPoint.equals(end)) {
            segment += forward ? 1 : -1;
            end = line[segment];
            if (!end) {
                return scale;
            }
        }

        var unit = end.sub(newAnchorPoint)._unit();
        newAnchorPoint = newAnchorPoint.sub(unit._mult(distance));

        prevScale = scale;
    }

    return placementScale;
}

},{"point-geometry":130}],63:[function(require,module,exports){
'use strict';

var resolveTokens = require('../util/token');

module.exports = resolveText;

/**
 * For an array of features determine what glyphs need to be loaded
 * and apply any text preprocessing. The remaining users of text should
 * use the `textFeatures` key returned by this function rather than accessing
 * feature text directly.
 * @private
 */
function resolveText(features, layoutProperties, codepoints) {
    var textFeatures = [];

    for (var i = 0, fl = features.length; i < fl; i++) {
        var text = resolveTokens(features[i].properties, layoutProperties['text-field']);
        if (!text) {
            textFeatures[i] = null;
            continue;
        }
        text = text.toString();

        var transform = layoutProperties['text-transform'];
        if (transform === 'uppercase') {
            text = text.toLocaleUpperCase();
        } else if (transform === 'lowercase') {
            text = text.toLocaleLowerCase();
        }

        for (var j = 0; j < text.length; j++) {
            codepoints[text.charCodeAt(j)] = true;
        }

        // Track indexes of features with text.
        textFeatures[i] = text;
    }

    return textFeatures;
}

},{"../util/token":93}],64:[function(require,module,exports){
'use strict';

module.exports = {
    shapeText: shapeText,
    shapeIcon: shapeIcon
};


// The position of a glyph relative to the text's anchor point.
function PositionedGlyph(codePoint, x, y, glyph) {
    this.codePoint = codePoint;
    this.x = x;
    this.y = y;
    this.glyph = glyph;
}

// A collection of positioned glyphs and some metadata
function Shaping(positionedGlyphs, text, top, bottom, left, right) {
    this.positionedGlyphs = positionedGlyphs;
    this.text = text;
    this.top = top;
    this.bottom = bottom;
    this.left = left;
    this.right = right;
}

function shapeText(text, glyphs, maxWidth, lineHeight, horizontalAlign, verticalAlign, justify, spacing, translate) {

    var positionedGlyphs = [];
    var shaping = new Shaping(positionedGlyphs, text, translate[1], translate[1], translate[0], translate[0]);

    // the y offset *should* be part of the font metadata
    var yOffset = -17;

    var x = 0;
    var y = yOffset;

    for (var i = 0; i < text.length; i++) {
        var codePoint = text.charCodeAt(i);
        var glyph = glyphs[codePoint];

        if (!glyph) continue;

        positionedGlyphs.push(new PositionedGlyph(codePoint, x, y, glyph));
        x += glyph.advance + spacing;
    }

    if (!positionedGlyphs.length) return false;

    linewrap(shaping, glyphs, lineHeight, maxWidth, horizontalAlign, verticalAlign, justify, translate);

    return shaping;
}

var invisible = {
    0x20:   true, // space
    0x200b: true  // zero-width space
};

var breakable = {
    0x20:   true, // space
    0x26:   true, // ampersand
    0x2b:   true, // plus sign
    0x2d:   true, // hyphen-minus
    0x2f:   true, // solidus
    0xad:   true, // soft hyphen
    0xb7:   true, // middle dot
    0x200b: true, // zero-width space
    0x2010: true, // hyphen
    0x2013: true  // en dash
};

function linewrap(shaping, glyphs, lineHeight, maxWidth, horizontalAlign, verticalAlign, justify, translate) {
    var lastSafeBreak = null;

    var lengthBeforeCurrentLine = 0;
    var lineStartIndex = 0;
    var line = 0;

    var maxLineLength = 0;

    var positionedGlyphs = shaping.positionedGlyphs;

    if (maxWidth) {
        for (var i = 0; i < positionedGlyphs.length; i++) {
            var positionedGlyph = positionedGlyphs[i];

            positionedGlyph.x -= lengthBeforeCurrentLine;
            positionedGlyph.y += lineHeight * line;

            if (positionedGlyph.x > maxWidth && lastSafeBreak !== null) {

                var lineLength = positionedGlyphs[lastSafeBreak + 1].x;
                maxLineLength = Math.max(lineLength, maxLineLength);

                for (var k = lastSafeBreak + 1; k <= i; k++) {
                    positionedGlyphs[k].y += lineHeight;
                    positionedGlyphs[k].x -= lineLength;
                }

                if (justify) {
                    // Collapse invisible characters.
                    var lineEnd = lastSafeBreak;
                    if (invisible[positionedGlyphs[lastSafeBreak].codePoint]) {
                        lineEnd--;
                    }

                    justifyLine(positionedGlyphs, glyphs, lineStartIndex, lineEnd, justify);
                }

                lineStartIndex = lastSafeBreak + 1;
                lastSafeBreak = null;
                lengthBeforeCurrentLine += lineLength;
                line++;
            }

            if (breakable[positionedGlyph.codePoint]) {
                lastSafeBreak = i;
            }
        }
    }

    var lastPositionedGlyph = positionedGlyphs[positionedGlyphs.length - 1];
    var lastLineLength = lastPositionedGlyph.x + glyphs[lastPositionedGlyph.codePoint].advance;
    maxLineLength = Math.max(maxLineLength, lastLineLength);

    var height = (line + 1) * lineHeight;

    justifyLine(positionedGlyphs, glyphs, lineStartIndex, positionedGlyphs.length - 1, justify);
    align(positionedGlyphs, justify, horizontalAlign, verticalAlign, maxLineLength, lineHeight, line, translate);

    // Calculate the bounding box
    shaping.top += -verticalAlign * height;
    shaping.bottom = shaping.top + height;
    shaping.left += -horizontalAlign * maxLineLength;
    shaping.right = shaping.left + maxLineLength;
}

function justifyLine(positionedGlyphs, glyphs, start, end, justify) {
    var lastAdvance = glyphs[positionedGlyphs[end].codePoint].advance;
    var lineIndent = (positionedGlyphs[end].x + lastAdvance) * justify;

    for (var j = start; j <= end; j++) {
        positionedGlyphs[j].x -= lineIndent;
    }

}

function align(positionedGlyphs, justify, horizontalAlign, verticalAlign, maxLineLength, lineHeight, line, translate) {
    var shiftX = (justify - horizontalAlign) * maxLineLength + translate[0];
    var shiftY = (-verticalAlign * (line + 1) + 0.5) * lineHeight + translate[1];

    for (var j = 0; j < positionedGlyphs.length; j++) {
        positionedGlyphs[j].x += shiftX;
        positionedGlyphs[j].y += shiftY;
    }
}


function shapeIcon(image, layout) {
    if (!image || !image.rect) return null;

    var dx = layout['icon-offset'][0];
    var dy = layout['icon-offset'][1];
    var x1 = dx - image.width / 2;
    var x2 = x1 + image.width;
    var y1 = dy - image.height / 2;
    var y2 = y1 + image.height;

    return new PositionedIcon(image, y1, y2, x1, x2);
}

function PositionedIcon(image, top, bottom, left, right) {
    this.image = image;
    this.top = top;
    this.bottom = bottom;
    this.left = left;
    this.right = right;
}

},{}],65:[function(require,module,exports){
'use strict';

var BinPack = require('./bin_pack');
var browser = require('../util/browser');

module.exports = SpriteAtlas;
function SpriteAtlas(width, height) {
    this.width = width;
    this.height = height;

    this.bin = new BinPack(width, height);
    this.images = {};
    this.data = false;
    this.texture = 0; // WebGL ID
    this.filter = 0; // WebGL ID
    this.pixelRatio = 1;
    this.dirty = true;
}

SpriteAtlas.prototype = {
    get debug() {
        return 'canvas' in this;
    },
    set debug(value) {
        if (value && !this.canvas) {
            this.canvas = document.createElement('canvas');
            this.canvas.width = this.width * this.pixelRatio;
            this.canvas.height = this.height * this.pixelRatio;
            this.canvas.style.width = this.width + 'px';
            this.canvas.style.width = this.width + 'px';
            document.body.appendChild(this.canvas);
            this.ctx = this.canvas.getContext('2d');
        } else if (!value && this.canvas) {
            this.canvas.parentNode.removeChild(this.canvas);
            delete this.ctx;
            delete this.canvas;
        }
    }
};

function copyBitmap(src, srcStride, srcX, srcY, dst, dstStride, dstX, dstY, width, height, wrap) {
    var srcI = srcY * srcStride + srcX;
    var dstI = dstY * dstStride + dstX;
    var x, y;

    if (wrap) {
        // add 1 pixel wrapped padding on each side of the image
        dstI -= dstStride;
        for (y = -1; y <= height; y++, srcI = ((y + height) % height + srcY) * srcStride + srcX, dstI += dstStride) {
            for (x = -1; x <= width; x++) {
                dst[dstI + x] = src[srcI + ((x + width) % width)];
            }
        }

    } else {
        for (y = 0; y < height; y++, srcI += srcStride, dstI += dstStride) {
            for (x = 0; x < width; x++) {
                dst[dstI + x] = src[srcI + x];
            }
        }
    }
}

SpriteAtlas.prototype.allocateImage = function(pixelWidth, pixelHeight) {

    pixelWidth = pixelWidth / this.pixelRatio;
    pixelHeight = pixelHeight / this.pixelRatio;

    // Increase to next number divisible by 4, but at least 1.
    // This is so we can scale down the texture coordinates and pack them
    // into 2 bytes rather than 4 bytes.
    // Pad icons to prevent them from polluting neighbours during linear interpolation
    var padding = 2;
    var packWidth = pixelWidth + padding + (4 - (pixelWidth + padding) % 4);
    var packHeight = pixelHeight + padding + (4 - (pixelHeight + padding) % 4);// + 4;

    // We have to allocate a new area in the bin, and store an empty image in it.
    // Add a 1px border around every image.
    var rect = this.bin.allocate(packWidth, packHeight);
    if (rect.x < 0) {
        console.warn('SpriteAtlas out of space.');
        return rect;
    }

    return rect;
};

SpriteAtlas.prototype.getImage = function(name, wrap) {
    if (this.images[name]) {
        return this.images[name];
    }

    if (!this.sprite) {
        return null;
    }

    var pos = this.sprite.getSpritePosition(name);
    if (!pos.width || !pos.height) {
        return null;
    }

    var rect = this.allocateImage(pos.width, pos.height);
    if (rect.x < 0) {
        return rect;
    }

    var image = new AtlasImage(rect, pos.width / pos.pixelRatio, pos.height / pos.pixelRatio, pos.sdf, pos.pixelRatio / this.pixelRatio);
    this.images[name] = image;

    this.copy(rect, pos, wrap);

    return image;
};


// Return position of a repeating fill pattern.
SpriteAtlas.prototype.getPosition = function(name, repeating) {
    var image = this.getImage(name, repeating);
    var rect = image && image.rect;

    if (!rect) {
        return null;
    }

    var width = image.width * image.pixelRatio;
    var height = image.height * image.pixelRatio;
    var padding = 1;

    return {
        size: [image.width, image.height],
        tl: [(rect.x + padding)         / this.width, (rect.y + padding)          / this.height],
        br: [(rect.x + padding + width) / this.width, (rect.y + padding + height) / this.height]
    };
};


SpriteAtlas.prototype.allocate = function() {
    if (!this.data) {
        var w = Math.floor(this.width * this.pixelRatio);
        var h = Math.floor(this.height * this.pixelRatio);
        this.data = new Uint32Array(w * h);
        for (var i = 0; i < this.data.length; i++) {
            this.data[i] = 0;
        }
    }
};


SpriteAtlas.prototype.copy = function(dst, src, wrap) {
    if (!this.sprite.img.data) return;
    var srcImg = new Uint32Array(this.sprite.img.data.buffer);

    this.allocate();
    var dstImg = this.data;

    var padding = 1;

    copyBitmap(
        /* source buffer */  srcImg,
        /* source stride */  this.sprite.img.width,
        /* source x */       src.x,
        /* source y */       src.y,
        /* dest buffer */    dstImg,
        /* dest stride */    this.width * this.pixelRatio,
        /* dest x */         (dst.x + padding) * this.pixelRatio,
        /* dest y */         (dst.y + padding) * this.pixelRatio,
        /* icon dimension */ src.width,
        /* icon dimension */ src.height,
        /* wrap */ wrap
    );

    this.dirty = true;
};

SpriteAtlas.prototype.setSprite = function(sprite) {
    if (sprite) {
        this.pixelRatio = browser.devicePixelRatio > 1 ? 2 : 1;

        if (this.canvas) {
            this.canvas.width = this.width * this.pixelRatio;
            this.canvas.height = this.height * this.pixelRatio;
        }
    }
    this.sprite = sprite;
};

SpriteAtlas.prototype.addIcons = function(icons, callback) {
    for (var i = 0; i < icons.length; i++) {
        this.getImage(icons[i]);
    }

    callback(null, this.images);
};

SpriteAtlas.prototype.bind = function(gl, linear) {
    var first = false;
    if (!this.texture) {
        this.texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        first = true;
    } else {
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
    }

    var filterVal = linear ? gl.LINEAR : gl.NEAREST;
    if (filterVal !== this.filter) {
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filterVal);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filterVal);
        this.filter = filterVal;
    }

    if (this.dirty) {
        this.allocate();

        if (first) {
            gl.texImage2D(
                gl.TEXTURE_2D, // enum target
                0, // ind level
                gl.RGBA, // ind internalformat
                this.width * this.pixelRatio, // GLsizei width
                this.height * this.pixelRatio, // GLsizei height
                0, // ind border
                gl.RGBA, // enum format
                gl.UNSIGNED_BYTE, // enum type
                new Uint8Array(this.data.buffer) // Object data
            );
        } else {
            gl.texSubImage2D(
                gl.TEXTURE_2D, // enum target
                0, // int level
                0, // int xoffset
                0, // int yoffset
                this.width * this.pixelRatio, // long width
                this.height * this.pixelRatio, // long height
                gl.RGBA, // enum format
                gl.UNSIGNED_BYTE, // enum type
                new Uint8Array(this.data.buffer) // Object pixels
            );
        }

        this.dirty = false;

        // DEBUG
        if (this.ctx) {
            var data = this.ctx.getImageData(0, 0, this.width * this.pixelRatio, this.height * this.pixelRatio);
            data.data.set(new Uint8ClampedArray(this.data.buffer));
            this.ctx.putImageData(data, 0, 0);

            this.ctx.strokeStyle = 'red';
            for (var k = 0; k < this.bin.free.length; k++) {
                var free = this.bin.free[k];
                this.ctx.strokeRect(free.x * this.pixelRatio, free.y * this.pixelRatio, free.w * this.pixelRatio, free.h * this.pixelRatio);
            }
        }
        // END DEBUG
    }
};

function AtlasImage(rect, width, height, sdf, pixelRatio) {
    this.rect = rect;
    this.width = width;
    this.height = height;
    this.sdf = sdf;
    this.pixelRatio = pixelRatio;
}

},{"../util/browser":83,"./bin_pack":52}],66:[function(require,module,exports){
'use strict';

var util = require('../util/util');
var interpolate = require('../util/interpolate');
var browser = require('../util/browser');
var LngLat = require('../geo/lng_lat');
var LngLatBounds = require('../geo/lng_lat_bounds');
var Point = require('point-geometry');

/**
 * Options common to Map#jumpTo, Map#easeTo, and Map#flyTo, controlling the destination
 * location, zoom level, bearing and pitch. All properties are options; unspecified
 * options will default to the current value for that property.
 *
 * @typedef {Object} CameraOptions
 * @property {LngLat} center Map center
 * @property {number} zoom Map zoom level
 * @property {number} bearing Map rotation bearing in degrees counter-clockwise from north
 * @property {number} pitch Map angle in degrees at which the camera is looking at the ground
 * @property {LngLat} around If zooming, the zoom center (defaults to map center)
 */

/**
 * Options common to map movement methods that involve animation, such as Map#panBy and
 * Map#easeTo, controlling the duration of the animation and easing function. All properties
 * are optional.
 *
 * @typedef {Object} AnimationOptions
 * @property {number} duration Number in milliseconds
 * @property {Function} easing
 * @property {Array} offset point, origin of movement relative to map center
 * @property {boolean} animate When set to false, no animation happens
 */

var Camera = module.exports = function() {};

util.extend(Camera.prototype, /** @lends Map.prototype */{
    /**
     * Get the current view geographical point.
     * @returns {LngLat}
     */
    getCenter: function() { return this.transform.center; },

    /**
     * Sets a map location. Equivalent to `jumpTo({center: center})`.
     *
     * @param {LngLat} center Map center to jump to
     * @fires movestart
     * @fires moveend
     * @returns {Map} `this`
     * @example
     * map.setCenter([-74, 38]);
     */
    setCenter: function(center) {
        this.jumpTo({center: center});
        return this;
    },

    /**
     * Pan by a certain number of pixels
     *
     * @param {Array<number>} offset [x, y]
     * @param {AnimationOptions} [options]
     * @fires movestart
     * @fires moveend
     * @returns {Map} `this`
     */
    panBy: function(offset, options) {
        this.panTo(this.transform.center, util.extend({offset: Point.convert(offset).mult(-1)}, options));
        return this;
    },

    /**
     * Pan to a certain location with easing
     *
     * @param {LngLat} lnglat Location to pan to
     * @param {AnimationOptions} [options]
     * @fires movestart
     * @fires moveend
     * @returns {Map} `this`
     */
    panTo: function(lnglat, options) {
        this.stop();

        lnglat = LngLat.convert(lnglat);

        options = util.extend({
            duration: 500,
            easing: util.ease,
            offset: [0, 0]
        }, options);

        var tr = this.transform,
            offset = Point.convert(options.offset).rotate(-tr.angle),
            from = tr.point,
            to = tr.project(lnglat).sub(offset);

        if (!options.noMoveStart) {
            this.fire('movestart');
        }

        this._ease(function(k) {
            tr.center = tr.unproject(from.add(to.sub(from).mult(k)));
            this.fire('move');
        }, function() {
            this.fire('moveend');
        }, options);

        return this;
    },


    /**
     * Get the current zoom
     * @returns {number}
     */
    getZoom: function() { return this.transform.zoom; },

    /**
     * Sets a map zoom. Equivalent to `jumpTo({zoom: zoom})`.
     *
     * @param {number} zoom Map zoom level
     * @fires movestart
     * @fires moveend
     * @returns {Map} `this`
     * @example
     * // zoom the map to 5
     * map.setZoom(5);
     */
    setZoom: function(zoom) {
        this.jumpTo({zoom: zoom});
        return this;
    },

    /**
     * Zooms to a certain zoom level with easing.
     *
     * @param {number} zoom
     * @param {AnimationOptions} [options]
     * @fires movestart
     * @fires moveend
     * @returns {Map} `this`
     */
    zoomTo: function(zoom, options) {
        this.stop();

        options = util.extend({
            duration: 500
        }, options);

        options.easing = this._updateEasing(options.duration, zoom, options.easing);

        var tr = this.transform,
            around = tr.center,
            startZoom = tr.zoom;

        if (options.around) {
            around = LngLat.convert(options.around);
        } else if (options.offset) {
            around = tr.pointLocation(tr.centerPoint.add(Point.convert(options.offset)));
        }

        if (options.animate === false) options.duration = 0;

        if (!this.zooming) {
            this.zooming = true;
            this.fire('movestart');
        }

        this._ease(function(k) {
            tr.setZoomAround(interpolate(startZoom, zoom, k), around);
            this.fire('move').fire('zoom');
        }, function() {
            this.ease = null;
            if (options.duration >= 200) {
                this.zooming = false;
                this.fire('moveend');
            }
        }, options);

        if (options.duration < 200) {
            clearTimeout(this._onZoomEnd);
            this._onZoomEnd = setTimeout(function() {
                this.zooming = false;
                this.fire('moveend');
            }.bind(this), 200);
        }

        return this;
    },

    /**
     * Zoom in by 1 level
     *
     * @param {AnimationOptions} [options]
     * @fires movestart
     * @fires moveend
     * @returns {Map} `this`
     */
    zoomIn: function(options) {
        this.zoomTo(this.getZoom() + 1, options);
        return this;
    },

    /**
     * Zoom out by 1 level
     *
     * @param {AnimationOptions} [options]
     * @fires movestart
     * @fires moveend
     * @returns {Map} `this`
     */
    zoomOut: function(options) {
        this.zoomTo(this.getZoom() - 1, options);
        return this;
    },


    /**
     * Get the current bearing in degrees
     * @returns {number}
     */
    getBearing: function() { return this.transform.bearing; },

    /**
     * Sets a map rotation. Equivalent to `jumpTo({bearing: bearing})`.
     *
     * @param {number} bearing Map rotation bearing in degrees counter-clockwise from north
     * @fires movestart
     * @fires moveend
     * @returns {Map} `this`
     * @example
     * // rotate the map to 90 degrees
     * map.setBearing(90);
     */
    setBearing: function(bearing) {
        this.jumpTo({bearing: bearing});
        return this;
    },

    /**
     * Rotate bearing by a certain number of degrees with easing
     *
     * @param {number} bearing
     * @param {AnimationOptions} [options]
     * @fires movestart
     * @fires moveend
     * @returns {Map} `this`
     */
    rotateTo: function(bearing, options) {
        this.stop();

        options = util.extend({
            duration: 500,
            easing: util.ease
        }, options);

        var tr = this.transform,
            start = this.getBearing(),
            around = tr.center;

        if (options.around) {
            around = LngLat.convert(options.around);
        } else if (options.offset) {
            around = tr.pointLocation(tr.centerPoint.add(Point.convert(options.offset)));
        }

        bearing = this._normalizeBearing(bearing, start);

        this.rotating = true;
        if (!options.noMoveStart) {
            this.fire('movestart');
        }

        this._ease(function(k) {
            tr.setBearingAround(interpolate(start, bearing, k), around);
            this.fire('move').fire('rotate');
        }, function() {
            this.rotating = false;
            this.fire('moveend');
        }, options);

        return this;
    },

    /**
     * Sets map bearing to 0 (north) with easing
     *
     * @param {AnimationOptions} [options]
     * @fires movestart
     * @fires moveend
     * @returns {Map} `this`
     */
    resetNorth: function(options) {
        this.rotateTo(0, util.extend({duration: 1000}, options));
        return this;
    },

    /**
     * Animates map bearing to 0 (north) if it's already close to it.
     *
     * @param {AnimationOptions} [options]
     * @fires movestart
     * @fires moveend
     * @returns {Map} `this`
     */
    snapToNorth: function(options) {
        if (Math.abs(this.getBearing()) < this.options.bearingSnap) {
            return this.resetNorth(options);
        }
        return this;
    },

    /**
     * Get the current angle in degrees
     * @returns {number}
     */
    getPitch: function() { return this.transform.pitch; },

    /**
     * Sets a map angle. Equivalent to `jumpTo({pitch: pitch})`.
     *
     * @param {number} pitch The angle at which the camera is looking at the ground
     * @fires movestart
     * @fires moveend
     * @returns {Map} `this`
     */
    setPitch: function(pitch) {
        this.jumpTo({pitch: pitch});
        return this;
    },


    /**
     * Zoom to contain certain geographical bounds
     *
     * @param {LngLatBounds|Array<Array<number>>} bounds [[minLng, minLat], [maxLng, maxLat]]
     * @param {Object} options
     * @param {boolean} [options.linear] When true, the map transitions to the new camera using
     *     {@link #Map.easeTo}. When false, the map transitions using {@link #Map.flyTo}. See
     *     {@link #Map.flyTo} for information on options specific to that animation transition.
     * @param {Function} options.easing
     * @param {number} options.padding how much padding there is around the given bounds on each side in pixels
     * @param {number} options.maxZoom The resulting zoom level will be at most
     *     this value.
     * @fires movestart
     * @fires moveend
     * @returns {Map} `this`
     */
    fitBounds: function(bounds, options) {

        options = util.extend({
            padding: 0,
            offset: [0, 0],
            maxZoom: Infinity
        }, options);

        bounds = LngLatBounds.convert(bounds);

        var offset = Point.convert(options.offset),
            tr = this.transform,
            nw = tr.project(bounds.getNorthWest()),
            se = tr.project(bounds.getSouthEast()),
            size = se.sub(nw),
            scaleX = (tr.width - options.padding * 2 - Math.abs(offset.x) * 2) / size.x,
            scaleY = (tr.height - options.padding * 2 - Math.abs(offset.y) * 2) / size.y;

        options.center = tr.unproject(nw.add(se).div(2));
        options.zoom = Math.min(tr.scaleZoom(tr.scale * Math.min(scaleX, scaleY)), options.maxZoom);
        options.bearing = 0;

        return options.linear ?
            this.easeTo(options) :
            this.flyTo(options);
    },

    /**
     * Change any combination of center, zoom, bearing, and pitch, without
     * a transition. The map will retain the current values for any options
     * not included in `options`.
     *
     * @param {CameraOptions} options map view options
     * @fires movestart
     * @fires moveend
     * @returns {Map} `this`
     */
    jumpTo: function(options) {
        this.stop();

        var tr = this.transform,
            zoomChanged = false,
            bearingChanged = false,
            pitchChanged = false;

        if ('zoom' in options && tr.zoom !== +options.zoom) {
            zoomChanged = true;
            tr.zoom = +options.zoom;
        }

        if ('center' in options) {
            tr.center = LngLat.convert(options.center);
        }

        if ('bearing' in options && tr.bearing !== +options.bearing) {
            bearingChanged = true;
            tr.bearing = +options.bearing;
        }

        if ('pitch' in options && tr.pitch !== +options.pitch) {
            pitchChanged = true;
            tr.pitch = +options.pitch;
        }

        this.fire('movestart')
            .fire('move');

        if (zoomChanged) {
            this.fire('zoom');
        }

        if (bearingChanged) {
            this.fire('rotate');
        }

        if (pitchChanged) {
            this.fire('pitch');
        }

        return this.fire('moveend');
    },

    /**
     * Change any combination of center, zoom, bearing, and pitch, with a smooth animation
     * between old and new values. The map will retain the current values for any options
     * not included in `options`.
     *
     * @param {CameraOptions|AnimationOptions} options map view and animation options
     * @fires movestart
     * @fires moveend
     * @returns {Map} `this`
     */
    easeTo: function(options) {
        this.stop();

        options = util.extend({
            offset: [0, 0],
            duration: 500,
            easing: util.ease
        }, options);

        var tr = this.transform,
            offset = Point.convert(options.offset).rotate(-tr.angle),
            from = tr.point,
            startWorldSize = tr.worldSize,
            startZoom = this.getZoom(),
            startBearing = this.getBearing(),
            startPitch = this.getPitch(),

            zoom = 'zoom' in options ? +options.zoom : startZoom,
            bearing = 'bearing' in options ? this._normalizeBearing(options.bearing, startBearing) : startBearing,
            pitch = 'pitch' in options ? +options.pitch : startPitch,

            scale = tr.zoomScale(zoom - startZoom),
            to = 'center' in options ? tr.project(LngLat.convert(options.center)).sub(offset.div(scale)) : from,
            around = 'center' in options ? null : LngLat.convert(options.around);

        if (zoom !== startZoom) {
            this.zooming = true;
        }
        if (startBearing !== bearing) {
            this.rotating = true;
        }

        if (pitch !== startPitch) {
            this.pitching = true;
        }

        if (this.zooming && !around) {
            around = tr.pointLocation(tr.centerPoint.add(to.sub(from).div(1 - 1 / scale)));
        }

        this.fire('movestart');

        this._ease(function (k) {
            if (this.zooming && around) {
                tr.setZoomAround(interpolate(startZoom, zoom, k), around);
            } else {
                if (this.zooming) tr.zoom = interpolate(startZoom, zoom, k);
                tr.center = tr.unproject(from.add(to.sub(from).mult(k)), startWorldSize);
            }

            if (this.rotating) {
                tr.bearing = interpolate(startBearing, bearing, k);
            }

            if (this.pitching) {
                tr.pitch = interpolate(startPitch, pitch, k);
            }

            this.fire('move');
            if (this.zooming) {
                this.fire('zoom');
            }
            if (this.rotating) {
                this.fire('rotate');
            }
            if (this.pitching) {
                this.fire('pitch');
            }
        }, function() {
            this.zooming = false;
            this.rotating = false;
            this.pitching = false;
            this.fire('moveend');
        }, options);

        return this;
    },

    /**
     * Change any combination of center, zoom, bearing, and pitch, animated along a curve that
     * evokes flight. The transition animation seamlessly incorporates zooming and panning to help
     * the user find his or her bearings even after traversing a great distance.
     *
     * @param {CameraOptions|AnimationOptions} options map view and animation options
     * @param {number} [options.curve=1.42] Relative amount of zooming that takes place along the
     *     flight path. A high value maximizes zooming for an exaggerated animation, while a low
     *     value minimizes zooming for something closer to {@link #Map.easeTo}. 1.42 is the average
     *     value selected by participants in the user study in
     *     [van Wijk (2003)](https://www.win.tue.nl/~vanwijk/zoompan.pdf). A value of
     *     `Math.pow(6, 0.25)` would be equivalent to the root mean squared average velocity. A
     *     value of 1 would produce a circular motion.
     * @param {number} [options.minZoom] Zero-based zoom level at the peak of the flight path. If
     *     `options.curve` is specified, this option is ignored.
     * @param {number} [options.speed=1.2] Average speed of the animation. A speed of 1.2 means that
     *     the map appears to move along the flight path by 1.2 times `options.curve` screenfuls every
     *     second. A _screenful_ is the visible span in pixels. It does not correspond to a fixed
     *     physical distance but rather varies by zoom level.
     * @param {number} [options.screenSpeed] Average speed of the animation, measured in screenfuls
     *     per second, assuming a linear timing curve. If `options.speed` is specified, this option
     *     is ignored.
     * @param {Function} [options.easing] Transition timing curve
     * @fires movestart
     * @fires moveend
     * @returns {this}
     * @example
     * // fly with default options to null island
     * map.flyTo({center: [0, 0], zoom: 9});
     * // using flyTo options
     * map.flyTo({
     *   center: [0, 0],
     *   zoom: 9,
     *   speed: 0.2,
     *   curve: 1,
     *   easing: function(t) {
     *     return t;
     *   }
     * });
     */
    flyTo: function(options) {
        // This method implements an “optimal path” animation, as detailed in:
        //
        // Van Wijk, Jarke J.; Nuij, Wim A. A. “Smooth and efficient zooming and panning.” INFOVIS
        //   ’03. pp. 15–22. <https://www.win.tue.nl/~vanwijk/zoompan.pdf#page=5>.
        //
        // Where applicable, local variable documentation begins with the associated variable or
        // function in van Wijk (2003).

        this.stop();

        options = util.extend({
            offset: [0, 0],
            speed: 1.2,
            curve: 1.42,
            easing: util.ease
        }, options);

        var tr = this.transform,
            offset = Point.convert(options.offset),
            startZoom = this.getZoom(),
            startBearing = this.getBearing(),
            startPitch = this.getPitch();

        var center = 'center' in options ? LngLat.convert(options.center) : this.getCenter();
        var zoom = 'zoom' in options ?  +options.zoom : startZoom;
        var bearing = 'bearing' in options ? this._normalizeBearing(options.bearing, startBearing) : startBearing;
        var pitch = 'pitch' in options ? +options.pitch : startPitch;

        // If a path crossing the antimeridian would be shorter, extend the final coordinate so that
        // interpolating between the two endpoints will cross it.
        if (Math.abs(tr.center.lng) + Math.abs(center.lng) > 180) {
            if (tr.center.lng > 0 && center.lng < 0) {
                center.lng += 360;
            } else if (tr.center.lng < 0 && center.lng > 0) {
                center.lng -= 360;
            }
        }

        var scale = tr.zoomScale(zoom - startZoom),
            from = tr.point,
            to = 'center' in options ? tr.project(center).sub(offset.div(scale)) : from;

        var startWorldSize = tr.worldSize,
            rho = options.curve,

            // w₀: Initial visible span, measured in pixels at the initial scale.
            w0 = Math.max(tr.width, tr.height),
            // w₁: Final visible span, measured in pixels with respect to the initial scale.
            w1 = w0 / scale,
            // Length of the flight path as projected onto the ground plane, measured in pixels from
            // the world image origin at the initial scale.
            u1 = to.sub(from).mag();

        if ('minZoom' in options) {
            var minZoom = util.clamp(Math.min(options.minZoom, startZoom, zoom), tr.minZoom, tr.maxZoom);
            // w<sub>m</sub>: Maximum visible span, measured in pixels with respect to the initial
            // scale.
            var wMax = w0 / tr.zoomScale(minZoom - startZoom);
            rho = Math.sqrt(wMax / u1 * 2);
        }

        // ρ²
        var rho2 = rho * rho;

        /**
         * rᵢ: Returns the zoom-out factor at one end of the animation.
         *
         * @param i 0 for the ascent or 1 for the descent.
         */
        function r(i) {
            var b = (w1 * w1 - w0 * w0 + (i ? -1 : 1) * rho2 * rho2 * u1 * u1) / (2 * (i ? w1 : w0) * rho2 * u1);
            return Math.log(Math.sqrt(b * b + 1) - b);
        }

        function sinh(n) { return (Math.exp(n) - Math.exp(-n)) / 2; }
        function cosh(n) { return (Math.exp(n) + Math.exp(-n)) / 2; }
        function tanh(n) { return sinh(n) / cosh(n); }

        // r₀: Zoom-out factor during ascent.
        var r0 = r(0),
            /**
             * w(s): Returns the visible span on the ground, measured in pixels with respect to the
             * initial scale.
             *
             * Assumes an angular field of view of 2 arctan ½ ≈ 53°.
             */
            w = function (s) { return (cosh(r0) / cosh(r0 + rho * s)); },
            /**
             * u(s): Returns the distance along the flight path as projected onto the ground plane,
             * measured in pixels from the world image origin at the initial scale.
             */
            u = function (s) { return w0 * ((cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2) / u1; },
            // S: Total length of the flight path, measured in ρ-screenfuls.
            S = (r(1) - r0) / rho;

        // When u₀ = u₁, the optimal path doesn’t require both ascent and descent.
        if (Math.abs(u1) < 0.000001) {
            // Perform a more or less instantaneous transition if the path is too short.
            if (Math.abs(w0 - w1) < 0.000001) return this.easeTo(options);

            var k = w1 < w0 ? -1 : 1;
            S = Math.abs(Math.log(w1 / w0)) / rho;

            u = function() { return 0; };
            w = function(s) { return Math.exp(k * rho * s); };
        }

        if ('duration' in options) {
            options.duration = +options.duration;
        } else {
            var V = 'screenSpeed' in options ? +options.screenSpeed / rho : +options.speed;
            options.duration = 1000 * S / V;
        }

        this.zooming = true;
        if (startBearing !== bearing) this.rotating = true;
        if (startPitch !== pitch) this.pitching = true;

        this.fire('movestart');

        this._ease(function (k) {
            // s: The distance traveled along the flight path, measured in ρ-screenfuls.
            var s = k * S,
                us = u(s);

            tr.zoom = startZoom + tr.scaleZoom(1 / w(s));
            tr.center = tr.unproject(from.add(to.sub(from).mult(us)), startWorldSize);

            if (this.rotating) {
                tr.bearing = interpolate(startBearing, bearing, k);
            }
            if (this.pitching) {
                tr.pitch = interpolate(startPitch, pitch, k);
            }

            this.fire('move').fire('zoom');
            if (this.rotating) {
                this.fire('rotate');
            }
            if (this.pitching) {
                this.fire('pitch');
            }
        }, function() {
            this.zooming = false;
            this.rotating = false;
            this.pitching = false;
            this.fire('moveend');
        }, options);

        return this;
    },

    isEasing: function() {
        return !!this._abortFn;
    },

    /**
     * Stop current animation
     *
     * @returns {Map} `this`
     */
    stop: function() {
        if (this._abortFn) {
            this._abortFn();
            this._finishEase();
        }
        return this;
    },

    _ease: function(frame, finish, options) {
        this._finishFn = finish;
        this._abortFn = browser.timed(function (t) {
            frame.call(this, options.easing(t));
            if (t === 1) {
                this._finishEase();
            }
        }, options.animate === false ? 0 : options.duration, this);
    },

    _finishEase: function() {
        delete this._abortFn;
        // The finish function might emit events which trigger new eases, which
        // set a new _finishFn. Ensure we don't delete it unintentionally.
        var finish = this._finishFn;
        delete this._finishFn;
        finish.call(this);
    },

    // convert bearing so that it's numerically close to the current one so that it interpolates properly
    _normalizeBearing: function(bearing, currentBearing) {
        bearing = util.wrap(bearing, -180, 180);
        var diff = Math.abs(bearing - currentBearing);
        if (Math.abs(bearing - 360 - currentBearing) < diff) bearing -= 360;
        if (Math.abs(bearing + 360 - currentBearing) < diff) bearing += 360;
        return bearing;
    },

    _updateEasing: function(duration, zoom, bezier) {
        var easing;

        if (this.ease) {
            var ease = this.ease,
                t = (Date.now() - ease.start) / ease.duration,
                speed = ease.easing(t + 0.01) - ease.easing(t),

                // Quick hack to make new bezier that is continuous with last
                x = 0.27 / Math.sqrt(speed * speed + 0.0001) * 0.01,
                y = Math.sqrt(0.27 * 0.27 - x * x);

            easing = util.bezier(x, y, 0.25, 1);
        } else {
            easing = bezier ? util.bezier.apply(util, bezier) : util.ease;
        }

        // store information on current easing
        this.ease = {
            start: (new Date()).getTime(),
            to: Math.pow(2, zoom),
            duration: duration,
            easing: easing
        };

        return easing;
    }
});

},{"../geo/lng_lat":10,"../geo/lng_lat_bounds":11,"../util/browser":83,"../util/interpolate":90,"../util/util":94,"point-geometry":130}],67:[function(require,module,exports){
'use strict';

var Control = require('./control');
var DOM = require('../../util/dom');
var util = require('../../util/util');

module.exports = Attribution;

/**
 * Creates an attribution control
 * @class Attribution
 * @param {Object} [options]
 * @param {string} [options.position='bottom-right'] A string indicating the control's position on the map. Options are `top-right`, `top-left`, `bottom-right`, `bottom-left`
 * @example
 * var map = new mapboxgl.Map({attributionContro: false})
 *     .addControl(new mapboxgl.Navigation({position: 'top-left'}));
 */
function Attribution(options) {
    util.setOptions(this, options);
}

Attribution.prototype = util.inherit(Control, {
    options: {
        position: 'bottom-right'
    },

    onAdd: function(map) {
        var className = 'mapboxgl-ctrl-attrib',
            container = this._container = DOM.create('div', className, map.getContainer());

        this._update();
        map.on('source.load', this._update.bind(this));
        map.on('source.change', this._update.bind(this));
        map.on('source.remove', this._update.bind(this));
        map.on('moveend', this._updateEditLink.bind(this));

        return container;
    },

    _update: function() {
        var attributions = [];

        if (this._map.style) {
            for (var id in this._map.style.sources) {
                var source = this._map.style.sources[id];
                if (source.attribution && attributions.indexOf(source.attribution) < 0) {
                    attributions.push(source.attribution);
                }
            }
        }

        this._container.innerHTML = attributions.join(' | ');
        this._editLink = this._container.getElementsByClassName('mapbox-improve-map')[0];
        this._updateEditLink();
    },

    _updateEditLink: function() {
        if (this._editLink) {
            var center = this._map.getCenter();
            this._editLink.href = 'https://www.mapbox.com/map-feedback/#/' +
                    center.lng + '/' + center.lat + '/' + Math.round(this._map.getZoom() + 1);
        }
    }
});

},{"../../util/dom":86,"../../util/util":94,"./control":68}],68:[function(require,module,exports){
'use strict';

module.exports = Control;

/**
 * A base class for map-related interface elements.
 *
 * @class Control
 */
function Control() {}

Control.prototype = {
    /**
     * Add this control to the map, returning the control itself
     * for chaining. This will insert the control's DOM element into
     * the map's DOM element if the control has a `position` specified.
     *
     * @param {Map} map
     * @returns {Control} `this`
     */
    addTo: function(map) {
        this._map = map;
        var container = this._container = this.onAdd(map);
        if (this.options && this.options.position) {
            var pos = this.options.position;
            var corner = map._controlCorners[pos];
            container.className += ' mapboxgl-ctrl';
            if (pos.indexOf('bottom') !== -1) {
                corner.insertBefore(container, corner.firstChild);
            } else {
                corner.appendChild(container);
            }
        }

        return this;
    },

    /**
     * Remove this control from the map it has been added to.
     *
     * @returns {Control} `this`
     */
    remove: function() {
        this._container.parentNode.removeChild(this._container);
        if (this.onRemove) this.onRemove(this._map);
        this._map = null;
        return this;
    }
};

},{}],69:[function(require,module,exports){
'use strict';

var Control = require('./control');
var DOM = require('../../util/dom');
var util = require('../../util/util');

module.exports = Navigation;

/**
 * Creates a navigation control with zoom buttons and a compass
 * @class Navigation
 * @param {Object} [options]
 * @param {string} [options.position='top-right'] A string indicating the control's position on the map. Options are `top-right`, `top-left`, `bottom-right`, `bottom-left`
 * @example
 * map.addControl(new mapboxgl.Navigation({position: 'top-left'})); // position is optional
 */
function Navigation(options) {
    util.setOptions(this, options);
}

Navigation.prototype = util.inherit(Control, {
    options: {
        position: 'top-right'
    },

    onAdd: function(map) {
        var className = 'mapboxgl-ctrl';

        var container = this._container = DOM.create('div', className + '-group', map.getContainer());
        this._container.addEventListener('contextmenu', this._onContextMenu.bind(this));

        this._zoomInButton = this._createButton(className + '-icon ' + className + '-zoom-in', map.zoomIn.bind(map));
        this._zoomOutButton = this._createButton(className + '-icon ' + className + '-zoom-out', map.zoomOut.bind(map));
        this._compass = this._createButton(className + '-icon ' + className + '-compass', map.resetNorth.bind(map));

        this._compassArrow = DOM.create('div', 'arrow', this._compass);

        this._compass.addEventListener('mousedown', this._onCompassDown.bind(this));
        this._onCompassMove = this._onCompassMove.bind(this);
        this._onCompassUp = this._onCompassUp.bind(this);

        map.on('rotate', this._rotateCompassArrow.bind(this));
        this._rotateCompassArrow();

        this._el = map.getCanvasContainer();

        return container;
    },

    _onContextMenu: function(e) {
        e.preventDefault();
    },

    _onCompassDown: function(e) {
        if (e.button !== 0) return;

        DOM.disableDrag();
        document.addEventListener('mousemove', this._onCompassMove);
        document.addEventListener('mouseup', this._onCompassUp);

        this._el.dispatchEvent(copyMouseEvent(e));
        e.stopPropagation();
    },

    _onCompassMove: function(e) {
        if (e.button !== 0) return;

        this._el.dispatchEvent(copyMouseEvent(e));
        e.stopPropagation();
    },

    _onCompassUp: function(e) {
        if (e.button !== 0) return;

        document.removeEventListener('mousemove', this._onCompassMove);
        document.removeEventListener('mouseup', this._onCompassUp);
        DOM.enableDrag();

        this._el.dispatchEvent(copyMouseEvent(e));
        e.stopPropagation();
    },

    _createButton: function(className, fn) {
        var a = DOM.create('button', className, this._container);
        a.addEventListener('click', function() { fn(); });
        return a;
    },

    _rotateCompassArrow: function() {
        var rotate = 'rotate(' + (this._map.transform.angle * (180 / Math.PI)) + 'deg)';
        this._compassArrow.style.transform = rotate;
    }
});


function copyMouseEvent(e) {
    return new MouseEvent(e.type, {
        button: 2,    // right click
        buttons: 2,   // right click
        bubbles: true,
        cancelable: true,
        detail: e.detail,
        view: e.view,
        screenX: e.screenX,
        screenY: e.screenY,
        clientX: e.clientX,
        clientY: e.clientY,
        movementX: e.movementX,
        movementY: e.movementY,
        ctrlKey: e.ctrlKey,
        shiftKey: e.shiftKey,
        altKey: e.altKey,
        metaKey: e.metaKey
    });
}


},{"../../util/dom":86,"../../util/util":94,"./control":68}],70:[function(require,module,exports){
'use strict';

var DOM = require('../../util/dom'),
    LngLatBounds = require('../../geo/lng_lat_bounds'),
    util = require('../../util/util');

module.exports = BoxZoom;


function BoxZoom(map) {
    this._map = map;
    this._el = map.getCanvasContainer();
    this._container = map.getContainer();

    util.bindHandlers(this);
}

BoxZoom.prototype = {
    enable: function () {
        this._el.addEventListener('mousedown', this._onMouseDown, false);
    },

    disable: function () {
        this._el.removeEventListener('mousedown', this._onMouseDown);
    },

    _onMouseDown: function (e) {
        if (!(e.shiftKey && e.button === 0)) return;

        document.addEventListener('mousemove', this._onMouseMove, false);
        document.addEventListener('keydown', this._onKeyDown, false);
        document.addEventListener('mouseup', this._onMouseUp, false);

        this._startPos = DOM.mousePos(this._el, e);
        this.active = true;
    },

    _onMouseMove: function (e) {
        var p0 = this._startPos,
            p1 = DOM.mousePos(this._el, e);

        if (!this._box) {
            this._box = DOM.create('div', 'mapboxgl-boxzoom', this._container);
            this._container.classList.add('mapboxgl-crosshair');

            DOM.disableDrag();

            this._fireEvent('boxzoomstart', e);
        }

        var minX = Math.min(p0.x, p1.x),
            maxX = Math.max(p0.x, p1.x),
            minY = Math.min(p0.y, p1.y),
            maxY = Math.max(p0.y, p1.y);

        DOM.setTransform(this._box, 'translate(' + minX + 'px,' + minY + 'px)');

        this._box.style.width = (maxX - minX) + 'px';
        this._box.style.height = (maxY - minY) + 'px';
    },

    _onMouseUp: function (e) {
        if (e.button !== 0) return;

        var p0 = this._startPos,
            p1 = DOM.mousePos(this._el, e),
            bounds = new LngLatBounds(this._map.unproject(p0), this._map.unproject(p1));

        this._finish();

        if (p0.x === p1.x && p0.y === p1.y) {
            this._fireEvent('boxzoomcancel', e);
        } else {
            this._map
                .fitBounds(bounds, {linear: true})
                .fire('boxzoomend', { originalEvent: e, boxZoomBounds: bounds });
        }
    },

    _onKeyDown: function (e) {
        if (e.keyCode === 27) {
            this._finish();
            this._fireEvent('boxzoomcancel', e);
        }
    },

    _finish: function () {
        this.active = false;

        document.removeEventListener('mousemove', this._onMouseMove, false);
        document.removeEventListener('keydown', this._onKeyDown, false);
        document.removeEventListener('mouseup', this._onMouseUp, false);

        this._container.classList.remove('mapboxgl-crosshair');

        if (this._box) {
            this._box.parentNode.removeChild(this._box);
            this._box = null;
        }

        DOM.enableDrag();
    },

    _fireEvent: function (type, e) {
        return this._map.fire(type, { originalEvent: e });
    }
};

/**
 * Boxzoom start event. This event is emitted at the start of a box zoom interaction.
 *
 * @event boxzoomstart
 * @memberof Map
 * @instance
 * @type {Object}
 * @property {Event} originalEvent the original DOM event
 */

/**
 * Boxzoom end event. This event is emitted at the end of a box zoom interaction
 *
 * @event boxzoomend
 * @memberof Map
 * @instance
 * @type {Object}
 * @property {Event} originalEvent the original DOM event
 * @property {LngLatBounds} boxZoomBounds the bounds of the box zoom target
 */

/**
 * Boxzoom cancel event.  This event is emitted when the user cancels a box zoom interaction,
 *   or when the box zoom does not meet the minimum size threshold.
 *
 * @event boxzoomcancel
 * @memberof Map
 * @instance
 * @type {Object}
 * @property {Event} originalEvent the original DOM event
 */

},{"../../geo/lng_lat_bounds":11,"../../util/dom":86,"../../util/util":94}],71:[function(require,module,exports){
'use strict';

module.exports = DoubleClickZoom;

function DoubleClickZoom(map) {
    this._map = map;
    this._onDblClick = this._onDblClick.bind(this);
}

DoubleClickZoom.prototype = {
    enable: function () {
        this._map.on('dblclick', this._onDblClick);
    },

    disable: function () {
        this._map.off('dblclick', this._onDblClick);
    },

    _onDblClick: function (e) {
        this._map.zoomTo(this._map.getZoom() +
            (e.originalEvent.shiftKey ? -1 : 1), {around: e.lngLat});
    }
};

},{}],72:[function(require,module,exports){
'use strict';

var DOM = require('../../util/dom'),
    util = require('../../util/util');

module.exports = DragPan;

var inertiaLinearity = 0.3,
    inertiaEasing = util.bezier(0, 0, inertiaLinearity, 1),
    inertiaMaxSpeed = 1400, // px/s
    inertiaDeceleration = 2500; // px/s^2


function DragPan(map) {
    this._map = map;
    this._el = map.getCanvasContainer();

    util.bindHandlers(this);
}

DragPan.prototype = {
    enable: function () {
        this._el.addEventListener('mousedown', this._onDown);
        this._el.addEventListener('touchstart', this._onDown);
    },

    disable: function () {
        this._el.removeEventListener('mousedown', this._onDown);
        this._el.removeEventListener('touchstart', this._onDown);
    },

    _onDown: function (e) {
        if (this._ignoreEvent(e)) return;
        if (this.active) return;

        if (e.touches) {
            document.addEventListener('touchmove', this._onMove);
            document.addEventListener('touchend', this._onTouchEnd);
        } else {
            document.addEventListener('mousemove', this._onMove);
            document.addEventListener('mouseup', this._onMouseUp);
        }

        this.active = false;
        this._startPos = this._pos = DOM.mousePos(this._el, e);
        this._inertia = [[Date.now(), this._pos]];
    },

    _onMove: function (e) {
        if (this._ignoreEvent(e)) return;

        if (!this.active) {
            this.active = true;
            this._fireEvent('dragstart', e);
            this._fireEvent('movestart', e);
        }

        var pos = DOM.mousePos(this._el, e),
            map = this._map;

        map.stop();
        this._drainInertiaBuffer();
        this._inertia.push([Date.now(), pos]);

        map.transform.setLocationAtPoint(map.transform.pointLocation(this._pos), pos);

        this._fireEvent('drag', e);
        this._fireEvent('move', e);

        this._pos = pos;

        e.preventDefault();
    },

    _onUp: function (e) {
        if (!this.active) return;

        this.active = false;
        this._fireEvent('dragend', e);
        this._drainInertiaBuffer();

        var finish = function() {
            this._fireEvent('moveend', e);
        }.bind(this);

        var inertia = this._inertia;
        if (inertia.length < 2) {
            finish();
            return;
        }

        var last = inertia[inertia.length - 1],
            first = inertia[0],
            flingOffset = last[1].sub(first[1]),
            flingDuration = (last[0] - first[0]) / 1000;

        if (flingDuration === 0 || last[1].equals(first[1])) {
            finish();
            return;
        }

        // calculate px/s velocity & adjust for increased initial animation speed when easing out
        var velocity = flingOffset.mult(inertiaLinearity / flingDuration),
            speed = velocity.mag(); // px/s

        if (speed > inertiaMaxSpeed) {
            speed = inertiaMaxSpeed;
            velocity._unit()._mult(speed);
        }

        var duration = speed / (inertiaDeceleration * inertiaLinearity),
            offset = velocity.mult(-duration / 2);

        this._map.panBy(offset, {
            duration: duration * 1000,
            easing: inertiaEasing,
            noMoveStart: true
        });
    },

    _onMouseUp: function (e) {
        if (this._ignoreEvent(e)) return;
        this._onUp(e);
        document.removeEventListener('mousemove', this._onMove);
        document.removeEventListener('mouseup', this._onMouseUp);
    },

    _onTouchEnd: function (e) {
        if (this._ignoreEvent(e)) return;
        this._onUp(e);
        document.removeEventListener('touchmove', this._onMove);
        document.removeEventListener('touchend', this._onTouchEnd);
    },

    _fireEvent: function (type, e) {
        return this._map.fire(type, { originalEvent: e });
    },

    _ignoreEvent: function (e) {
        var map = this._map;

        if (map.boxZoom && map.boxZoom.active) return true;
        if (map.dragRotate && map.dragRotate.active) return true;
        if (e.touches) {
            return (e.touches.length > 1);
        } else {
            if (e.ctrlKey) return true;
            var buttons = 1,  // left button
                button = 0;   // left button
            return (e.type === 'mousemove' ? e.buttons & buttons === 0 : e.button !== button);
        }
    },

    _drainInertiaBuffer: function () {
        var inertia = this._inertia,
            now = Date.now(),
            cutoff = 160;   // msec

        while (inertia.length > 0 && now - inertia[0][0] > cutoff) inertia.shift();
    }
};



/**
 * Drag start event. This event is emitted at the start of a user-initiated pan interaction.
 *
 * @event dragstart
 * @memberof Map
 * @instance
 * @type {Object}
 * @property {Event} originalEvent the original DOM event
 */

/**
 * Drag event. This event is emitted repeatedly during a user-initiated pan interaction.
 *
 * @event drag
 * @memberof Map
 * @instance
 * @type {Object}
 * @property {Event} originalEvent the original DOM event
 */

/**
 * Drag end event. This event is emitted at the end of a user-initiated pan interaction.
 *
 * @event dragend
 * @memberof Map
 * @instance
 * @type {Object}
 * @property {Event} originalEvent the original DOM event
 */

},{"../../util/dom":86,"../../util/util":94}],73:[function(require,module,exports){
'use strict';

var DOM = require('../../util/dom'),
    Point = require('point-geometry'),
    util = require('../../util/util');

module.exports = DragRotate;

var inertiaLinearity = 0.25,
    inertiaEasing = util.bezier(0, 0, inertiaLinearity, 1),
    inertiaMaxSpeed = 180, // deg/s
    inertiaDeceleration = 720; // deg/s^2


function DragRotate(map) {
    this._map = map;
    this._el = map.getCanvasContainer();

    util.bindHandlers(this);
}

DragRotate.prototype = {
    enable: function () {
        this._el.addEventListener('mousedown', this._onDown);
    },

    disable: function () {
        this._el.removeEventListener('mousedown', this._onDown);
    },

    _onDown: function (e) {
        if (this._ignoreEvent(e)) return;
        if (this.active) return;

        document.addEventListener('mousemove', this._onMove);
        document.addEventListener('mouseup', this._onUp);

        this.active = false;
        this._inertia = [[Date.now(), this._map.getBearing()]];
        this._startPos = this._pos = DOM.mousePos(this._el, e);
        this._center = this._map.transform.centerPoint;  // Center of rotation

        // If the first click was too close to the center, move the center of rotation by 200 pixels
        // in the direction of the click.
        var startToCenter = this._startPos.sub(this._center),
            startToCenterDist = startToCenter.mag();

        if (startToCenterDist < 200) {
            this._center = this._startPos.add(new Point(-200, 0)._rotate(startToCenter.angle()));
        }

        e.preventDefault();
    },

    _onMove: function (e) {
        if (this._ignoreEvent(e)) return;

        if (!this.active) {
            this.active = true;
            this._fireEvent('rotatestart', e);
            this._fireEvent('movestart', e);
        }

        var map = this._map;
        map.stop();

        var p1 = this._pos,
            p2 = DOM.mousePos(this._el, e),
            center = this._center,
            bearingDiff = p1.sub(center).angleWith(p2.sub(center)) / Math.PI * 180,
            bearing = map.getBearing() - bearingDiff,
            inertia = this._inertia,
            last = inertia[inertia.length - 1];

        this._drainInertiaBuffer();
        inertia.push([Date.now(), map._normalizeBearing(bearing, last[1])]);

        map.transform.bearing = bearing;

        this._fireEvent('rotate', e);
        this._fireEvent('move', e);

        this._pos = p2;
    },

    _onUp: function (e) {
        if (this._ignoreEvent(e)) return;
        document.removeEventListener('mousemove', this._onMove);
        document.removeEventListener('mouseup', this._onUp);

        if (!this.active) return;

        this.active = false;
        this._fireEvent('rotateend', e);
        this._drainInertiaBuffer();

        var map = this._map,
            mapBearing = map.getBearing(),
            inertia = this._inertia;

        var finish = function() {
            if (Math.abs(mapBearing) < map.options.bearingSnap) {
                map.resetNorth({noMoveStart: true});
            } else {
                this._fireEvent('moveend', e);
            }
        }.bind(this);

        if (inertia.length < 2) {
            finish();
            return;
        }

        var first = inertia[0],
            last = inertia[inertia.length - 1],
            previous = inertia[inertia.length - 2],
            bearing = map._normalizeBearing(mapBearing, previous[1]),
            flingDiff = last[1] - first[1],
            sign = flingDiff < 0 ? -1 : 1,
            flingDuration = (last[0] - first[0]) / 1000;

        if (flingDiff === 0 || flingDuration === 0) {
            finish();
            return;
        }

        var speed = Math.abs(flingDiff * (inertiaLinearity / flingDuration));  // deg/s
        if (speed > inertiaMaxSpeed) {
            speed = inertiaMaxSpeed;
        }

        var duration = speed / (inertiaDeceleration * inertiaLinearity),
            offset = sign * speed * (duration / 2);

        bearing += offset;

        if (Math.abs(map._normalizeBearing(bearing, 0)) < map.options.bearingSnap) {
            bearing = map._normalizeBearing(0, bearing);
        }

        map.rotateTo(bearing, {
            duration: duration * 1000,
            easing: inertiaEasing,
            noMoveStart: true
        });
    },

    _fireEvent: function (type, e) {
        return this._map.fire(type, { originalEvent: e });
    },

    _ignoreEvent: function (e) {
        var map = this._map;

        if (map.boxZoom && map.boxZoom.active) return true;
        if (map.dragPan && map.dragPan.active) return true;
        if (e.touches) {
            return (e.touches.length > 1);
        } else {
            var buttons = (e.ctrlKey ? 1 : 2),  // ? ctrl+left button : right button
                button = (e.ctrlKey ? 0 : 2);   // ? ctrl+left button : right button
            return (e.type === 'mousemove' ? e.buttons & buttons === 0 : e.button !== button);
        }
    },

    _drainInertiaBuffer: function () {
        var inertia = this._inertia,
            now = Date.now(),
            cutoff = 160;   //msec

        while (inertia.length > 0 && now - inertia[0][0] > cutoff)
            inertia.shift();
    }

};


/**
 * Rotate start event. This event is emitted at the start of a user-initiated rotate interaction.
 *
 * @event rotatestart
 * @memberof Map
 * @instance
 * @type {Object}
 * @property {Event} originalEvent the original DOM event
 */

/**
 * Rotate event. This event is emitted repeatedly during a user-initiated rotate interaction.
 *
 * @event rotate
 * @memberof Map
 * @instance
 * @type {Object}
 * @property {Event} originalEvent the original DOM event
 */

/**
 * Rotate end event. This event is emitted at the end of a user-initiated rotate interaction.
 *
 * @event rotateend
 * @memberof Map
 * @instance
 * @type {Object}
 * @property {Event} originalEvent the original DOM event
 */

},{"../../util/dom":86,"../../util/util":94,"point-geometry":130}],74:[function(require,module,exports){
'use strict';

module.exports = Keyboard;


var panDelta = 80,
    rotateDelta = 2,
    pitchDelta = 5;

/**
 * The `Keyboard` handler responds to keyboard input by zooming, rotating, or panning the
 * map. The following keyboard shortcuts are supported:
 *  * `=` / `+`: increase zoom level by 1
 *  * `Shift-=` / `Shift-+`: increase zoom level by 2
 *  * `-`: decrease zoom level by 1
 *  * `Shift--`: decrease zoom level by 2
 *  * Arrow keys: pan by 80 pixels
 *  * `Shift+⇢`: increase rotation by 2 degrees
 *  * `Shift+⇠`: decrease rotation by 2 degrees
 *  * `Shift+⇡`: increase pitch by 5 degrees
 *  * `Shift+⇣`: decrease pitch by 5 degrees
 * @class Keyboard
 * @example
 *   // Disable the keyboard handler
 *   map.keyboard.disable();
 * @example
 *   // Enable the keyboard handler
 *   map.keyboard.enable();
 */
function Keyboard(map) {
    this._map = map;
    this._el = map.getCanvasContainer();

    this._onKeyDown = this._onKeyDown.bind(this);
}

Keyboard.prototype = {
    enable: function () {
        this._el.addEventListener('keydown', this._onKeyDown, false);
    },

    disable: function () {
        this._el.removeEventListener('keydown', this._onKeyDown);
    },

    _onKeyDown: function (e) {
        if (e.altKey || e.ctrlKey || e.metaKey) return;

        var map = this._map;

        switch (e.keyCode) {
        case 61:
        case 107:
        case 171:
        case 187:
            map.zoomTo(Math.round(map.getZoom()) + (e.shiftKey ? 2 : 1));
            break;

        case 189:
        case 109:
        case 173:
            map.zoomTo(Math.round(map.getZoom()) - (e.shiftKey ? 2 : 1));
            break;

        case 37:
            if (e.shiftKey) {
                map.easeTo({ bearing: map.getBearing() - rotateDelta });
            } else {
                map.panBy([-panDelta, 0]);
            }
            break;

        case 39:
            if (e.shiftKey) {
                map.easeTo({ bearing: map.getBearing() + rotateDelta });
            } else {
                map.panBy([panDelta, 0]);
            }
            break;

        case 38:
            if (e.shiftKey) {
                map.easeTo({ pitch: map.getPitch() + pitchDelta });
            } else {
                map.panBy([0, -panDelta]);
            }
            break;

        case 40:
            if (e.shiftKey) {
                map.easeTo({ pitch: Math.max(map.getPitch() - pitchDelta, 0) });
            } else {
                map.panBy([0, panDelta]);
            }
            break;
        }
    }
};

},{}],75:[function(require,module,exports){
'use strict';

var DOM = require('../../util/dom'),
    browser = require('../../util/browser'),
    util = require('../../util/util');

module.exports = ScrollZoom;


var ua = typeof navigator !== 'undefined' ? navigator.userAgent.toLowerCase() : '',
    firefox = ua.indexOf('firefox') !== -1,
    safari = ua.indexOf('safari') !== -1 && ua.indexOf('chrom') === -1;


function ScrollZoom(map) {
    this._map = map;
    this._el = map.getCanvasContainer();

    util.bindHandlers(this);
}

ScrollZoom.prototype = {
    enable: function () {
        this._el.addEventListener('wheel', this._onWheel, false);
        this._el.addEventListener('mousewheel', this._onWheel, false);
    },

    disable: function () {
        this._el.removeEventListener('wheel', this._onWheel);
        this._el.removeEventListener('mousewheel', this._onWheel);
    },

    _onWheel: function (e) {
        var value;

        if (e.type === 'wheel') {
            value = e.deltaY;
            // Firefox doubles the values on retina screens...
            if (firefox && e.deltaMode === window.WheelEvent.DOM_DELTA_PIXEL) value /= browser.devicePixelRatio;
            if (e.deltaMode === window.WheelEvent.DOM_DELTA_LINE) value *= 40;

        } else if (e.type === 'mousewheel') {
            value = -e.wheelDeltaY;
            if (safari) value = value / 3;
        }

        var now = (window.performance || Date).now(),
            timeDelta = now - (this._time || 0);

        this._pos = DOM.mousePos(this._el, e);
        this._time = now;

        if (value !== 0 && (value % 4.000244140625) === 0) {
            // This one is definitely a mouse wheel event.
            this._type = 'wheel';
            // Normalize this value to match trackpad.
            value = Math.floor(value / 4);

        } else if (value !== 0 && Math.abs(value) < 4) {
            // This one is definitely a trackpad event because it is so small.
            this._type = 'trackpad';

        } else if (timeDelta > 400) {
            // This is likely a new scroll action.
            this._type = null;
            this._lastValue = value;

            // Start a timeout in case this was a singular event, and dely it by up to 40ms.
            this._timeout = setTimeout(this._onTimeout, 40);

        } else if (!this._type) {
            // This is a repeating event, but we don't know the type of event just yet.
            // If the delta per time is small, we assume it's a fast trackpad; otherwise we switch into wheel mode.
            this._type = (Math.abs(timeDelta * value) < 200) ? 'trackpad' : 'wheel';

            // Make sure our delayed event isn't fired again, because we accumulate
            // the previous event (which was less than 40ms ago) into this event.
            if (this._timeout) {
                clearTimeout(this._timeout);
                this._timeout = null;
                value += this._lastValue;
            }
        }

        // Slow down zoom if shift key is held for more precise zooming
        if (e.shiftKey && value) value = value / 4;

        // Only fire the callback if we actually know what type of scrolling device the user uses.
        if (this._type) this._zoom(-value);

        e.preventDefault();
    },

    _onTimeout: function () {
        this._type = 'wheel';
        this._zoom(-this._lastValue);
    },

    _zoom: function (delta) {
        var map = this._map;

        // Scale by sigmoid of scroll wheel delta.
        var scale = 2 / (1 + Math.exp(-Math.abs(delta / 100)));
        if (delta < 0 && scale !== 0) scale = 1 / scale;

        var fromScale = map.ease ? map.ease.to : map.transform.scale,
            targetZoom = map.transform.scaleZoom(fromScale * scale);

        map.zoomTo(targetZoom, {
            duration: 0,
            around: map.unproject(this._pos)
        });
    }
};

},{"../../util/browser":83,"../../util/dom":86,"../../util/util":94}],76:[function(require,module,exports){
'use strict';

var DOM = require('../../util/dom'),
    util = require('../../util/util');

module.exports = TouchZoomRotate;

var inertiaLinearity = 0.15,
    inertiaEasing = util.bezier(0, 0, inertiaLinearity, 1),
    inertiaDeceleration = 12, // scale / s^2
    inertiaMaxSpeed = 2.5, // scale / s
    significantScaleThreshold = 0.15,
    significantRotateThreshold = 4;


function TouchZoomRotate(map) {
    this._map = map;
    this._el = map.getCanvasContainer();

    util.bindHandlers(this);
}

TouchZoomRotate.prototype = {
    enable: function () {
        this._el.addEventListener('touchstart', this._onStart, false);
    },

    disable: function () {
        this._el.removeEventListener('touchstart', this._onStart);
    },

    disableRotation: function() {
        this._rotationDisabled = true;
    },

    enableRotation: function() {
        this._rotationDisabled = false;
    },

    _onStart: function (e) {
        if (e.touches.length !== 2) return;

        var p0 = DOM.mousePos(this._el, e.touches[0]),
            p1 = DOM.mousePos(this._el, e.touches[1]);

        this._startVec = p0.sub(p1);
        this._startScale = this._map.transform.scale;
        this._startBearing = this._map.transform.bearing;
        this._gestureIntent = undefined;
        this._inertia = [];

        document.addEventListener('touchmove', this._onMove, false);
        document.addEventListener('touchend', this._onEnd, false);
    },

    _onMove: function (e) {
        if (e.touches.length !== 2) return;

        var p0 = DOM.mousePos(this._el, e.touches[0]),
            p1 = DOM.mousePos(this._el, e.touches[1]),
            p = p0.add(p1).div(2),
            vec = p0.sub(p1),
            scale = vec.mag() / this._startVec.mag(),
            bearing = this._rotationDisabled ? 0 : vec.angleWith(this._startVec) * 180 / Math.PI,
            map = this._map;

        // Determine 'intent' by whichever threshold is surpassed first,
        // then keep that state for the duration of this gesture.
        if (!this._gestureIntent) {
            var scalingSignificantly = (Math.abs(1 - scale) > significantScaleThreshold),
                rotatingSignificantly = (Math.abs(bearing) > significantRotateThreshold);

            if (rotatingSignificantly) {
                this._gestureIntent = 'rotate';
            } else if (scalingSignificantly) {
                this._gestureIntent = 'zoom';
            }

            if (this._gestureIntent) {
                this._startVec = vec;
                this._startScale = map.transform.scale;
                this._startBearing = map.transform.bearing;
            }

        } else {
            var param = { duration: 0, around: map.unproject(p) };

            if (this._gestureIntent === 'rotate') {
                param.bearing = this._startBearing + bearing;
            }
            if (this._gestureIntent === 'zoom' || this._gestureIntent === 'rotate') {
                param.zoom = map.transform.scaleZoom(this._startScale * scale);
            }

            map.stop();
            this._drainInertiaBuffer();
            this._inertia.push([Date.now(), scale, p]);

            map.easeTo(param);
        }

        e.preventDefault();
    },

    _onEnd: function () {
        document.removeEventListener('touchmove', this._onMove);
        document.removeEventListener('touchend', this._onEnd);
        this._drainInertiaBuffer();

        var inertia = this._inertia,
            map = this._map;

        if (inertia.length < 2) {
            map.snapToNorth();
            return;
        }

        var last = inertia[inertia.length - 1],
            first = inertia[0],
            lastScale = map.transform.scaleZoom(this._startScale * last[1]),
            firstScale = map.transform.scaleZoom(this._startScale * first[1]),
            scaleOffset = lastScale - firstScale,
            scaleDuration = (last[0] - first[0]) / 1000,
            p = last[2];

        if (scaleDuration === 0 || lastScale === firstScale) {
            map.snapToNorth();
            return;
        }

        // calculate scale/s speed and adjust for increased initial animation speed when easing
        var speed = scaleOffset * inertiaLinearity / scaleDuration; // scale/s

        if (Math.abs(speed) > inertiaMaxSpeed) {
            if (speed > 0) {
                speed = inertiaMaxSpeed;
            } else {
                speed = -inertiaMaxSpeed;
            }
        }

        var duration = Math.abs(speed / (inertiaDeceleration * inertiaLinearity)) * 1000,
            targetScale = lastScale + speed * duration / 2000;

        if (targetScale < 0) {
            targetScale = 0;
        }

        map.easeTo({
            zoom: targetScale,
            duration: duration,
            easing: inertiaEasing,
            around: map.unproject(p)
        });
    },

    _drainInertiaBuffer: function() {
        var inertia = this._inertia,
            now = Date.now(),
            cutoff = 160; // msec

        while (inertia.length > 2 && now - inertia[0][0] > cutoff) inertia.shift();
    }
};

},{"../../util/dom":86,"../../util/util":94}],77:[function(require,module,exports){
'use strict';

/*
 * Adds positional coordinates to URL hashes. Passed as an option to the map object
 *
 * @class mapboxgl.Hash
 * @returns {Hash} `this`
 */
module.exports = Hash;

var util = require('../util/util');

function Hash() {
    util.bindAll([
        '_onHashChange',
        '_updateHash'
    ], this);
}

Hash.prototype = {
    /* Map element to listen for coordinate changes
     *
     * @param {Object} map
     * @returns {Hash} `this`
     */
    addTo: function(map) {
        this._map = map;
        window.addEventListener('hashchange', this._onHashChange, false);
        this._map.on('moveend', this._updateHash);
        return this;
    },

    /* Removes hash
     *
     * @returns {Popup} `this`
     */
    remove: function() {
        window.removeEventListener('hashchange', this._onHashChange, false);
        this._map.off('moveend', this._updateHash);
        delete this._map;
        return this;
    },

    _onHashChange: function() {
        var loc = location.hash.replace('#', '').split('/');
        if (loc.length >= 3) {
            this._map.jumpTo({
                center: [+loc[2], +loc[1]],
                zoom: +loc[0],
                bearing: +(loc[3] || 0)
            });
            return true;
        }
        return false;
    },

    _updateHash: function() {
        var center = this._map.getCenter(),
            zoom = this._map.getZoom(),
            bearing = this._map.getBearing(),
            precision = Math.max(0, Math.ceil(Math.log(zoom) / Math.LN2)),

            hash = '#' + (Math.round(zoom * 100) / 100) +
                '/' + center.lat.toFixed(precision) +
                '/' + center.lng.toFixed(precision) +
                (bearing ? '/' + (Math.round(bearing * 10) / 10) : '');

        window.history.replaceState('', '', hash);
    }
};

},{"../util/util":94}],78:[function(require,module,exports){
'use strict';

var handlers = {
    scrollZoom: require('./handler/scroll_zoom'),
    boxZoom: require('./handler/box_zoom'),
    dragRotate: require('./handler/drag_rotate'),
    dragPan: require('./handler/drag_pan'),
    keyboard: require('./handler/keyboard'),
    doubleClickZoom: require('./handler/dblclick_zoom'),
    touchZoomRotate: require('./handler/touch_zoom_rotate')
};

var DOM = require('../util/dom'),
    util = require('../util/util');

module.exports = Interaction;

function Interaction(map) {
    this._map = map;
    this._el = map.getCanvasContainer();

    for (var name in handlers) {
        map[name] = new handlers[name](map);
    }

    util.bindHandlers(this);
}

Interaction.prototype = {
    enable: function () {
        var options = this._map.options,
            el = this._el;

        for (var name in handlers) {
            if (options[name]) this._map[name].enable();
        }

        el.addEventListener('mousedown', this._onMouseDown, false);
        el.addEventListener('mouseup', this._onMouseUp, false);
        el.addEventListener('touchstart', this._onTouchStart, false);
        el.addEventListener('click', this._onClick, false);
        el.addEventListener('mousemove', this._onMouseMove, false);
        el.addEventListener('dblclick', this._onDblClick, false);
        el.addEventListener('contextmenu', this._onContextMenu, false);
    },

    disable: function () {
        var options = this._map.options,
            el = this._el;

        for (var name in handlers) {
            if (options[name]) this._map[name].disable();
        }

        el.removeEventListener('mousedown', this._onMouseDown);
        el.removeEventListener('mouseup', this._onMouseUp);
        el.removeEventListener('touchstart', this._onTouchStart);
        el.removeEventListener('click', this._onClick);
        el.removeEventListener('mousemove', this._onMouseMove);
        el.removeEventListener('dblclick', this._onDblClick);
        el.removeEventListener('contextmenu', this._onContextMenu);
    },

    _onMouseDown: function (e) {
        this._map.stop();
        this._startPos = DOM.mousePos(this._el, e);
        this._fireEvent('mousedown', e);
    },

    _onMouseUp: function (e) {
        var map = this._map,
            rotating = map.dragRotate && map.dragRotate.active;

        if (this._contextMenuEvent && !rotating) {
            this._fireEvent('contextmenu', this._contextMenuEvent);
        }

        this._contextMenuEvent = null;
        this._fireEvent('mouseup', e);
    },

    _onTouchStart: function (e) {
        if (!e.touches || e.touches.length > 1) return;

        if (!this._tapped) {
            this._tapped = setTimeout(this._onTimeout, 300);

        } else {
            clearTimeout(this._tapped);
            this._tapped = null;
            this._fireEvent('dblclick', e);
        }
    },

    _onTimeout: function () {
        this._tapped = null;
    },

    _onMouseMove: function (e) {
        var map = this._map,
            el = this._el;

        if (map.dragPan && map.dragPan.active) return;
        if (map.dragRotate && map.dragRotate.active) return;

        var target = e.toElement || e.target;
        while (target && target !== el) target = target.parentNode;
        if (target !== el) return;

        this._fireEvent('mousemove', e);
    },

    _onClick: function (e) {
        var pos = DOM.mousePos(this._el, e);

        if (pos.equals(this._startPos)) {
            this._fireEvent('click', e);
        }
    },

    _onDblClick: function (e) {
        this._fireEvent('dblclick', e);
        e.preventDefault();
    },

    _onContextMenu: function (e) {
        this._contextMenuEvent = e;
        e.preventDefault();
    },

    _fireEvent: function (type, e) {
        var pos = DOM.mousePos(this._el, e);

        return this._map.fire(type, {
            lngLat: this._map.unproject(pos),
            point: pos,
            originalEvent: e
        });
    }
};


/**
 * Mouse down event.
 *
 * @event mousedown
 * @memberof Map
 * @type {Object}
 * @property {Point} point the pixel location of the event
 * @property {LngLat} lngLat the geographic location of the event
 * @property {Event} originalEvent the original DOM event
 */

/**
 * Mouse up event.
 *
 * @event mouseup
 * @memberof Map
 * @type {Object}
 * @property {Point} point the pixel location of the event
 * @property {LngLat} lngLat the geographic location of the event
 * @property {Event} originalEvent the original DOM event
 */

/**
 * Mouse move event.
 *
 * @event mousemove
 * @memberof Map
 * @instance
 * @type {Object}
 * @property {Point} point the pixel location of the event
 * @property {LngLat} lngLat the geographic location of the event
 * @property {Event} originalEvent the original DOM event
 */

/**
 * Click event.
 *
 * @event click
 * @memberof Map
 * @instance
 * @type {Object}
 * @property {Point} point the pixel location of the event
 * @property {LngLat} lngLat the geographic location of the event
 * @property {Event} originalEvent the original DOM event
 */

/**
 * Double click event.
 *
 * @event dblclick
 * @memberof Map
 * @instance
 * @type {Object}
 * @property {Point} point the pixel location of the event
 * @property {LngLat} lngLat the geographic location of the event
 * @property {Event} originalEvent the original DOM event
 */

/**
 * Context menu event.
 *
 * @event contextmenu
 * @memberof Map
 * @instance
 * @type {Object}
 * @property {Point} point the pixel location of the event
 * @property {LngLat} lngLat the geographic location of the event
 * @property {Event} originalEvent the original DOM event
 */

/**
 * Load event. This event is emitted immediately after all necessary resources have been downloaded
 * and the first visually complete rendering has occurred.
 *
 * @event load
 * @memberof Map
 * @instance
 * @type {Object}
 */

/**
 * Move start event. This event is emitted just before the map begins a transition from one
 * view to another, either as a result of user interaction or the use of methods such as `Map#jumpTo`.
 *
 * @event movestart
 * @memberof Map
 * @instance
 * @type {Object}
 * @property {Event} originalEvent the original DOM event, only present if triggered by user interaction
 */

/**
 * Move event. This event is emitted repeatedly during animated transitions from one view to
 * another, either as a result of user interaction or the use of methods such as `Map#jumpTo`.
 *
 * @event move
 * @memberof Map
 * @instance
 * @type {Object}
 * @property {Event} originalEvent the original DOM event, only present if triggered by user interaction
 */

/**
 * Move end event. This event is emitted just after the map completes a transition from one
 * view to another, either as a result of user interaction or the use of methods such as `Map#jumpTo`.
 *
 * @event moveend
 * @memberof Map
 * @instance
 * @type {Object}
 * @property {Event} originalEvent the original DOM event, only present if triggered by user interaction
 */

},{"../util/dom":86,"../util/util":94,"./handler/box_zoom":70,"./handler/dblclick_zoom":71,"./handler/drag_pan":72,"./handler/drag_rotate":73,"./handler/keyboard":74,"./handler/scroll_zoom":75,"./handler/touch_zoom_rotate":76}],79:[function(require,module,exports){
'use strict';

var Canvas = require('../util/canvas');
var util = require('../util/util');
var browser = require('../util/browser');
var Evented = require('../util/evented');
var DOM = require('../util/dom');

var Style = require('../style/style');
var AnimationLoop = require('../style/animation_loop');
var Painter = require('../render/painter');

var Transform = require('../geo/transform');
var Hash = require('./hash');

var Interaction = require('./interaction');

var Camera = require('./camera');
var LngLat = require('../geo/lng_lat');
var LngLatBounds = require('../geo/lng_lat_bounds');
var Point = require('point-geometry');
var Attribution = require('./control/attribution');

/**
 * Options common to Map#addClass, Map#removeClass, and Map#setClasses, controlling
 * whether or not to smoothly transition property changes triggered by the class change.
 *
 * @typedef {Object} StyleOptions
 * @property {boolean} transition
 */

/**
 * Creates a map instance.
 * @class Map
 * @param {Object} options
 * @param {string|Element} options.container HTML element to initialize the map in (or element id as string)
 * @param {number} [options.minZoom=0] Minimum zoom of the map
 * @param {number} [options.maxZoom=20] Maximum zoom of the map
 * @param {Object|string} [options.style] Map style. This must be an an object conforming to the schema described in the [style reference](https://mapbox.com/mapbox-gl-style-spec/), or a URL to a JSON style. To load a style from the Mapbox API, you can use a URL of the form `mapbox://styles/:owner/:style`, where `:owner` is your Mapbox account name and `:style` is the style ID. Or you can use one of the predefined Mapbox styles:
 *   * `mapbox://styles/mapbox/basic-v8` - Simple and flexible starting template.
 *   * `mapbox://styles/mapbox/bright-v8` - Template for complex custom basemaps.
 *   * `mapbox://styles/mapbox/streets-v8` - A ready-to-use basemap, perfect for minor customization or incorporating your own data.
 *   * `mapbox://styles/mapbox/light-v8` - Subtle light backdrop for data vizualizations.
 *   * `mapbox://styles/mapbox/dark-v8` - Subtle dark backdrop for data vizualizations.
 * @param {boolean} [options.hash=false] If `true`, the map will track and update the page URL according to map position
 * @param {boolean} [options.interactive=true] If `false`, no mouse, touch, or keyboard listeners are attached to the map, so it will not respond to input
 * @param {number} [options.bearingSnap=7] Snap to north threshold in degrees.
 * @param {Array} [options.classes] Style class names with which to initialize the map
 * @param {boolean} [options.attributionControl=true] If `true`, an attribution control will be added to the map.
 * @param {boolean} [options.failIfMajorPerformanceCaveat=false] If `true`, map creation will fail if the implementation determines that the performance of the created WebGL context would be dramatically lower than expected.
 * @param {boolean} [options.preserveDrawingBuffer=false] If `true`, The maps canvas can be exported to a PNG using `map.getCanvas().toDataURL();`. This is false by default as a performance optimization.
 * @param {LngLatBounds|Array<Array<number>>} [options.maxBounds] If set, the map is constrained to the given bounds.
 * @example
 * var map = new mapboxgl.Map({
 *   container: 'map',
 *   center: [-122.420679, 37.772537],
 *   zoom: 13,
 *   style: style_object,
 *   hash: true
 * });
 */
var Map = module.exports = function(options) {

    options = this.options = util.inherit(this.options, options);

    this.animationLoop = new AnimationLoop();
    this.transform = new Transform(options.minZoom, options.maxZoom);

    if (options.maxBounds) {
        var b = LngLatBounds.convert(options.maxBounds);
        this.transform.lngRange = [b.getWest(), b.getEast()];
        this.transform.latRange = [b.getSouth(), b.getNorth()];
    }

    util.bindAll([
        '_forwardStyleEvent',
        '_forwardSourceEvent',
        '_forwardLayerEvent',
        '_forwardTileEvent',
        '_onStyleLoad',
        '_onStyleChange',
        '_onSourceAdd',
        '_onSourceRemove',
        '_onSourceUpdate',
        '_onWindowResize',
        'onError',
        '_update',
        '_render'
    ], this);

    this._setupContainer();
    this._setupPainter();

    this.on('move', this._update.bind(this, false));
    this.on('zoom', this._update.bind(this, true));
    this.on('moveend', function() {
        this.animationLoop.set(300); // text fading
        this._rerender();
    }.bind(this));

    if (typeof window !== 'undefined') {
        window.addEventListener('resize', this._onWindowResize, false);
    }

    this.interaction = new Interaction(this);

    if (options.interactive) {
        this.interaction.enable();
    }

    this._hash = options.hash && (new Hash()).addTo(this);
    // don't set position from options if set through hash
    if (!this._hash || !this._hash._onHashChange()) {
        this.jumpTo(options);
    }

    this.sources = {};
    this.stacks = {};
    this._classes = {};

    this.resize();

    if (options.classes) this.setClasses(options.classes);
    if (options.style) this.setStyle(options.style);
    if (options.attributionControl) this.addControl(new Attribution(options.attributionControl));

    this.on('style.error', this.onError);
    this.on('source.error', this.onError);
    this.on('tile.error', this.onError);
};

util.extend(Map.prototype, Evented);
util.extend(Map.prototype, Camera.prototype);
util.extend(Map.prototype, /** @lends Map.prototype */{

    options: {
        center: [0, 0],
        zoom: 0,
        bearing: 0,
        pitch: 0,

        minZoom: 0,
        maxZoom: 20,

        interactive: true,

        scrollZoom: true,
        boxZoom: true,
        dragRotate: true,
        dragPan: true,
        keyboard: true,
        doubleClickZoom: true,
        touchZoomRotate: true,

        bearingSnap: 7,

        hash: false,

        attributionControl: true,

        failIfMajorPerformanceCaveat: false,
        preserveDrawingBuffer: false
    },

    /**
     * Adds a control to the map, calling `control.addTo(this)`.
     *
     * @param {Control} control
     * @returns {Map} `this`
     */
    addControl: function(control) {
        control.addTo(this);
        return this;
    },

    /**
     * Adds a style class to a map
     *
     * @param {string} klass name of style class
     * @param {StyleOptions} [options]
     * @fires change
     * @returns {Map} `this`
     */
    addClass: function(klass, options) {
        if (this._classes[klass]) return;
        this._classes[klass] = true;
        if (this.style) this.style._cascade(this._classes, options);
    },

    /**
     * Removes a style class from a map
     *
     * @param {string} klass name of style class
     * @param {StyleOptions} [options]
     * @fires change
     * @returns {Map} `this`
     */
    removeClass: function(klass, options) {
        if (!this._classes[klass]) return;
        delete this._classes[klass];
        if (this.style) this.style._cascade(this._classes, options);
    },

    /**
     * Helper method to add more than one class
     *
     * @param {Array<string>} klasses An array of class names
     * @param {StyleOptions} [options]
     * @fires change
     * @returns {Map} `this`
     */
    setClasses: function(klasses, options) {
        this._classes = {};
        for (var i = 0; i < klasses.length; i++) {
            this._classes[klasses[i]] = true;
        }
        if (this.style) this.style._cascade(this._classes, options);
    },

    /**
     * Check whether a style class is active
     *
     * @param {string} klass Name of style class
     * @returns {boolean}
     */
    hasClass: function(klass) {
        return !!this._classes[klass];
    },

    /**
     * Return an array of the current active style classes
     *
     * @returns {boolean}
     */
    getClasses: function() {
        return Object.keys(this._classes);
    },

    /**
     * Detect the map's new width and height and resize it.
     *
     * @returns {Map} `this`
     */
    resize: function() {
        var width = 0, height = 0;

        if (this._container) {
            width = this._container.offsetWidth || 400;
            height = this._container.offsetHeight || 300;
        }

        this._canvas.resize(width, height);
        this.transform.resize(width, height);
        this.painter.resize(width, height);

        return this
            .fire('movestart')
            .fire('move')
            .fire('resize')
            .fire('moveend');
    },

    /**
     * Get the map's geographical bounds
     *
     * @returns {LngLatBounds}
     */
    getBounds: function() {
        return new LngLatBounds(
            this.transform.pointLocation(new Point(0, 0)),
            this.transform.pointLocation(this.transform.size));
    },

    /**
     * Get pixel coordinates (relative to map container) given a geographical location
     *
     * @param {LngLat} lnglat
     * @returns {Object} `x` and `y` coordinates
     */
    project: function(lnglat) {
        return this.transform.locationPoint(LngLat.convert(lnglat));
    },

    /**
     * Get geographical coordinates given pixel coordinates
     *
     * @param {Array<number>} point [x, y] pixel coordinates
     * @returns {LngLat}
     */
    unproject: function(point) {
        return this.transform.pointLocation(Point.convert(point));
    },

    /**
     * Query features at a point, or within a certain radius thereof.
     *
     * To use this method, you must set the style property `"interactive": true` on layers you wish to query.
     *
     * @param {Array<number>} point [x, y] pixel coordinates
     * @param {Object} params
     * @param {number} [params.radius=0] Radius in pixels to search in
     * @param {string|Array<string>} [params.layer] Only return features from a given layer or layers
     * @param {string} [params.type] Either `raster` or `vector`
     * @param {boolean} [params.includeGeometry=false] If `true`, geometry of features will be included in the results at the expense of a much slower query time.
     * @param {featuresCallback} callback function that receives the results
     *
     * @returns {Map} `this`
     *
     * @example
     * map.featuresAt([10, 20], { radius: 10 }, function(err, features) {
     *   console.log(features);
     * });
     */
    featuresAt: function(point, params, callback) {
        var location = this.unproject(point).wrap();
        var coord = this.transform.locationCoordinate(location);
        this.style.featuresAt(coord, params, callback);
        return this;
    },

    /**
     * Query features within a rectangle.
     *
     * To use this method, you must set the style property `"interactive": true` on layers you wish to query.
     *
     * @param {Array<Point>|Array<Array<number>>} [bounds] Coordinates of opposite corners of bounding rectangle, in pixel coordinates. Optional: use entire viewport if omitted.
     * @param {Object} params
     * @param {string|Array<string>} [params.layer] Only return features from a given layer or layers
     * @param {string} [params.type] Either `raster` or `vector`
     * @param {boolean} [params.includeGeometry=false] If `true`, geometry of features will be included in the results at the expense of a much slower query time.
     * @param {featuresCallback} callback function that receives the results
     *
     * @returns {Map} `this`
     *
     * @example
     * map.featuresIn([[10, 20], [30, 50]], { layer: 'my-layer-name' }, function(err, features) {
     *   console.log(features);
     * });
     */
    featuresIn: function(bounds, params, callback) {
        if (typeof callback === 'undefined') {
            callback = params;
            params = bounds;
          // bounds was omitted: use full viewport
            bounds = [
                Point.convert([0, 0]),
                Point.convert([this.transform.width, this.transform.height])
            ];
        }
        bounds = bounds.map(Point.convert.bind(Point));
        bounds = [
            new Point(
            Math.min(bounds[0].x, bounds[1].x),
            Math.min(bounds[0].y, bounds[1].y)
          ),
            new Point(
            Math.max(bounds[0].x, bounds[1].x),
            Math.max(bounds[0].y, bounds[1].y)
          )
        ].map(this.transform.pointCoordinate.bind(this.transform));
        this.style.featuresIn(bounds, params, callback);
        return this;
    },

    /**
     * Apply multiple style mutations in a batch
     *
     * @param {function} work Function which accepts a `StyleBatch` object,
     *      a subset of `Map`, with `addLayer`, `removeLayer`,
     *      `setPaintProperty`, `setLayoutProperty`, `setFilter`,
     *      `setLayerZoomRange`, `addSource`, and `removeSource`
     *
     * @example
     * map.batch(function (batch) {
     *     batch.addLayer(layer1);
     *     batch.addLayer(layer2);
     *     ...
     *     batch.addLayer(layerN);
     * });
     *
     */
    batch: function(work) {
        this.style.batch(work);

        this.style._cascade(this._classes);
        this._update(true);
    },

    /**
     * Replaces the map's style object
     *
     * @param {Object} style A style object formatted as JSON
     * @returns {Map} `this`
     */
    setStyle: function(style) {
        if (this.style) {
            this.style
                .off('load', this._onStyleLoad)
                .off('error', this._forwardStyleEvent)
                .off('change', this._onStyleChange)
                .off('source.add', this._onSourceAdd)
                .off('source.remove', this._onSourceRemove)
                .off('source.load', this._onSourceUpdate)
                .off('source.error', this._forwardSourceEvent)
                .off('source.change', this._onSourceUpdate)
                .off('layer.add', this._forwardLayerEvent)
                .off('layer.remove', this._forwardLayerEvent)
                .off('tile.add', this._forwardTileEvent)
                .off('tile.remove', this._forwardTileEvent)
                .off('tile.load', this._update)
                .off('tile.error', this._forwardTileEvent)
                .off('tile.stats', this._forwardTileEvent)
                ._remove();

            this.off('rotate', this.style._redoPlacement);
            this.off('pitch', this.style._redoPlacement);
        }

        if (!style) {
            this.style = null;
            return this;
        } else if (style instanceof Style) {
            this.style = style;
        } else {
            this.style = new Style(style, this.animationLoop);
        }

        this.style
            .on('load', this._onStyleLoad)
            .on('error', this._forwardStyleEvent)
            .on('change', this._onStyleChange)
            .on('source.add', this._onSourceAdd)
            .on('source.remove', this._onSourceRemove)
            .on('source.load', this._onSourceUpdate)
            .on('source.error', this._forwardSourceEvent)
            .on('source.change', this._onSourceUpdate)
            .on('layer.add', this._forwardLayerEvent)
            .on('layer.remove', this._forwardLayerEvent)
            .on('tile.add', this._forwardTileEvent)
            .on('tile.remove', this._forwardTileEvent)
            .on('tile.load', this._update)
            .on('tile.error', this._forwardTileEvent)
            .on('tile.stats', this._forwardTileEvent);

        this.on('rotate', this.style._redoPlacement);
        this.on('pitch', this.style._redoPlacement);

        return this;
    },

    /**
     * Add a source to the map style.
     *
     * @param {string} id ID of the source. Must not be used by any existing source.
     * @param {Object} source source specification, following the
     * [Mapbox GL Style Reference](https://www.mapbox.com/mapbox-gl-style-spec/#sources)
     * @fires source.add
     * @returns {Map} `this`
     */
    addSource: function(id, source) {
        this.style.addSource(id, source);
        return this;
    },

    /**
     * Remove an existing source from the map style.
     *
     * @param {string} id ID of the source to remove
     * @fires source.remove
     * @returns {Map} `this`
     */
    removeSource: function(id) {
        this.style.removeSource(id);
        return this;
    },

    /**
     * Return the style source object with the given `id`.
     *
     * @param {string} id source ID
     * @returns {Object}
     */
    getSource: function(id) {
        return this.style.getSource(id);
    },

    /**
     * Add a layer to the map style. The layer will be inserted before the layer with
     * ID `before`, or appended if `before` is omitted.
     * @param {StyleLayer|Object} layer
     * @param {string=} before  ID of an existing layer to insert before
     * @fires layer.add
     * @returns {Map} `this`
     */
    addLayer: function(layer, before) {
        this.style.addLayer(layer, before);
        this.style._cascade(this._classes);
        return this;
    },

    /**
     * Remove the layer with the given `id` from the map. Any layers which refer to the
     * specified layer via a `ref` property are also removed.
     *
     * @param {string} id layer id
     * @throws {Error} if no layer with the given `id` exists
     * @fires layer.remove
     * @returns {Map} `this`
     */
    removeLayer: function(id) {
        this.style.removeLayer(id);
        this.style._cascade(this._classes);
        return this;
    },

    /**
     * Return the style layer object with the given `id`.
     *
     * @param {string} id layer id
     * @returns {?Object} a layer, if one with the given `id` exists
     */
    getLayer: function(id) {
        return this.style.getLayer(id);
    },

    /**
     * Set the filter for a given style layer.
     *
     * @param {string} layer ID of a layer
     * @param {Array} filter filter specification, as defined in the [Style Specification](https://www.mapbox.com/mapbox-gl-style-spec/#types-filter)
     * @returns {Map} `this`
     */
    setFilter: function(layer, filter) {
        this.style.setFilter(layer, filter);
        return this;
    },

    /**
     * Set the zoom extent for a given style layer.
     *
     * @param {string} layerId ID of a layer
     * @param {number} minzoom minimum zoom extent
     * @param {number} maxzoom maximum zoom extent
     * @returns {Map} `this`
     */
    setLayerZoomRange: function(layerId, minzoom, maxzoom) {
        this.style.setLayerZoomRange(layerId, minzoom, maxzoom);
        return this;
    },

    /**
     * Get the filter for a given style layer.
     *
     * @param {string} layer ID of a layer
     * @returns {Array} filter specification, as defined in the [Style Specification](https://www.mapbox.com/mapbox-gl-style-spec/#filter)
     */
    getFilter: function(layer) {
        return this.style.getFilter(layer);
    },

    /**
     * Set the value of a paint property in a given style layer.
     *
     * @param {string} layer ID of a layer
     * @param {string} name name of a paint property
     * @param {*} value value for the paint propery; must have the type appropriate for the property as defined in the [Style Specification](https://www.mapbox.com/mapbox-gl-style-spec/)
     * @param {string=} klass optional class specifier for the property
     * @returns {Map} `this`
     */
    setPaintProperty: function(layer, name, value, klass) {
        this.batch(function(batch) {
            batch.setPaintProperty(layer, name, value, klass);
        });

        return this;
    },

    /**
     * Get the value of a paint property in a given style layer.
     *
     * @param {string} layer ID of a layer
     * @param {string} name name of a paint property
     * @param {string=} klass optional class specifier for the property
     * @returns {*} value for the paint propery
     */
    getPaintProperty: function(layer, name, klass) {
        return this.style.getPaintProperty(layer, name, klass);
    },

    /**
     * Set the value of a layout property in a given style layer.
     *
     * @param {string} layer ID of a layer
     * @param {string} name name of a layout property
     * @param {*} value value for the layout propery; must have the type appropriate for the property as defined in the [Style Specification](https://www.mapbox.com/mapbox-gl-style-spec/)
     * @returns {Map} `this`
     */
    setLayoutProperty: function(layer, name, value) {
        this.batch(function(batch) {
            batch.setLayoutProperty(layer, name, value);
        });

        return this;
    },

    /**
     * Get the value of a layout property in a given style layer.
     *
     * @param {string} layer ID of a layer
     * @param {string} name name of a layout property
     * @param {string=} klass optional class specifier for the property
     * @returns {*} value for the layout propery
     */
    getLayoutProperty: function(layer, name) {
        return this.style.getLayoutProperty(layer, name);
    },

    /**
     * Get the Map's container as an HTML element
     * @returns {HTMLElement} container
     */
    getContainer: function() {
        return this._container;
    },

    /**
     * Get the container for the map `canvas` element.
     *
     * If you want to add non-GL overlays to the map, you should append them to this element. This
     * is the element to which event bindings for map interactivity such as panning and zooming are
     * attached. It will receive bubbled events for child elements such as the `canvas`, but not for
     * map controls.
     *
     * @returns {HTMLElement} container
     */
    getCanvasContainer: function() {
        return this._canvasContainer;
    },

    /**
     * Get the Map's canvas as an HTML canvas
     * @returns {HTMLElement} canvas
     */
    getCanvas: function() {
        return this._canvas.getElement();
    },

    _setupContainer: function() {
        var id = this.options.container;

        var container = this._container = typeof id === 'string' ? document.getElementById(id) : id;
        container.classList.add('mapboxgl-map');

        var canvasContainer = this._canvasContainer = DOM.create('div', 'mapboxgl-canvas-container', container);
        if (this.options.interactive) {
            canvasContainer.classList.add('mapboxgl-interactive');
        }
        this._canvas = new Canvas(this, canvasContainer);

        var controlContainer = this._controlContainer = DOM.create('div', 'mapboxgl-control-container', container);
        var corners = this._controlCorners = {};
        ['top-left', 'top-right', 'bottom-left', 'bottom-right'].forEach(function (pos) {
            corners[pos] = DOM.create('div', 'mapboxgl-ctrl-' + pos, controlContainer);
        });
    },

    _setupPainter: function() {
        var gl = this._canvas.getWebGLContext({
            failIfMajorPerformanceCaveat: this.options.failIfMajorPerformanceCaveat,
            preserveDrawingBuffer: this.options.preserveDrawingBuffer
        });

        if (!gl) {
            console.error('Failed to initialize WebGL');
            return;
        }

        this.painter = new Painter(gl, this.transform);
    },

    /**
     * WebGL Context Lost event.
     *
     * @event webglcontextlost
     * @memberof Map
     * @instance
     * @type {Object}
     * @property {Event} originalEvent the original DOM event
     */
    _contextLost: function(event) {
        event.preventDefault();
        if (this._frameId) {
            browser.cancelFrame(this._frameId);
        }
        this.fire("webglcontextlost", {originalEvent: event});
    },

    /**
     * WebGL Context Restored event.
     *
     * @event webglcontextrestored
     * @memberof Map
     * @instance
     * @type {Object}
     */
    _contextRestored: function(event) {
        this._setupPainter();
        this.resize();
        this._update();
        this.fire("webglcontextrestored", {originalEvent: event});
    },

    /**
     * Is this map fully loaded? If the style isn't loaded
     * or it has a change to the sources or style that isn't
     * propagated to its style, return false.
     *
     * @returns {boolean} whether the map is loaded
     */
    loaded: function() {
        if (this._styleDirty || this._sourcesDirty)
            return false;
        if (this.style && !this.style.loaded())
            return false;
        return true;
    },

    /**
     * Update this map's style and sources, and re-render the map.
     *
     * @param {boolean} updateStyle mark the map's style for reprocessing as
     * well as its sources
     * @returns {Map} this
     * @private
     */
    _update: function(updateStyle) {
        if (!this.style) return this;

        this._styleDirty = this._styleDirty || updateStyle;
        this._sourcesDirty = true;

        this._rerender();

        return this;
    },

    /**
     * Call when a (re-)render of the map is required, e.g. when the
     * user panned or zoomed,f or new data is available.
     * @returns {Map} this
     * @private
     */
    _render: function() {
        if (this.style && this._styleDirty) {
            this._styleDirty = false;
            this.style._recalculate(this.transform.zoom);
        }

        if (this.style && this._sourcesDirty && !this._sourcesDirtyTimeout) {
            this._sourcesDirty = false;
            this._sourcesDirtyTimeout = setTimeout(function() {
                this._sourcesDirtyTimeout = null;
            }.bind(this), 50);
            this.style._updateSources(this.transform);
        }

        this.painter.render(this.style, {
            debug: this.debug,
            vertices: this.vertices,
            rotating: this.rotating,
            zooming: this.zooming
        });

        this.fire('render');

        if (this.loaded() && !this._loaded) {
            this._loaded = true;
            this.fire('load');
        }

        this._frameId = null;

        if (!this.animationLoop.stopped()) {
            this._styleDirty = true;
        }

        if (this._sourcesDirty || this._repaint || !this.animationLoop.stopped()) {
            this._rerender();
        }

        return this;
    },

    /**
     * Destroys the map's underlying resources, including web workers and DOM elements. Afterwards,
     * you must not call any further methods on this Map instance.
     *
     * @returns {undefined}
     */
    remove: function() {
        if (this._hash) this._hash.remove();
        browser.cancelFrame(this._frameId);
        clearTimeout(this._sourcesDirtyTimeout);
        this.setStyle(null);
        if (typeof window !== 'undefined') {
            window.removeEventListener('resize', this._onWindowResize, false);
        }
        removeNode(this._canvasContainer);
        removeNode(this._controlContainer);
        this._container.classList.remove('mapboxgl-map');
    },

    /**
     * A default error handler for `style.error`, `source.error`, and `tile.error` events.
     * It logs the error via `console.error`.
     *
     * @example
     * // Disable the default error handler
     * map.off('style.error', map.onError);
     * map.off('source.error', map.onError);
     * map.off('tile.error', map.onError);
     */
    onError: function(e) {
        console.error(e.error);
    },

    _rerender: function() {
        if (this.style && !this._frameId) {
            this._frameId = browser.frame(this._render);
        }
    },

    _forwardStyleEvent: function(e) {
        this.fire('style.' + e.type, util.extend({style: e.target}, e));
    },

    _forwardSourceEvent: function(e) {
        this.fire(e.type, util.extend({style: e.target}, e));
    },

    _forwardLayerEvent: function(e) {
        this.fire(e.type, util.extend({style: e.target}, e));
    },

    _forwardTileEvent: function(e) {
        this.fire(e.type, util.extend({style: e.target}, e));
    },

    _onStyleLoad: function(e) {
        if (this.transform.unmodified) {
            this.jumpTo(this.style.stylesheet);
        }
        this.style._cascade(this._classes, {transition: false});
        this._forwardStyleEvent(e);
    },

    _onStyleChange: function(e) {
        this._update(true);
        this._forwardStyleEvent(e);
    },

    _onSourceAdd: function(e) {
        var source = e.source;
        if (source.onAdd)
            source.onAdd(this);
        this._forwardSourceEvent(e);
    },

    _onSourceRemove: function(e) {
        var source = e.source;
        if (source.onRemove)
            source.onRemove(this);
        this._forwardSourceEvent(e);
    },

    _onSourceUpdate: function(e) {
        this._update();
        this._forwardSourceEvent(e);
    },

    _onWindowResize: function() {
        this.stop().resize()._update();
    }
});


/**
 * Callback to receive results from `Map#featuresAt` and `Map#featuresIn`.
 *
 * Note: because features come from vector tiles or GeoJSON data that is converted to vector tiles internally, the returned features will be:
 *
 * 1. Truncated at tile boundaries.
 * 2. Duplicated across tile boundaries.
 *
 * For example, suppose there is a highway running through your rectangle in a `featuresIn` query. `featuresIn` will only give you the parts of the highway feature that lie within the map tiles covering your rectangle, even if the road actually extends into other tiles. Also, the portion of the highway within each map tile will come back as a separate feature.
 *
 * @callback featuresCallback
 * @param {?Error} err - An error that occurred during query processing, if any. If this parameter is non-null, the `features` parameter will be null.
 * @param {?Array<Object>} features - An array of [GeoJSON](http://geojson.org/) features matching the query parameters. The GeoJSON properties of each feature are taken from the original source. Each feature object also contains a top-level `layer` property whose value is an object representing the style layer to which the feature belongs. Layout and paint properties in this object contain values which are fully evaluated for the given zoom level and feature.
 */


util.extendAll(Map.prototype, /** @lends Map.prototype */{

    /**
     * Enable debugging mode
     *
     * @name debug
     * @type {boolean}
     */
    _debug: false,
    get debug() { return this._debug; },
    set debug(value) { this._debug = value; this._update(); },

    /**
     * Show collision boxes: useful for debugging label placement
     * in styles.
     *
     * @name collisionDebug
     * @type {boolean}
     */
    _collisionDebug: false,
    get collisionDebug() { return this._collisionDebug; },
    set collisionDebug(value) {
        this._collisionDebug = value;
        this.style._redoPlacement();
    },

    /**
     * Enable continuous repaint to analyze performance
     *
     * @name repaint
     * @type {boolean}
     */
    _repaint: false,
    get repaint() { return this._repaint; },
    set repaint(value) { this._repaint = value; this._update(); },

    // show vertices
    _vertices: false,
    get vertices() { return this._vertices; },
    set vertices(value) { this._vertices = value; this._update(); }
});

function removeNode(node) {
    if (node.parentNode) {
        node.parentNode.removeChild(node);
    }
}

},{"../geo/lng_lat":10,"../geo/lng_lat_bounds":11,"../geo/transform":12,"../render/painter":26,"../style/animation_loop":40,"../style/style":45,"../util/browser":83,"../util/canvas":84,"../util/dom":86,"../util/evented":88,"../util/util":94,"./camera":66,"./control/attribution":67,"./hash":77,"./interaction":78,"point-geometry":130}],80:[function(require,module,exports){
'use strict';

module.exports = Popup;

var util = require('../util/util');
var Evented = require('../util/evented');
var DOM = require('../util/dom');
var LngLat = require('../geo/lng_lat');

/**
 * Creates a popup component
 * @class Popup
 * @param {Object} options
 * @param {boolean} options.closeButton
 * @param {boolean} options.closeOnClick
 * @param {string} options.anchor - One of "top", "bottom", "left", "right", "top-left",
 * "top-right", "bottom-left", or "bottom-right", describing where the popup's anchor
 * relative to the coordinate set via `setLngLat`.
 * @example
 * var tooltip = new mapboxgl.Popup()
 *   .setLngLat(e.lngLat)
 *   .setHTML("<h1>Hello World!</h1>")
 *   .addTo(map);
 */
function Popup(options) {
    util.setOptions(this, options);
    util.bindAll([
        '_update',
        '_onClickClose'],
        this);
}

Popup.prototype = util.inherit(Evented, /** @lends Popup.prototype */{
    options: {
        closeButton: true,
        closeOnClick: true
    },

    /**
     * Attaches the popup to a map
     * @param {Map} map
     * @returns {Popup} `this`
     */
    addTo: function(map) {
        this._map = map;
        this._map.on('move', this._update);
        if (this.options.closeOnClick) {
            this._map.on('click', this._onClickClose);
        }
        this._update();
        return this;
    },

    /**
     * Removes the popup from the map
     * @example
     * var popup = new mapboxgl.Popup().addTo(map);
     * popup.remove();
     * @returns {Popup} `this`
     */
    remove: function() {
        if (this._content && this._content.parentNode) {
            this._content.parentNode.removeChild(this._content);
        }

        if (this._container) {
            this._container.parentNode.removeChild(this._container);
            delete this._container;
        }

        if (this._map) {
            this._map.off('move', this._update);
            this._map.off('click', this._onClickClose);
            delete this._map;
        }

        return this;
    },

    /**
     * Get the current coordinates of popup element relative to map
     * @returns {LngLat}
     */
    getLngLat: function() {
        return this._lngLat;
    },

    /**
     * Set the coordinates of a popup element to a map
     * @param {LngLat} lnglat
     * @returns {Popup} `this`
     */
    setLngLat: function(lnglat) {
        this._lngLat = LngLat.convert(lnglat);
        this._update();
        return this;
    },

    /**
     * Fill a popup element with text only content
     * @param {string} text
     * @returns {Popup} `this`
     */
    setText: function(text) {
        this._createContent();
        this._content.appendChild(document.createTextNode(text));

        this._update();
        return this;
    },

    /**
     * Fill a popup element with HTML content
     * @param {string} html
     * @returns {Popup} `this`
     */
    setHTML: function(html) {
        this._createContent();

        var temp = document.createElement('body'), child;
        temp.innerHTML = html;
        while (true) {
            child = temp.firstChild;
            if (!child) break;
            this._content.appendChild(child);
        }

        this._update();
        return this;
    },

    _createContent: function() {
        if (this._content && this._content.parentNode) {
            this._content.parentNode.removeChild(this._content);
        }

        this._content = DOM.create('div', 'mapboxgl-popup-content', this._container);

        if (this.options.closeButton) {
            this._closeButton = DOM.create('button', 'mapboxgl-popup-close-button', this._content);
            this._closeButton.innerHTML = '&#215;';
            this._closeButton.addEventListener('click', this._onClickClose);
        }
    },

    _update: function() {
        if (!this._map || !this._lngLat || !this._content) { return; }

        if (!this._container) {
            this._container = DOM.create('div', 'mapboxgl-popup', this._map.getContainer());
            this._tip       = DOM.create('div', 'mapboxgl-popup-tip', this._container);
            this._container.appendChild(this._content);
        }

        var pos = this._map.project(this._lngLat).round(),
            anchor = this.options.anchor;

        if (!anchor) {
            var width = this._container.offsetWidth,
                height = this._container.offsetHeight;

            if (pos.y < height) {
                anchor = ['top'];
            } else if (pos.y > this._map.transform.height - height) {
                anchor = ['bottom'];
            } else {
                anchor = [];
            }

            if (pos.x < width / 2) {
                anchor.push('left');
            } else if (pos.x > this._map.transform.width - width / 2) {
                anchor.push('right');
            }

            if (anchor.length === 0) {
                anchor = 'bottom';
            } else {
                anchor = anchor.join('-');
            }
        }

        var anchorTranslate = {
            'top': 'translate(-50%,0)',
            'top-left': 'translate(0,0)',
            'top-right': 'translate(-100%,0)',
            'bottom': 'translate(-50%,-100%)',
            'bottom-left': 'translate(0,-100%)',
            'bottom-right': 'translate(-100%,-100%)',
            'left': 'translate(0,-50%)',
            'right': 'translate(-100%,-50%)'
        };

        var classList = this._container.classList;
        for (var key in anchorTranslate) {
            classList.remove('mapboxgl-popup-anchor-' + key);
        }
        classList.add('mapboxgl-popup-anchor-' + anchor);

        DOM.setTransform(this._container, anchorTranslate[anchor] + ' translate(' + pos.x + 'px,' + pos.y + 'px)');
    },

    _onClickClose: function() {
        this.remove();
    }
});

},{"../geo/lng_lat":10,"../util/dom":86,"../util/evented":88,"../util/util":94}],81:[function(require,module,exports){
'use strict';

module.exports = Actor;

/**
 * An implementation of the [Actor design pattern](http://en.wikipedia.org/wiki/Actor_model)
 * that maintains the relationship between asynchronous tasks and the objects
 * that spin them off - in this case, tasks like parsing parts of styles,
 * owned by the styles
 *
 * @param {WebWorker} target
 * @param {WebWorker} parent
 * @private
 */
function Actor(target, parent) {
    this.target = target;
    this.parent = parent;
    this.callbacks = {};
    this.callbackID = 0;
    this.receive = this.receive.bind(this);
    this.target.addEventListener('message', this.receive, false);
}

Actor.prototype.receive = function(message) {
    var data = message.data,
        callback;

    if (data.type === '<response>') {
        callback = this.callbacks[data.id];
        delete this.callbacks[data.id];
        callback(data.error || null, data.data);
    } else if (typeof data.id !== 'undefined') {
        var id = data.id;
        this.parent[data.type](data.data, function(err, data, buffers) {
            this.postMessage({
                type: '<response>',
                id: String(id),
                error: err ? String(err) : null,
                data: data
            }, buffers);
        }.bind(this));
    } else {
        this.parent[data.type](data.data);
    }
};

Actor.prototype.send = function(type, data, callback, buffers) {
    var id = null;
    if (callback) this.callbacks[id = this.callbackID++] = callback;
    this.postMessage({ type: type, id: String(id), data: data }, buffers);
};

/**
 * Wrapped postMessage API that abstracts around IE's lack of
 * `transferList` support.
 *
 * @param {Object} message
 * @param {Object} transferList
 * @private
 */
Actor.prototype.postMessage = function(message, transferList) {
    try {
        this.target.postMessage(message, transferList);
    } catch (e) {
        this.target.postMessage(message); // No support for transferList on IE
    }
};

},{}],82:[function(require,module,exports){
'use strict';

exports.getJSON = function(url, callback) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, true);
    xhr.setRequestHeader('Accept', 'application/json');
    xhr.onerror = function(e) {
        callback(e);
    };
    xhr.onload = function() {
        if (xhr.status >= 200 && xhr.status < 300 && xhr.response) {
            var data;
            try {
                data = JSON.parse(xhr.response);
            } catch (err) {
                return callback(err);
            }
            callback(null, data);
        } else {
            callback(new Error(xhr.statusText));
        }
    };
    xhr.send();
    return xhr;
};

exports.getArrayBuffer = function(url, callback) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, true);
    xhr.responseType = 'arraybuffer';
    xhr.onerror = function(e) {
        callback(e);
    };
    xhr.onload = function() {
        if (xhr.status >= 200 && xhr.status < 300 && xhr.response) {
            callback(null, xhr.response);
        } else {
            callback(new Error(xhr.statusText));
        }
    };
    xhr.send();
    return xhr;
};

function sameOrigin(url) {
    var a = document.createElement('a');
    a.href = url;
    return a.protocol === document.location.protocol && a.host === document.location.host;
}

exports.getImage = function(url, callback) {
    return exports.getArrayBuffer(url, function(err, imgData) {
        if (err) return callback(err);
        var img = new Image();
        img.onload = function() {
            callback(null, img);
            (window.URL || window.webkitURL).revokeObjectURL(img.src);
        };
        var blob = new Blob([new Uint8Array(imgData)], { type: 'image/png' });
        img.src = (window.URL || window.webkitURL).createObjectURL(blob);
        img.getData = function() {
            var canvas = document.createElement('canvas');
            var context = canvas.getContext('2d');
            canvas.width = img.width;
            canvas.height = img.height;
            context.drawImage(img, 0, 0);
            return context.getImageData(0, 0, img.width, img.height).data;
        };
        return img;
    });
};

exports.getVideo = function(urls, callback) {
    var video = document.createElement('video');
    video.onloadstart = function() {
        callback(null, video);
    };
    for (var i = 0; i < urls.length; i++) {
        var s = document.createElement('source');
        if (!sameOrigin(urls[i])) {
            video.crossOrigin = 'Anonymous';
        }
        s.src = urls[i];
        video.appendChild(s);
    }
    video.getData = function() { return video; };
    return video;
};

},{}],83:[function(require,module,exports){
'use strict';

var Canvas = require('./canvas');

var frame = window.requestAnimationFrame ||
    window.mozRequestAnimationFrame ||
    window.webkitRequestAnimationFrame ||
    window.msRequestAnimationFrame;

exports.frame = function(fn) {
    return frame(fn);
};

var cancel = window.cancelAnimationFrame ||
    window.mozCancelAnimationFrame ||
    window.webkitCancelAnimationFrame ||
    window.msCancelAnimationFrame;

exports.cancelFrame = function(id) {
    cancel(id);
};

exports.timed = function (fn, dur, ctx) {
    if (!dur) {
        fn.call(ctx, 1);
        return null;
    }

    var abort = false,
        start = window.performance ? window.performance.now() : Date.now();

    function tick(now) {
        if (abort) return;
        if (!window.performance) now = Date.now();

        if (now >= start + dur) {
            fn.call(ctx, 1);
        } else {
            fn.call(ctx, (now - start) / dur);
            exports.frame(tick);
        }
    }

    exports.frame(tick);

    return function() { abort = true; };
};

/**
 * Test whether the basic JavaScript and DOM features required for Mapbox GL are present.
 * @param {Object} options
 * @param {boolean} [options.failIfMajorPerformanceCaveat=false] If `true`, map creation will fail if the implementation determines that the performance of the created WebGL context would be dramatically lower than expected.
 * @return {boolean} Returns true if Mapbox GL should be expected to work, and false if not.
 * @memberof mapboxgl
 * @static
 */
exports.supported = function(options) {

    var supports = [

        function() { return typeof window !== 'undefined'; },

        function() { return typeof document !== 'undefined'; },

        function () {
            return !!(Array.prototype &&
                Array.prototype.every &&
                Array.prototype.filter &&
                Array.prototype.forEach &&
                Array.prototype.indexOf &&
                Array.prototype.lastIndexOf &&
                Array.prototype.map &&
                Array.prototype.some &&
                Array.prototype.reduce &&
                Array.prototype.reduceRight &&
                Array.isArray);
        },

        function() {
            return !!(Function.prototype && Function.prototype.bind) &&
                !!(Object.keys &&
                    Object.create &&
                    Object.getPrototypeOf &&
                    Object.getOwnPropertyNames &&
                    Object.isSealed &&
                    Object.isFrozen &&
                    Object.isExtensible &&
                    Object.getOwnPropertyDescriptor &&
                    Object.defineProperty &&
                    Object.defineProperties &&
                    Object.seal &&
                    Object.freeze &&
                    Object.preventExtensions);
        },

        function() {
            return 'JSON' in window && 'parse' in JSON && 'stringify' in JSON;
        },

        function() {
            return new Canvas().supportsWebGLContext((options && options.failIfMajorPerformanceCaveat) || false);
        },

        function() { return 'Worker' in window; }
    ];

    for (var i = 0; i < supports.length; i++) {
        if (!supports[i]()) return false;
    }
    return true;
};

exports.hardwareConcurrency = navigator.hardwareConcurrency || 8;

Object.defineProperty(exports, 'devicePixelRatio', {
    get: function() { return window.devicePixelRatio; }
});

exports.supportsWebp = false;

var webpImgTest = document.createElement('img');
webpImgTest.onload = function() {
    exports.supportsWebp = true;
};
webpImgTest.src = 'data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=';

},{"./canvas":84}],84:[function(require,module,exports){
'use strict';

var util = require('../util');

module.exports = Canvas;

function Canvas(parent, container) {
    this.canvas = document.createElement('canvas');

    if (parent && container) {
        this.canvas.style.position = 'absolute';
        this.canvas.classList.add('mapboxgl-canvas');
        this.canvas.addEventListener('webglcontextlost', parent._contextLost.bind(parent), false);
        this.canvas.addEventListener('webglcontextrestored', parent._contextRestored.bind(parent), false);
        this.canvas.setAttribute('tabindex', 0);
        container.appendChild(this.canvas);
    }
}

Canvas.prototype.resize = function(width, height) {
    var pixelRatio = window.devicePixelRatio || 1;

    // Request the required canvas size taking the pixelratio into account.
    this.canvas.width = pixelRatio * width;
    this.canvas.height = pixelRatio * height;

    // Maintain the same canvas size, potentially downscaling it for HiDPI displays
    this.canvas.style.width = width + 'px';
    this.canvas.style.height = height + 'px';
};

var requiredContextAttributes = {
    antialias: false,
    alpha: true,
    stencil: true,
    depth: true
};

Canvas.prototype.getWebGLContext = function(attributes) {
    attributes = util.extend({}, attributes, requiredContextAttributes);

    return this.canvas.getContext('webgl', attributes) ||
        this.canvas.getContext('experimental-webgl', attributes);
};

Canvas.prototype.supportsWebGLContext = function(failIfMajorPerformanceCaveat) {
    var attributes = util.extend({
        failIfMajorPerformanceCaveat: failIfMajorPerformanceCaveat
    }, requiredContextAttributes);

    if ('probablySupportsContext' in this.canvas) {
        return this.canvas.probablySupportsContext('webgl', attributes) ||
            this.canvas.probablySupportsContext('experimental-webgl', attributes);
    } else if ('supportsContext' in this.canvas) {
        return this.canvas.supportsContext('webgl', attributes) ||
            this.canvas.supportsContext('experimental-webgl', attributes);
    }

    return !!window.WebGLRenderingContext && !!this.getWebGLContext(failIfMajorPerformanceCaveat);
};

Canvas.prototype.getElement = function() {
    return this.canvas;
};

},{"../util":94}],85:[function(require,module,exports){
'use strict';

var Actor = require('../actor');
var WebWorkify = require('webworkify');

module.exports = Dispatcher;

function Dispatcher(length, parent) {
    this.actors = [];
    this.currentActor = 0;
    for (var i = 0; i < length; i++) {
        var worker = new WebWorkify(require('../../source/worker'));
        var actor = new Actor(worker, parent);
        actor.name = "Worker " + i;
        this.actors.push(actor);
    }
}

Dispatcher.prototype = {
    broadcast: function(type, data) {
        for (var i = 0; i < this.actors.length; i++) {
            this.actors[i].send(type, data);
        }
    },

    send: function(type, data, callback, targetID, buffers) {
        if (typeof targetID !== 'number' || isNaN(targetID)) {
            // Use round robin to send requests to web workers.
            targetID = this.currentActor = (this.currentActor + 1) % this.actors.length;
        }

        this.actors[targetID].send(type, data, callback, buffers);
        return targetID;
    },

    remove: function() {
        for (var i = 0; i < this.actors.length; i++) {
            this.actors[i].target.terminate();
        }
        this.actors = [];
    }
};

},{"../../source/worker":38,"../actor":81,"webworkify":138}],86:[function(require,module,exports){
'use strict';

var Point = require('point-geometry');

exports.create = function (tagName, className, container) {
    var el = document.createElement(tagName);
    if (className) el.className = className;
    if (container) container.appendChild(el);
    return el;
};

var docStyle = document.documentElement.style;

function testProp(props) {
    for (var i = 0; i < props.length; i++) {
        if (props[i] in docStyle) {
            return props[i];
        }
    }
}

var selectProp = testProp(['userSelect', 'MozUserSelect', 'WebkitUserSelect', 'msUserSelect']),
    userSelect;
exports.disableDrag = function () {
    if (selectProp) {
        userSelect = docStyle[selectProp];
        docStyle[selectProp] = 'none';
    }
};
exports.enableDrag = function () {
    if (selectProp) {
        docStyle[selectProp] = userSelect;
    }
};

var transformProp = testProp(['transform', 'WebkitTransform']);
exports.setTransform = function(el, value) {
    el.style[transformProp] = value;
};

// Suppress the next click, but only if it's immediate.
function suppressClick(e) {
    e.preventDefault();
    e.stopPropagation();
    window.removeEventListener('click', suppressClick, true);
}
exports.suppressClick = function() {
    window.addEventListener('click', suppressClick, true);
    window.setTimeout(function() {
        window.removeEventListener('click', suppressClick, true);
    }, 0);
};

exports.mousePos = function (el, e) {
    var rect = el.getBoundingClientRect();
    e = e.touches ? e.touches[0] : e;
    return new Point(
        e.clientX - rect.left - el.clientLeft,
        e.clientY - rect.top - el.clientTop);
};

},{"point-geometry":130}],87:[function(require,module,exports){
'use strict';

module.exports = {
    API_URL: 'https://api.mapbox.com',
    REQUIRE_ACCESS_TOKEN: true
};

},{}],88:[function(require,module,exports){
'use strict';

var util = require('./util');

/**
 * Methods mixed in to other classes for event capabilities.
 * @mixin Evented
 */
var Evented = {

    /**
     * Subscribe to a specified event with a listener function the latter gets the data object that was passed to `fire` and additionally `target` and `type` properties
     *
     * @param {string} type Event type
     * @param {Function} listener Function to be called when the event is fired
     */
    on: function(type, fn) {
        this._events = this._events || {};
        this._events[type] = this._events[type] || [];
        this._events[type].push(fn);

        return this;
    },

    /**
     * Remove a event listener
     *
     * @param {string} [type] Event type. If none is specified, remove all listeners
     * @param {Function} [listener] Function to be called when the event is fired. If none is specified all listeners are removed
     */
    off: function(type, fn) {
        if (!type) {
            // clear all listeners if no arguments specified
            delete this._events;
            return this;
        }

        if (!this.listens(type)) return this;

        if (fn) {
            var idx = this._events[type].indexOf(fn);
            if (idx >= 0) {
                this._events[type].splice(idx, 1);
            }
            if (!this._events[type].length) {
                delete this._events[type];
            }
        } else {
            delete this._events[type];
        }

        return this;
    },

    /**
     * Call a function once when an event has fired
     *
     * @param {string} type Event type.
     * @param {Function} listener Function to be called once when the event is fired
     */
    once: function(type, fn) {
        var wrapper = function(data) {
            this.off(type, wrapper);
            fn.call(this, data);
        }.bind(this);
        this.on(type, wrapper);
        return this;
    },

    /**
     * Fire event of a given string type with the given data object
     *
     * @param {string} type Event type
     * @param {Object} [data] Optional data passed down to the event object
     * @returns {Object} `this`
     */
    fire: function(type, data) {
        if (!this.listens(type)) return this;

        data = util.extend({}, data);
        util.extend(data, {type: type, target: this});

        // make sure adding/removing listeners inside other listeners won't cause infinite loop
        var listeners = this._events[type].slice();

        for (var i = 0; i < listeners.length; i++) {
            listeners[i].call(this, data);
        }

        return this;
    },

    /**
     * Check if an event is registered to a type
     * @param {string} type Event type
     * @returns {boolean} `true` if there is at least one registered listener for events of type `type`
     */
    listens: function(type) {
        return !!(this._events && this._events[type]);
    }
};

module.exports = Evented;

},{"./util":94}],89:[function(require,module,exports){
'use strict';

module.exports = Glyphs;

function Glyphs(pbf, end) {
    this.stacks = pbf.readFields(readFontstacks, [], end);
}

function readFontstacks(tag, stacks, pbf) {
    if (tag === 1) {
        var fontstack = pbf.readMessage(readFontstack, {glyphs: {}});
        stacks.push(fontstack);
    }
}

function readFontstack(tag, fontstack, pbf) {
    if (tag === 1) fontstack.name = pbf.readString();
    else if (tag === 2) fontstack.range = pbf.readString();
    else if (tag === 3) {
        var glyph = pbf.readMessage(readGlyph, {});
        fontstack.glyphs[glyph.id] = glyph;
    }
}

function readGlyph(tag, glyph, pbf) {
    if (tag === 1) glyph.id = pbf.readVarint();
    else if (tag === 2) glyph.bitmap = pbf.readBytes();
    else if (tag === 3) glyph.width = pbf.readVarint();
    else if (tag === 4) glyph.height = pbf.readVarint();
    else if (tag === 5) glyph.left = pbf.readSVarint();
    else if (tag === 6) glyph.top = pbf.readSVarint();
    else if (tag === 7) glyph.advance = pbf.readVarint();
}

},{}],90:[function(require,module,exports){
'use strict';

module.exports = interpolate;

function interpolate(a, b, t) {
    return (a * (1 - t)) + (b * t);
}

interpolate.number = interpolate;

interpolate.vec2 = function(from, to, t) {
    return [
        interpolate(from[0], to[0], t),
        interpolate(from[1], to[1], t)
    ];
};

/*
 * Interpolate between two colors given as 4-element arrays.
 *
 * @param {Color} from
 * @param {Color} to
 * @param {number} t interpolation factor between 0 and 1
 * @returns {Color} interpolated color
 */
interpolate.color = function(from, to, t) {
    return [
        interpolate(from[0], to[0], t),
        interpolate(from[1], to[1], t),
        interpolate(from[2], to[2], t),
        interpolate(from[3], to[3], t)
    ];
};

interpolate.array = function(from, to, t) {
    return from.map(function(d, i) {
        return interpolate(d, to[i], t);
    });
};

},{}],91:[function(require,module,exports){
'use strict';

var config = require('./config');
var browser = require('./browser');

function normalizeURL(url, pathPrefix, accessToken) {
    accessToken = accessToken || config.ACCESS_TOKEN;

    if (!accessToken && config.REQUIRE_ACCESS_TOKEN) {
        throw new Error('An API access token is required to use Mapbox GL. ' +
            'See https://www.mapbox.com/developers/api/#access-tokens');
    }

    url = url.replace(/^mapbox:\/\//, config.API_URL + pathPrefix);
    url += url.indexOf('?') !== -1 ? '&access_token=' : '?access_token=';

    if (config.REQUIRE_ACCESS_TOKEN) {
        if (accessToken[0] === 's') {
            throw new Error('Use a public access token (pk.*) with Mapbox GL JS, not a secret access token (sk.*). ' +
                'See https://www.mapbox.com/developers/api/#access-tokens');
        }

        url += accessToken;
    }

    return url;
}

module.exports.normalizeStyleURL = function(url, accessToken) {
    if (!url.match(/^mapbox:\/\/styles\//))
        return url;

    var split = url.split('/');
    var user = split[3];
    var style = split[4];
    var draft = split[5] ? '/draft' : '';
    return normalizeURL('mapbox://' + user + '/' + style + draft, '/styles/v1/', accessToken);
};

module.exports.normalizeSourceURL = function(url, accessToken) {
    if (!url.match(/^mapbox:\/\//))
        return url;

    // TileJSON requests need a secure flag appended to their URLs so
    // that the server knows to send SSL-ified resource references.
    return normalizeURL(url + '.json', '/v4/', accessToken) + '&secure';
};

module.exports.normalizeGlyphsURL = function(url, accessToken) {
    if (!url.match(/^mapbox:\/\//))
        return url;

    var user = url.split('/')[3];
    return normalizeURL('mapbox://' + user + '/{fontstack}/{range}.pbf', '/fonts/v1/', accessToken);
};

module.exports.normalizeSpriteURL = function(url, format, ext, accessToken) {
    if (!url.match(/^mapbox:\/\/sprites\//))
        return url + format + ext;

    var split = url.split('/');
    var user = split[3];
    var style = split[4];
    var draft = split[5] ? '/draft' : '';
    return normalizeURL('mapbox://' + user + '/' + style + draft + '/sprite' + format + ext, '/styles/v1/', accessToken);
};

module.exports.normalizeTileURL = function(url, sourceUrl) {
    if (!sourceUrl || !sourceUrl.match(/^mapbox:\/\//))
        return url;

    url = url.replace(/([?&]access_token=)tk\.[^&]+/, '$1' + config.ACCESS_TOKEN);
    var extension = browser.supportsWebp ? 'webp' : '$1';
    return url.replace(/\.((?:png|jpg)\d*)(?=$|\?)/, browser.devicePixelRatio >= 2 ? '@2x.' + extension : '.' + extension);
};

},{"./browser":83,"./config":87}],92:[function(require,module,exports){
'use strict';

/**
 * A [most-recently-used cache](http://en.wikipedia.org/wiki/Cache_algorithms)
 * with hash lookup made possible by keeping a list of keys in parallel to
 * an array of dictionary of values
 *
 * @param {number} max number of permitted values
 * @param {Function} onRemove callback called with items when they expire
 * @private
 */
module.exports = MRUCache;
function MRUCache(max, onRemove) {
    this.max = max;
    this.onRemove = onRemove;
    this.reset();
}

/**
 * Clear the cache
 *
 * @returns {MRUCache} this cache
 * @private
 */
MRUCache.prototype.reset = function() {
    for (var key in this.list) {
        this.onRemove(this.list[key]);
    }

    this.list = {};
    this.order = [];

    return this;
};

/**
 * Add a key, value combination to the cache, trimming its size if this pushes
 * it over max length.
 *
 * @param {string} key lookup key for the item
 * @param {*} data any value
 *
 * @returns {MRUCache} this cache
 * @private
 */
MRUCache.prototype.add = function(key, data) {
    this.list[key] = data;
    this.order.push(key);

    if (this.order.length > this.max) {
        var removedData = this.get(this.order[0]);
        if (removedData) this.onRemove(removedData);
    }

    return this;
};

/**
 * Determine whether the value attached to `key` is present
 *
 * @param {string} key the key to be looked-up
 * @returns {boolean} whether the cache has this value
 * @private
 */
MRUCache.prototype.has = function(key) {
    return key in this.list;
};

/**
 * List all keys in the cache
 *
 * @returns {Array<string>} an array of keys in this cache.
 * @private
 */
MRUCache.prototype.keys = function() {
    return this.order;
};

/**
 * Get the value attached to a specific key. If the key is not found,
 * returns `null`
 *
 * @param {string} key the key to look up
 * @returns {*} the data, or null if it isn't found
 * @private
 */
MRUCache.prototype.get = function(key) {
    if (!this.has(key)) { return null; }

    var data = this.list[key];

    delete this.list[key];
    this.order.splice(this.order.indexOf(key), 1);

    return data;
};

},{}],93:[function(require,module,exports){
'use strict';

module.exports = resolveTokens;

/**
 * Replace tokens in a string template with values in an object
 *
 * @param {Object} properties a key/value relationship between tokens and replacements
 * @param {string} text the template string
 * @returns {string} the template with tokens replaced
 * @private
 */
function resolveTokens(properties, text) {
    return text.replace(/{([^{}()\[\]<>$=:;.,^]+)}/g, function(match, key) {
        return key in properties ? properties[key] : '';
    });
}

},{}],94:[function(require,module,exports){
'use strict';

var UnitBezier = require('unitbezier');
var Coordinate = require('../geo/coordinate');

/**
 * Given a value `t` that varies between 0 and 1, return
 * an interpolation function that eases between 0 and 1 in a pleasing
 * cubic in-out fashion.
 *
 * @param {number} t input
 * @returns {number} input
 * @private
 */
exports.easeCubicInOut = function (t) {
    if (t <= 0) return 0;
    if (t >= 1) return 1;
    var t2 = t * t,
        t3 = t2 * t;
    return 4 * (t < 0.5 ? t3 : 3 * (t - t2) + t3 - 0.75);
};

/**
 * Given given (x, y), (x1, y1) control points for a bezier curve,
 * return a function that interpolates along that curve.
 *
 * @param {number} p1x control point 1 x coordinate
 * @param {number} p1y control point 1 y coordinate
 * @param {number} p2x control point 2 x coordinate
 * @param {number} p2y control point 2 y coordinate
 * @returns {Function} interpolator: receives number value, returns
 * number value.
 * @private
 */
exports.bezier = function(p1x, p1y, p2x, p2y) {
    var bezier = new UnitBezier(p1x, p1y, p2x, p2y);
    return function(t) {
        return bezier.solve(t);
    };
};

/**
 * A default bezier-curve powered easing function with
 * control points (0.25, 0.1) and (0.25, 1)
 *
 * @param {number} t
 * @returns {number} output
 * @private
 */
exports.ease = exports.bezier(0.25, 0.1, 0.25, 1);

/**
 * Given a four-element array of numbers that represents a color in
 * RGBA, return a version for which the RGB components are multiplied
 * by the A (alpha) component
 *
 * @param {Array<number>} c color array
 * @returns {Array<number>} premultiplied color array
 * @private
 */
exports.premultiply = function (c) {
    c[0] *= c[3];
    c[1] *= c[3];
    c[2] *= c[3];
    return c;
};

/**
 * constrain n to the given range via min + max
 *
 * @param {number} n value
 * @param {number} min the minimum value to be returned
 * @param {number} max the maximum value to be returned
 * @returns {number} the clamped value
 * @private
 */
exports.clamp = function (n, min, max) {
    return Math.min(max, Math.max(min, n));
};

/*
 * constrain n to the given range, excluding the minimum, via modular arithmetic
 * @param {number} n value
 * @param {number} min the minimum value to be returned, exclusive
 * @param {number} max the maximum value to be returned, inclusive
 * @returns {number} constrained number
 * @private
 */
exports.wrap = function (n, min, max) {
    var d = max - min;
    var w = ((n - min) % d + d) % d + min;
    return (w === min) ? max : w;
};

/*
 * return the first non-null and non-undefined argument to this function.
 * @returns {*} argument
 * @private
 */
exports.coalesce = function() {
    for (var i = 0; i < arguments.length; i++) {
        var arg = arguments[i];
        if (arg !== null && arg !== undefined)
            return arg;
    }
};

/*
 * Call an asynchronous function on an array of arguments,
 * calling `callback` with the completed results of all calls.
 *
 * @param {Array<*>} array input to each call of the async function.
 * @param {Function} fn an async function with signature (data, callback)
 * @param {Function} callback a callback run after all async work is done.
 * called with an array, containing the results of each async call.
 * @returns {undefined}
 * @private
 */
exports.asyncAll = function (array, fn, callback) {
    if (!array.length) { return callback(null, []); }
    var remaining = array.length;
    var results = new Array(array.length);
    var error = null;
    array.forEach(function (item, i) {
        fn(item, function (err, result) {
            if (err) error = err;
            results[i] = result;
            if (--remaining === 0) callback(error, results);
        });
    });
};

/*
 * Compute the difference between the keys in one object and the keys
 * in another object.
 *
 * @param {Object} obj
 * @param {Object} other
 * @returns {Array<string>} keys difference
 * @private
 */
exports.keysDifference = function (obj, other) {
    var difference = [];
    for (var i in obj) {
        if (!(i in other)) {
            difference.push(i);
        }
    }
    return difference;
};

/**
 * Given a destination object and optionally many source objects,
 * copy all properties from the source objects into the destination.
 * The last source object given overrides properties from previous
 * source objects.
 * @param {Object} dest destination object
 * @param {...Object} sources sources from which properties are pulled
 * @returns {Object} dest
 * @private
 */
exports.extend = function (dest) {
    for (var i = 1; i < arguments.length; i++) {
        var src = arguments[i];
        for (var k in src) {
            dest[k] = src[k];
        }
    }
    return dest;
};

/**
 * Extend a destination object with all properties of the src object,
 * using defineProperty instead of simple assignment.
 * @param {Object} dest
 * @param {Object} src
 * @returns {Object} dest
 * @private
 */
exports.extendAll = function (dest, src) {
    for (var i in src) {
        Object.defineProperty(dest, i, Object.getOwnPropertyDescriptor(src, i));
    }
    return dest;
};

/**
 * Extend a parent's prototype with all properties in a properties
 * object.
 *
 * @param {Object} parent
 * @param {Object} props
 * @returns {Object}
 * @private
 */
exports.inherit = function (parent, props) {
    var parentProto = typeof parent === 'function' ? parent.prototype : parent,
        proto = Object.create(parentProto);
    exports.extendAll(proto, props);
    return proto;
};

/**
 * Given an object and a number of properties as strings, return version
 * of that object with only those properties.
 *
 * @param {Object} src the object
 * @param {Array<string>} properties an array of property names chosen
 * to appear on the resulting object.
 * @returns {Object} object with limited properties.
 * @example
 * var foo = { name: 'Charlie', age: 10 };
 * var justName = pick(foo, ['name']);
 * // justName = { name: 'Charlie' }
 * @private
 */
exports.pick = function (src, properties) {
    var result = {};
    for (var i = 0; i < properties.length; i++) {
        var k = properties[i];
        if (k in src) {
            result[k] = src[k];
        }
    }
    return result;
};

var id = 1;

/**
 * Return a unique numeric id, starting at 1 and incrementing with
 * each call.
 *
 * @returns {number} unique numeric id.
 * @private
 */
exports.uniqueId = function () {
    return id++;
};

/**
 * Create a version of `fn` that only fires once every `time` millseconds.
 *
 * @param {Function} fn the function to be throttled
 * @param {number} time millseconds required between function calls
 * @param {*} context the value of `this` with which the function is called
 * @returns {Function} debounced function
 * @private
 */
exports.throttle = function (fn, time, context) {
    var lock, args, wrapperFn, later;

    later = function () {
        // reset lock and call if queued
        lock = false;
        if (args) {
            wrapperFn.apply(context, args);
            args = false;
        }
    };

    wrapperFn = function () {
        if (lock) {
            // called too soon, queue to call later
            args = arguments;

        } else {
            // call and lock until later
            fn.apply(context, arguments);
            setTimeout(later, time);
            lock = true;
        }
    };

    return wrapperFn;
};

/**
 * Create a version of `fn` that is only called `time` milliseconds
 * after its last invocation
 *
 * @param {Function} fn the function to be debounced
 * @param {number} time millseconds after which the function will be invoked
 * @returns {Function} debounced function
 * @private
 */
exports.debounce = function(fn, time) {
    var timer, args;

    return function() {
        args = arguments;
        clearTimeout(timer);

        timer = setTimeout(function() {
            fn.apply(null, args);
        }, time);
    };
};

/**
 * Given an array of member function names as strings, replace all of them
 * with bound versions that will always refer to `context` as `this`. This
 * is useful for classes where otherwise event bindings would reassign
 * `this` to the evented object or some other value: this lets you ensure
 * the `this` value always.
 *
 * @param {Array<string>} fns list of member function names
 * @param {*} context the context value
 * @returns {undefined} changes functions in-place
 * @example
 * function MyClass() {
 *   bindAll(['ontimer'], this);
 *   this.name = 'Tom';
 * }
 * MyClass.prototype.ontimer = function() {
 *   alert(this.name);
 * };
 * var myClass = new MyClass();
 * setTimeout(myClass.ontimer, 100);
 * @private
 */
exports.bindAll = function(fns, context) {
    fns.forEach(function(fn) {
        context[fn] = context[fn].bind(context);
    });
};

/**
 * Given a class, bind all of the methods that look like handlers: that
 * begin with _on, and bind them to the class.
 *
 * @param {Object} context an object with methods
 * @private
 */
exports.bindHandlers = function(context) {
    for (var i in context) {
        if (typeof context[i] === 'function' && i.indexOf('_on') === 0) {
            context[i] = context[i].bind(context);
        }
    }
};

/**
 * Set the 'options' property on `obj` with properties
 * from the `options` argument. Properties in the `options`
 * object will override existing properties.
 *
 * @param {Object} obj destination object
 * @param {Object} options object of override options
 * @returns {Object} derived options object.
 * @private
 */
exports.setOptions = function(obj, options) {
    if (!obj.hasOwnProperty('options')) {
        obj.options = obj.options ? Object.create(obj.options) : {};
    }
    for (var i in options) {
        obj.options[i] = options[i];
    }
    return obj.options;
};

/**
 * Given a list of coordinates, get their center as a coordinate.
 * @param {Array<Coordinate>} coords
 * @returns {Coordinate} centerpoint
 * @private
 */
exports.getCoordinatesCenter = function(coords) {
    var minX = Infinity;
    var minY = Infinity;
    var maxX = -Infinity;
    var maxY = -Infinity;

    for (var i = 0; i < coords.length; i++) {
        minX = Math.min(minX, coords[i].column);
        minY = Math.min(minY, coords[i].row);
        maxX = Math.max(maxX, coords[i].column);
        maxY = Math.max(maxY, coords[i].row);
    }

    var dx = maxX - minX;
    var dy = maxY - minY;
    var dMax = Math.max(dx, dy);
    return new Coordinate((minX + maxX) / 2, (minY + maxY) / 2, 0)
        .zoomTo(Math.floor(-Math.log(dMax) / Math.LN2));
};

},{"../geo/coordinate":9,"unitbezier":133}],95:[function(require,module,exports){
// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

// when used in node, this will actually load the util module we depend on
// versus loading the builtin util module as happens otherwise
// this is a bug in node module loading as far as I am concerned
var util = require('util/');

var pSlice = Array.prototype.slice;
var hasOwn = Object.prototype.hasOwnProperty;

// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  }
  else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      // try to strip useless frames
      var fn_name = stackStartFunction.name;
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);

function replacer(key, value) {
  if (util.isUndefined(value)) {
    return '' + value;
  }
  if (util.isNumber(value) && !isFinite(value)) {
    return value.toString();
  }
  if (util.isFunction(value) || util.isRegExp(value)) {
    return value.toString();
  }
  return value;
}

function truncate(s, n) {
  if (util.isString(s)) {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}

function getMessage(self) {
  return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' +
         self.operator + ' ' +
         truncate(JSON.stringify(self.expected, replacer), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

function _deepEqual(actual, expected) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (util.isBuffer(actual) && util.isBuffer(expected)) {
    if (actual.length != expected.length) return false;

    for (var i = 0; i < actual.length; i++) {
      if (actual[i] !== expected[i]) return false;
    }

    return true;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (!util.isObject(actual) && !util.isObject(expected)) {
    return actual == expected;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b) {
  if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  // if one is a primitive, the other must be same
  if (util.isPrimitive(a) || util.isPrimitive(b)) {
    return a === b;
  }
  var aIsArgs = isArguments(a),
      bIsArgs = isArguments(b);
  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
    return false;
  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b);
  }
  var ka = objectKeys(a),
      kb = objectKeys(b),
      key, i;
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key])) return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  } else if (actual instanceof expected) {
    return true;
  } else if (expected.call({}, actual) === true) {
    return true;
  }

  return false;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (util.isString(expected)) {
    message = expected;
    expected = null;
  }

  try {
    block();
  } catch (e) {
    actual = e;
  }

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  if (!shouldThrow && expectedException(actual, expected)) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws.apply(this, [true].concat(pSlice.call(arguments)));
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/message) {
  _throws.apply(this, [false].concat(pSlice.call(arguments)));
};

assert.ifError = function(err) { if (err) {throw err;}};

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};

},{"util/":100}],96:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],97:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))

},{"_process":98}],98:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],99:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],100:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":99,"_process":98,"inherits":96}],101:[function(require,module,exports){
// (c) Dean McNamee <dean@gmail.com>, 2012.
//
// https://github.com/deanm/css-color-parser-js
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.

// http://www.w3.org/TR/css3-color/
var kCSSColorTable = {
  "transparent": [0,0,0,0], "aliceblue": [240,248,255,1],
  "antiquewhite": [250,235,215,1], "aqua": [0,255,255,1],
  "aquamarine": [127,255,212,1], "azure": [240,255,255,1],
  "beige": [245,245,220,1], "bisque": [255,228,196,1],
  "black": [0,0,0,1], "blanchedalmond": [255,235,205,1],
  "blue": [0,0,255,1], "blueviolet": [138,43,226,1],
  "brown": [165,42,42,1], "burlywood": [222,184,135,1],
  "cadetblue": [95,158,160,1], "chartreuse": [127,255,0,1],
  "chocolate": [210,105,30,1], "coral": [255,127,80,1],
  "cornflowerblue": [100,149,237,1], "cornsilk": [255,248,220,1],
  "crimson": [220,20,60,1], "cyan": [0,255,255,1],
  "darkblue": [0,0,139,1], "darkcyan": [0,139,139,1],
  "darkgoldenrod": [184,134,11,1], "darkgray": [169,169,169,1],
  "darkgreen": [0,100,0,1], "darkgrey": [169,169,169,1],
  "darkkhaki": [189,183,107,1], "darkmagenta": [139,0,139,1],
  "darkolivegreen": [85,107,47,1], "darkorange": [255,140,0,1],
  "darkorchid": [153,50,204,1], "darkred": [139,0,0,1],
  "darksalmon": [233,150,122,1], "darkseagreen": [143,188,143,1],
  "darkslateblue": [72,61,139,1], "darkslategray": [47,79,79,1],
  "darkslategrey": [47,79,79,1], "darkturquoise": [0,206,209,1],
  "darkviolet": [148,0,211,1], "deeppink": [255,20,147,1],
  "deepskyblue": [0,191,255,1], "dimgray": [105,105,105,1],
  "dimgrey": [105,105,105,1], "dodgerblue": [30,144,255,1],
  "firebrick": [178,34,34,1], "floralwhite": [255,250,240,1],
  "forestgreen": [34,139,34,1], "fuchsia": [255,0,255,1],
  "gainsboro": [220,220,220,1], "ghostwhite": [248,248,255,1],
  "gold": [255,215,0,1], "goldenrod": [218,165,32,1],
  "gray": [128,128,128,1], "green": [0,128,0,1],
  "greenyellow": [173,255,47,1], "grey": [128,128,128,1],
  "honeydew": [240,255,240,1], "hotpink": [255,105,180,1],
  "indianred": [205,92,92,1], "indigo": [75,0,130,1],
  "ivory": [255,255,240,1], "khaki": [240,230,140,1],
  "lavender": [230,230,250,1], "lavenderblush": [255,240,245,1],
  "lawngreen": [124,252,0,1], "lemonchiffon": [255,250,205,1],
  "lightblue": [173,216,230,1], "lightcoral": [240,128,128,1],
  "lightcyan": [224,255,255,1], "lightgoldenrodyellow": [250,250,210,1],
  "lightgray": [211,211,211,1], "lightgreen": [144,238,144,1],
  "lightgrey": [211,211,211,1], "lightpink": [255,182,193,1],
  "lightsalmon": [255,160,122,1], "lightseagreen": [32,178,170,1],
  "lightskyblue": [135,206,250,1], "lightslategray": [119,136,153,1],
  "lightslategrey": [119,136,153,1], "lightsteelblue": [176,196,222,1],
  "lightyellow": [255,255,224,1], "lime": [0,255,0,1],
  "limegreen": [50,205,50,1], "linen": [250,240,230,1],
  "magenta": [255,0,255,1], "maroon": [128,0,0,1],
  "mediumaquamarine": [102,205,170,1], "mediumblue": [0,0,205,1],
  "mediumorchid": [186,85,211,1], "mediumpurple": [147,112,219,1],
  "mediumseagreen": [60,179,113,1], "mediumslateblue": [123,104,238,1],
  "mediumspringgreen": [0,250,154,1], "mediumturquoise": [72,209,204,1],
  "mediumvioletred": [199,21,133,1], "midnightblue": [25,25,112,1],
  "mintcream": [245,255,250,1], "mistyrose": [255,228,225,1],
  "moccasin": [255,228,181,1], "navajowhite": [255,222,173,1],
  "navy": [0,0,128,1], "oldlace": [253,245,230,1],
  "olive": [128,128,0,1], "olivedrab": [107,142,35,1],
  "orange": [255,165,0,1], "orangered": [255,69,0,1],
  "orchid": [218,112,214,1], "palegoldenrod": [238,232,170,1],
  "palegreen": [152,251,152,1], "paleturquoise": [175,238,238,1],
  "palevioletred": [219,112,147,1], "papayawhip": [255,239,213,1],
  "peachpuff": [255,218,185,1], "peru": [205,133,63,1],
  "pink": [255,192,203,1], "plum": [221,160,221,1],
  "powderblue": [176,224,230,1], "purple": [128,0,128,1],
  "red": [255,0,0,1], "rosybrown": [188,143,143,1],
  "royalblue": [65,105,225,1], "saddlebrown": [139,69,19,1],
  "salmon": [250,128,114,1], "sandybrown": [244,164,96,1],
  "seagreen": [46,139,87,1], "seashell": [255,245,238,1],
  "sienna": [160,82,45,1], "silver": [192,192,192,1],
  "skyblue": [135,206,235,1], "slateblue": [106,90,205,1],
  "slategray": [112,128,144,1], "slategrey": [112,128,144,1],
  "snow": [255,250,250,1], "springgreen": [0,255,127,1],
  "steelblue": [70,130,180,1], "tan": [210,180,140,1],
  "teal": [0,128,128,1], "thistle": [216,191,216,1],
  "tomato": [255,99,71,1], "turquoise": [64,224,208,1],
  "violet": [238,130,238,1], "wheat": [245,222,179,1],
  "white": [255,255,255,1], "whitesmoke": [245,245,245,1],
  "yellow": [255,255,0,1], "yellowgreen": [154,205,50,1]}

function clamp_css_byte(i) {  // Clamp to integer 0 .. 255.
  i = Math.round(i);  // Seems to be what Chrome does (vs truncation).
  return i < 0 ? 0 : i > 255 ? 255 : i;
}

function clamp_css_float(f) {  // Clamp to float 0.0 .. 1.0.
  return f < 0 ? 0 : f > 1 ? 1 : f;
}

function parse_css_int(str) {  // int or percentage.
  if (str[str.length - 1] === '%')
    return clamp_css_byte(parseFloat(str) / 100 * 255);
  return clamp_css_byte(parseInt(str));
}

function parse_css_float(str) {  // float or percentage.
  if (str[str.length - 1] === '%')
    return clamp_css_float(parseFloat(str) / 100);
  return clamp_css_float(parseFloat(str));
}

function css_hue_to_rgb(m1, m2, h) {
  if (h < 0) h += 1;
  else if (h > 1) h -= 1;

  if (h * 6 < 1) return m1 + (m2 - m1) * h * 6;
  if (h * 2 < 1) return m2;
  if (h * 3 < 2) return m1 + (m2 - m1) * (2/3 - h) * 6;
  return m1;
}

function parseCSSColor(css_str) {
  // Remove all whitespace, not compliant, but should just be more accepting.
  var str = css_str.replace(/ /g, '').toLowerCase();

  // Color keywords (and transparent) lookup.
  if (str in kCSSColorTable) return kCSSColorTable[str].slice();  // dup.

  // #abc and #abc123 syntax.
  if (str[0] === '#') {
    if (str.length === 4) {
      var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.
      if (!(iv >= 0 && iv <= 0xfff)) return null;  // Covers NaN.
      return [((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),
              (iv & 0xf0) | ((iv & 0xf0) >> 4),
              (iv & 0xf) | ((iv & 0xf) << 4),
              1];
    } else if (str.length === 7) {
      var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.
      if (!(iv >= 0 && iv <= 0xffffff)) return null;  // Covers NaN.
      return [(iv & 0xff0000) >> 16,
              (iv & 0xff00) >> 8,
              iv & 0xff,
              1];
    }

    return null;
  }

  var op = str.indexOf('('), ep = str.indexOf(')');
  if (op !== -1 && ep + 1 === str.length) {
    var fname = str.substr(0, op);
    var params = str.substr(op+1, ep-(op+1)).split(',');
    var alpha = 1;  // To allow case fallthrough.
    switch (fname) {
      case 'rgba':
        if (params.length !== 4) return null;
        alpha = parse_css_float(params.pop());
        // Fall through.
      case 'rgb':
        if (params.length !== 3) return null;
        return [parse_css_int(params[0]),
                parse_css_int(params[1]),
                parse_css_int(params[2]),
                alpha];
      case 'hsla':
        if (params.length !== 4) return null;
        alpha = parse_css_float(params.pop());
        // Fall through.
      case 'hsl':
        if (params.length !== 3) return null;
        var h = (((parseFloat(params[0]) % 360) + 360) % 360) / 360;  // 0 .. 1
        // NOTE(deanm): According to the CSS spec s/l should only be
        // percentages, but we don't bother and let float or percentage.
        var s = parse_css_float(params[1]);
        var l = parse_css_float(params[2]);
        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
        var m1 = l * 2 - m2;
        return [clamp_css_byte(css_hue_to_rgb(m1, m2, h+1/3) * 255),
                clamp_css_byte(css_hue_to_rgb(m1, m2, h) * 255),
                clamp_css_byte(css_hue_to_rgb(m1, m2, h-1/3) * 255),
                alpha];
      default:
        return null;
    }
  }

  return null;
}

try { exports.parseCSSColor = parseCSSColor } catch(e) { }

},{}],102:[function(require,module,exports){
'use strict';

var VectorTileFeatureTypes = ['Unknown', 'Point', 'LineString', 'Polygon'];

function infix(operator) {
    return function(_, key, value) {
        if (key === '$type') {
            return 't' + operator + VectorTileFeatureTypes.indexOf(value);
        } else {
            return 'p[' + JSON.stringify(key) + ']' + operator + JSON.stringify(value);
        }
    };
}

function strictInfix(operator) {
    var nonstrictInfix = infix(operator);
    return function(_, key, value) {
        if (key === '$type') {
            return nonstrictInfix(_, key, value);
        } else {
            return 'typeof(p[' + JSON.stringify(key) + ']) === typeof(' + JSON.stringify(value) + ') && ' +
                nonstrictInfix(_, key, value);
        }
    };
}

var operators = {
    '==': infix('==='),
    '!=': infix('!=='),
    '>': strictInfix('>'),
    '<': strictInfix('<'),
    '<=': strictInfix('<='),
    '>=': strictInfix('>='),
    'in': function(_, key) {
        return '(function(){' + Array.prototype.slice.call(arguments, 2).map(function(value) {
            return 'if (' + operators['=='](_, key, value) + ') return true;';
        }).join('') + 'return false;})()';
    },
    '!in': function() {
        return '!(' + operators.in.apply(this, arguments) + ')';
    },
    'any': function() {
        return Array.prototype.slice.call(arguments, 1).map(function(filter) {
            return '(' + compile(filter) + ')';
        }).join('||') || 'false';
    },
    'all': function() {
        return Array.prototype.slice.call(arguments, 1).map(function(filter) {
            return '(' + compile(filter) + ')';
        }).join('&&') || 'true';
    },
    'none': function() {
        return '!(' + operators.any.apply(this, arguments) + ')';
    }
};

function compile(filter) {
    return operators[filter[0]].apply(filter, filter);
}

function truth() {
    return true;
}

/**
 * Given a filter expressed as nested arrays, return a new function
 * that evaluates whether a given feature (with a .properties or .tags property)
 * passes its test.
 *
 * @param {Array} filter mapbox gl filter
 * @returns {Function} filter-evaluating function
 */
module.exports = function (filter) {
    if (!filter) return truth;
    var filterStr = 'var p = f.properties || f.tags || {}, t = f.type; return ' + compile(filter) + ';';
    // jshint evil: true
    return new Function('f', filterStr);
};

},{}],103:[function(require,module,exports){
'use strict';

module.exports = clip;

/* clip features between two axis-parallel lines:
 *     |        |
 *  ___|___     |     /
 * /   |   \____|____/
 *     |        |
 */

function clip(features, scale, k1, k2, axis, intersect, minAll, maxAll) {

    k1 /= scale;
    k2 /= scale;

    if (minAll >= k1 && maxAll <= k2) return features; // trivial accept
    else if (minAll > k2 || maxAll < k1) return null; // trivial reject

    var clipped = [];

    for (var i = 0; i < features.length; i++) {

        var feature = features[i],
            geometry = feature.geometry,
            type = feature.type,
            min, max;

        min = feature.min[axis];
        max = feature.max[axis];

        if (min >= k1 && max <= k2) { // trivial accept
            clipped.push(feature);
            continue;
        } else if (min > k2 || max < k1) continue; // trivial reject

        var slices = type === 1 ?
                clipPoints(geometry, k1, k2, axis) :
                clipGeometry(geometry, k1, k2, axis, intersect, type === 3);

        if (slices.length) {
            // if a feature got clipped, it will likely get clipped on the next zoom level as well,
            // so there's no need to recalculate bboxes
            clipped.push({
                geometry: slices,
                type: type,
                tags: features[i].tags || null,
                min: feature.min,
                max: feature.max
            });
        }
    }

    return clipped.length ? clipped : null;
}

function clipPoints(geometry, k1, k2, axis) {
    var slice = [];

    for (var i = 0; i < geometry.length; i++) {
        var a = geometry[i],
            ak = a[axis];

        if (ak >= k1 && ak <= k2) slice.push(a);
    }
    return slice;
}

function clipGeometry(geometry, k1, k2, axis, intersect, closed) {

    var slices = [];

    for (var i = 0; i < geometry.length; i++) {

        var ak = 0,
            bk = 0,
            b = null,
            points = geometry[i],
            area = points.area,
            dist = points.dist,
            len = points.length,
            a, j, last;

        var slice = [];

        for (j = 0; j < len - 1; j++) {
            a = b || points[j];
            b = points[j + 1];
            ak = bk || a[axis];
            bk = b[axis];

            if (ak < k1) {

                if ((bk > k2)) { // ---|-----|-->
                    slice.push(intersect(a, b, k1), intersect(a, b, k2));
                    if (!closed) slice = newSlice(slices, slice, area, dist);

                } else if (bk >= k1) slice.push(intersect(a, b, k1)); // ---|-->  |

            } else if (ak > k2) {

                if ((bk < k1)) { // <--|-----|---
                    slice.push(intersect(a, b, k2), intersect(a, b, k1));
                    if (!closed) slice = newSlice(slices, slice, area, dist);

                } else if (bk <= k2) slice.push(intersect(a, b, k2)); // |  <--|---

            } else {

                slice.push(a);

                if (bk < k1) { // <--|---  |
                    slice.push(intersect(a, b, k1));
                    if (!closed) slice = newSlice(slices, slice, area, dist);

                } else if (bk > k2) { // |  ---|-->
                    slice.push(intersect(a, b, k2));
                    if (!closed) slice = newSlice(slices, slice, area, dist);
                }
                // | --> |
            }
        }

        // add the last point
        a = points[len - 1];
        ak = a[axis];
        if (ak >= k1 && ak <= k2) slice.push(a);

        // close the polygon if its endpoints are not the same after clipping

        last = slice[slice.length - 1];
        if (closed && last && (slice[0][0] !== last[0] || slice[0][1] !== last[1])) slice.push(slice[0]);

        // add the final slice
        newSlice(slices, slice, area, dist);
    }

    return slices;
}

function newSlice(slices, slice, area, dist) {
    if (slice.length) {
        // we don't recalculate the area/length of the unclipped geometry because the case where it goes
        // below the visibility threshold as a result of clipping is rare, so we avoid doing unnecessary work
        slice.area = area;
        slice.dist = dist;

        slices.push(slice);
    }
    return [];
}

},{}],104:[function(require,module,exports){
'use strict';

module.exports = convert;

var simplify = require('./simplify');

// converts GeoJSON feature into an intermediate projected JSON vector format with simplification data

function convert(data, tolerance) {
    var features = [];

    if (data.type === 'FeatureCollection') {
        for (var i = 0; i < data.features.length; i++) {
            convertFeature(features, data.features[i], tolerance);
        }
    } else if (data.type === 'Feature') {
        convertFeature(features, data, tolerance);

    } else {
        // single geometry or a geometry collection
        convertFeature(features, {geometry: data}, tolerance);
    }
    return features;
}

function convertFeature(features, feature, tolerance) {
    var geom = feature.geometry,
        type = geom.type,
        coords = geom.coordinates,
        tags = feature.properties,
        i, j, rings;

    if (type === 'Point') {
        features.push(create(tags, 1, [projectPoint(coords)]));

    } else if (type === 'MultiPoint') {
        features.push(create(tags, 1, project(coords)));

    } else if (type === 'LineString') {
        features.push(create(tags, 2, [project(coords, tolerance)]));

    } else if (type === 'MultiLineString' || type === 'Polygon') {
        rings = [];
        for (i = 0; i < coords.length; i++) {
            rings.push(project(coords[i], tolerance));
        }
        features.push(create(tags, type === 'Polygon' ? 3 : 2, rings));

    } else if (type === 'MultiPolygon') {
        rings = [];
        for (i = 0; i < coords.length; i++) {
            for (j = 0; j < coords[i].length; j++) {
                rings.push(project(coords[i][j], tolerance));
            }
        }
        features.push(create(tags, 3, rings));

    } else if (type === 'GeometryCollection') {
        for (i = 0; i < geom.geometries.length; i++) {
            convertFeature(features, {
                geometry: geom.geometries[i],
                properties: tags
            }, tolerance);
        }

    } else {
        throw new Error('Input data is not a valid GeoJSON object.');
    }
}

function create(tags, type, geometry) {
    var feature = {
        geometry: geometry,
        type: type,
        tags: tags || null,
        min: [2, 1], // initial bbox values;
        max: [-1, 0]  // note that coords are usually in [0..1] range
    };
    calcBBox(feature);
    return feature;
}

function project(lonlats, tolerance) {
    var projected = [];
    for (var i = 0; i < lonlats.length; i++) {
        projected.push(projectPoint(lonlats[i]));
    }
    if (tolerance) {
        simplify(projected, tolerance);
        calcSize(projected);
    }
    return projected;
}

function projectPoint(p) {
    var sin = Math.sin(p[1] * Math.PI / 180),
        x = (p[0] / 360 + 0.5),
        y = (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);

    y = y < -1 ? -1 :
        y > 1 ? 1 : y;

    return [x, y, 0];
}

// calculate area and length of the poly
function calcSize(points) {
    var area = 0,
        dist = 0;

    for (var i = 0, a, b; i < points.length - 1; i++) {
        a = b || points[i];
        b = points[i + 1];

        area += a[0] * b[1] - b[0] * a[1];

        // use Manhattan distance instead of Euclidian one to avoid expensive square root computation
        dist += Math.abs(b[0] - a[0]) + Math.abs(b[1] - a[1]);
    }
    points.area = Math.abs(area / 2);
    points.dist = dist;
}

// calculate the feature bounding box for faster clipping later
function calcBBox(feature) {
    var geometry = feature.geometry,
        min = feature.min,
        max = feature.max;

    if (feature.type === 1) calcRingBBox(min, max, geometry);
    else for (var i = 0; i < geometry.length; i++) calcRingBBox(min, max, geometry[i]);

    return feature;
}

function calcRingBBox(min, max, points) {
    for (var i = 0, p; i < points.length; i++) {
        p = points[i];
        min[0] = Math.min(p[0], min[0]);
        max[0] = Math.max(p[0], max[0]);
        min[1] = Math.min(p[1], min[1]);
        max[1] = Math.max(p[1], max[1]);
    }
}

},{"./simplify":106}],105:[function(require,module,exports){
'use strict';

module.exports = geojsonvt;

var convert = require('./convert'),     // GeoJSON conversion and preprocessing
    transform = require('./transform'), // coordinate transformation
    clip = require('./clip'),           // stripe clipping algorithm
    wrap = require('./wrap'),           // date line processing
    createTile = require('./tile');     // final simplified tile generation


function geojsonvt(data, options) {
    return new GeoJSONVT(data, options);
}

function GeoJSONVT(data, options) {
    options = this.options = extend(Object.create(this.options), options);

    var debug = options.debug;

    if (debug) console.time('preprocess data');

    var z2 = 1 << options.maxZoom, // 2^z
        features = convert(data, options.tolerance / (z2 * options.extent));

    this.tiles = {};
    this.tileCoords = [];

    if (debug) {
        console.timeEnd('preprocess data');
        console.log('index: maxZoom: %d, maxPoints: %d', options.indexMaxZoom, options.indexMaxPoints);
        console.time('generate tiles');
        this.stats = {};
        this.total = 0;
    }

    features = wrap(features, options.buffer / options.extent, intersectX);

    // start slicing from the top tile down
    if (features.length) this.splitTile(features, 0, 0, 0);

    if (debug) {
        if (features.length) console.log('features: %d, points: %d', this.tiles[0].numFeatures, this.tiles[0].numPoints);
        console.timeEnd('generate tiles');
        console.log('tiles generated:', this.total, JSON.stringify(this.stats));
    }
}

GeoJSONVT.prototype.options = {
    maxZoom: 14,            // max zoom to preserve detail on
    indexMaxZoom: 5,        // max zoom in the tile index
    indexMaxPoints: 100000, // max number of points per tile in the tile index
    solidChildren: false,   // whether to tile solid square tiles further
    tolerance: 3,           // simplification tolerance (higher means simpler)
    extent: 4096,           // tile extent
    buffer: 64,             // tile buffer on each side
    debug: 0                // logging level (0, 1 or 2)
};

GeoJSONVT.prototype.splitTile = function (features, z, x, y, cz, cx, cy) {

    var stack = [features, z, x, y],
        options = this.options,
        debug = options.debug,
        solid = null;

    // avoid recursion by using a processing queue
    while (stack.length) {
        y = stack.pop();
        x = stack.pop();
        z = stack.pop();
        features = stack.pop();

        var z2 = 1 << z,
            id = toID(z, x, y),
            tile = this.tiles[id],
            tileTolerance = z === options.maxZoom ? 0 : options.tolerance / (z2 * options.extent);

        if (!tile) {
            if (debug > 1) console.time('creation');

            tile = this.tiles[id] = createTile(features, z2, x, y, tileTolerance, z === options.maxZoom);
            this.tileCoords.push({z: z, x: x, y: y});

            if (debug) {
                if (debug > 1) {
                    console.log('tile z%d-%d-%d (features: %d, points: %d, simplified: %d)',
                        z, x, y, tile.numFeatures, tile.numPoints, tile.numSimplified);
                    console.timeEnd('creation');
                }
                var key = 'z' + z;
                this.stats[key] = (this.stats[key] || 0) + 1;
                this.total++;
            }
        }

        // save reference to original geometry in tile so that we can drill down later if we stop now
        tile.source = features;

        // if it's the first-pass tiling
        if (!cz) {
            // stop tiling if we reached max zoom, or if the tile is too simple
            if (z === options.indexMaxZoom || tile.numPoints <= options.indexMaxPoints) continue;

        // if a drilldown to a specific tile
        } else {
            // stop tiling if we reached base zoom or our target tile zoom
            if (z === options.maxZoom || z === cz) continue;

            // stop tiling if it's not an ancestor of the target tile
            var m = 1 << (cz - z);
            if (x !== Math.floor(cx / m) || y !== Math.floor(cy / m)) continue;
        }

        // stop tiling if the tile is solid clipped square
        if (!options.solidChildren && isClippedSquare(tile, options.extent, options.buffer)) {
            if (cz) solid = z; // and remember the zoom if we're drilling down
            continue;
        }

        // if we slice further down, no need to keep source geometry
        tile.source = null;

        if (debug > 1) console.time('clipping');

        // values we'll use for clipping
        var k1 = 0.5 * options.buffer / options.extent,
            k2 = 0.5 - k1,
            k3 = 0.5 + k1,
            k4 = 1 + k1,
            tl, bl, tr, br, left, right;

        tl = bl = tr = br = null;

        left  = clip(features, z2, x - k1, x + k3, 0, intersectX, tile.min[0], tile.max[0]);
        right = clip(features, z2, x + k2, x + k4, 0, intersectX, tile.min[0], tile.max[0]);

        if (left) {
            tl = clip(left, z2, y - k1, y + k3, 1, intersectY, tile.min[1], tile.max[1]);
            bl = clip(left, z2, y + k2, y + k4, 1, intersectY, tile.min[1], tile.max[1]);
        }

        if (right) {
            tr = clip(right, z2, y - k1, y + k3, 1, intersectY, tile.min[1], tile.max[1]);
            br = clip(right, z2, y + k2, y + k4, 1, intersectY, tile.min[1], tile.max[1]);
        }

        if (debug > 1) console.timeEnd('clipping');

        if (tl) stack.push(tl, z + 1, x * 2,     y * 2);
        if (bl) stack.push(bl, z + 1, x * 2,     y * 2 + 1);
        if (tr) stack.push(tr, z + 1, x * 2 + 1, y * 2);
        if (br) stack.push(br, z + 1, x * 2 + 1, y * 2 + 1);
    }

    return solid;
};

GeoJSONVT.prototype.getTile = function (z, x, y) {
    var options = this.options,
        extent = options.extent,
        debug = options.debug;

    var z2 = 1 << z;
    x = ((x % z2) + z2) % z2; // wrap tile x coordinate

    var id = toID(z, x, y);
    if (this.tiles[id]) return transform.tile(this.tiles[id], extent);

    if (debug > 1) console.log('drilling down to z%d-%d-%d', z, x, y);

    var z0 = z,
        x0 = x,
        y0 = y,
        parent;

    while (!parent && z0 > 0) {
        z0--;
        x0 = Math.floor(x0 / 2);
        y0 = Math.floor(y0 / 2);
        parent = this.tiles[toID(z0, x0, y0)];
    }

    if (!parent || !parent.source) return null;

    // if we found a parent tile containing the original geometry, we can drill down from it
    if (debug > 1) console.log('found parent tile z%d-%d-%d', z0, x0, y0);

    // it parent tile is a solid clipped square, return it instead since it's identical
    if (isClippedSquare(parent, extent, options.buffer)) return transform.tile(parent, extent);

    if (debug > 1) console.time('drilling down');
    var solid = this.splitTile(parent.source, z0, x0, y0, z, x, y);
    if (debug > 1) console.timeEnd('drilling down');

    // one of the parent tiles was a solid clipped square
    if (solid !== null) {
        var m = 1 << (z - solid);
        id = toID(solid, Math.floor(x / m), Math.floor(y / m));
    }

    return this.tiles[id] ? transform.tile(this.tiles[id], extent) : null;
};

function toID(z, x, y) {
    return (((1 << z) * y + x) * 32) + z;
}

function intersectX(a, b, x) {
    return [x, (x - a[0]) * (b[1] - a[1]) / (b[0] - a[0]) + a[1], 1];
}
function intersectY(a, b, y) {
    return [(y - a[1]) * (b[0] - a[0]) / (b[1] - a[1]) + a[0], y, 1];
}

function extend(dest, src) {
    for (var i in src) dest[i] = src[i];
    return dest;
}

// checks whether a tile is a whole-area fill after clipping; if it is, there's no sense slicing it further
function isClippedSquare(tile, extent, buffer) {

    var features = tile.source;
    if (features.length !== 1) return false;

    var feature = features[0];
    if (feature.type !== 3 || feature.geometry.length > 1) return false;

    var len = feature.geometry[0].length;
    if (len !== 5) return false;

    for (var i = 0; i < len; i++) {
        var p = transform.point(feature.geometry[0][i], extent, tile.z2, tile.x, tile.y);
        if ((p[0] !== -buffer && p[0] !== extent + buffer) ||
            (p[1] !== -buffer && p[1] !== extent + buffer)) return false;
    }

    return true;
}

},{"./clip":103,"./convert":104,"./tile":107,"./transform":108,"./wrap":109}],106:[function(require,module,exports){
'use strict';

module.exports = simplify;

// calculate simplification data using optimized Douglas-Peucker algorithm

function simplify(points, tolerance) {

    var sqTolerance = tolerance * tolerance,
        len = points.length,
        first = 0,
        last = len - 1,
        stack = [],
        i, maxSqDist, sqDist, index;

    // always retain the endpoints (1 is the max value)
    points[first][2] = 1;
    points[last][2] = 1;

    // avoid recursion by using a stack
    while (last) {

        maxSqDist = 0;

        for (i = first + 1; i < last; i++) {
            sqDist = getSqSegDist(points[i], points[first], points[last]);

            if (sqDist > maxSqDist) {
                index = i;
                maxSqDist = sqDist;
            }
        }

        if (maxSqDist > sqTolerance) {
            points[index][2] = maxSqDist; // save the point importance in squared pixels as a z coordinate
            stack.push(first);
            stack.push(index);
            first = index;

        } else {
            last = stack.pop();
            first = stack.pop();
        }
    }
}

// square distance from a point to a segment
function getSqSegDist(p, a, b) {

    var x = a[0], y = a[1],
        bx = b[0], by = b[1],
        px = p[0], py = p[1],
        dx = bx - x,
        dy = by - y;

    if (dx !== 0 || dy !== 0) {

        var t = ((px - x) * dx + (py - y) * dy) / (dx * dx + dy * dy);

        if (t > 1) {
            x = bx;
            y = by;

        } else if (t > 0) {
            x += dx * t;
            y += dy * t;
        }
    }

    dx = px - x;
    dy = py - y;

    return dx * dx + dy * dy;
}

},{}],107:[function(require,module,exports){
'use strict';

module.exports = createTile;

function createTile(features, z2, tx, ty, tolerance, noSimplify) {
    var tile = {
        features: [],
        numPoints: 0,
        numSimplified: 0,
        numFeatures: 0,
        source: null,
        x: tx,
        y: ty,
        z2: z2,
        transformed: false,
        min: [2, 1],
        max: [-1, 0]
    };
    for (var i = 0; i < features.length; i++) {
        tile.numFeatures++;
        addFeature(tile, features[i], tolerance, noSimplify);

        var min = features[i].min,
            max = features[i].max;

        if (min[0] < tile.min[0]) tile.min[0] = min[0];
        if (min[1] < tile.min[1]) tile.min[1] = min[1];
        if (max[0] > tile.max[0]) tile.max[0] = max[0];
        if (max[1] > tile.max[1]) tile.max[1] = max[1];
    }
    return tile;
}

function addFeature(tile, feature, tolerance, noSimplify) {

    var geom = feature.geometry,
        type = feature.type,
        simplified = [],
        sqTolerance = tolerance * tolerance,
        i, j, ring, p;

    if (type === 1) {
        for (i = 0; i < geom.length; i++) {
            simplified.push(geom[i]);
            tile.numPoints++;
            tile.numSimplified++;
        }

    } else {

        // simplify and transform projected coordinates for tile geometry
        for (i = 0; i < geom.length; i++) {
            ring = geom[i];

            // filter out tiny polylines & polygons
            if (!noSimplify && ((type === 2 && ring.dist < tolerance) ||
                                (type === 3 && ring.area < sqTolerance))) {
                tile.numPoints += ring.length;
                continue;
            }

            var simplifiedRing = [];

            for (j = 0; j < ring.length; j++) {
                p = ring[j];
                // keep points with importance > tolerance
                if (noSimplify || p[2] > sqTolerance) {
                    simplifiedRing.push(p);
                    tile.numSimplified++;
                }
                tile.numPoints++;
            }

            simplified.push(simplifiedRing);
        }
    }

    if (simplified.length) {
        tile.features.push({
            geometry: simplified,
            type: type,
            tags: feature.tags || null
        });
    }
}

},{}],108:[function(require,module,exports){
'use strict';

exports.tile = transformTile;
exports.point = transformPoint;

// Transforms the coordinates of each feature in the given tile from
// mercator-projected space into (extent x extent) tile space.
function transformTile(tile, extent) {
    if (tile.transformed) return tile;

    var z2 = tile.z2,
        tx = tile.x,
        ty = tile.y,
        i, j, k;

    for (i = 0; i < tile.features.length; i++) {
        var feature = tile.features[i],
            geom = feature.geometry,
            type = feature.type;

        if (type === 1) {
            for (j = 0; j < geom.length; j++) geom[j] = transformPoint(geom[j], extent, z2, tx, ty);

        } else {
            for (j = 0; j < geom.length; j++) {
                var ring = geom[j];
                for (k = 0; k < ring.length; k++) ring[k] = transformPoint(ring[k], extent, z2, tx, ty);
            }
        }
    }

    tile.transformed = true;

    return tile;
}

function transformPoint(p, extent, z2, tx, ty) {
    var x = Math.round(extent * (p[0] * z2 - tx)),
        y = Math.round(extent * (p[1] * z2 - ty));
    return [x, y];
}

},{}],109:[function(require,module,exports){
'use strict';

var clip = require('./clip');

module.exports = wrap;

function wrap(features, buffer, intersectX) {
    var merged = features,
        left  = clip(features, 1, -1 - buffer, buffer,     0, intersectX, -1, 2), // left world copy
        right = clip(features, 1,  1 - buffer, 2 + buffer, 0, intersectX, -1, 2); // right world copy

    if (left || right) {
        merged = clip(features, 1, -buffer, 1 + buffer, 0, intersectX, -1, 2); // center world copy

        if (left) merged = shiftFeatureCoords(left, 1).concat(merged); // merge left into center
        if (right) merged = merged.concat(shiftFeatureCoords(right, -1)); // merge right into center
    }

    return merged;
}

function shiftFeatureCoords(features, offset) {
    var newFeatures = [];

    for (var i = 0; i < features.length; i++) {
        var feature = features[i],
            type = feature.type;

        var newGeometry;

        if (type === 1) {
            newGeometry = shiftCoords(feature.geometry, offset);
        } else {
            newGeometry = [];
            for (var j = 0; j < feature.geometry.length; j++) {
                newGeometry.push(shiftCoords(feature.geometry[j], offset));
            }
        }

        newFeatures.push({
            geometry: newGeometry,
            type: type,
            tags: feature.tags,
            min: [feature.min[0] + offset, feature.min[1]],
            max: [feature.max[0] + offset, feature.max[1]]
        });
    }

    return newFeatures;
}

function shiftCoords(points, offset) {
    var newPoints = [];
    newPoints.area = points.area;
    newPoints.dist = points.dist;

    for (var i = 0; i < points.length; i++) {
        newPoints.push([points[i][0] + offset, points[i][1], points[i][2]]);
    }
    return newPoints;
}

},{"./clip":103}],110:[function(require,module,exports){
/**
 * @fileoverview gl-matrix - High performance matrix and vector operations
 * @author Brandon Jones
 * @author Colin MacKenzie IV
 * @version 2.3.0
 */

/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */
// END HEADER

exports.glMatrix = require("./gl-matrix/common.js");
exports.mat2 = require("./gl-matrix/mat2.js");
exports.mat2d = require("./gl-matrix/mat2d.js");
exports.mat3 = require("./gl-matrix/mat3.js");
exports.mat4 = require("./gl-matrix/mat4.js");
exports.quat = require("./gl-matrix/quat.js");
exports.vec2 = require("./gl-matrix/vec2.js");
exports.vec3 = require("./gl-matrix/vec3.js");
exports.vec4 = require("./gl-matrix/vec4.js");
},{"./gl-matrix/common.js":111,"./gl-matrix/mat2.js":112,"./gl-matrix/mat2d.js":113,"./gl-matrix/mat3.js":114,"./gl-matrix/mat4.js":115,"./gl-matrix/quat.js":116,"./gl-matrix/vec2.js":117,"./gl-matrix/vec3.js":118,"./gl-matrix/vec4.js":119}],111:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

/**
 * @class Common utilities
 * @name glMatrix
 */
var glMatrix = {};

// Constants
glMatrix.EPSILON = 0.000001;
glMatrix.ARRAY_TYPE = (typeof Float32Array !== 'undefined') ? Float32Array : Array;
glMatrix.RANDOM = Math.random;

/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Type} type Array type, such as Float32Array or Array
 */
glMatrix.setMatrixArrayType = function(type) {
    GLMAT_ARRAY_TYPE = type;
}

var degree = Math.PI / 180;

/**
* Convert Degree To Radian
*
* @param {Number} Angle in Degrees
*/
glMatrix.toRadian = function(a){
     return a * degree;
}

module.exports = glMatrix;

},{}],112:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 2x2 Matrix
 * @name mat2
 */
var mat2 = {};

/**
 * Creates a new identity mat2
 *
 * @returns {mat2} a new 2x2 matrix
 */
mat2.create = function() {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Creates a new mat2 initialized with values from an existing matrix
 *
 * @param {mat2} a matrix to clone
 * @returns {mat2} a new 2x2 matrix
 */
mat2.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Copy the values from one mat2 to another
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Set a mat2 to the identity matrix
 *
 * @param {mat2} out the receiving matrix
 * @returns {mat2} out
 */
mat2.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Transpose the values of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a1 = a[1];
        out[1] = a[2];
        out[2] = a1;
    } else {
        out[0] = a[0];
        out[1] = a[2];
        out[2] = a[1];
        out[3] = a[3];
    }
    
    return out;
};

/**
 * Inverts a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.invert = function(out, a) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],

        // Calculate the determinant
        det = a0 * a3 - a2 * a1;

    if (!det) {
        return null;
    }
    det = 1.0 / det;
    
    out[0] =  a3 * det;
    out[1] = -a1 * det;
    out[2] = -a2 * det;
    out[3] =  a0 * det;

    return out;
};

/**
 * Calculates the adjugate of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.adjoint = function(out, a) {
    // Caching this value is nessecary if out == a
    var a0 = a[0];
    out[0] =  a[3];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] =  a0;

    return out;
};

/**
 * Calculates the determinant of a mat2
 *
 * @param {mat2} a the source matrix
 * @returns {Number} determinant of a
 */
mat2.determinant = function (a) {
    return a[0] * a[3] - a[2] * a[1];
};

/**
 * Multiplies two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
mat2.multiply = function (out, a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    out[0] = a0 * b0 + a2 * b1;
    out[1] = a1 * b0 + a3 * b1;
    out[2] = a0 * b2 + a2 * b3;
    out[3] = a1 * b2 + a3 * b3;
    return out;
};

/**
 * Alias for {@link mat2.multiply}
 * @function
 */
mat2.mul = mat2.multiply;

/**
 * Rotates a mat2 by the given angle
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */
mat2.rotate = function (out, a, rad) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = a0 *  c + a2 * s;
    out[1] = a1 *  c + a3 * s;
    out[2] = a0 * -s + a2 * c;
    out[3] = a1 * -s + a3 * c;
    return out;
};

/**
 * Scales the mat2 by the dimensions in the given vec2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2} out
 **/
mat2.scale = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        v0 = v[0], v1 = v[1];
    out[0] = a0 * v0;
    out[1] = a1 * v0;
    out[2] = a2 * v1;
    out[3] = a3 * v1;
    return out;
};

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.rotate(dest, dest, rad);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */
mat2.fromRotation = function(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = c;
    out[1] = s;
    out[2] = -s;
    out[3] = c;
    return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.scale(dest, dest, vec);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat2} out
 */
mat2.fromScaling = function(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = v[1];
    return out;
}

/**
 * Returns a string representation of a mat2
 *
 * @param {mat2} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat2.str = function (a) {
    return 'mat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

/**
 * Returns Frobenius norm of a mat2
 *
 * @param {mat2} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat2.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2)))
};

/**
 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
 * @param {mat2} L the lower triangular matrix 
 * @param {mat2} D the diagonal matrix 
 * @param {mat2} U the upper triangular matrix 
 * @param {mat2} a the input matrix to factorize
 */

mat2.LDU = function (L, D, U, a) { 
    L[2] = a[2]/a[0]; 
    U[0] = a[0]; 
    U[1] = a[1]; 
    U[3] = a[3] - L[2] * U[1]; 
    return [L, D, U];       
}; 


module.exports = mat2;

},{"./common.js":111}],113:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 2x3 Matrix
 * @name mat2d
 * 
 * @description 
 * A mat2d contains six elements defined as:
 * <pre>
 * [a, c, tx,
 *  b, d, ty]
 * </pre>
 * This is a short form for the 3x3 matrix:
 * <pre>
 * [a, c, tx,
 *  b, d, ty,
 *  0, 0, 1]
 * </pre>
 * The last row is ignored so the array is shorter and operations are faster.
 */
var mat2d = {};

/**
 * Creates a new identity mat2d
 *
 * @returns {mat2d} a new 2x3 matrix
 */
mat2d.create = function() {
    var out = new glMatrix.ARRAY_TYPE(6);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    return out;
};

/**
 * Creates a new mat2d initialized with values from an existing matrix
 *
 * @param {mat2d} a matrix to clone
 * @returns {mat2d} a new 2x3 matrix
 */
mat2d.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(6);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    return out;
};

/**
 * Copy the values from one mat2d to another
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
mat2d.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    return out;
};

/**
 * Set a mat2d to the identity matrix
 *
 * @param {mat2d} out the receiving matrix
 * @returns {mat2d} out
 */
mat2d.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    return out;
};

/**
 * Inverts a mat2d
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
mat2d.invert = function(out, a) {
    var aa = a[0], ab = a[1], ac = a[2], ad = a[3],
        atx = a[4], aty = a[5];

    var det = aa * ad - ab * ac;
    if(!det){
        return null;
    }
    det = 1.0 / det;

    out[0] = ad * det;
    out[1] = -ab * det;
    out[2] = -ac * det;
    out[3] = aa * det;
    out[4] = (ac * aty - ad * atx) * det;
    out[5] = (ab * atx - aa * aty) * det;
    return out;
};

/**
 * Calculates the determinant of a mat2d
 *
 * @param {mat2d} a the source matrix
 * @returns {Number} determinant of a
 */
mat2d.determinant = function (a) {
    return a[0] * a[3] - a[1] * a[2];
};

/**
 * Multiplies two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
mat2d.multiply = function (out, a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];
    out[0] = a0 * b0 + a2 * b1;
    out[1] = a1 * b0 + a3 * b1;
    out[2] = a0 * b2 + a2 * b3;
    out[3] = a1 * b2 + a3 * b3;
    out[4] = a0 * b4 + a2 * b5 + a4;
    out[5] = a1 * b4 + a3 * b5 + a5;
    return out;
};

/**
 * Alias for {@link mat2d.multiply}
 * @function
 */
mat2d.mul = mat2d.multiply;

/**
 * Rotates a mat2d by the given angle
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */
mat2d.rotate = function (out, a, rad) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = a0 *  c + a2 * s;
    out[1] = a1 *  c + a3 * s;
    out[2] = a0 * -s + a2 * c;
    out[3] = a1 * -s + a3 * c;
    out[4] = a4;
    out[5] = a5;
    return out;
};

/**
 * Scales the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2d} out
 **/
mat2d.scale = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        v0 = v[0], v1 = v[1];
    out[0] = a0 * v0;
    out[1] = a1 * v0;
    out[2] = a2 * v1;
    out[3] = a3 * v1;
    out[4] = a4;
    out[5] = a5;
    return out;
};

/**
 * Translates the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to translate the matrix by
 * @returns {mat2d} out
 **/
mat2d.translate = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        v0 = v[0], v1 = v[1];
    out[0] = a0;
    out[1] = a1;
    out[2] = a2;
    out[3] = a3;
    out[4] = a0 * v0 + a2 * v1 + a4;
    out[5] = a1 * v0 + a3 * v1 + a5;
    return out;
};

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.rotate(dest, dest, rad);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */
mat2d.fromRotation = function(out, rad) {
    var s = Math.sin(rad), c = Math.cos(rad);
    out[0] = c;
    out[1] = s;
    out[2] = -s;
    out[3] = c;
    out[4] = 0;
    out[5] = 0;
    return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.scale(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat2d} out
 */
mat2d.fromScaling = function(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = v[1];
    out[4] = 0;
    out[5] = 0;
    return out;
}

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.translate(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat2d} out
 */
mat2d.fromTranslation = function(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = v[0];
    out[5] = v[1];
    return out;
}

/**
 * Returns a string representation of a mat2d
 *
 * @param {mat2d} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat2d.str = function (a) {
    return 'mat2d(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + 
                    a[3] + ', ' + a[4] + ', ' + a[5] + ')';
};

/**
 * Returns Frobenius norm of a mat2d
 *
 * @param {mat2d} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat2d.frob = function (a) { 
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + 1))
}; 

module.exports = mat2d;

},{"./common.js":111}],114:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 3x3 Matrix
 * @name mat3
 */
var mat3 = {};

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */
mat3.create = function() {
    var out = new glMatrix.ARRAY_TYPE(9);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
};

/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {mat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */
mat3.fromMat4 = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[4];
    out[4] = a[5];
    out[5] = a[6];
    out[6] = a[8];
    out[7] = a[9];
    out[8] = a[10];
    return out;
};

/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {mat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */
mat3.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(9);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */
mat3.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
};

/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a12 = a[5];
        out[1] = a[3];
        out[2] = a[6];
        out[3] = a01;
        out[5] = a[7];
        out[6] = a02;
        out[7] = a12;
    } else {
        out[0] = a[0];
        out[1] = a[3];
        out[2] = a[6];
        out[3] = a[1];
        out[4] = a[4];
        out[5] = a[7];
        out[6] = a[2];
        out[7] = a[5];
        out[8] = a[8];
    }
    
    return out;
};

/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.invert = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        b01 = a22 * a11 - a12 * a21,
        b11 = -a22 * a10 + a12 * a20,
        b21 = a21 * a10 - a11 * a20,

        // Calculate the determinant
        det = a00 * b01 + a01 * b11 + a02 * b21;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = b01 * det;
    out[1] = (-a22 * a01 + a02 * a21) * det;
    out[2] = (a12 * a01 - a02 * a11) * det;
    out[3] = b11 * det;
    out[4] = (a22 * a00 - a02 * a20) * det;
    out[5] = (-a12 * a00 + a02 * a10) * det;
    out[6] = b21 * det;
    out[7] = (-a21 * a00 + a01 * a20) * det;
    out[8] = (a11 * a00 - a01 * a10) * det;
    return out;
};

/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.adjoint = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8];

    out[0] = (a11 * a22 - a12 * a21);
    out[1] = (a02 * a21 - a01 * a22);
    out[2] = (a01 * a12 - a02 * a11);
    out[3] = (a12 * a20 - a10 * a22);
    out[4] = (a00 * a22 - a02 * a20);
    out[5] = (a02 * a10 - a00 * a12);
    out[6] = (a10 * a21 - a11 * a20);
    out[7] = (a01 * a20 - a00 * a21);
    out[8] = (a00 * a11 - a01 * a10);
    return out;
};

/**
 * Calculates the determinant of a mat3
 *
 * @param {mat3} a the source matrix
 * @returns {Number} determinant of a
 */
mat3.determinant = function (a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8];

    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
};

/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
mat3.multiply = function (out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        b00 = b[0], b01 = b[1], b02 = b[2],
        b10 = b[3], b11 = b[4], b12 = b[5],
        b20 = b[6], b21 = b[7], b22 = b[8];

    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
    out[2] = b00 * a02 + b01 * a12 + b02 * a22;

    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
    out[5] = b10 * a02 + b11 * a12 + b12 * a22;

    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
    return out;
};

/**
 * Alias for {@link mat3.multiply}
 * @function
 */
mat3.mul = mat3.multiply;

/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to translate
 * @param {vec2} v vector to translate by
 * @returns {mat3} out
 */
mat3.translate = function(out, a, v) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],
        x = v[0], y = v[1];

    out[0] = a00;
    out[1] = a01;
    out[2] = a02;

    out[3] = a10;
    out[4] = a11;
    out[5] = a12;

    out[6] = x * a00 + y * a10 + a20;
    out[7] = x * a01 + y * a11 + a21;
    out[8] = x * a02 + y * a12 + a22;
    return out;
};

/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
mat3.rotate = function (out, a, rad) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        s = Math.sin(rad),
        c = Math.cos(rad);

    out[0] = c * a00 + s * a10;
    out[1] = c * a01 + s * a11;
    out[2] = c * a02 + s * a12;

    out[3] = c * a10 - s * a00;
    out[4] = c * a11 - s * a01;
    out[5] = c * a12 - s * a02;

    out[6] = a20;
    out[7] = a21;
    out[8] = a22;
    return out;
};

/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/
mat3.scale = function(out, a, v) {
    var x = v[0], y = v[1];

    out[0] = x * a[0];
    out[1] = x * a[1];
    out[2] = x * a[2];

    out[3] = y * a[3];
    out[4] = y * a[4];
    out[5] = y * a[5];

    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.translate(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat3} out
 */
mat3.fromTranslation = function(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = v[0];
    out[7] = v[1];
    out[8] = 1;
    return out;
}

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.rotate(dest, dest, rad);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
mat3.fromRotation = function(out, rad) {
    var s = Math.sin(rad), c = Math.cos(rad);

    out[0] = c;
    out[1] = s;
    out[2] = 0;

    out[3] = -s;
    out[4] = c;
    out[5] = 0;

    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.scale(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat3} out
 */
mat3.fromScaling = function(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;

    out[3] = 0;
    out[4] = v[1];
    out[5] = 0;

    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
}

/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat2d} a the matrix to copy
 * @returns {mat3} out
 **/
mat3.fromMat2d = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = 0;

    out[3] = a[2];
    out[4] = a[3];
    out[5] = 0;

    out[6] = a[4];
    out[7] = a[5];
    out[8] = 1;
    return out;
};

/**
* Calculates a 3x3 matrix from the given quaternion
*
* @param {mat3} out mat3 receiving operation result
* @param {quat} q Quaternion to create matrix from
*
* @returns {mat3} out
*/
mat3.fromQuat = function (out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        yx = y * x2,
        yy = y * y2,
        zx = z * x2,
        zy = z * y2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - yy - zz;
    out[3] = yx - wz;
    out[6] = zx + wy;

    out[1] = yx + wz;
    out[4] = 1 - xx - zz;
    out[7] = zy - wx;

    out[2] = zx - wy;
    out[5] = zy + wx;
    out[8] = 1 - xx - yy;

    return out;
};

/**
* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
*
* @param {mat3} out mat3 receiving operation result
* @param {mat4} a Mat4 to derive the normal matrix from
*
* @returns {mat3} out
*/
mat3.normalFromMat4 = function (out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;

    out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;

    out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;

    return out;
};

/**
 * Returns a string representation of a mat3
 *
 * @param {mat3} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat3.str = function (a) {
    return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + 
                    a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + 
                    a[6] + ', ' + a[7] + ', ' + a[8] + ')';
};

/**
 * Returns Frobenius norm of a mat3
 *
 * @param {mat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat3.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2)))
};


module.exports = mat3;

},{"./common.js":111}],115:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 4x4 Matrix
 * @name mat4
 */
var mat4 = {};

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */
mat4.create = function() {
    var out = new glMatrix.ARRAY_TYPE(16);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};

/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {mat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */
mat4.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(16);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */
mat4.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};

/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a03 = a[3],
            a12 = a[6], a13 = a[7],
            a23 = a[11];

        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a01;
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a02;
        out[9] = a12;
        out[11] = a[14];
        out[12] = a03;
        out[13] = a13;
        out[14] = a23;
    } else {
        out[0] = a[0];
        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a[1];
        out[5] = a[5];
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a[2];
        out[9] = a[6];
        out[10] = a[10];
        out[11] = a[14];
        out[12] = a[3];
        out[13] = a[7];
        out[14] = a[11];
        out[15] = a[15];
    }
    
    return out;
};

/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.invert = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

    return out;
};

/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.adjoint = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    out[0]  =  (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));
    out[1]  = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
    out[2]  =  (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));
    out[3]  = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
    out[4]  = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
    out[5]  =  (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));
    out[6]  = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
    out[7]  =  (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));
    out[8]  =  (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));
    out[9]  = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
    out[10] =  (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));
    out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
    out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
    out[13] =  (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));
    out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
    out[15] =  (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));
    return out;
};

/**
 * Calculates the determinant of a mat4
 *
 * @param {mat4} a the source matrix
 * @returns {Number} determinant of a
 */
mat4.determinant = function (a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32;

    // Calculate the determinant
    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
};

/**
 * Multiplies two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
mat4.multiply = function (out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    // Cache only the current line of the second matrix
    var b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];  
    out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
    out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
    out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
    out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
    return out;
};

/**
 * Alias for {@link mat4.multiply}
 * @function
 */
mat4.mul = mat4.multiply;

/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
mat4.translate = function (out, a, v) {
    var x = v[0], y = v[1], z = v[2],
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23;

    if (a === out) {
        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    } else {
        a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
        a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
        a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

        out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
        out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
        out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

        out[12] = a00 * x + a10 * y + a20 * z + a[12];
        out[13] = a01 * x + a11 * y + a21 * z + a[13];
        out[14] = a02 * x + a12 * y + a22 * z + a[14];
        out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }

    return out;
};

/**
 * Scales the mat4 by the dimensions in the given vec3
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/
mat4.scale = function(out, a, v) {
    var x = v[0], y = v[1], z = v[2];

    out[0] = a[0] * x;
    out[1] = a[1] * x;
    out[2] = a[2] * x;
    out[3] = a[3] * x;
    out[4] = a[4] * y;
    out[5] = a[5] * y;
    out[6] = a[6] * y;
    out[7] = a[7] * y;
    out[8] = a[8] * z;
    out[9] = a[9] * z;
    out[10] = a[10] * z;
    out[11] = a[11] * z;
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Rotates a mat4 by the given angle around the given axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
mat4.rotate = function (out, a, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2],
        len = Math.sqrt(x * x + y * y + z * z),
        s, c, t,
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23,
        b00, b01, b02,
        b10, b11, b12,
        b20, b21, b22;

    if (Math.abs(len) < glMatrix.EPSILON) { return null; }
    
    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;

    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;

    a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
    a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
    a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

    // Construct the elements of the rotation matrix
    b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;
    b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;
    b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;

    // Perform rotation-specific matrix multiplication
    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }
    return out;
};

/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.rotateX = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[0]  = a[0];
        out[1]  = a[1];
        out[2]  = a[2];
        out[3]  = a[3];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[4] = a10 * c + a20 * s;
    out[5] = a11 * c + a21 * s;
    out[6] = a12 * c + a22 * s;
    out[7] = a13 * c + a23 * s;
    out[8] = a20 * c - a10 * s;
    out[9] = a21 * c - a11 * s;
    out[10] = a22 * c - a12 * s;
    out[11] = a23 * c - a13 * s;
    return out;
};

/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.rotateY = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[4]  = a[4];
        out[5]  = a[5];
        out[6]  = a[6];
        out[7]  = a[7];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c - a20 * s;
    out[1] = a01 * c - a21 * s;
    out[2] = a02 * c - a22 * s;
    out[3] = a03 * c - a23 * s;
    out[8] = a00 * s + a20 * c;
    out[9] = a01 * s + a21 * c;
    out[10] = a02 * s + a22 * c;
    out[11] = a03 * s + a23 * c;
    return out;
};

/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.rotateZ = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[8]  = a[8];
        out[9]  = a[9];
        out[10] = a[10];
        out[11] = a[11];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c + a10 * s;
    out[1] = a01 * c + a11 * s;
    out[2] = a02 * c + a12 * s;
    out[3] = a03 * c + a13 * s;
    out[4] = a10 * c - a00 * s;
    out[5] = a11 * c - a01 * s;
    out[6] = a12 * c - a02 * s;
    out[7] = a13 * c - a03 * s;
    return out;
};

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
mat4.fromTranslation = function(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.scale(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Scaling vector
 * @returns {mat4} out
 */
mat4.fromScaling = function(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = v[1];
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = v[2];
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotate(dest, dest, rad, axis);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
mat4.fromRotation = function(out, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2],
        len = Math.sqrt(x * x + y * y + z * z),
        s, c, t;
    
    if (Math.abs(len) < glMatrix.EPSILON) { return null; }
    
    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;
    
    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;
    
    // Perform rotation-specific matrix multiplication
    out[0] = x * x * t + c;
    out[1] = y * x * t + z * s;
    out[2] = z * x * t - y * s;
    out[3] = 0;
    out[4] = x * y * t - z * s;
    out[5] = y * y * t + c;
    out[6] = z * y * t + x * s;
    out[7] = 0;
    out[8] = x * z * t + y * s;
    out[9] = y * z * t - x * s;
    out[10] = z * z * t + c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateX(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.fromXRotation = function(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);
    
    // Perform axis-specific matrix multiplication
    out[0]  = 1;
    out[1]  = 0;
    out[2]  = 0;
    out[3]  = 0;
    out[4] = 0;
    out[5] = c;
    out[6] = s;
    out[7] = 0;
    out[8] = 0;
    out[9] = -s;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateY(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.fromYRotation = function(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);
    
    // Perform axis-specific matrix multiplication
    out[0]  = c;
    out[1]  = 0;
    out[2]  = -s;
    out[3]  = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = s;
    out[9] = 0;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateZ(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.fromZRotation = function(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);
    
    // Perform axis-specific matrix multiplication
    out[0]  = c;
    out[1]  = s;
    out[2]  = 0;
    out[3]  = 0;
    out[4] = -s;
    out[5] = c;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
mat4.fromRotationTranslation = function (out, q, v) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        xy = x * y2,
        xz = x * z2,
        yy = y * y2,
        yz = y * z2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - (yy + zz);
    out[1] = xy + wz;
    out[2] = xz - wy;
    out[3] = 0;
    out[4] = xy - wz;
    out[5] = 1 - (xx + zz);
    out[6] = yz + wx;
    out[7] = 0;
    out[8] = xz + wy;
    out[9] = yz - wx;
    out[10] = 1 - (xx + yy);
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    
    return out;
};

/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @returns {mat4} out
 */
mat4.fromRotationTranslationScale = function (out, q, v, s) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        xy = x * y2,
        xz = x * z2,
        yy = y * y2,
        yz = y * z2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2,
        sx = s[0],
        sy = s[1],
        sz = s[2];

    out[0] = (1 - (yy + zz)) * sx;
    out[1] = (xy + wz) * sx;
    out[2] = (xz - wy) * sx;
    out[3] = 0;
    out[4] = (xy - wz) * sy;
    out[5] = (1 - (xx + zz)) * sy;
    out[6] = (yz + wx) * sy;
    out[7] = 0;
    out[8] = (xz + wy) * sz;
    out[9] = (yz - wx) * sz;
    out[10] = (1 - (xx + yy)) * sz;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    
    return out;
};

/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     mat4.translate(dest, origin);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *     mat4.translate(dest, negativeOrigin);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @param {vec3} o The origin vector around which to scale and rotate
 * @returns {mat4} out
 */
mat4.fromRotationTranslationScaleOrigin = function (out, q, v, s, o) {
  // Quaternion math
  var x = q[0], y = q[1], z = q[2], w = q[3],
      x2 = x + x,
      y2 = y + y,
      z2 = z + z,

      xx = x * x2,
      xy = x * y2,
      xz = x * z2,
      yy = y * y2,
      yz = y * z2,
      zz = z * z2,
      wx = w * x2,
      wy = w * y2,
      wz = w * z2,
      
      sx = s[0],
      sy = s[1],
      sz = s[2],

      ox = o[0],
      oy = o[1],
      oz = o[2];
      
  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0] + ox - (out[0] * ox + out[4] * oy + out[8] * oz);
  out[13] = v[1] + oy - (out[1] * ox + out[5] * oy + out[9] * oz);
  out[14] = v[2] + oz - (out[2] * ox + out[6] * oy + out[10] * oz);
  out[15] = 1;
        
  return out;
};

mat4.fromQuat = function (out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        yx = y * x2,
        yy = y * y2,
        zx = z * x2,
        zy = z * y2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;

    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;

    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;

    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;

    return out;
};

/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.frustum = function (out, left, right, bottom, top, near, far) {
    var rl = 1 / (right - left),
        tb = 1 / (top - bottom),
        nf = 1 / (near - far);
    out[0] = (near * 2) * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = (near * 2) * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl;
    out[9] = (top + bottom) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (far * near * 2) * nf;
    out[15] = 0;
    return out;
};

/**
 * Generates a perspective projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.perspective = function (out, fovy, aspect, near, far) {
    var f = 1.0 / Math.tan(fovy / 2),
        nf = 1 / (near - far);
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (2 * far * near) * nf;
    out[15] = 0;
    return out;
};

/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.perspectiveFromFieldOfView = function (out, fov, near, far) {
    var upTan = Math.tan(fov.upDegrees * Math.PI/180.0),
        downTan = Math.tan(fov.downDegrees * Math.PI/180.0),
        leftTan = Math.tan(fov.leftDegrees * Math.PI/180.0),
        rightTan = Math.tan(fov.rightDegrees * Math.PI/180.0),
        xScale = 2.0 / (leftTan + rightTan),
        yScale = 2.0 / (upTan + downTan);

    out[0] = xScale;
    out[1] = 0.0;
    out[2] = 0.0;
    out[3] = 0.0;
    out[4] = 0.0;
    out[5] = yScale;
    out[6] = 0.0;
    out[7] = 0.0;
    out[8] = -((leftTan - rightTan) * xScale * 0.5);
    out[9] = ((upTan - downTan) * yScale * 0.5);
    out[10] = far / (near - far);
    out[11] = -1.0;
    out[12] = 0.0;
    out[13] = 0.0;
    out[14] = (far * near) / (near - far);
    out[15] = 0.0;
    return out;
}

/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.ortho = function (out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right),
        bt = 1 / (bottom - top),
        nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
};

/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */
mat4.lookAt = function (out, eye, center, up) {
    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len,
        eyex = eye[0],
        eyey = eye[1],
        eyez = eye[2],
        upx = up[0],
        upy = up[1],
        upz = up[2],
        centerx = center[0],
        centery = center[1],
        centerz = center[2];

    if (Math.abs(eyex - centerx) < glMatrix.EPSILON &&
        Math.abs(eyey - centery) < glMatrix.EPSILON &&
        Math.abs(eyez - centerz) < glMatrix.EPSILON) {
        return mat4.identity(out);
    }

    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;

    len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
    z0 *= len;
    z1 *= len;
    z2 *= len;

    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
    if (!len) {
        x0 = 0;
        x1 = 0;
        x2 = 0;
    } else {
        len = 1 / len;
        x0 *= len;
        x1 *= len;
        x2 *= len;
    }

    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;

    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
    if (!len) {
        y0 = 0;
        y1 = 0;
        y2 = 0;
    } else {
        len = 1 / len;
        y0 *= len;
        y1 *= len;
        y2 *= len;
    }

    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;

    return out;
};

/**
 * Returns a string representation of a mat4
 *
 * @param {mat4} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat4.str = function (a) {
    return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' +
                    a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' +
                    a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' + 
                    a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
};

/**
 * Returns Frobenius norm of a mat4
 *
 * @param {mat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat4.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2) ))
};


module.exports = mat4;

},{"./common.js":111}],116:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");
var mat3 = require("./mat3.js");
var vec3 = require("./vec3.js");
var vec4 = require("./vec4.js");

/**
 * @class Quaternion
 * @name quat
 */
var quat = {};

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */
quat.create = function() {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {vec3} a the initial vector
 * @param {vec3} b the destination vector
 * @returns {quat} out
 */
quat.rotationTo = (function() {
    var tmpvec3 = vec3.create();
    var xUnitVec3 = vec3.fromValues(1,0,0);
    var yUnitVec3 = vec3.fromValues(0,1,0);

    return function(out, a, b) {
        var dot = vec3.dot(a, b);
        if (dot < -0.999999) {
            vec3.cross(tmpvec3, xUnitVec3, a);
            if (vec3.length(tmpvec3) < 0.000001)
                vec3.cross(tmpvec3, yUnitVec3, a);
            vec3.normalize(tmpvec3, tmpvec3);
            quat.setAxisAngle(out, tmpvec3, Math.PI);
            return out;
        } else if (dot > 0.999999) {
            out[0] = 0;
            out[1] = 0;
            out[2] = 0;
            out[3] = 1;
            return out;
        } else {
            vec3.cross(tmpvec3, a, b);
            out[0] = tmpvec3[0];
            out[1] = tmpvec3[1];
            out[2] = tmpvec3[2];
            out[3] = 1 + dot;
            return quat.normalize(out, out);
        }
    };
})();

/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {vec3} view  the vector representing the viewing direction
 * @param {vec3} right the vector representing the local "right" direction
 * @param {vec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */
quat.setAxes = (function() {
    var matr = mat3.create();

    return function(out, view, right, up) {
        matr[0] = right[0];
        matr[3] = right[1];
        matr[6] = right[2];

        matr[1] = up[0];
        matr[4] = up[1];
        matr[7] = up[2];

        matr[2] = -view[0];
        matr[5] = -view[1];
        matr[8] = -view[2];

        return quat.normalize(out, quat.fromMat3(out, matr));
    };
})();

/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {quat} a quaternion to clone
 * @returns {quat} a new quaternion
 * @function
 */
quat.clone = vec4.clone;

/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */
quat.fromValues = vec4.fromValues;

/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the source quaternion
 * @returns {quat} out
 * @function
 */
quat.copy = vec4.copy;

/**
 * Set the components of a quat to the given values
 *
 * @param {quat} out the receiving quaternion
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} out
 * @function
 */
quat.set = vec4.set;

/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */
quat.identity = function(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {vec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/
quat.setAxisAngle = function(out, axis, rad) {
    rad = rad * 0.5;
    var s = Math.sin(rad);
    out[0] = s * axis[0];
    out[1] = s * axis[1];
    out[2] = s * axis[2];
    out[3] = Math.cos(rad);
    return out;
};

/**
 * Adds two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 * @function
 */
quat.add = vec4.add;

/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 */
quat.multiply = function(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = b[0], by = b[1], bz = b[2], bw = b[3];

    out[0] = ax * bw + aw * bx + ay * bz - az * by;
    out[1] = ay * bw + aw * by + az * bx - ax * bz;
    out[2] = az * bw + aw * bz + ax * by - ay * bx;
    out[3] = aw * bw - ax * bx - ay * by - az * bz;
    return out;
};

/**
 * Alias for {@link quat.multiply}
 * @function
 */
quat.mul = quat.multiply;

/**
 * Scales a quat by a scalar number
 *
 * @param {quat} out the receiving vector
 * @param {quat} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {quat} out
 * @function
 */
quat.scale = vec4.scale;

/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateX = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw + aw * bx;
    out[1] = ay * bw + az * bx;
    out[2] = az * bw - ay * bx;
    out[3] = aw * bw - ax * bx;
    return out;
};

/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateY = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        by = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw - az * by;
    out[1] = ay * bw + aw * by;
    out[2] = az * bw + ax * by;
    out[3] = aw * bw - ay * by;
    return out;
};

/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateZ = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bz = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw + ay * bz;
    out[1] = ay * bw - ax * bz;
    out[2] = az * bw + aw * bz;
    out[3] = aw * bw - az * bz;
    return out;
};

/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate W component of
 * @returns {quat} out
 */
quat.calculateW = function (out, a) {
    var x = a[0], y = a[1], z = a[2];

    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
    return out;
};

/**
 * Calculates the dot product of two quat's
 *
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */
quat.dot = vec4.dot;

/**
 * Performs a linear interpolation between two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 * @function
 */
quat.lerp = vec4.lerp;

/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 */
quat.slerp = function (out, a, b, t) {
    // benchmarks:
    //    http://jsperf.com/quaternion-slerp-implementations

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = b[0], by = b[1], bz = b[2], bw = b[3];

    var        omega, cosom, sinom, scale0, scale1;

    // calc cosine
    cosom = ax * bx + ay * by + az * bz + aw * bw;
    // adjust signs (if necessary)
    if ( cosom < 0.0 ) {
        cosom = -cosom;
        bx = - bx;
        by = - by;
        bz = - bz;
        bw = - bw;
    }
    // calculate coefficients
    if ( (1.0 - cosom) > 0.000001 ) {
        // standard case (slerp)
        omega  = Math.acos(cosom);
        sinom  = Math.sin(omega);
        scale0 = Math.sin((1.0 - t) * omega) / sinom;
        scale1 = Math.sin(t * omega) / sinom;
    } else {        
        // "from" and "to" quaternions are very close 
        //  ... so we can do a linear interpolation
        scale0 = 1.0 - t;
        scale1 = t;
    }
    // calculate final values
    out[0] = scale0 * ax + scale1 * bx;
    out[1] = scale0 * ay + scale1 * by;
    out[2] = scale0 * az + scale1 * bz;
    out[3] = scale0 * aw + scale1 * bw;
    
    return out;
};

/**
 * Performs a spherical linear interpolation with two control points
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {quat} c the third operand
 * @param {quat} d the fourth operand
 * @param {Number} t interpolation amount
 * @returns {quat} out
 */
quat.sqlerp = (function () {
  var temp1 = quat.create();
  var temp2 = quat.create();
  
  return function (out, a, b, c, d, t) {
    quat.slerp(temp1, a, d, t);
    quat.slerp(temp2, b, c, t);
    quat.slerp(out, temp1, temp2, 2 * t * (1 - t));
    
    return out;
  };
}());

/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate inverse of
 * @returns {quat} out
 */
quat.invert = function(out, a) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        dot = a0*a0 + a1*a1 + a2*a2 + a3*a3,
        invDot = dot ? 1.0/dot : 0;
    
    // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

    out[0] = -a0*invDot;
    out[1] = -a1*invDot;
    out[2] = -a2*invDot;
    out[3] = a3*invDot;
    return out;
};

/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate conjugate of
 * @returns {quat} out
 */
quat.conjugate = function (out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = a[3];
    return out;
};

/**
 * Calculates the length of a quat
 *
 * @param {quat} a vector to calculate length of
 * @returns {Number} length of a
 * @function
 */
quat.length = vec4.length;

/**
 * Alias for {@link quat.length}
 * @function
 */
quat.len = quat.length;

/**
 * Calculates the squared length of a quat
 *
 * @param {quat} a vector to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */
quat.squaredLength = vec4.squaredLength;

/**
 * Alias for {@link quat.squaredLength}
 * @function
 */
quat.sqrLen = quat.squaredLength;

/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */
quat.normalize = vec4.normalize;

/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {mat3} m rotation matrix
 * @returns {quat} out
 * @function
 */
quat.fromMat3 = function(out, m) {
    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
    // article "Quaternion Calculus and Fast Animation".
    var fTrace = m[0] + m[4] + m[8];
    var fRoot;

    if ( fTrace > 0.0 ) {
        // |w| > 1/2, may as well choose w > 1/2
        fRoot = Math.sqrt(fTrace + 1.0);  // 2w
        out[3] = 0.5 * fRoot;
        fRoot = 0.5/fRoot;  // 1/(4w)
        out[0] = (m[5]-m[7])*fRoot;
        out[1] = (m[6]-m[2])*fRoot;
        out[2] = (m[1]-m[3])*fRoot;
    } else {
        // |w| <= 1/2
        var i = 0;
        if ( m[4] > m[0] )
          i = 1;
        if ( m[8] > m[i*3+i] )
          i = 2;
        var j = (i+1)%3;
        var k = (i+2)%3;
        
        fRoot = Math.sqrt(m[i*3+i]-m[j*3+j]-m[k*3+k] + 1.0);
        out[i] = 0.5 * fRoot;
        fRoot = 0.5 / fRoot;
        out[3] = (m[j*3+k] - m[k*3+j]) * fRoot;
        out[j] = (m[j*3+i] + m[i*3+j]) * fRoot;
        out[k] = (m[k*3+i] + m[i*3+k]) * fRoot;
    }
    
    return out;
};

/**
 * Returns a string representation of a quatenion
 *
 * @param {quat} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
quat.str = function (a) {
    return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

module.exports = quat;

},{"./common.js":111,"./mat3.js":114,"./vec3.js":118,"./vec4.js":119}],117:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 2 Dimensional Vector
 * @name vec2
 */
var vec2 = {};

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */
vec2.create = function() {
    var out = new glMatrix.ARRAY_TYPE(2);
    out[0] = 0;
    out[1] = 0;
    return out;
};

/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {vec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */
vec2.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(2);
    out[0] = a[0];
    out[1] = a[1];
    return out;
};

/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */
vec2.fromValues = function(x, y) {
    var out = new glMatrix.ARRAY_TYPE(2);
    out[0] = x;
    out[1] = y;
    return out;
};

/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the source vector
 * @returns {vec2} out
 */
vec2.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    return out;
};

/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */
vec2.set = function(out, x, y) {
    out[0] = x;
    out[1] = y;
    return out;
};

/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    return out;
};

/**
 * Alias for {@link vec2.subtract}
 * @function
 */
vec2.sub = vec2.subtract;

/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    return out;
};

/**
 * Alias for {@link vec2.multiply}
 * @function
 */
vec2.mul = vec2.multiply;

/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    return out;
};

/**
 * Alias for {@link vec2.divide}
 * @function
 */
vec2.div = vec2.divide;

/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    return out;
};

/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    return out;
};

/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */
vec2.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    return out;
};

/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */
vec2.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} distance between a and b
 */
vec2.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return Math.sqrt(x*x + y*y);
};

/**
 * Alias for {@link vec2.distance}
 * @function
 */
vec2.dist = vec2.distance;

/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec2.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return x*x + y*y;
};

/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */
vec2.sqrDist = vec2.squaredDistance;

/**
 * Calculates the length of a vec2
 *
 * @param {vec2} a vector to calculate length of
 * @returns {Number} length of a
 */
vec2.length = function (a) {
    var x = a[0],
        y = a[1];
    return Math.sqrt(x*x + y*y);
};

/**
 * Alias for {@link vec2.length}
 * @function
 */
vec2.len = vec2.length;

/**
 * Calculates the squared length of a vec2
 *
 * @param {vec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec2.squaredLength = function (a) {
    var x = a[0],
        y = a[1];
    return x*x + y*y;
};

/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */
vec2.sqrLen = vec2.squaredLength;

/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to negate
 * @returns {vec2} out
 */
vec2.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    return out;
};

/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to invert
 * @returns {vec2} out
 */
vec2.inverse = function(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
};

/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to normalize
 * @returns {vec2} out
 */
vec2.normalize = function(out, a) {
    var x = a[0],
        y = a[1];
    var len = x*x + y*y;
    if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} dot product of a and b
 */
vec2.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1];
};

/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec3} out
 */
vec2.cross = function(out, a, b) {
    var z = a[0] * b[1] - a[1] * b[0];
    out[0] = out[1] = 0;
    out[2] = z;
    return out;
};

/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec2} out
 */
vec2.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */
vec2.random = function (out, scale) {
    scale = scale || 1.0;
    var r = glMatrix.RANDOM() * 2.0 * Math.PI;
    out[0] = Math.cos(r) * scale;
    out[1] = Math.sin(r) * scale;
    return out;
};

/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat2 = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[2] * y;
    out[1] = m[1] * x + m[3] * y;
    return out;
};

/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2d} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat2d = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[2] * y + m[4];
    out[1] = m[1] * x + m[3] * y + m[5];
    return out;
};

/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat3} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat3 = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[3] * y + m[6];
    out[1] = m[1] * x + m[4] * y + m[7];
    return out;
};

/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat4 = function(out, a, m) {
    var x = a[0], 
        y = a[1];
    out[0] = m[0] * x + m[4] * y + m[12];
    out[1] = m[1] * x + m[5] * y + m[13];
    return out;
};

/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec2.forEach = (function() {
    var vec = vec2.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 2;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1];
        }
        
        return a;
    };
})();

/**
 * Returns a string representation of a vector
 *
 * @param {vec2} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec2.str = function (a) {
    return 'vec2(' + a[0] + ', ' + a[1] + ')';
};

module.exports = vec2;

},{"./common.js":111}],118:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 3 Dimensional Vector
 * @name vec3
 */
var vec3 = {};

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */
vec3.create = function() {
    var out = new glMatrix.ARRAY_TYPE(3);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    return out;
};

/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */
vec3.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(3);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
};

/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */
vec3.fromValues = function(x, y, z) {
    var out = new glMatrix.ARRAY_TYPE(3);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
};

/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the source vector
 * @returns {vec3} out
 */
vec3.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
};

/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */
vec3.set = function(out, x, y, z) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
};

/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    return out;
};

/**
 * Alias for {@link vec3.subtract}
 * @function
 */
vec3.sub = vec3.subtract;

/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    return out;
};

/**
 * Alias for {@link vec3.multiply}
 * @function
 */
vec3.mul = vec3.multiply;

/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    return out;
};

/**
 * Alias for {@link vec3.divide}
 * @function
 */
vec3.div = vec3.divide;

/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    return out;
};

/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    return out;
};

/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */
vec3.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    return out;
};

/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */
vec3.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} distance between a and b
 */
vec3.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2];
    return Math.sqrt(x*x + y*y + z*z);
};

/**
 * Alias for {@link vec3.distance}
 * @function
 */
vec3.dist = vec3.distance;

/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec3.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2];
    return x*x + y*y + z*z;
};

/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */
vec3.sqrDist = vec3.squaredDistance;

/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */
vec3.length = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    return Math.sqrt(x*x + y*y + z*z);
};

/**
 * Alias for {@link vec3.length}
 * @function
 */
vec3.len = vec3.length;

/**
 * Calculates the squared length of a vec3
 *
 * @param {vec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec3.squaredLength = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    return x*x + y*y + z*z;
};

/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */
vec3.sqrLen = vec3.squaredLength;

/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to negate
 * @returns {vec3} out
 */
vec3.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    return out;
};

/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to invert
 * @returns {vec3} out
 */
vec3.inverse = function(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
};

/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */
vec3.normalize = function(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    var len = x*x + y*y + z*z;
    if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
        out[2] = a[2] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */
vec3.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
};

/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.cross = function(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2],
        bx = b[0], by = b[1], bz = b[2];

    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
};

/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
vec3.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1],
        az = a[2];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    return out;
};

/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
vec3.hermite = function (out, a, b, c, d, t) {
  var factorTimes2 = t * t,
      factor1 = factorTimes2 * (2 * t - 3) + 1,
      factor2 = factorTimes2 * (t - 2) + t,
      factor3 = factorTimes2 * (t - 1),
      factor4 = factorTimes2 * (3 - 2 * t);
  
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  
  return out;
};

/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
vec3.bezier = function (out, a, b, c, d, t) {
  var inverseFactor = 1 - t,
      inverseFactorTimesTwo = inverseFactor * inverseFactor,
      factorTimes2 = t * t,
      factor1 = inverseFactorTimesTwo * inverseFactor,
      factor2 = 3 * t * inverseFactorTimesTwo,
      factor3 = 3 * factorTimes2 * inverseFactor,
      factor4 = factorTimes2 * t;
  
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  
  return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */
vec3.random = function (out, scale) {
    scale = scale || 1.0;

    var r = glMatrix.RANDOM() * 2.0 * Math.PI;
    var z = (glMatrix.RANDOM() * 2.0) - 1.0;
    var zScale = Math.sqrt(1.0-z*z) * scale;

    out[0] = Math.cos(r) * zScale;
    out[1] = Math.sin(r) * zScale;
    out[2] = z * scale;
    return out;
};

/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */
vec3.transformMat4 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2],
        w = m[3] * x + m[7] * y + m[11] * z + m[15];
    w = w || 1.0;
    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
    return out;
};

/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */
vec3.transformMat3 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2];
    out[0] = x * m[0] + y * m[3] + z * m[6];
    out[1] = x * m[1] + y * m[4] + z * m[7];
    out[2] = x * m[2] + y * m[5] + z * m[8];
    return out;
};

/**
 * Transforms the vec3 with a quat
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec3} out
 */
vec3.transformQuat = function(out, a, q) {
    // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations

    var x = a[0], y = a[1], z = a[2],
        qx = q[0], qy = q[1], qz = q[2], qw = q[3],

        // calculate quat * vec
        ix = qw * x + qy * z - qz * y,
        iy = qw * y + qz * x - qx * z,
        iz = qw * z + qx * y - qy * x,
        iw = -qx * x - qy * y - qz * z;

    // calculate result * inverse quat
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return out;
};

/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
vec3.rotateX = function(out, a, b, c){
   var p = [], r=[];
	  //Translate point to the origin
	  p[0] = a[0] - b[0];
	  p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];

	  //perform rotation
	  r[0] = p[0];
	  r[1] = p[1]*Math.cos(c) - p[2]*Math.sin(c);
	  r[2] = p[1]*Math.sin(c) + p[2]*Math.cos(c);

	  //translate to correct position
	  out[0] = r[0] + b[0];
	  out[1] = r[1] + b[1];
	  out[2] = r[2] + b[2];

  	return out;
};

/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
vec3.rotateY = function(out, a, b, c){
  	var p = [], r=[];
  	//Translate point to the origin
  	p[0] = a[0] - b[0];
  	p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];
  
  	//perform rotation
  	r[0] = p[2]*Math.sin(c) + p[0]*Math.cos(c);
  	r[1] = p[1];
  	r[2] = p[2]*Math.cos(c) - p[0]*Math.sin(c);
  
  	//translate to correct position
  	out[0] = r[0] + b[0];
  	out[1] = r[1] + b[1];
  	out[2] = r[2] + b[2];
  
  	return out;
};

/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
vec3.rotateZ = function(out, a, b, c){
  	var p = [], r=[];
  	//Translate point to the origin
  	p[0] = a[0] - b[0];
  	p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];
  
  	//perform rotation
  	r[0] = p[0]*Math.cos(c) - p[1]*Math.sin(c);
  	r[1] = p[0]*Math.sin(c) + p[1]*Math.cos(c);
  	r[2] = p[2];
  
  	//translate to correct position
  	out[0] = r[0] + b[0];
  	out[1] = r[1] + b[1];
  	out[2] = r[2] + b[2];
  
  	return out;
};

/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec3.forEach = (function() {
    var vec = vec3.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 3;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2];
        }
        
        return a;
    };
})();

/**
 * Get the angle between two 3D vectors
 * @param {vec3} a The first operand
 * @param {vec3} b The second operand
 * @returns {Number} The angle in radians
 */
vec3.angle = function(a, b) {
   
    var tempA = vec3.fromValues(a[0], a[1], a[2]);
    var tempB = vec3.fromValues(b[0], b[1], b[2]);
 
    vec3.normalize(tempA, tempA);
    vec3.normalize(tempB, tempB);
 
    var cosine = vec3.dot(tempA, tempB);

    if(cosine > 1.0){
        return 0;
    } else {
        return Math.acos(cosine);
    }     
};

/**
 * Returns a string representation of a vector
 *
 * @param {vec3} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec3.str = function (a) {
    return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
};

module.exports = vec3;

},{"./common.js":111}],119:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 4 Dimensional Vector
 * @name vec4
 */
var vec4 = {};

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */
vec4.create = function() {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    return out;
};

/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {vec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */
vec4.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */
vec4.fromValues = function(x, y, z, w) {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
};

/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the source vector
 * @returns {vec4} out
 */
vec4.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */
vec4.set = function(out, x, y, z, w) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
};

/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    return out;
};

/**
 * Alias for {@link vec4.subtract}
 * @function
 */
vec4.sub = vec4.subtract;

/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    out[3] = a[3] * b[3];
    return out;
};

/**
 * Alias for {@link vec4.multiply}
 * @function
 */
vec4.mul = vec4.multiply;

/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    out[3] = a[3] / b[3];
    return out;
};

/**
 * Alias for {@link vec4.divide}
 * @function
 */
vec4.div = vec4.divide;

/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    out[3] = Math.min(a[3], b[3]);
    return out;
};

/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    out[3] = Math.max(a[3], b[3]);
    return out;
};

/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */
vec4.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    return out;
};

/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */
vec4.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    out[3] = a[3] + (b[3] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} distance between a and b
 */
vec4.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2],
        w = b[3] - a[3];
    return Math.sqrt(x*x + y*y + z*z + w*w);
};

/**
 * Alias for {@link vec4.distance}
 * @function
 */
vec4.dist = vec4.distance;

/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec4.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2],
        w = b[3] - a[3];
    return x*x + y*y + z*z + w*w;
};

/**
 * Alias for {@link vec4.squaredDistance}
 * @function
 */
vec4.sqrDist = vec4.squaredDistance;

/**
 * Calculates the length of a vec4
 *
 * @param {vec4} a vector to calculate length of
 * @returns {Number} length of a
 */
vec4.length = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    return Math.sqrt(x*x + y*y + z*z + w*w);
};

/**
 * Alias for {@link vec4.length}
 * @function
 */
vec4.len = vec4.length;

/**
 * Calculates the squared length of a vec4
 *
 * @param {vec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec4.squaredLength = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    return x*x + y*y + z*z + w*w;
};

/**
 * Alias for {@link vec4.squaredLength}
 * @function
 */
vec4.sqrLen = vec4.squaredLength;

/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to negate
 * @returns {vec4} out
 */
vec4.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = -a[3];
    return out;
};

/**
 * Returns the inverse of the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to invert
 * @returns {vec4} out
 */
vec4.inverse = function(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  out[3] = 1.0 / a[3];
  return out;
};

/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to normalize
 * @returns {vec4} out
 */
vec4.normalize = function(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    var len = x*x + y*y + z*z + w*w;
    if (len > 0) {
        len = 1 / Math.sqrt(len);
        out[0] = x * len;
        out[1] = y * len;
        out[2] = z * len;
        out[3] = w * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} dot product of a and b
 */
vec4.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
};

/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec4} out
 */
vec4.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1],
        az = a[2],
        aw = a[3];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    out[3] = aw + t * (b[3] - aw);
    return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */
vec4.random = function (out, scale) {
    scale = scale || 1.0;

    //TODO: This is a pretty awful way of doing this. Find something better.
    out[0] = glMatrix.RANDOM();
    out[1] = glMatrix.RANDOM();
    out[2] = glMatrix.RANDOM();
    out[3] = glMatrix.RANDOM();
    vec4.normalize(out, out);
    vec4.scale(out, out, scale);
    return out;
};

/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec4} out
 */
vec4.transformMat4 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2], w = a[3];
    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
    return out;
};

/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec4} out
 */
vec4.transformQuat = function(out, a, q) {
    var x = a[0], y = a[1], z = a[2],
        qx = q[0], qy = q[1], qz = q[2], qw = q[3],

        // calculate quat * vec
        ix = qw * x + qy * z - qz * y,
        iy = qw * y + qz * x - qx * z,
        iz = qw * z + qx * y - qy * x,
        iw = -qx * x - qy * y - qz * z;

    // calculate result * inverse quat
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    out[3] = a[3];
    return out;
};

/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec4.forEach = (function() {
    var vec = vec4.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 4;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2]; vec[3] = a[i+3];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2]; a[i+3] = vec[3];
        }
        
        return a;
    };
})();

/**
 * Returns a string representation of a vector
 *
 * @param {vec4} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec4.str = function (a) {
    return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

module.exports = vec4;

},{"./common.js":111}],120:[function(require,module,exports){
'use strict';

function constant(value) {
    return function() {
        return value;
    }
}

function interpolateNumber(a, b, t) {
    return (a * (1 - t)) + (b * t);
}

function interpolateArray(a, b, t) {
    var result = [];
    for (var i = 0; i < a.length; i++) {
        result[i] = interpolateNumber(a[i], b[i], t);
    }
    return result;
}

exports['interpolated'] = function(f) {
    if (!f.stops) {
        return constant(f);
    }

    var stops = f.stops,
        base = f.base || 1,
        interpolate = Array.isArray(stops[0][1]) ? interpolateArray : interpolateNumber;

    return function(z) {
        // find the two stops which the current z is between
        var low, high;

        for (var i = 0; i < stops.length; i++) {
            var stop = stops[i];

            if (stop[0] <= z) {
                low = stop;
            }

            if (stop[0] > z) {
                high = stop;
                break;
            }
        }

        if (low && high) {
            var zoomDiff = high[0] - low[0],
                zoomProgress = z - low[0],

                t = base === 1 ?
                zoomProgress / zoomDiff :
                (Math.pow(base, zoomProgress) - 1) / (Math.pow(base, zoomDiff) - 1);

            return interpolate(low[1], high[1], t);

        } else if (low) {
            return low[1];

        } else if (high) {
            return high[1];
        }
    };
};

exports['piecewise-constant'] = function(f) {
    if (!f.stops) {
        return constant(f);
    }

    var stops = f.stops;

    return function(z) {
        for (var i = 0; i < stops.length; i++) {
            if (stops[i][0] > z) {
                return stops[i === 0 ? 0 : i - 1][1];
            }
        }

        return stops[stops.length - 1][1];
    }
};

},{}],121:[function(require,module,exports){
'use strict';

var reference = require('../../reference/latest.min.js');
var validate = require('./parsed');

module.exports = function(style) {
    return validate(style, reference);
};

},{"../../reference/latest.min.js":124,"./parsed":122}],122:[function(require,module,exports){
'use strict';

var parseCSSColor = require('csscolorparser').parseCSSColor;
var format = require('util').format;

module.exports = function(style, reference) {

    var constants = style.constants || {},
        layers = {},
        errors = [];

    function error(key, val /*, message, ...*/) {
        var err = {
            message: (key ? key + ': ' : '') +
            format.apply(format, Array.prototype.slice.call(arguments, 2))
        };

        if (val !== null && val !== undefined && val.__line__) {
            err.line = val.__line__;
        }

        errors.push(err);
    }

    // Main recursive validation function. Tracks:
    //
    // - key: string representing location of validation in style tree. Used only
    //   for more informative error reporting.
    // - val: current value from style being evaluated. May be anything from a
    //   high level object that needs to be descended into deeper or a simple
    //   scalar value.
    // - spec: current spec being evaluated. Tracks val.
    //
    function validate(key, val, spec) {
        var type = typeof_(val);

        // Constants
        if (type === 'string' && val[0] === '@') {

            if (reference.$version > 7) {
                return error(key, val, 'constants have been deprecated as of v8');
            } else {
                if (!(val in constants)) {
                    return error(key, val, 'constant "%s" not found', val);
                }

                val = constants[val];
                type = typeof_(val);
            }
        }

        if (spec.function && type === 'object') {
            return validate.function(key, val, spec);
        }

        if (spec.type) {
            var validator = validate[spec.type];
            if (validator) {
                return validator(key, val, spec);
            }
            spec = reference[spec.type];
        }

        validate.object(key, val, spec);
    }

    validate.constants = function(key, val) {

        if (reference.$version > 7) {
            if (val) {
                return error(key, val, 'constants have been deprecated as of v8');
            }
        } else {
            var type = typeof_(val);
            if (type !== 'object') {
                return error(key, val, 'object expected, %s found', type);
            }

            for (var k in val) {
                if (k[0] !== '@') {
                    error(key + '.' + k, val[k], 'constants must start with "@"');
                }
            }
        }

    };

    validate.source = function(key, val) {
        if (!val.type) {
            error(key, val, '"type" is required');
            return;
        }

        var type = unbundle(val.type);
        switch (type) {
            case 'vector':
            case 'raster':
                validate.object(key, val, reference.source_tile);

                if ('url' in val) {
                    for (var prop in val) {
                        if (['type', 'url', 'tileSize'].indexOf(prop) < 0) {
                            error(key + '.' + prop, val[prop], 'a source with a "url" property may not include a "%s" property', prop);
                        }
                    }
                }

                break;
            case 'geojson':
                validate.object(key, val, reference.source_geojson);
                break;
            case 'video':
                validate.object(key, val, reference.source_video);
                break;
            case 'image':
                validate.object(key, val, reference.source_image);
                break;
            default:
                validate.enum(key + '.type', val.type, {values: ['vector', 'raster', 'geojson', 'video', 'image']});
        }
    };

    validate.layer = function(key, val) {
        if (!val.type && !val.ref) {
            error(key, val, 'either "type" or "ref" is required');
        }

        var type = unbundle(val.type),
            ref = unbundle(val.ref);

        if (val.id) {
            if (layers[val.id]) {
                error(key, val.id, 'duplicate layer id "%s", previously used at line %d', val.id, layers[val.id]);
            } else {
                layers[val.id] = val.id.__line__;
            }
        }

        if ('ref' in val) {
            ['type', 'source', 'source-layer', 'filter', 'layout'].forEach(function (p) {
                if (p in val) {
                    error(key, val[p], '"%s" is prohibited for ref layers', p);
                }
            });

            var parent;

            style.layers.forEach(function(layer) {
                if (layer.id == ref) parent = layer;
            });

            if (!parent) {
                error(key, val.ref, 'ref layer "%s" not found', ref);
            } else if (parent.ref) {
                error(key, val.ref, 'ref cannot reference another ref layer');
            } else {
                type = parent.type;
            }
        } else if (type !== 'background') {
            if (!val.source) {
                error(key, val, 'missing required property "source"');
            } else {
                var source = style.sources[val.source];
                if (!source) {
                    error(key, val.source, 'source "%s" not found', val.source);
                } else if (source.type == 'vector' && type == 'raster') {
                    error(key, val.source, 'layer "%s" requires a raster source', val.id);
                } else if (source.type == 'raster' && type != 'raster') {
                    error(key, val.source, 'layer "%s" requires a vector source', val.id);
                } else if (source.type == 'vector' && !val['source-layer']) {
                    error(key, val, 'layer "%s" must specify a "source-layer"', val.id);
                }
            }
        }

        validate.object(key, val, reference.layer, {
            filter: validate.filter,
            layout: function(key, val) {
                var spec = reference['layout_' + type];
                return type && spec && validate(key, val, spec);
            },
            paint: function(key, val) {
                var spec = reference['paint_' + type];
                return type && spec && validate(key, val, spec);
            }
        });
    };

    validate.object = function (key, val, spec, validators) {
        validators = validators || {};

        var type = typeof_(val);
        if (type !== 'object') {
            return error(key, val, 'object expected, %s found', type);
        }

        for (var k in val) {
            var speckey = k.split('.')[0]; // treat 'paint.*' as 'paint'
            var def = spec[speckey] || spec['*'];
            var transition = speckey.match(/^(.*)-transition$/);

            if (def) {
                (validators[speckey] || validate)((key ? key + '.' : key) + k, val[k], def);
            } else if (transition && spec[transition[1]] && spec[transition[1]].transition) {
                validate((key ? key + '.' : key) + k, val[k], reference.transition);
            // tolerate root-level extra keys & arbitrary layer properties
            } else if (key !== '' && key.split('.').length !== 1) {
                error(key, val[k], 'unknown property "%s"', k);
            }
        }

        for (var l in spec) {
            if (spec[l].required && spec[l]['default'] === undefined && val[l] === undefined) {
                error(key, val, 'missing required property "%s"', l);
            }
        }
    };

    validate.array = function (key, val, spec, validator) {
        if (typeof_(val) !== 'array') {
            return error(key, val, 'array expected, %s found', typeof_(val));
        }

        if (spec.length && val.length !== spec.length) {
            return error(key, val, 'array length %d expected, length %d found', spec.length, val.length);
        }

        if (spec['min-length'] && val.length < spec['min-length']) {
            return error(key, val, 'array length at least %d expected, length %d found', spec['min-length'], val.length);
        }

        var value = {
            "type": spec.value
        };

        if (style.version < 7) {
            value.function = spec.function;
        }

        if (typeof_(spec.value) === 'object') {
            value = spec.value;
        }

        for (var i = 0; i < val.length; i++) {
            (validator || validate)(key + '[' + i + ']', val[i], value);
        }
    };


    validate.filter = function(key, val) {
        var type;

        if (typeof_(val) !== 'array') {
            return error(key, val, 'array expected, %s found', typeof_(val));
        }

        if (val.length < 1) {
            return error(key, val, 'filter array must have at least 1 element');
        }

        validate.enum(key + '[0]', val[0], reference.filter_operator);

        switch (unbundle(val[0])) {
            case '<':
            case '<=':
            case '>':
            case '>=':
                if (val.length >= 2 && val[1] == '$type') {
                    error(key, val, '"$type" cannot be use with operator "%s"', val[0]);
                }
            /* falls through */
            case '==':
            case '!=':
                if (val.length != 3) {
                    error(key, val, 'filter array for operator "%s" must have 3 elements', val[0]);
                }
            /* falls through */
            case 'in':
            case '!in':
                if (val.length >= 2) {
                    type = typeof_(val[1]);
                    if (type !== 'string') {
                        error(key + '[1]', val[1], 'string expected, %s found', type);
                    } else if (val[1][0] === '@') {
                        error(key + '[1]', val[1], 'filter key cannot be a constant');
                    }
                }
                for (var i = 2; i < val.length; i++) {
                    type = typeof_(val[i]);
                    if (val[1] == '$type') {
                        validate.enum(key + '[' + i + ']', val[i], reference.geometry_type);
                    } else if (type === 'string' && val[i][0] === '@') {
                        error(key + '[' + i + ']', val[i], 'filter value cannot be a constant');
                    } else if (type !== 'string' && type !== 'number' && type !== 'boolean') {
                        error(key + '[' + i + ']', val[i], 'string, number, or boolean expected, %s found', type);
                    }
                }
                break;

            case 'any':
            case 'all':
            case 'none':
                for (i = 1; i < val.length; i++) {
                    validate.filter(key + '[' + i + ']', val[i]);
                }
                break;
        }
    };

    validate.function = function(key, val, spec) {
        validate.object(key, val, reference.function, {
            stops: function (key, val, arraySpec) {
                var lastStop = -Infinity;
                validate.array(key, val, arraySpec, function validateStop(key, val) {
                    if (typeof_(val) !== 'array') {
                        return error(key, val, 'array expected, %s found', typeof_(val));
                    }

                    if (val.length !== 2) {
                        return error(key, val, 'array length %d expected, length %d found', 2, val.length);
                    }

                    validate(key + '[0]', val[0], {type: 'number'});
                    validate(key + '[1]', val[1], spec);

                    if (typeof_(val[0]) === 'number') {
                        if (spec.function === 'piecewise-constant' && val[0] % 1 !== 0) {
                            error(key + '[0]', val[0], 'zoom level for piecewise-constant functions must be an integer');
                        }

                        if (val[0] < lastStop) {
                            error(key + '[0]', val[0], 'array stops must appear in ascending order');
                        }

                        lastStop = val[0];
                    }
                });

                if (typeof_(val) === 'array' && val.length === 0) {
                    error(key, val, 'array must have at least one stop');
                }
            }
        });
    };

    validate.enum = function (key, val, spec) {
        if (spec.values.indexOf(unbundle(val)) === -1) {
            error(key, val, 'expected one of [%s], %s found', spec.values.join(', '), val);
        }
    };

    validate.color = function(key, val) {
        var type = typeof_(val);
        if (type !== 'string') {
            return error(key, val, 'color expected, %s found', type);
        }

        if (parseCSSColor(val) === null) {
            return error(key, val, 'color expected, "%s" found', val);
        }

    };

    function typeValidator(expected) {
        return function(key, val, spec) {
            var actual = typeof_(val);
            if (actual !== expected) {
                error(key, val, '%s expected, %s found', expected, actual);
            }

            if ('minimum' in spec && val < spec.minimum) {
                error(key, val, '%s is less than the minimum value %s', val, spec.minimum);
            }

            if ('maximum' in spec && val > spec.maximum) {
                error(key, val, '%s is greater than the maximum value %s', val, spec.maximum);
            }
        };
    }

    validate.number = typeValidator('number');
    validate.string = typeValidator('string');
    validate.boolean = typeValidator('boolean');

    validate['*'] = function() {};

    validate('', style, reference.$root);
    if (reference.$version > 7 && style.constants) {
        validate.constants('constants', style.constants);
    }

    errors.sort(function (a, b) {
      return a.line - b.line;
    });

    return errors;
};

function typeof_(val) {
    if (val instanceof Number)
        return 'number';
    if (val instanceof String)
        return 'string';
    if (val instanceof Boolean)
        return 'boolean';
    if (Array.isArray(val))
        return 'array';
    if (val === null)
        return 'null';
    return typeof val;
}

function unbundle(_) {
    if (_ instanceof Number ||
        _ instanceof String ||
        _ instanceof Boolean) {
        return _.valueOf();
    } else {
        return _;
    }
}

},{"csscolorparser":101,"util":100}],123:[function(require,module,exports){
module.exports = require('./v8.json');

},{"./v8.json":125}],124:[function(require,module,exports){
module.exports = require('./v8.min.json');

},{"./v8.min.json":126}],125:[function(require,module,exports){
module.exports={
  "$version": 8,
  "$root": {
    "version": {
      "required": true,
      "type": "enum",
      "values": [8],
      "doc": "Stylesheet version number. Must be 8.",
      "example": 8
    },
    "name": {
      "type": "string",
      "doc": "A human-readable name for the style.",
      "example": "Bright"
    },
    "metadata": {
      "type": "*",
      "doc": "Arbitrary properties useful to track with the stylesheet, but do not influence rendering. Properties should be prefixed to avoid collisions, like 'mapbox:'."
    },
    "center": {
      "type": "array",
      "value": "number",
      "doc": "Default map center in longitude and latitude.  The style center will be used only if the map has not been positioned by other means (e.g. map options or user interaction).",
      "example": [-73.9749, 40.7736]
    },
    "zoom": {
      "type": "number",
      "doc": "Default zoom level.  The style zoom will be used only if the map has not been positioned by other means (e.g. map options or user interaction).",
      "example": 12.5
    },
    "bearing": {
      "type": "number",
      "default": 0,
      "period": 360,
      "units": "degrees",
      "doc": "Default bearing, in degrees.  The style bearing will be used only if the map has not been positioned by other means (e.g. map options or user interaction).",
      "example": 29
    },
    "pitch": {
      "type": "number",
      "default": 0,
      "units": "degrees",
      "doc": "Default pitch, in degrees. Zero is perpendicular to the surface.  The style pitch will be used only if the map has not been positioned by other means (e.g. map options or user interaction).",
      "example": 50
    },
    "sources": {
      "required": true,
      "type": "sources",
      "doc": "Data source specifications.",
      "example": {
        "mapbox-streets": {
          "type": "vector",
          "url": "mapbox://mapbox.mapbox-streets-v6"
        }
      }
    },
    "sprite": {
      "type": "string",
      "doc": "A base URL for retrieving the sprite image and metadata. The extensions `.png`, `.json` and scale factor `@2x.png` will be automatically appended.",
      "example": "mapbox://sprites/mapbox/bright-v8"
    },
    "glyphs": {
      "type": "string",
      "doc": "A URL template for loading signed-distance-field glyph sets in PBF format. Valid tokens are {fontstack} and {range}.",
      "example": "mapbox://fonts/mapbox/{fontstack}/{range}.pbf"
    },
    "transition": {
      "type": "transition",
      "doc": "A global transition definition to use as a default across properties.",
      "example": {
        "duration": 300,
        "delay": 0
      }
    },
    "layers": {
      "required": true,
      "type": "array",
      "value": "layer",
      "doc": "Layers will be drawn in the order of this array.",
      "example": [
        {
          "id": "water",
          "source": "mapbox-streets",
          "source-layer": "water",
          "type": "fill",
          "paint": {
            "fill-color": "#00ffff"
          }
        }
      ]
    }
  },
  "sources": {
    "*": {
      "type": "source",
      "doc": "Specification of a data source. For vector and raster sources, either TileJSON or a URL to a TileJSON must be provided. For GeoJSON and video sources, a URL must be provided."
    }
  },
  "source": [
    "source_tile",
    "source_geojson",
    "source_video",
    "source_image"
  ],
  "source_tile": {
    "type": {
      "required": true,
      "type": "enum",
      "values": [
        "vector",
        "raster"
      ],
      "doc": "The data type of the tile source."
    },
    "url": {
      "type": "string",
      "doc": "A URL to a TileJSON resource. Supported protocols are `http:`, `https:`, and `mapbox://<mapid>`."
    },
    "tiles": {
      "type": "array",
      "value": "string",
      "doc": "An array of one or more tile source URLs, as in the TileJSON spec."
    },
    "minzoom": {
      "type": "number",
      "default": 0,
      "doc": "Minimum zoom level for which tiles are available, as in the TileJSON spec."
    },
    "maxzoom": {
      "type": "number",
      "default": 22,
      "doc": "Maximum zoom level for which tiles are available, as in the TileJSON spec. Data from tiles at the maxzoom are used when displaying the map at higher zoom levels."
    },
    "tileSize": {
      "type": "number",
      "default": 512,
      "units": "pixels",
      "doc": "The minimum visual size to display tiles for this layer. Only configurable for raster layers."
    },
    "*": {
      "type": "*",
      "doc": "Other keys to configure the data source."
    }
  },
  "source_geojson": {
    "type": {
      "required": true,
      "type": "enum",
      "values": [
        "geojson"
      ],
      "doc": "The data type of the GeoJSON source."
    },
    "data": {
      "type": "*",
      "doc": "A URL to a GeoJSON file, or inline GeoJSON."
    },
    "maxzoom": {
      "type": "number",
      "default": 14,
      "doc": "Maximum zoom to preserve detail at."
    },
    "buffer": {
      "type": "number",
      "default": 64,
      "doc": "Tile buffer on each side."
    },
    "tolerance": {
      "type": "number",
      "default": 3,
      "doc": "Simplification tolerance (higher means simpler)."
    }
  },
  "source_video": {
    "type": {
      "required": true,
      "type": "enum",
      "values": [
        "video"
      ],
      "doc": "The data type of the video source."
    },
    "urls": {
      "required": true,
      "type": "array",
      "value": "string",
      "doc": "URLs to video content in order of preferred format."
    },
    "coordinates": {
      "required": true,
      "doc": "Corners of video specified in longitude, latitude pairs.",
      "type": "array",
      "length": 4,
      "value": {
        "type": "array",
        "length": 2,
        "value": "number",
        "doc": "A single longitude, latitude pair."
      }
    }
  },
  "source_image": {
    "type": {
      "required": true,
      "type": "enum",
      "values": [
        "image"
      ],
      "doc": "The data type of the image source."
    },
    "url": {
      "required": true,
      "type": "string",
      "doc": "URL that points to an image"
    },
    "coordinates": {
      "required": true,
      "doc": "Corners of image specified in longitude, latitude pairs.",
      "type": "array",
      "length": 4,
      "value": {
        "type": "array",
        "length": 2,
        "value": "number",
        "doc": "A single longitude, latitude pair."
      }
    }
  },
  "layer": {
    "id": {
      "type": "string",
      "doc": "Unique layer name."
    },
    "type": {
      "type": "enum",
      "values": [
        "fill",
        "line",
        "symbol",
        "circle",
        "raster",
        "background"
      ],
      "doc": "Rendering type of this layer."
    },
    "metadata": {
      "type": "*",
      "doc": "Arbitrary properties useful to track with the layer, but do not influence rendering. Properties should be prefixed to avoid collisions, like 'mapbox:'."
    },
    "ref": {
      "type": "string",
      "doc": "References another layer to copy `type`, `source`, `source-layer`, `minzoom`, `maxzoom`, `filter`, and `layout` properties from. This allows the layers to share processing and be more efficient."
    },
    "source": {
      "type": "string",
      "doc": "Name of a source description to be used for this layer."
    },
    "source-layer": {
      "type": "string",
      "doc": "Layer to use from a vector tile source. Required if the source supports multiple layers."
    },
    "minzoom": {
      "type": "number",
      "minimum": 0,
      "maximum": 22,
      "doc": "The minimum zoom level on which the layer gets parsed and appears on."
    },
    "maxzoom": {
      "type": "number",
      "minimum": 0,
      "maximum": 22,
      "doc": "The maximum zoom level on which the layer gets parsed and appears on."
    },
    "interactive": {
      "type": "boolean",
      "doc": "Enable querying of feature data from this layer for interactivity.",
      "default": false
    },
    "filter": {
      "type": "filter",
      "doc": "A expression specifying conditions on source features. Only features that match the filter are displayed."
    },
    "layout": {
      "type": "layout",
      "doc": "Layout properties for the layer."
    },
    "paint": {
      "type": "paint",
      "doc": "Default paint properties for this layer."
    },
    "paint.*": {
      "type": "paint",
      "doc": "Class-specific paint properties for this layer. The class name is the part after the first dot."
    }
  },
  "layout": [
    "layout_fill",
    "layout_line",
    "layout_circle",
    "layout_symbol",
    "layout_raster",
    "layout_background"
  ],
  "layout_background": {
    "visibility": {
      "type": "enum",
      "function": "piecewise-constant",
      "values": [
        "visible",
        "none"
      ],
      "default": "visible",
      "doc": "The display of this layer. `none` hides this layer."
    }
  },
  "layout_fill": {
    "visibility": {
      "type": "enum",
      "function": "piecewise-constant",
      "values": [
        "visible",
        "none"
      ],
      "default": "visible",
      "doc": "The display of this layer. `none` hides this layer."
    }
  },
  "layout_circle": {
    "visibility": {
      "type": "enum",
      "function": "piecewise-constant",
      "values": [
        "visible",
        "none"
      ],
      "default": "visible",
      "doc": "The display of this layer. `none` hides this layer."
    }
  },
  "layout_line": {
    "line-cap": {
      "type": "enum",
      "function": "piecewise-constant",
      "values": [
        "butt",
        "round",
        "square"
      ],
      "default": "butt",
      "doc": "The display of line endings."
    },
    "line-join": {
      "type": "enum",
      "function": "piecewise-constant",
      "values": [
        "bevel",
        "round",
        "miter"
      ],
      "default": "miter",
      "doc": "The display of lines when joining."
    },
    "line-miter-limit": {
      "type": "number",
      "default": 2,
      "function": "interpolated",
      "doc": "Used to automatically convert miter joins to bevel joins for sharp angles.",
      "requires": [
        {
          "line-join": "miter"
        }
      ]
    },
    "line-round-limit": {
      "type": "number",
      "default": 1.05,
      "function": "interpolated",
      "doc": "Used to automatically convert round joins to miter joins for shallow angles.",
      "requires": [
        {
          "line-join": "round"
        }
      ]
    },
    "visibility": {
      "type": "enum",
      "function": "piecewise-constant",
      "values": [
        "visible",
        "none"
      ],
      "default": "visible",
      "doc": "The display of this layer. `none` hides this layer."
    }
  },
  "layout_symbol": {
    "symbol-placement": {
      "type": "enum",
      "function": "piecewise-constant",
      "values": [
          "point",
          "line"
      ],
      "default": "point",
      "doc": "Label placement relative to its geometry. `line` can only be used on LineStrings and Polygons."
    },
    "symbol-spacing": {
      "type": "number",
      "default": 250,
      "minimum": 1,
      "function": "interpolated",
      "units": "pixels",
      "doc": "Distance between two symbol anchors.",
      "requires": [
        {
          "symbol-placement": "line"
        }
      ]
    },
    "symbol-avoid-edges": {
      "type": "boolean",
      "function": "piecewise-constant",
      "default": false,
      "doc": "If true, the symbols will not cross tile edges to avoid mutual collisions. Recommended in layers that don't have enough padding in the vector tile to prevent collisions, or if it is a point symbol layer placed after a line symbol layer."
    },
    "icon-allow-overlap": {
      "type": "boolean",
      "function": "piecewise-constant",
      "default": false,
      "doc": "If true, the icon will be visible even if it collides with other previously drawn symbols.",
      "requires": [
        "icon-image"
      ]
    },
    "icon-ignore-placement": {
      "type": "boolean",
      "function": "piecewise-constant",
      "default": false,
      "doc": "If true, other symbols can be visible even if they collide with the icon.",
      "requires": [
        "icon-image"
      ]
    },
    "icon-optional": {
      "type": "boolean",
      "function": "piecewise-constant",
      "default": false,
      "doc": "If true, text will display without their corresponding icons when the icon collides with other symbols and the text does not.",
      "requires": [
        "icon-image",
        "text-field"
      ]
    },
    "icon-rotation-alignment": {
      "type": "enum",
      "function": "piecewise-constant",
      "values": [
        "map",
        "viewport"
      ],
      "default": "viewport",
      "doc": "Orientation of icon when map is rotated.",
      "requires": [
        "icon-image"
      ]
    },
    "icon-size": {
      "type": "number",
      "default": 1,
      "minimum": 0,
      "function": "interpolated",
      "doc": "Scale factor for icon. 1 is original size, 3 triples the size.",
      "requires": [
        "icon-image"
      ]
    },
    "icon-image": {
      "type": "string",
      "function": "piecewise-constant",
      "doc": "A string with {tokens} replaced, referencing the data property to pull from.",
      "tokens": true
    },
    "icon-rotate": {
      "type": "number",
      "default": 0,
      "period": 360,
      "function": "interpolated",
      "units": "degrees",
      "doc": "Rotates the icon clockwise.",
      "requires": [
        "icon-image"
      ]
    },
    "icon-padding": {
      "type": "number",
      "default": 2,
      "minimum": 0,
      "function": "interpolated",
      "units": "pixels",
      "doc": "Size of the additional area around the icon bounding box used for detecting symbol collisions.",
      "requires": [
        "icon-image"
      ]
    },
    "icon-keep-upright": {
      "type": "boolean",
      "function": "piecewise-constant",
      "default": false,
      "doc": "If true, the icon may be flipped to prevent it from being rendered upside-down.",
      "requires": [
        "icon-image",
        {
          "icon-rotation-alignment": "map"
        },
        {
          "symbol-placement": "line"
        }
      ]
    },
    "icon-offset": {
      "type": "array",
      "value": "number",
      "length": 2,
      "default": [
        0,
        0
      ],
      "function": "interpolated",
      "doc": "Offset distance of icon from its anchor. Positive values indicate right and down, while negative values indicate left and up.",
      "requires": [
        "icon-image"
      ]
    },
    "text-rotation-alignment": {
      "type": "enum",
      "function": "piecewise-constant",
      "values": [
        "map",
        "viewport"
      ],
      "default": "viewport",
      "doc": "Orientation of text when map is rotated.",
      "requires": [
        "text-field"
      ]
    },
    "text-field": {
      "type": "string",
      "function": "piecewise-constant",
      "default": "",
      "tokens": true,
      "doc": "Value to use for a text label. Feature properties are specified using tokens like {field_name}."
    },
    "text-font": {
      "type": "array",
      "value": "string",
      "function": "piecewise-constant",
      "default": ["Open Sans Regular", "Arial Unicode MS Regular"],
      "doc": "Font stack to use for displaying text.",
      "requires": [
        "text-field"
      ]
    },
    "text-size": {
      "type": "number",
      "default": 16,
      "minimum": 0,
      "units": "pixels",
      "function": "interpolated",
      "doc": "Font size.",
      "requires": [
        "text-field"
      ]
    },
    "text-max-width": {
      "type": "number",
      "default": 10,
      "minimum": 0,
      "units": "em",
      "function": "interpolated",
      "doc": "The maximum line width for text wrapping.",
      "requires": [
        "text-field"
      ]
    },
    "text-line-height": {
      "type": "number",
      "default": 1.2,
      "units": "em",
      "function": "interpolated",
      "doc": "Text leading value for multi-line text.",
      "requires": [
        "text-field"
      ]
    },
    "text-letter-spacing": {
      "type": "number",
      "default": 0,
      "units": "em",
      "function": "interpolated",
      "doc": "Text tracking amount.",
      "requires": [
        "text-field"
      ]
    },
    "text-justify": {
      "type": "enum",
      "function": "piecewise-constant",
      "values": [
        "left",
        "center",
        "right"
      ],
      "default": "center",
      "doc": "Text justification options.",
      "requires": [
        "text-field"
      ]
    },
    "text-anchor": {
      "type": "enum",
      "function": "piecewise-constant",
      "values": [
        "center",
        "left",
        "right",
        "top",
        "bottom",
        "top-left",
        "top-right",
        "bottom-left",
        "bottom-right"
      ],
      "default": "center",
      "doc": "Part of the text placed closest to the anchor.",
      "requires": [
        "text-field"
      ]
    },
    "text-max-angle": {
      "type": "number",
      "default": 45,
      "units": "degrees",
      "function": "interpolated",
      "doc": "Maximum angle change between adjacent characters.",
      "requires": [
        "text-field",
        {
          "symbol-placement": "line"
        }
      ]
    },
    "text-rotate": {
      "type": "number",
      "default": 0,
      "period": 360,
      "units": "degrees",
      "function": "interpolated",
      "doc": "Rotates the text clockwise.",
      "requires": [
        "text-field"
      ]
    },
    "text-padding": {
      "type": "number",
      "default": 2,
      "minimum": 0,
      "units": "pixels",
      "function": "interpolated",
      "doc": "Size of the additional area around the text bounding box used for detecting symbol collisions.",
      "requires": [
        "text-field"
      ]
    },
    "text-keep-upright": {
      "type": "boolean",
      "function": "piecewise-constant",
      "default": true,
      "doc": "If true, the text may be flipped vertically to prevent it from being rendered upside-down.",
      "requires": [
        "text-field",
        {
          "text-rotation-alignment": "map"
        },
        {
          "symbol-placement": "line"
        }
      ]
    },
    "text-transform": {
      "type": "enum",
      "function": "piecewise-constant",
      "values": [
        "none",
        "uppercase",
        "lowercase"
      ],
      "default": "none",
      "doc": "Specifies how to capitalize text, similar to the CSS `text-transform` property.",
      "requires": [
        "text-field"
      ]
    },
    "text-offset": {
      "type": "array",
      "doc": "Offset distance of text from its anchor. Positive values indicate right and down, while negative values indicate left and up.",
      "value": "number",
      "units": "ems",
      "function": "interpolated",
      "length": 2,
      "default": [
        0,
        0
      ],
      "requires": [
        "text-field"
      ]
    },
    "text-allow-overlap": {
      "type": "boolean",
      "function": "piecewise-constant",
      "default": false,
      "doc": "If true, the text will be visible even if it collides with other previously drawn symbols.",
      "requires": [
        "text-field"
      ]
    },
    "text-ignore-placement": {
      "type": "boolean",
      "function": "piecewise-constant",
      "default": false,
      "doc": "If true, other symbols can be visible even if they collide with the text.",
      "requires": [
        "text-field"
      ]
    },
    "text-optional": {
      "type": "boolean",
      "function": "piecewise-constant",
      "default": false,
      "doc": "If true, icons will display without their corresponding text when the text collides with other symbols and the icon does not.",
      "requires": [
        "text-field",
        "icon-image"
      ]
    },
    "visibility": {
      "type": "enum",
      "function": "piecewise-constant",
      "values": [
        "visible",
        "none"
      ],
      "default": "visible",
      "doc": "The display of this layer. `none` hides this layer."
    }
  },
  "layout_raster": {
    "visibility": {
      "type": "enum",
      "function": "piecewise-constant",
      "values": [
        "visible",
        "none"
      ],
      "default": "visible",
      "doc": "The display of this layer. `none` hides this layer."
    }
  },
  "filter": {
    "type": "array",
    "value": "*",
    "doc": "A filter selects specific features from a layer."
  },
  "filter_operator": {
    "type": "enum",
    "values": [
      "==",
      "!=",
      ">",
      ">=",
      "<",
      "<=",
      "in",
      "!in",
      "all",
      "any",
      "none"
    ],
    "doc": "The filter operator."
  },
  "geometry_type": {
    "type": "enum",
    "values": [
      "Point",
      "LineString",
      "Polygon"
    ],
    "doc": "The geometry type for the filter to select."
  },
  "color_operation": {
    "type": "enum",
    "values": [
      "lighten",
      "saturate",
      "spin",
      "fade",
      "mix"
    ],
    "doc": "A color operation to apply."
  },
  "function": {
    "stops": {
      "type": "array",
      "required": true,
      "doc": "An array of stops.",
      "value": "function_stop"
    },
    "base": {
      "type": "number",
      "default": 1,
      "minimum": 0,
      "doc": "The exponential base of the interpolation curve. It controls the rate at which the result increases. Higher values make the result increase more towards the high end of the range. With `1` the stops are interpolated linearly."
    }
  },
  "function_stop": {
    "type": "array",
    "minimum": 0,
    "maximum": 22,
    "value": [
      "number",
      "color"
    ],
    "length": 2,
    "doc": "Zoom level and value pair."
  },
  "paint": [
    "paint_fill",
    "paint_line",
    "paint_circle",
    "paint_symbol",
    "paint_raster",
    "paint_background"
  ],
  "paint_fill": {
    "fill-antialias": {
      "type": "boolean",
      "function": "piecewise-constant",
      "default": true,
      "doc": "Whether or not the fill should be antialiased."
    },
    "fill-opacity": {
      "type": "number",
      "function": "interpolated",
      "default": 1,
      "minimum": 0,
      "maximum": 1,
      "doc": "The opacity given to the fill color.",
      "transition": true
    },
    "fill-color": {
      "type": "color",
      "default": "#000000",
      "doc": "The color of the fill.",
      "function": "interpolated",
      "transition": true,
      "requires": [
        {
          "!": "fill-pattern"
        }
      ]
    },
    "fill-outline-color": {
      "type": "color",
      "doc": "The outline color of the fill. Matches the value of `fill-color` if unspecified.",
      "function": "interpolated",
      "transition": true,
      "requires": [
        {
          "!": "fill-pattern"
        },
        {
          "fill-antialias": true
        }
      ]
    },
    "fill-translate": {
      "type": "array",
      "value": "number",
      "length": 2,
      "default": [
        0,
        0
      ],
      "function": "interpolated",
      "transition": true,
      "units": "pixels",
      "doc": "The geometry's offset. Values are [x, y] where negatives indicate left and up, respectively."
    },
    "fill-translate-anchor": {
      "type": "enum",
      "function": "piecewise-constant",
      "values": [
        "map",
        "viewport"
      ],
      "doc": "Control whether the translation is relative to the map (north) or viewport (screen)",
      "default": "map",
      "requires": [
        "fill-translate"
      ]
    },
    "fill-pattern": {
      "type": "string",
      "function": "piecewise-constant",
      "transition": true,
      "doc": "Name of image in sprite to use for drawing image fills. For seamless patterns, image width and height must be a factor of two (2, 4, 8, ..., 512)."
    }
  },
  "paint_line": {
    "line-opacity": {
      "type": "number",
      "doc": "The opacity at which the line will be drawn.",
      "function": "interpolated",
      "default": 1,
      "minimum": 0,
      "maximum": 1,
      "transition": true
    },
    "line-color": {
      "type": "color",
      "doc": "The color with which the line will be drawn.",
      "default": "#000000",
      "function": "interpolated",
      "transition": true,
      "requires": [
        {
          "!": "line-pattern"
        }
      ]
    },
    "line-translate": {
      "type": "array",
      "value": "number",
      "length": 2,
      "default": [
        0,
        0
      ],
      "function": "interpolated",
      "transition": true,
      "units": "pixels",
      "doc": "The geometry's offset. Values are [x, y] where negatives indicate left and up, respectively."
    },
    "line-translate-anchor": {
      "type": "enum",
      "function": "piecewise-constant",
      "values": [
        "map",
        "viewport"
      ],
      "doc": "Control whether the translation is relative to the map (north) or viewport (screen)",
      "default": "map",
      "requires": [
        "line-translate"
      ]
    },
    "line-width": {
      "type": "number",
      "default": 1,
      "minimum": 0,
      "function": "interpolated",
      "transition": true,
      "units": "pixels",
      "doc": "Stroke thickness."
    },
    "line-gap-width": {
      "type": "number",
      "default": 0,
      "minimum": 0,
      "doc": "Draws a line casing outside of a line's actual path. Value indicates the width of the inner gap.",
      "function": "interpolated",
      "transition": true,
      "units": "pixels"
    },
    "line-offset": {
      "type": "number",
      "default": 0,
      "doc": "The line's offset perpendicular to its direction. Values may be positive or negative, where positive indicates \"leftwards\" (if you were moving in the direction of the line) and negative indicates \"rightwards.\"",
      "function": "interpolated",
      "transition": true,
      "units": "pixels"
    },
    "line-blur": {
      "type": "number",
      "default": 0,
      "minimum": 0,
      "function": "interpolated",
      "transition": true,
      "units": "pixels",
      "doc": "Blur applied to the line, in pixels."
    },
    "line-dasharray": {
      "type": "array",
      "value": "number",
      "function": "piecewise-constant",
      "doc": "Specifies the lengths of the alternating dashes and gaps that form the dash pattern. The lengths are later scaled by the line width. To convert a dash length to pixels, multiply the length by the current line width.",
      "minimum": 0,
      "transition": true,
      "units": "line widths",
      "requires": [
        {
          "!": "line-pattern"
        }
      ]
    },
    "line-pattern": {
      "type": "string",
      "function": "piecewise-constant",
      "transition": true,
      "doc": "Name of image in sprite to use for drawing image lines. For seamless patterns, image width must be a factor of two (2, 4, 8, ..., 512)."
    }
  },
  "paint_circle": {
    "circle-radius": {
      "type": "number",
      "default": 5,
      "minimum": 0,
      "function": "interpolated",
      "transition": true,
      "units": "pixels",
      "doc": "Circle radius."
    },
    "circle-color": {
      "type": "color",
      "default": "#000000",
      "doc": "The color of the circle.",
      "function": "interpolated",
      "transition": true
    },
    "circle-blur": {
      "type": "number",
      "default": 0,
      "doc": "Amount to blur the circle. 1 blurs the circle such that only the centerpoint is full opacity.",
      "function": "interpolated",
      "transition": true
    },
    "circle-opacity": {
      "type": "number",
      "doc": "The opacity at which the circle will be drawn.",
      "default": 1,
      "minimum": 0,
      "maximum": 1,
      "function": "interpolated",
      "transition": true
    },
    "circle-translate": {
      "type": "array",
      "value": "number",
      "length": 2,
      "default": [0, 0],
      "function": "interpolated",
      "transition": true,
      "units": "pixels",
      "doc": "The geometry's offset. Values are [x, y] where negatives indicate left and up, respectively."
    },
    "circle-translate-anchor": {
      "type": "enum",
      "function": "piecewise-constant",
      "values": [
        "map",
        "viewport"
      ],
      "doc": "Control whether the translation is relative to the map (north) or viewport (screen)",
      "default": "map",
      "requires": [
        "circle-translate"
      ]
    }
  },
  "paint_symbol": {
    "icon-opacity": {
      "doc": "The opacity at which the icon will be drawn.",
      "type": "number",
      "default": 1,
      "minimum": 0,
      "maximum": 1,
      "function": "interpolated",
      "transition": true,
      "requires": [
        "icon-image"
      ]
    },
    "icon-color": {
      "type": "color",
      "default": "#000000",
      "function": "interpolated",
      "transition": true,
      "doc": "The color of the icon. This can only be used with sdf icons.",
      "requires": [
        "icon-image"
      ]
    },
    "icon-halo-color": {
      "type": "color",
      "default": "rgba(0, 0, 0, 0)",
      "function": "interpolated",
      "transition": true,
      "doc": "The color of the icon's halo. Icon halos can only be used with sdf icons.",
      "requires": [
        "icon-image"
      ]
    },
    "icon-halo-width": {
      "type": "number",
      "default": 0,
      "minimum": 0,
      "function": "interpolated",
      "transition": true,
      "units": "pixels",
      "doc": "Distance of halo to the icon outline.",
      "requires": [
        "icon-image"
      ]
    },
    "icon-halo-blur": {
      "type": "number",
      "default": 0,
      "minimum": 0,
      "function": "interpolated",
      "transition": true,
      "units": "pixels",
      "doc": "Fade out the halo towards the outside.",
      "requires": [
        "icon-image"
      ]
    },
    "icon-translate": {
      "type": "array",
      "value": "number",
      "length": 2,
      "default": [
        0,
        0
      ],
      "function": "interpolated",
      "transition": true,
      "units": "pixels",
      "doc": "Distance that the icon's anchor is moved from its original placement. Positive values indicate right and down, while negative values indicate left and up.",
      "requires": [
        "icon-image"
      ]
    },
    "icon-translate-anchor": {
      "type": "enum",
      "function": "piecewise-constant",
      "values": [
        "map",
        "viewport"
      ],
      "doc": "Control whether the translation is relative to the map (north) or viewport (screen).",
      "default": "map",
      "requires": [
        "icon-image",
        "icon-translate"
      ]
    },
    "text-opacity": {
      "type": "number",
      "doc": "The opacity at which the text will be drawn.",
      "default": 1,
      "minimum": 0,
      "maximum": 1,
      "function": "interpolated",
      "transition": true,
      "requires": [
        "text-field"
      ]
    },
    "text-color": {
      "type": "color",
      "doc": "The color with which the text will be drawn.",
      "default": "#000000",
      "function": "interpolated",
      "transition": true,
      "requires": [
        "text-field"
      ]
    },
    "text-halo-color": {
      "type": "color",
      "default": "rgba(0, 0, 0, 0)",
      "function": "interpolated",
      "transition": true,
      "doc": "The color of the text's halo, which helps it stand out from backgrounds.",
      "requires": [
        "text-field"
      ]
    },
    "text-halo-width": {
      "type": "number",
      "default": 0,
      "minimum": 0,
      "function": "interpolated",
      "transition": true,
      "units": "pixels",
      "doc": "Distance of halo to the font outline. Max text halo width is 1/4 of the font-size.",
      "requires": [
        "text-field"
      ]
    },
    "text-halo-blur": {
      "type": "number",
      "default": 0,
      "minimum": 0,
      "function": "interpolated",
      "transition": true,
      "units": "pixels",
      "doc": "The halo's fadeout distance towards the outside.",
      "requires": [
        "text-field"
      ]
    },
    "text-translate": {
      "type": "array",
      "value": "number",
      "length": 2,
      "default": [
        0,
        0
      ],
      "function": "interpolated",
      "transition": true,
      "units": "pixels",
      "doc": "Distance that the text's anchor is moved from its original placement. Positive values indicate right and down, while negative values indicate left and up.",
      "requires": [
        "text-field"
      ]
    },
    "text-translate-anchor": {
      "type": "enum",
      "function": "piecewise-constant",
      "values": [
        "map",
        "viewport"
      ],
      "doc": "Control whether the translation is relative to the map (north) or viewport (screen).",
      "default": "map",
      "requires": [
        "text-field",
        "text-translate"
      ]
    }
  },
  "paint_raster": {
    "raster-opacity": {
      "type": "number",
      "doc": "The opacity at which the image will be drawn.",
      "default": 1,
      "minimum": 0,
      "maximum": 1,
      "function": "interpolated",
      "transition": true
    },
    "raster-hue-rotate": {
      "type": "number",
      "default": 0,
      "period": 360,
      "function": "interpolated",
      "transition": true,
      "units": "degrees",
      "doc": "Rotates hues around the color wheel."
    },
    "raster-brightness-min": {
      "type": "number",
      "function": "interpolated",
      "doc": "Increase or reduce the brightness of the image. The value is the minimum brightness.",
      "default": 0,
      "minimum": 0,
      "maximum": 1,
      "transition": true
    },
    "raster-brightness-max": {
      "type": "number",
      "function": "interpolated",
      "doc": "Increase or reduce the brightness of the image. The value is the maximum brightness.",
      "default": 1,
      "minimum": 0,
      "maximum": 1,
      "transition": true
    },
    "raster-saturation": {
      "type": "number",
      "doc": "Increase or reduce the saturation of the image.",
      "default": 0,
      "minimum": -1,
      "maximum": 1,
      "function": "interpolated",
      "transition": true
    },
    "raster-contrast": {
      "type": "number",
      "doc": "Increase or reduce the contrast of the image.",
      "default": 0,
      "minimum": -1,
      "maximum": 1,
      "function": "interpolated",
      "transition": true
    },
    "raster-fade-duration": {
      "type": "number",
      "default": 300,
      "minimum": 0,
      "function": "interpolated",
      "transition": true,
      "units": "milliseconds",
      "doc": "Fade duration when a new tile is added."
    }
  },
  "paint_background": {
    "background-color": {
      "type": "color",
      "default": "#000000",
      "doc": "The color with which the background will be drawn.",
      "function": "interpolated",
      "transition": true,
      "requires": [
        {
          "!": "background-pattern"
        }
      ]
    },
    "background-pattern": {
      "type": "string",
      "function": "piecewise-constant",
      "transition": true,
      "doc": "Name of image in sprite to use for drawing an image background. For seamless patterns, image width and height must be a factor of two (2, 4, 8, ..., 512)."
    },
    "background-opacity": {
      "type": "number",
      "default": 1,
      "minimum": 0,
      "maximum": 1,
      "doc": "The opacity at which the background will be drawn.",
      "function": "interpolated",
      "transition": true
    }
  },
  "transition": {
    "duration": {
      "type": "number",
      "default": 300,
      "minimum": 0,
      "units": "milliseconds",
      "doc": "Time allotted for transitions to complete."
    },
    "delay": {
      "type": "number",
      "default": 0,
      "minimum": 0,
      "units": "milliseconds",
      "doc": "Length of time before a transition begins."
    }
  }
}

},{}],126:[function(require,module,exports){
module.exports={"$version":8,"$root":{"version":{"required":true,"type":"enum","values":[8]},"name":{"type":"string"},"metadata":{"type":"*"},"center":{"type":"array","value":"number"},"zoom":{"type":"number"},"bearing":{"type":"number","default":0,"period":360,"units":"degrees"},"pitch":{"type":"number","default":0,"units":"degrees"},"sources":{"required":true,"type":"sources"},"sprite":{"type":"string"},"glyphs":{"type":"string"},"transition":{"type":"transition"},"layers":{"required":true,"type":"array","value":"layer"}},"sources":{"*":{"type":"source"}},"source":["source_tile","source_geojson","source_video","source_image"],"source_tile":{"type":{"required":true,"type":"enum","values":["vector","raster"]},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512,"units":"pixels"},"*":{"type":"*"}},"source_geojson":{"type":{"required":true,"type":"enum","values":["geojson"]},"data":{"type":"*"},"maxzoom":{"type":"number","default":14},"buffer":{"type":"number","default":64},"tolerance":{"type":"number","default":3}},"source_video":{"type":{"required":true,"type":"enum","values":["video"]},"urls":{"required":true,"type":"array","value":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"source_image":{"type":{"required":true,"type":"enum","values":["image"]},"url":{"required":true,"type":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"layer":{"id":{"type":"string"},"type":{"type":"enum","values":["fill","line","symbol","circle","raster","background"]},"metadata":{"type":"*"},"ref":{"type":"string"},"source":{"type":"string"},"source-layer":{"type":"string"},"minzoom":{"type":"number","minimum":0,"maximum":22},"maxzoom":{"type":"number","minimum":0,"maximum":22},"interactive":{"type":"boolean","default":false},"filter":{"type":"filter"},"layout":{"type":"layout"},"paint":{"type":"paint"},"paint.*":{"type":"paint"}},"layout":["layout_fill","layout_line","layout_circle","layout_symbol","layout_raster","layout_background"],"layout_background":{"visibility":{"type":"enum","function":"piecewise-constant","values":["visible","none"],"default":"visible"}},"layout_fill":{"visibility":{"type":"enum","function":"piecewise-constant","values":["visible","none"],"default":"visible"}},"layout_circle":{"visibility":{"type":"enum","function":"piecewise-constant","values":["visible","none"],"default":"visible"}},"layout_line":{"line-cap":{"type":"enum","function":"piecewise-constant","values":["butt","round","square"],"default":"butt"},"line-join":{"type":"enum","function":"piecewise-constant","values":["bevel","round","miter"],"default":"miter"},"line-miter-limit":{"type":"number","default":2,"function":"interpolated","requires":[{"line-join":"miter"}]},"line-round-limit":{"type":"number","default":1.05,"function":"interpolated","requires":[{"line-join":"round"}]},"visibility":{"type":"enum","function":"piecewise-constant","values":["visible","none"],"default":"visible"}},"layout_symbol":{"symbol-placement":{"type":"enum","function":"piecewise-constant","values":["point","line"],"default":"point"},"symbol-spacing":{"type":"number","default":250,"minimum":1,"function":"interpolated","units":"pixels","requires":[{"symbol-placement":"line"}]},"symbol-avoid-edges":{"type":"boolean","function":"piecewise-constant","default":false},"icon-allow-overlap":{"type":"boolean","function":"piecewise-constant","default":false,"requires":["icon-image"]},"icon-ignore-placement":{"type":"boolean","function":"piecewise-constant","default":false,"requires":["icon-image"]},"icon-optional":{"type":"boolean","function":"piecewise-constant","default":false,"requires":["icon-image","text-field"]},"icon-rotation-alignment":{"type":"enum","function":"piecewise-constant","values":["map","viewport"],"default":"viewport","requires":["icon-image"]},"icon-size":{"type":"number","default":1,"minimum":0,"function":"interpolated","requires":["icon-image"]},"icon-image":{"type":"string","function":"piecewise-constant","tokens":true},"icon-rotate":{"type":"number","default":0,"period":360,"function":"interpolated","units":"degrees","requires":["icon-image"]},"icon-padding":{"type":"number","default":2,"minimum":0,"function":"interpolated","units":"pixels","requires":["icon-image"]},"icon-keep-upright":{"type":"boolean","function":"piecewise-constant","default":false,"requires":["icon-image",{"icon-rotation-alignment":"map"},{"symbol-placement":"line"}]},"icon-offset":{"type":"array","value":"number","length":2,"default":[0,0],"function":"interpolated","requires":["icon-image"]},"text-rotation-alignment":{"type":"enum","function":"piecewise-constant","values":["map","viewport"],"default":"viewport","requires":["text-field"]},"text-field":{"type":"string","function":"piecewise-constant","default":"","tokens":true},"text-font":{"type":"array","value":"string","function":"piecewise-constant","default":["Open Sans Regular","Arial Unicode MS Regular"],"requires":["text-field"]},"text-size":{"type":"number","default":16,"minimum":0,"units":"pixels","function":"interpolated","requires":["text-field"]},"text-max-width":{"type":"number","default":10,"minimum":0,"units":"em","function":"interpolated","requires":["text-field"]},"text-line-height":{"type":"number","default":1.2,"units":"em","function":"interpolated","requires":["text-field"]},"text-letter-spacing":{"type":"number","default":0,"units":"em","function":"interpolated","requires":["text-field"]},"text-justify":{"type":"enum","function":"piecewise-constant","values":["left","center","right"],"default":"center","requires":["text-field"]},"text-anchor":{"type":"enum","function":"piecewise-constant","values":["center","left","right","top","bottom","top-left","top-right","bottom-left","bottom-right"],"default":"center","requires":["text-field"]},"text-max-angle":{"type":"number","default":45,"units":"degrees","function":"interpolated","requires":["text-field",{"symbol-placement":"line"}]},"text-rotate":{"type":"number","default":0,"period":360,"units":"degrees","function":"interpolated","requires":["text-field"]},"text-padding":{"type":"number","default":2,"minimum":0,"units":"pixels","function":"interpolated","requires":["text-field"]},"text-keep-upright":{"type":"boolean","function":"piecewise-constant","default":true,"requires":["text-field",{"text-rotation-alignment":"map"},{"symbol-placement":"line"}]},"text-transform":{"type":"enum","function":"piecewise-constant","values":["none","uppercase","lowercase"],"default":"none","requires":["text-field"]},"text-offset":{"type":"array","value":"number","units":"ems","function":"interpolated","length":2,"default":[0,0],"requires":["text-field"]},"text-allow-overlap":{"type":"boolean","function":"piecewise-constant","default":false,"requires":["text-field"]},"text-ignore-placement":{"type":"boolean","function":"piecewise-constant","default":false,"requires":["text-field"]},"text-optional":{"type":"boolean","function":"piecewise-constant","default":false,"requires":["text-field","icon-image"]},"visibility":{"type":"enum","function":"piecewise-constant","values":["visible","none"],"default":"visible"}},"layout_raster":{"visibility":{"type":"enum","function":"piecewise-constant","values":["visible","none"],"default":"visible"}},"filter":{"type":"array","value":"*"},"filter_operator":{"type":"enum","values":["==","!=",">",">=","<","<=","in","!in","all","any","none"]},"geometry_type":{"type":"enum","values":["Point","LineString","Polygon"]},"color_operation":{"type":"enum","values":["lighten","saturate","spin","fade","mix"]},"function":{"stops":{"type":"array","required":true,"value":"function_stop"},"base":{"type":"number","default":1,"minimum":0}},"function_stop":{"type":"array","minimum":0,"maximum":22,"value":["number","color"],"length":2},"paint":["paint_fill","paint_line","paint_circle","paint_symbol","paint_raster","paint_background"],"paint_fill":{"fill-antialias":{"type":"boolean","function":"piecewise-constant","default":true},"fill-opacity":{"type":"number","function":"interpolated","default":1,"minimum":0,"maximum":1,"transition":true},"fill-color":{"type":"color","default":"#000000","function":"interpolated","transition":true,"requires":[{"!":"fill-pattern"}]},"fill-outline-color":{"type":"color","function":"interpolated","transition":true,"requires":[{"!":"fill-pattern"},{"fill-antialias":true}]},"fill-translate":{"type":"array","value":"number","length":2,"default":[0,0],"function":"interpolated","transition":true,"units":"pixels"},"fill-translate-anchor":{"type":"enum","function":"piecewise-constant","values":["map","viewport"],"default":"map","requires":["fill-translate"]},"fill-pattern":{"type":"string","function":"piecewise-constant","transition":true}},"paint_line":{"line-opacity":{"type":"number","function":"interpolated","default":1,"minimum":0,"maximum":1,"transition":true},"line-color":{"type":"color","default":"#000000","function":"interpolated","transition":true,"requires":[{"!":"line-pattern"}]},"line-translate":{"type":"array","value":"number","length":2,"default":[0,0],"function":"interpolated","transition":true,"units":"pixels"},"line-translate-anchor":{"type":"enum","function":"piecewise-constant","values":["map","viewport"],"default":"map","requires":["line-translate"]},"line-width":{"type":"number","default":1,"minimum":0,"function":"interpolated","transition":true,"units":"pixels"},"line-gap-width":{"type":"number","default":0,"minimum":0,"function":"interpolated","transition":true,"units":"pixels"},"line-offset":{"type":"number","default":0,"function":"interpolated","transition":true,"units":"pixels"},"line-blur":{"type":"number","default":0,"minimum":0,"function":"interpolated","transition":true,"units":"pixels"},"line-dasharray":{"type":"array","value":"number","function":"piecewise-constant","minimum":0,"transition":true,"units":"line widths","requires":[{"!":"line-pattern"}]},"line-pattern":{"type":"string","function":"piecewise-constant","transition":true}},"paint_circle":{"circle-radius":{"type":"number","default":5,"minimum":0,"function":"interpolated","transition":true,"units":"pixels"},"circle-color":{"type":"color","default":"#000000","function":"interpolated","transition":true},"circle-blur":{"type":"number","default":0,"function":"interpolated","transition":true},"circle-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"function":"interpolated","transition":true},"circle-translate":{"type":"array","value":"number","length":2,"default":[0,0],"function":"interpolated","transition":true,"units":"pixels"},"circle-translate-anchor":{"type":"enum","function":"piecewise-constant","values":["map","viewport"],"default":"map","requires":["circle-translate"]}},"paint_symbol":{"icon-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"function":"interpolated","transition":true,"requires":["icon-image"]},"icon-color":{"type":"color","default":"#000000","function":"interpolated","transition":true,"requires":["icon-image"]},"icon-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","function":"interpolated","transition":true,"requires":["icon-image"]},"icon-halo-width":{"type":"number","default":0,"minimum":0,"function":"interpolated","transition":true,"units":"pixels","requires":["icon-image"]},"icon-halo-blur":{"type":"number","default":0,"minimum":0,"function":"interpolated","transition":true,"units":"pixels","requires":["icon-image"]},"icon-translate":{"type":"array","value":"number","length":2,"default":[0,0],"function":"interpolated","transition":true,"units":"pixels","requires":["icon-image"]},"icon-translate-anchor":{"type":"enum","function":"piecewise-constant","values":["map","viewport"],"default":"map","requires":["icon-image","icon-translate"]},"text-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"function":"interpolated","transition":true,"requires":["text-field"]},"text-color":{"type":"color","default":"#000000","function":"interpolated","transition":true,"requires":["text-field"]},"text-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","function":"interpolated","transition":true,"requires":["text-field"]},"text-halo-width":{"type":"number","default":0,"minimum":0,"function":"interpolated","transition":true,"units":"pixels","requires":["text-field"]},"text-halo-blur":{"type":"number","default":0,"minimum":0,"function":"interpolated","transition":true,"units":"pixels","requires":["text-field"]},"text-translate":{"type":"array","value":"number","length":2,"default":[0,0],"function":"interpolated","transition":true,"units":"pixels","requires":["text-field"]},"text-translate-anchor":{"type":"enum","function":"piecewise-constant","values":["map","viewport"],"default":"map","requires":["text-field","text-translate"]}},"paint_raster":{"raster-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"function":"interpolated","transition":true},"raster-hue-rotate":{"type":"number","default":0,"period":360,"function":"interpolated","transition":true,"units":"degrees"},"raster-brightness-min":{"type":"number","function":"interpolated","default":0,"minimum":0,"maximum":1,"transition":true},"raster-brightness-max":{"type":"number","function":"interpolated","default":1,"minimum":0,"maximum":1,"transition":true},"raster-saturation":{"type":"number","default":0,"minimum":-1,"maximum":1,"function":"interpolated","transition":true},"raster-contrast":{"type":"number","default":0,"minimum":-1,"maximum":1,"function":"interpolated","transition":true},"raster-fade-duration":{"type":"number","default":300,"minimum":0,"function":"interpolated","transition":true,"units":"milliseconds"}},"paint_background":{"background-color":{"type":"color","default":"#000000","function":"interpolated","transition":true,"requires":[{"!":"background-pattern"}]},"background-pattern":{"type":"string","function":"piecewise-constant","transition":true},"background-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"function":"interpolated","transition":true}},"transition":{"duration":{"type":"number","default":300,"minimum":0,"units":"milliseconds"},"delay":{"type":"number","default":0,"minimum":0,"units":"milliseconds"}}}
},{}],127:[function(require,module,exports){
'use strict';

// lightweight Buffer shim for pbf browser build
// based on code from github.com/feross/buffer (MIT-licensed)

module.exports = Buffer;

var ieee754 = require('ieee754');

var BufferMethods;

function Buffer(length) {
    var arr;
    if (length && length.length) {
        arr = length;
        length = arr.length;
    }
    var buf = new Uint8Array(length || 0);
    if (arr) buf.set(arr);

    buf.readUInt32LE = BufferMethods.readUInt32LE;
    buf.writeUInt32LE = BufferMethods.writeUInt32LE;
    buf.readInt32LE = BufferMethods.readInt32LE;
    buf.writeInt32LE = BufferMethods.writeInt32LE;
    buf.readFloatLE = BufferMethods.readFloatLE;
    buf.writeFloatLE = BufferMethods.writeFloatLE;
    buf.readDoubleLE = BufferMethods.readDoubleLE;
    buf.writeDoubleLE = BufferMethods.writeDoubleLE;
    buf.toString = BufferMethods.toString;
    buf.write = BufferMethods.write;
    buf.slice = BufferMethods.slice;
    buf.copy = BufferMethods.copy;

    buf._isBuffer = true;
    return buf;
}

var lastStr, lastStrEncoded;

BufferMethods = {
    readUInt32LE: function(pos) {
        return ((this[pos]) |
            (this[pos + 1] << 8) |
            (this[pos + 2] << 16)) +
            (this[pos + 3] * 0x1000000);
    },

    writeUInt32LE: function(val, pos) {
        this[pos] = val;
        this[pos + 1] = (val >>> 8);
        this[pos + 2] = (val >>> 16);
        this[pos + 3] = (val >>> 24);
    },

    readInt32LE: function(pos) {
        return ((this[pos]) |
            (this[pos + 1] << 8) |
            (this[pos + 2] << 16)) +
            (this[pos + 3] << 24);
    },

    readFloatLE:  function(pos) { return ieee754.read(this, pos, true, 23, 4); },
    readDoubleLE: function(pos) { return ieee754.read(this, pos, true, 52, 8); },

    writeFloatLE:  function(val, pos) { return ieee754.write(this, val, pos, true, 23, 4); },
    writeDoubleLE: function(val, pos) { return ieee754.write(this, val, pos, true, 52, 8); },

    toString: function(encoding, start, end) {
        var str = '',
            tmp = '';

        start = start || 0;
        end = Math.min(this.length, end || this.length);

        for (var i = start; i < end; i++) {
            var ch = this[i];
            if (ch <= 0x7F) {
                str += decodeURIComponent(tmp) + String.fromCharCode(ch);
                tmp = '';
            } else {
                tmp += '%' + ch.toString(16);
            }
        }

        str += decodeURIComponent(tmp);

        return str;
    },

    write: function(str, pos) {
        var bytes = str === lastStr ? lastStrEncoded : encodeString(str);
        for (var i = 0; i < bytes.length; i++) {
            this[pos + i] = bytes[i];
        }
    },

    slice: function(start, end) {
        return this.subarray(start, end);
    },

    copy: function(buf, pos) {
        pos = pos || 0;
        for (var i = 0; i < this.length; i++) {
            buf[pos + i] = this[i];
        }
    }
};

BufferMethods.writeInt32LE = BufferMethods.writeUInt32LE;

Buffer.byteLength = function(str) {
    lastStr = str;
    lastStrEncoded = encodeString(str);
    return lastStrEncoded.length;
};

Buffer.isBuffer = function(buf) {
    return !!(buf && buf._isBuffer);
};

function encodeString(str) {
    var length = str.length,
        bytes = [];

    for (var i = 0, c, lead; i < length; i++) {
        c = str.charCodeAt(i); // code point

        if (c > 0xD7FF && c < 0xE000) {

            if (lead) {
                if (c < 0xDC00) {
                    bytes.push(0xEF, 0xBF, 0xBD);
                    lead = c;
                    continue;

                } else {
                    c = lead - 0xD800 << 10 | c - 0xDC00 | 0x10000;
                    lead = null;
                }

            } else {
                if (c > 0xDBFF || (i + 1 === length)) bytes.push(0xEF, 0xBF, 0xBD);
                else lead = c;

                continue;
            }

        } else if (lead) {
            bytes.push(0xEF, 0xBF, 0xBD);
            lead = null;
        }

        if (c < 0x80) bytes.push(c);
        else if (c < 0x800) bytes.push(c >> 0x6 | 0xC0, c & 0x3F | 0x80);
        else if (c < 0x10000) bytes.push(c >> 0xC | 0xE0, c >> 0x6 & 0x3F | 0x80, c & 0x3F | 0x80);
        else bytes.push(c >> 0x12 | 0xF0, c >> 0xC & 0x3F | 0x80, c >> 0x6 & 0x3F | 0x80, c & 0x3F | 0x80);
    }
    return bytes;
}

},{"ieee754":129}],128:[function(require,module,exports){
(function (global){
'use strict';

module.exports = Pbf;

var Buffer = global.Buffer || require('./buffer');

function Pbf(buf) {
    this.buf = !Buffer.isBuffer(buf) ? new Buffer(buf || 0) : buf;
    this.pos = 0;
    this.length = this.buf.length;
}

Pbf.Varint  = 0; // varint: int32, int64, uint32, uint64, sint32, sint64, bool, enum
Pbf.Fixed64 = 1; // 64-bit: double, fixed64, sfixed64
Pbf.Bytes   = 2; // length-delimited: string, bytes, embedded messages, packed repeated fields
Pbf.Fixed32 = 5; // 32-bit: float, fixed32, sfixed32

var SHIFT_LEFT_32 = (1 << 16) * (1 << 16),
    SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32,
    POW_2_63 = Math.pow(2, 63);

Pbf.prototype = {

    destroy: function() {
        this.buf = null;
    },

    // === READING =================================================================

    readFields: function(readField, result, end) {
        end = end || this.length;

        while (this.pos < end) {
            var val = this.readVarint(),
                tag = val >> 3,
                startPos = this.pos;

            readField(tag, result, this);

            if (this.pos === startPos) this.skip(val);
        }
        return result;
    },

    readMessage: function(readField, result) {
        return this.readFields(readField, result, this.readVarint() + this.pos);
    },

    readFixed32: function() {
        var val = this.buf.readUInt32LE(this.pos);
        this.pos += 4;
        return val;
    },

    readSFixed32: function() {
        var val = this.buf.readInt32LE(this.pos);
        this.pos += 4;
        return val;
    },

    // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)

    readFixed64: function() {
        var val = this.buf.readUInt32LE(this.pos) + this.buf.readUInt32LE(this.pos + 4) * SHIFT_LEFT_32;
        this.pos += 8;
        return val;
    },

    readSFixed64: function() {
        var val = this.buf.readUInt32LE(this.pos) + this.buf.readInt32LE(this.pos + 4) * SHIFT_LEFT_32;
        this.pos += 8;
        return val;
    },

    readFloat: function() {
        var val = this.buf.readFloatLE(this.pos);
        this.pos += 4;
        return val;
    },

    readDouble: function() {
        var val = this.buf.readDoubleLE(this.pos);
        this.pos += 8;
        return val;
    },

    readVarint: function() {
        var buf = this.buf,
            val, b, b0, b1, b2, b3;

        b0 = buf[this.pos++]; if (b0 < 0x80) return b0;                 b0 = b0 & 0x7f;
        b1 = buf[this.pos++]; if (b1 < 0x80) return b0 | b1 << 7;       b1 = (b1 & 0x7f) << 7;
        b2 = buf[this.pos++]; if (b2 < 0x80) return b0 | b1 | b2 << 14; b2 = (b2 & 0x7f) << 14;
        b3 = buf[this.pos++]; if (b3 < 0x80) return b0 | b1 | b2 | b3 << 21;

        val = b0 | b1 | b2 | (b3 & 0x7f) << 21;

        b = buf[this.pos++]; val += (b & 0x7f) * 0x10000000;         if (b < 0x80) return val;
        b = buf[this.pos++]; val += (b & 0x7f) * 0x800000000;        if (b < 0x80) return val;
        b = buf[this.pos++]; val += (b & 0x7f) * 0x40000000000;      if (b < 0x80) return val;
        b = buf[this.pos++]; val += (b & 0x7f) * 0x2000000000000;    if (b < 0x80) return val;
        b = buf[this.pos++]; val += (b & 0x7f) * 0x100000000000000;  if (b < 0x80) return val;
        b = buf[this.pos++]; val += (b & 0x7f) * 0x8000000000000000; if (b < 0x80) return val;

        throw new Error('Expected varint not more than 10 bytes');
    },

    readVarint64: function() {
        var startPos = this.pos,
            val = this.readVarint();

        if (val < POW_2_63) return val;

        var pos = this.pos - 2;
        while (this.buf[pos] === 0xff) pos--;
        if (pos < startPos) pos = startPos;

        val = 0;
        for (var i = 0; i < pos - startPos + 1; i++) {
            var b = ~this.buf[startPos + i] & 0x7f;
            val += i < 4 ? b << i * 7 : b * Math.pow(2, i * 7);
        }

        return -val - 1;
    },

    readSVarint: function() {
        var num = this.readVarint();
        return num % 2 === 1 ? (num + 1) / -2 : num / 2; // zigzag encoding
    },

    readBoolean: function() {
        return Boolean(this.readVarint());
    },

    readString: function() {
        var end = this.readVarint() + this.pos,
            str = this.buf.toString('utf8', this.pos, end);
        this.pos = end;
        return str;
    },

    readBytes: function() {
        var end = this.readVarint() + this.pos,
            buffer = this.buf.slice(this.pos, end);
        this.pos = end;
        return buffer;
    },

    // verbose for performance reasons; doesn't affect gzipped size

    readPackedVarint: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readVarint());
        return arr;
    },
    readPackedSVarint: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readSVarint());
        return arr;
    },
    readPackedBoolean: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readBoolean());
        return arr;
    },
    readPackedFloat: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readFloat());
        return arr;
    },
    readPackedDouble: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readDouble());
        return arr;
    },
    readPackedFixed32: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readFixed32());
        return arr;
    },
    readPackedSFixed32: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readSFixed32());
        return arr;
    },
    readPackedFixed64: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readFixed64());
        return arr;
    },
    readPackedSFixed64: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readSFixed64());
        return arr;
    },

    skip: function(val) {
        var type = val & 0x7;
        if (type === Pbf.Varint) while (this.buf[this.pos++] > 0x7f) {}
        else if (type === Pbf.Bytes) this.pos = this.readVarint() + this.pos;
        else if (type === Pbf.Fixed32) this.pos += 4;
        else if (type === Pbf.Fixed64) this.pos += 8;
        else throw new Error('Unimplemented type: ' + type);
    },

    // === WRITING =================================================================

    writeTag: function(tag, type) {
        this.writeVarint((tag << 3) | type);
    },

    realloc: function(min) {
        var length = this.length || 16;

        while (length < this.pos + min) length *= 2;

        if (length !== this.length) {
            var buf = new Buffer(length);
            this.buf.copy(buf);
            this.buf = buf;
            this.length = length;
        }
    },

    finish: function() {
        this.length = this.pos;
        this.pos = 0;
        return this.buf.slice(0, this.length);
    },

    writeFixed32: function(val) {
        this.realloc(4);
        this.buf.writeUInt32LE(val, this.pos);
        this.pos += 4;
    },

    writeSFixed32: function(val) {
        this.realloc(4);
        this.buf.writeInt32LE(val, this.pos);
        this.pos += 4;
    },

    writeFixed64: function(val) {
        this.realloc(8);
        this.buf.writeInt32LE(val & -1, this.pos);
        this.buf.writeUInt32LE(Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
        this.pos += 8;
    },

    writeSFixed64: function(val) {
        this.realloc(8);
        this.buf.writeInt32LE(val & -1, this.pos);
        this.buf.writeInt32LE(Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
        this.pos += 8;
    },

    writeVarint: function(val) {
        val = +val;

        if (val <= 0x7f) {
            this.realloc(1);
            this.buf[this.pos++] = val;

        } else if (val <= 0x3fff) {
            this.realloc(2);
            this.buf[this.pos++] = ((val >>> 0) & 0x7f) | 0x80;
            this.buf[this.pos++] = ((val >>> 7) & 0x7f);

        } else if (val <= 0x1fffff) {
            this.realloc(3);
            this.buf[this.pos++] = ((val >>> 0) & 0x7f) | 0x80;
            this.buf[this.pos++] = ((val >>> 7) & 0x7f) | 0x80;
            this.buf[this.pos++] = ((val >>> 14) & 0x7f);

        } else if (val <= 0xfffffff) {
            this.realloc(4);
            this.buf[this.pos++] = ((val >>> 0) & 0x7f) | 0x80;
            this.buf[this.pos++] = ((val >>> 7) & 0x7f) | 0x80;
            this.buf[this.pos++] = ((val >>> 14) & 0x7f) | 0x80;
            this.buf[this.pos++] = ((val >>> 21) & 0x7f);

        } else {
            var pos = this.pos;
            while (val >= 0x80) {
                this.realloc(1);
                this.buf[this.pos++] = (val & 0xff) | 0x80;
                val /= 0x80;
            }
            this.realloc(1);
            this.buf[this.pos++] = val | 0;
            if (this.pos - pos > 10) throw new Error('Given varint doesn\'t fit into 10 bytes');
        }
    },

    writeSVarint: function(val) {
        this.writeVarint(val < 0 ? -val * 2 - 1 : val * 2);
    },

    writeBoolean: function(val) {
        this.writeVarint(Boolean(val));
    },

    writeString: function(str) {
        str = String(str);
        var bytes = Buffer.byteLength(str);
        this.writeVarint(bytes);
        this.realloc(bytes);
        this.buf.write(str, this.pos);
        this.pos += bytes;
    },

    writeFloat: function(val) {
        this.realloc(4);
        this.buf.writeFloatLE(val, this.pos);
        this.pos += 4;
    },

    writeDouble: function(val) {
        this.realloc(8);
        this.buf.writeDoubleLE(val, this.pos);
        this.pos += 8;
    },

    writeBytes: function(buffer) {
        var len = buffer.length;
        this.writeVarint(len);
        this.realloc(len);
        for (var i = 0; i < len; i++) this.buf[this.pos++] = buffer[i];
    },

    writeRawMessage: function(fn, obj) {
        this.pos++; // reserve 1 byte for short message length

        // write the message directly to the buffer and see how much was written
        var startPos = this.pos;
        fn(obj, this);
        var len = this.pos - startPos;

        var varintLen =
            len <= 0x7f ? 1 :
            len <= 0x3fff ? 2 :
            len <= 0x1fffff ? 3 :
            len <= 0xfffffff ? 4 : Math.ceil(Math.log(len) / (Math.LN2 * 7));

        // if 1 byte isn't enough for encoding message length, shift the data to the right
        if (varintLen > 1) {
            this.realloc(varintLen - 1);
            for (var i = this.pos - 1; i >= startPos; i--) this.buf[i + varintLen - 1] = this.buf[i];
        }

        // finally, write the message length in the reserved place and restore the position
        this.pos = startPos - 1;
        this.writeVarint(len);
        this.pos += len;
    },

    writeMessage: function(tag, fn, obj) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeRawMessage(fn, obj);
    },

    writePackedVarint:   function(tag, arr) { this.writeMessage(tag, writePackedVarint, arr);   },
    writePackedSVarint:  function(tag, arr) { this.writeMessage(tag, writePackedSVarint, arr);  },
    writePackedBoolean:  function(tag, arr) { this.writeMessage(tag, writePackedBoolean, arr);  },
    writePackedFloat:    function(tag, arr) { this.writeMessage(tag, writePackedFloat, arr);    },
    writePackedDouble:   function(tag, arr) { this.writeMessage(tag, writePackedDouble, arr);   },
    writePackedFixed32:  function(tag, arr) { this.writeMessage(tag, writePackedFixed32, arr);  },
    writePackedSFixed32: function(tag, arr) { this.writeMessage(tag, writePackedSFixed32, arr); },
    writePackedFixed64:  function(tag, arr) { this.writeMessage(tag, writePackedFixed64, arr);  },
    writePackedSFixed64: function(tag, arr) { this.writeMessage(tag, writePackedSFixed64, arr); },

    writeBytesField: function(tag, buffer) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeBytes(buffer);
    },
    writeFixed32Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeFixed32(val);
    },
    writeSFixed32Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeSFixed32(val);
    },
    writeFixed64Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeFixed64(val);
    },
    writeSFixed64Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeSFixed64(val);
    },
    writeVarintField: function(tag, val) {
        this.writeTag(tag, Pbf.Varint);
        this.writeVarint(val);
    },
    writeSVarintField: function(tag, val) {
        this.writeTag(tag, Pbf.Varint);
        this.writeSVarint(val);
    },
    writeStringField: function(tag, str) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeString(str);
    },
    writeFloatField: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeFloat(val);
    },
    writeDoubleField: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeDouble(val);
    },
    writeBooleanField: function(tag, val) {
        this.writeVarintField(tag, Boolean(val));
    }
};

function writePackedVarint(arr, pbf)   { for (var i = 0; i < arr.length; i++) pbf.writeVarint(arr[i]);   }
function writePackedSVarint(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeSVarint(arr[i]);  }
function writePackedFloat(arr, pbf)    { for (var i = 0; i < arr.length; i++) pbf.writeFloat(arr[i]);    }
function writePackedDouble(arr, pbf)   { for (var i = 0; i < arr.length; i++) pbf.writeDouble(arr[i]);   }
function writePackedBoolean(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeBoolean(arr[i]);  }
function writePackedFixed32(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeFixed32(arr[i]);  }
function writePackedSFixed32(arr, pbf) { for (var i = 0; i < arr.length; i++) pbf.writeSFixed32(arr[i]); }
function writePackedFixed64(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeFixed64(arr[i]);  }
function writePackedSFixed64(arr, pbf) { for (var i = 0; i < arr.length; i++) pbf.writeSFixed64(arr[i]); }

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./buffer":127}],129:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],130:[function(require,module,exports){
'use strict';

module.exports = Point;

function Point(x, y) {
    this.x = x;
    this.y = y;
}

Point.prototype = {
    clone: function() { return new Point(this.x, this.y); },

    add:     function(p) { return this.clone()._add(p);     },
    sub:     function(p) { return this.clone()._sub(p);     },
    mult:    function(k) { return this.clone()._mult(k);    },
    div:     function(k) { return this.clone()._div(k);     },
    rotate:  function(a) { return this.clone()._rotate(a);  },
    matMult: function(m) { return this.clone()._matMult(m); },
    unit:    function() { return this.clone()._unit(); },
    perp:    function() { return this.clone()._perp(); },
    round:   function() { return this.clone()._round(); },

    mag: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    },

    equals: function(p) {
        return this.x === p.x &&
               this.y === p.y;
    },

    dist: function(p) {
        return Math.sqrt(this.distSqr(p));
    },

    distSqr: function(p) {
        var dx = p.x - this.x,
            dy = p.y - this.y;
        return dx * dx + dy * dy;
    },

    angle: function() {
        return Math.atan2(this.y, this.x);
    },

    angleTo: function(b) {
        return Math.atan2(this.y - b.y, this.x - b.x);
    },

    angleWith: function(b) {
        return this.angleWithSep(b.x, b.y);
    },

    // Find the angle of the two vectors, solving the formula for the cross product a x b = |a||b|sin(θ) for θ.
    angleWithSep: function(x, y) {
        return Math.atan2(
            this.x * y - this.y * x,
            this.x * x + this.y * y);
    },

    _matMult: function(m) {
        var x = m[0] * this.x + m[1] * this.y,
            y = m[2] * this.x + m[3] * this.y;
        this.x = x;
        this.y = y;
        return this;
    },

    _add: function(p) {
        this.x += p.x;
        this.y += p.y;
        return this;
    },

    _sub: function(p) {
        this.x -= p.x;
        this.y -= p.y;
        return this;
    },

    _mult: function(k) {
        this.x *= k;
        this.y *= k;
        return this;
    },

    _div: function(k) {
        this.x /= k;
        this.y /= k;
        return this;
    },

    _unit: function() {
        this._div(this.mag());
        return this;
    },

    _perp: function() {
        var y = this.y;
        this.y = this.x;
        this.x = -y;
        return this;
    },

    _rotate: function(angle) {
        var cos = Math.cos(angle),
            sin = Math.sin(angle),
            x = cos * this.x - sin * this.y,
            y = sin * this.x + cos * this.y;
        this.x = x;
        this.y = y;
        return this;
    },

    _round: function() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        return this;
    }
};

// constructs Point from an array if necessary
Point.convert = function (a) {
    if (a instanceof Point) {
        return a;
    }
    if (Array.isArray(a)) {
        return new Point(a[0], a[1]);
    }
    return a;
};

},{}],131:[function(require,module,exports){
/*
 (c) 2015, Vladimir Agafonkin
 RBush, a JavaScript library for high-performance 2D spatial indexing of points and rectangles.
 https://github.com/mourner/rbush
*/

(function () {
'use strict';

function rbush(maxEntries, format) {

    // jshint newcap: false, validthis: true
    if (!(this instanceof rbush)) return new rbush(maxEntries, format);

    // max entries in a node is 9 by default; min node fill is 40% for best performance
    this._maxEntries = Math.max(4, maxEntries || 9);
    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));

    if (format) {
        this._initFormat(format);
    }

    this.clear();
}

rbush.prototype = {

    all: function () {
        return this._all(this.data, []);
    },

    search: function (bbox) {

        var node = this.data,
            result = [],
            toBBox = this.toBBox;

        if (!intersects(bbox, node.bbox)) return result;

        var nodesToSearch = [],
            i, len, child, childBBox;

        while (node) {
            for (i = 0, len = node.children.length; i < len; i++) {

                child = node.children[i];
                childBBox = node.leaf ? toBBox(child) : child.bbox;

                if (intersects(bbox, childBBox)) {
                    if (node.leaf) result.push(child);
                    else if (contains(bbox, childBBox)) this._all(child, result);
                    else nodesToSearch.push(child);
                }
            }
            node = nodesToSearch.pop();
        }

        return result;
    },

    collides: function (bbox) {

        var node = this.data,
            toBBox = this.toBBox;

        if (!intersects(bbox, node.bbox)) return false;

        var nodesToSearch = [],
            i, len, child, childBBox;

        while (node) {
            for (i = 0, len = node.children.length; i < len; i++) {

                child = node.children[i];
                childBBox = node.leaf ? toBBox(child) : child.bbox;

                if (intersects(bbox, childBBox)) {
                    if (node.leaf || contains(bbox, childBBox)) return true;
                    nodesToSearch.push(child);
                }
            }
            node = nodesToSearch.pop();
        }

        return false;
    },

    load: function (data) {
        if (!(data && data.length)) return this;

        if (data.length < this._minEntries) {
            for (var i = 0, len = data.length; i < len; i++) {
                this.insert(data[i]);
            }
            return this;
        }

        // recursively build the tree with the given data from stratch using OMT algorithm
        var node = this._build(data.slice(), 0, data.length - 1, 0);

        if (!this.data.children.length) {
            // save as is if tree is empty
            this.data = node;

        } else if (this.data.height === node.height) {
            // split root if trees have the same height
            this._splitRoot(this.data, node);

        } else {
            if (this.data.height < node.height) {
                // swap trees if inserted one is bigger
                var tmpNode = this.data;
                this.data = node;
                node = tmpNode;
            }

            // insert the small tree into the large tree at appropriate level
            this._insert(node, this.data.height - node.height - 1, true);
        }

        return this;
    },

    insert: function (item) {
        if (item) this._insert(item, this.data.height - 1);
        return this;
    },

    clear: function () {
        this.data = {
            children: [],
            height: 1,
            bbox: empty(),
            leaf: true
        };
        return this;
    },

    remove: function (item) {
        if (!item) return this;

        var node = this.data,
            bbox = this.toBBox(item),
            path = [],
            indexes = [],
            i, parent, index, goingUp;

        // depth-first iterative tree traversal
        while (node || path.length) {

            if (!node) { // go up
                node = path.pop();
                parent = path[path.length - 1];
                i = indexes.pop();
                goingUp = true;
            }

            if (node.leaf) { // check current node
                index = node.children.indexOf(item);

                if (index !== -1) {
                    // item found, remove the item and condense tree upwards
                    node.children.splice(index, 1);
                    path.push(node);
                    this._condense(path);
                    return this;
                }
            }

            if (!goingUp && !node.leaf && contains(node.bbox, bbox)) { // go down
                path.push(node);
                indexes.push(i);
                i = 0;
                parent = node;
                node = node.children[0];

            } else if (parent) { // go right
                i++;
                node = parent.children[i];
                goingUp = false;

            } else node = null; // nothing found
        }

        return this;
    },

    toBBox: function (item) { return item; },

    compareMinX: function (a, b) { return a[0] - b[0]; },
    compareMinY: function (a, b) { return a[1] - b[1]; },

    toJSON: function () { return this.data; },

    fromJSON: function (data) {
        this.data = data;
        return this;
    },

    _all: function (node, result) {
        var nodesToSearch = [];
        while (node) {
            if (node.leaf) result.push.apply(result, node.children);
            else nodesToSearch.push.apply(nodesToSearch, node.children);

            node = nodesToSearch.pop();
        }
        return result;
    },

    _build: function (items, left, right, height) {

        var N = right - left + 1,
            M = this._maxEntries,
            node;

        if (N <= M) {
            // reached leaf level; return leaf
            node = {
                children: items.slice(left, right + 1),
                height: 1,
                bbox: null,
                leaf: true
            };
            calcBBox(node, this.toBBox);
            return node;
        }

        if (!height) {
            // target height of the bulk-loaded tree
            height = Math.ceil(Math.log(N) / Math.log(M));

            // target number of root entries to maximize storage utilization
            M = Math.ceil(N / Math.pow(M, height - 1));
        }

        node = {
            children: [],
            height: height,
            bbox: null,
            leaf: false
        };

        // split the items into M mostly square tiles

        var N2 = Math.ceil(N / M),
            N1 = N2 * Math.ceil(Math.sqrt(M)),
            i, j, right2, right3;

        multiSelect(items, left, right, N1, this.compareMinX);

        for (i = left; i <= right; i += N1) {

            right2 = Math.min(i + N1 - 1, right);

            multiSelect(items, i, right2, N2, this.compareMinY);

            for (j = i; j <= right2; j += N2) {

                right3 = Math.min(j + N2 - 1, right2);

                // pack each entry recursively
                node.children.push(this._build(items, j, right3, height - 1));
            }
        }

        calcBBox(node, this.toBBox);

        return node;
    },

    _chooseSubtree: function (bbox, node, level, path) {

        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;

        while (true) {
            path.push(node);

            if (node.leaf || path.length - 1 === level) break;

            minArea = minEnlargement = Infinity;

            for (i = 0, len = node.children.length; i < len; i++) {
                child = node.children[i];
                area = bboxArea(child.bbox);
                enlargement = enlargedArea(bbox, child.bbox) - area;

                // choose entry with the least area enlargement
                if (enlargement < minEnlargement) {
                    minEnlargement = enlargement;
                    minArea = area < minArea ? area : minArea;
                    targetNode = child;

                } else if (enlargement === minEnlargement) {
                    // otherwise choose one with the smallest area
                    if (area < minArea) {
                        minArea = area;
                        targetNode = child;
                    }
                }
            }

            node = targetNode;
        }

        return node;
    },

    _insert: function (item, level, isNode) {

        var toBBox = this.toBBox,
            bbox = isNode ? item.bbox : toBBox(item),
            insertPath = [];

        // find the best node for accommodating the item, saving all nodes along the path too
        var node = this._chooseSubtree(bbox, this.data, level, insertPath);

        // put the item into the node
        node.children.push(item);
        extend(node.bbox, bbox);

        // split on node overflow; propagate upwards if necessary
        while (level >= 0) {
            if (insertPath[level].children.length > this._maxEntries) {
                this._split(insertPath, level);
                level--;
            } else break;
        }

        // adjust bboxes along the insertion path
        this._adjustParentBBoxes(bbox, insertPath, level);
    },

    // split overflowed node into two
    _split: function (insertPath, level) {

        var node = insertPath[level],
            M = node.children.length,
            m = this._minEntries;

        this._chooseSplitAxis(node, m, M);

        var splitIndex = this._chooseSplitIndex(node, m, M);

        var newNode = {
            children: node.children.splice(splitIndex, node.children.length - splitIndex),
            height: node.height,
            bbox: null,
            leaf: false
        };

        if (node.leaf) newNode.leaf = true;

        calcBBox(node, this.toBBox);
        calcBBox(newNode, this.toBBox);

        if (level) insertPath[level - 1].children.push(newNode);
        else this._splitRoot(node, newNode);
    },

    _splitRoot: function (node, newNode) {
        // split root node
        this.data = {
            children: [node, newNode],
            height: node.height + 1,
            bbox: null,
            leaf: false
        };
        calcBBox(this.data, this.toBBox);
    },

    _chooseSplitIndex: function (node, m, M) {

        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;

        minOverlap = minArea = Infinity;

        for (i = m; i <= M - m; i++) {
            bbox1 = distBBox(node, 0, i, this.toBBox);
            bbox2 = distBBox(node, i, M, this.toBBox);

            overlap = intersectionArea(bbox1, bbox2);
            area = bboxArea(bbox1) + bboxArea(bbox2);

            // choose distribution with minimum overlap
            if (overlap < minOverlap) {
                minOverlap = overlap;
                index = i;

                minArea = area < minArea ? area : minArea;

            } else if (overlap === minOverlap) {
                // otherwise choose distribution with minimum area
                if (area < minArea) {
                    minArea = area;
                    index = i;
                }
            }
        }

        return index;
    },

    // sorts node children by the best axis for split
    _chooseSplitAxis: function (node, m, M) {

        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,
            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,
            xMargin = this._allDistMargin(node, m, M, compareMinX),
            yMargin = this._allDistMargin(node, m, M, compareMinY);

        // if total distributions margin value is minimal for x, sort by minX,
        // otherwise it's already sorted by minY
        if (xMargin < yMargin) node.children.sort(compareMinX);
    },

    // total margin of all possible split distributions where each node is at least m full
    _allDistMargin: function (node, m, M, compare) {

        node.children.sort(compare);

        var toBBox = this.toBBox,
            leftBBox = distBBox(node, 0, m, toBBox),
            rightBBox = distBBox(node, M - m, M, toBBox),
            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),
            i, child;

        for (i = m; i < M - m; i++) {
            child = node.children[i];
            extend(leftBBox, node.leaf ? toBBox(child) : child.bbox);
            margin += bboxMargin(leftBBox);
        }

        for (i = M - m - 1; i >= m; i--) {
            child = node.children[i];
            extend(rightBBox, node.leaf ? toBBox(child) : child.bbox);
            margin += bboxMargin(rightBBox);
        }

        return margin;
    },

    _adjustParentBBoxes: function (bbox, path, level) {
        // adjust bboxes along the given tree path
        for (var i = level; i >= 0; i--) {
            extend(path[i].bbox, bbox);
        }
    },

    _condense: function (path) {
        // go through the path, removing empty nodes and updating bboxes
        for (var i = path.length - 1, siblings; i >= 0; i--) {
            if (path[i].children.length === 0) {
                if (i > 0) {
                    siblings = path[i - 1].children;
                    siblings.splice(siblings.indexOf(path[i]), 1);

                } else this.clear();

            } else calcBBox(path[i], this.toBBox);
        }
    },

    _initFormat: function (format) {
        // data format (minX, minY, maxX, maxY accessors)

        // uses eval-type function compilation instead of just accepting a toBBox function
        // because the algorithms are very sensitive to sorting functions performance,
        // so they should be dead simple and without inner calls

        // jshint evil: true

        var compareArr = ['return a', ' - b', ';'];

        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));
        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));

        this.toBBox = new Function('a', 'return [a' + format.join(', a') + '];');
    }
};


// calculate node's bbox from bboxes of its children
function calcBBox(node, toBBox) {
    node.bbox = distBBox(node, 0, node.children.length, toBBox);
}

// min bounding rectangle of node children from k to p-1
function distBBox(node, k, p, toBBox) {
    var bbox = empty();

    for (var i = k, child; i < p; i++) {
        child = node.children[i];
        extend(bbox, node.leaf ? toBBox(child) : child.bbox);
    }

    return bbox;
}

function empty() { return [Infinity, Infinity, -Infinity, -Infinity]; }

function extend(a, b) {
    a[0] = Math.min(a[0], b[0]);
    a[1] = Math.min(a[1], b[1]);
    a[2] = Math.max(a[2], b[2]);
    a[3] = Math.max(a[3], b[3]);
    return a;
}

function compareNodeMinX(a, b) { return a.bbox[0] - b.bbox[0]; }
function compareNodeMinY(a, b) { return a.bbox[1] - b.bbox[1]; }

function bboxArea(a)   { return (a[2] - a[0]) * (a[3] - a[1]); }
function bboxMargin(a) { return (a[2] - a[0]) + (a[3] - a[1]); }

function enlargedArea(a, b) {
    return (Math.max(b[2], a[2]) - Math.min(b[0], a[0])) *
           (Math.max(b[3], a[3]) - Math.min(b[1], a[1]));
}

function intersectionArea(a, b) {
    var minX = Math.max(a[0], b[0]),
        minY = Math.max(a[1], b[1]),
        maxX = Math.min(a[2], b[2]),
        maxY = Math.min(a[3], b[3]);

    return Math.max(0, maxX - minX) *
           Math.max(0, maxY - minY);
}

function contains(a, b) {
    return a[0] <= b[0] &&
           a[1] <= b[1] &&
           b[2] <= a[2] &&
           b[3] <= a[3];
}

function intersects(a, b) {
    return b[0] <= a[2] &&
           b[1] <= a[3] &&
           b[2] >= a[0] &&
           b[3] >= a[1];
}

// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;
// combines selection algorithm with binary divide & conquer approach

function multiSelect(arr, left, right, n, compare) {
    var stack = [left, right],
        mid;

    while (stack.length) {
        right = stack.pop();
        left = stack.pop();

        if (right - left <= n) continue;

        mid = left + Math.ceil((right - left) / n / 2) * n;
        select(arr, left, right, mid, compare);

        stack.push(left, mid, mid, right);
    }
}

// Floyd-Rivest selection algorithm:
// sort an array between left and right (inclusive) so that the smallest k elements come first (unordered)
function select(arr, left, right, k, compare) {
    var n, i, z, s, sd, newLeft, newRight, t, j;

    while (right > left) {
        if (right - left > 600) {
            n = right - left + 1;
            i = k - left + 1;
            z = Math.log(n);
            s = 0.5 * Math.exp(2 * z / 3);
            sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (i - n / 2 < 0 ? -1 : 1);
            newLeft = Math.max(left, Math.floor(k - i * s / n + sd));
            newRight = Math.min(right, Math.floor(k + (n - i) * s / n + sd));
            select(arr, newLeft, newRight, k, compare);
        }

        t = arr[k];
        i = left;
        j = right;

        swap(arr, left, k);
        if (compare(arr[right], t) > 0) swap(arr, left, right);

        while (i < j) {
            swap(arr, i, j);
            i++;
            j--;
            while (compare(arr[i], t) < 0) i++;
            while (compare(arr[j], t) > 0) j--;
        }

        if (compare(arr[left], t) === 0) swap(arr, left, j);
        else {
            j++;
            swap(arr, j, right);
        }

        if (j <= k) left = j + 1;
        if (k <= j) right = j - 1;
    }
}

function swap(arr, i, j) {
    var tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}


// export as AMD/CommonJS module or global variable
if (typeof define === 'function' && define.amd) define('rbush', function () { return rbush; });
else if (typeof module !== 'undefined') module.exports = rbush;
else if (typeof self !== 'undefined') self.rbush = rbush;
else window.rbush = rbush;

})();

},{}],132:[function(require,module,exports){
// Copyright 2014 Simon Lydell
// X11 (“MIT”) Licensed. (See LICENSE.)

void (function(root, factory) {
  if (typeof define === "function" && define.amd) {
    define(factory)
  } else if (typeof exports === "object") {
    module.exports = factory()
  } else {
    root.resolveUrl = factory()
  }
}(this, function() {

  function resolveUrl(/* ...urls */) {
    var numUrls = arguments.length

    if (numUrls === 0) {
      throw new Error("resolveUrl requires at least one argument; got none.")
    }

    var base = document.createElement("base")
    base.href = arguments[0]

    if (numUrls === 1) {
      return base.href
    }

    var head = document.getElementsByTagName("head")[0]
    head.insertBefore(base, head.firstChild)

    var a = document.createElement("a")
    var resolved

    for (var index = 1; index < numUrls; index++) {
      a.href = arguments[index]
      resolved = a.href
      base.href = resolved
    }

    head.removeChild(base)

    return resolved
  }

  return resolveUrl

}));

},{}],133:[function(require,module,exports){
/*
 * Copyright (C) 2008 Apple Inc. All Rights Reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Ported from Webkit
 * http://svn.webkit.org/repository/webkit/trunk/Source/WebCore/platform/graphics/UnitBezier.h
 */

module.exports = UnitBezier;

function UnitBezier(p1x, p1y, p2x, p2y) {
    // Calculate the polynomial coefficients, implicit first and last control points are (0,0) and (1,1).
    this.cx = 3.0 * p1x;
    this.bx = 3.0 * (p2x - p1x) - this.cx;
    this.ax = 1.0 - this.cx - this.bx;

    this.cy = 3.0 * p1y;
    this.by = 3.0 * (p2y - p1y) - this.cy;
    this.ay = 1.0 - this.cy - this.by;

    this.p1x = p1x;
    this.p1y = p2y;
    this.p2x = p2x;
    this.p2y = p2y;
}

UnitBezier.prototype.sampleCurveX = function(t) {
    // `ax t^3 + bx t^2 + cx t' expanded using Horner's rule.
    return ((this.ax * t + this.bx) * t + this.cx) * t;
};

UnitBezier.prototype.sampleCurveY = function(t) {
    return ((this.ay * t + this.by) * t + this.cy) * t;
};

UnitBezier.prototype.sampleCurveDerivativeX = function(t) {
    return (3.0 * this.ax * t + 2.0 * this.bx) * t + this.cx;
};

UnitBezier.prototype.solveCurveX = function(x, epsilon) {
    if (typeof epsilon === 'undefined') epsilon = 1e-6;

    var t0, t1, t2, x2, i;

    // First try a few iterations of Newton's method -- normally very fast.
    for (t2 = x, i = 0; i < 8; i++) {

        x2 = this.sampleCurveX(t2) - x;
        if (Math.abs(x2) < epsilon) return t2;

        var d2 = this.sampleCurveDerivativeX(t2);
        if (Math.abs(d2) < 1e-6) break;

        t2 = t2 - x2 / d2;
    }

    // Fall back to the bisection method for reliability.
    t0 = 0.0;
    t1 = 1.0;
    t2 = x;

    if (t2 < t0) return t0;
    if (t2 > t1) return t1;

    while (t0 < t1) {

        x2 = this.sampleCurveX(t2);
        if (Math.abs(x2 - x) < epsilon) return t2;

        if (x > x2) {
            t0 = t2;
        } else {
            t1 = t2;
        }

        t2 = (t1 - t0) * 0.5 + t0;
    }

    // Failure.
    return t2;
};

UnitBezier.prototype.solve = function(x, epsilon) {
    return this.sampleCurveY(this.solveCurveX(x, epsilon));
};

},{}],134:[function(require,module,exports){
module.exports.VectorTile = require('./lib/vectortile.js');
module.exports.VectorTileFeature = require('./lib/vectortilefeature.js');
module.exports.VectorTileLayer = require('./lib/vectortilelayer.js');

},{"./lib/vectortile.js":135,"./lib/vectortilefeature.js":136,"./lib/vectortilelayer.js":137}],135:[function(require,module,exports){
'use strict';

var VectorTileLayer = require('./vectortilelayer');

module.exports = VectorTile;

function VectorTile(pbf, end) {
    this.layers = pbf.readFields(readTile, {}, end);
}

function readTile(tag, layers, pbf) {
    if (tag === 3) {
        var layer = new VectorTileLayer(pbf, pbf.readVarint() + pbf.pos);
        if (layer.length) layers[layer.name] = layer;
    }
}


},{"./vectortilelayer":137}],136:[function(require,module,exports){
'use strict';

var Point = require('point-geometry');

module.exports = VectorTileFeature;

function VectorTileFeature(pbf, end, extent, keys, values) {
    // Public
    this.properties = {};
    this.extent = extent;
    this.type = 0;

    // Private
    this._pbf = pbf;
    this._geometry = -1;
    this._keys = keys;
    this._values = values;

    pbf.readFields(readFeature, this, end);
}

function readFeature(tag, feature, pbf) {
    if (tag == 1) feature._id = pbf.readVarint();
    else if (tag == 2) readTag(pbf, feature);
    else if (tag == 3) feature.type = pbf.readVarint();
    else if (tag == 4) feature._geometry = pbf.pos;
}

function readTag(pbf, feature) {
    var end = pbf.readVarint() + pbf.pos;

    while (pbf.pos < end) {
        var key = feature._keys[pbf.readVarint()],
            value = feature._values[pbf.readVarint()];
        feature.properties[key] = value;
    }
}

VectorTileFeature.types = ['Unknown', 'Point', 'LineString', 'Polygon'];

VectorTileFeature.prototype.loadGeometry = function() {
    var pbf = this._pbf;
    pbf.pos = this._geometry;

    var end = pbf.readVarint() + pbf.pos,
        cmd = 1,
        length = 0,
        x = 0,
        y = 0,
        lines = [],
        line;

    while (pbf.pos < end) {
        if (!length) {
            var cmdLen = pbf.readVarint();
            cmd = cmdLen & 0x7;
            length = cmdLen >> 3;
        }

        length--;

        if (cmd === 1 || cmd === 2) {
            x += pbf.readSVarint();
            y += pbf.readSVarint();

            if (cmd === 1) { // moveTo
                if (line) lines.push(line);
                line = [];
            }

            line.push(new Point(x, y));

        } else if (cmd === 7) {

            // Workaround for https://github.com/mapbox/mapnik-vector-tile/issues/90
            if (line) {
                line.push(line[0].clone()); // closePolygon
            }

        } else {
            throw new Error('unknown command ' + cmd);
        }
    }

    if (line) lines.push(line);

    return lines;
};

VectorTileFeature.prototype.bbox = function() {
    var pbf = this._pbf;
    pbf.pos = this._geometry;

    var end = pbf.readVarint() + pbf.pos,
        cmd = 1,
        length = 0,
        x = 0,
        y = 0,
        x1 = Infinity,
        x2 = -Infinity,
        y1 = Infinity,
        y2 = -Infinity;

    while (pbf.pos < end) {
        if (!length) {
            var cmdLen = pbf.readVarint();
            cmd = cmdLen & 0x7;
            length = cmdLen >> 3;
        }

        length--;

        if (cmd === 1 || cmd === 2) {
            x += pbf.readSVarint();
            y += pbf.readSVarint();
            if (x < x1) x1 = x;
            if (x > x2) x2 = x;
            if (y < y1) y1 = y;
            if (y > y2) y2 = y;

        } else if (cmd !== 7) {
            throw new Error('unknown command ' + cmd);
        }
    }

    return [x1, y1, x2, y2];
};

VectorTileFeature.prototype.toGeoJSON = function(x, y, z) {
    var size = this.extent * Math.pow(2, z),
        x0 = this.extent * x,
        y0 = this.extent * y,
        coords = this.loadGeometry(),
        type = VectorTileFeature.types[this.type];

    for (var i = 0; i < coords.length; i++) {
        var line = coords[i];
        for (var j = 0; j < line.length; j++) {
            var p = line[j], y2 = 180 - (p.y + y0) * 360 / size;
            line[j] = [
                (p.x + x0) * 360 / size - 180,
                360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90
            ];
        }
    }

    if (type === 'Point' && coords.length === 1) {
        coords = coords[0][0];
    } else if (type === 'Point') {
        coords = coords[0];
        type = 'MultiPoint';
    } else if (type === 'LineString' && coords.length === 1) {
        coords = coords[0];
    } else if (type === 'LineString') {
        type = 'MultiLineString';
    }

    var result = {
        type: "Feature",
        geometry: {
            type: type,
            coordinates: coords
        },
        properties: this.properties
    };

    if ('_id' in this) {
        result.id = this._id;
    }

    return result;
};

},{"point-geometry":130}],137:[function(require,module,exports){
'use strict';

var VectorTileFeature = require('./vectortilefeature.js');

module.exports = VectorTileLayer;

function VectorTileLayer(pbf, end) {
    // Public
    this.version = 1;
    this.name = null;
    this.extent = 4096;
    this.length = 0;

    // Private
    this._pbf = pbf;
    this._keys = [];
    this._values = [];
    this._features = [];

    pbf.readFields(readLayer, this, end);

    this.length = this._features.length;
}

function readLayer(tag, layer, pbf) {
    if (tag === 15) layer.version = pbf.readVarint();
    else if (tag === 1) layer.name = pbf.readString();
    else if (tag === 5) layer.extent = pbf.readVarint();
    else if (tag === 2) layer._features.push(pbf.pos);
    else if (tag === 3) layer._keys.push(pbf.readString());
    else if (tag === 4) layer._values.push(readValueMessage(pbf));
}

function readValueMessage(pbf) {
    var value = null,
        end = pbf.readVarint() + pbf.pos;

    while (pbf.pos < end) {
        var tag = pbf.readVarint() >> 3;

        value = tag === 1 ? pbf.readString() :
            tag === 2 ? pbf.readFloat() :
            tag === 3 ? pbf.readDouble() :
            tag === 4 ? pbf.readVarint64() :
            tag === 5 ? pbf.readVarint() :
            tag === 6 ? pbf.readSVarint() :
            tag === 7 ? pbf.readBoolean() : null;
    }

    return value;
}

// return feature `i` from this layer as a `VectorTileFeature`
VectorTileLayer.prototype.feature = function(i) {
    if (i < 0 || i >= this._features.length) throw new Error('feature index out of bounds');

    this._pbf.pos = this._features[i];

    var end = this._pbf.readVarint() + this._pbf.pos;
    return new VectorTileFeature(this._pbf, end, this.extent, this._keys, this._values);
};

},{"./vectortilefeature.js":136}],138:[function(require,module,exports){
var bundleFn = arguments[3];
var sources = arguments[4];
var cache = arguments[5];

var stringify = JSON.stringify;

module.exports = function (fn) {
    var keys = [];
    var wkey;
    var cacheKeys = Object.keys(cache);

    for (var i = 0, l = cacheKeys.length; i < l; i++) {
        var key = cacheKeys[i];
        var exp = cache[key].exports;
        // Using babel as a transpiler to use esmodule, the export will always
        // be an object with the default export as a property of it. To ensure
        // the existing api and babel esmodule exports are both supported we
        // check for both
        if (exp === fn || exp.default === fn) {
            wkey = key;
            break;
        }
    }

    if (!wkey) {
        wkey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);
        var wcache = {};
        for (var i = 0, l = cacheKeys.length; i < l; i++) {
            var key = cacheKeys[i];
            wcache[key] = key;
        }
        sources[wkey] = [
            Function(['require','module','exports'], '(' + fn + ')(self)'),
            wcache
        ];
    }
    var skey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);

    var scache = {}; scache[wkey] = wkey;
    sources[skey] = [
        Function(['require'], (
            // try to call default if defined to also support babel esmodule
            // exports
            'var f = require(' + stringify(wkey) + ');' +
            '(f.default ? f.default : f)(self);'
        )),
        scache
    ];

    var src = '(' + bundleFn + ')({'
        + Object.keys(sources).map(function (key) {
            return stringify(key) + ':['
                + sources[key][0]
                + ',' + stringify(sources[key][1]) + ']'
            ;
        }).join(',')
        + '},{},[' + stringify(skey) + '])'
    ;

    var URL = window.URL || window.webkitURL || window.mozURL || window.msURL;

    return new Worker(URL.createObjectURL(
        new Blob([src], { type: 'text/javascript' })
    ));
};

},{}]},{},[14])(14)
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJqcy9kYXRhL2J1Y2tldC5qcyIsImpzL2RhdGEvYnVmZmVyLmpzIiwianMvZGF0YS9jaXJjbGVfYnVja2V0LmpzIiwianMvZGF0YS9lbGVtZW50X2dyb3Vwcy5qcyIsImpzL2RhdGEvZmVhdHVyZV90cmVlLmpzIiwianMvZGF0YS9maWxsX2J1Y2tldC5qcyIsImpzL2RhdGEvbGluZV9idWNrZXQuanMiLCJqcy9kYXRhL3N5bWJvbF9idWNrZXQuanMiLCJqcy9nZW8vY29vcmRpbmF0ZS5qcyIsImpzL2dlby9sbmdfbGF0LmpzIiwianMvZ2VvL2xuZ19sYXRfYm91bmRzLmpzIiwianMvZ2VvL3RyYW5zZm9ybS5qcyIsImpzL2xpYi9kZWJ1Z3RleHQuanMiLCJqcy9tYXBib3gtZ2wuanMiLCJqcy9yZW5kZXIvZHJhd19iYWNrZ3JvdW5kLmpzIiwianMvcmVuZGVyL2RyYXdfY2lyY2xlLmpzIiwianMvcmVuZGVyL2RyYXdfY29sbGlzaW9uX2RlYnVnLmpzIiwianMvcmVuZGVyL2RyYXdfZGVidWcuanMiLCJqcy9yZW5kZXIvZHJhd19maWxsLmpzIiwianMvcmVuZGVyL2RyYXdfbGluZS5qcyIsImpzL3JlbmRlci9kcmF3X3Jhc3Rlci5qcyIsImpzL3JlbmRlci9kcmF3X3N5bWJvbC5qcyIsImpzL3JlbmRlci9mcmFtZV9oaXN0b3J5LmpzIiwianMvcmVuZGVyL2dsX3V0aWwuanMiLCJqcy9yZW5kZXIvbGluZV9hdGxhcy5qcyIsImpzL3JlbmRlci9wYWludGVyLmpzIiwianMvcmVuZGVyL3NoYWRlcnMuanMiLCJqcy9zb3VyY2UvZ2VvanNvbl9zb3VyY2UuanMiLCJqcy9zb3VyY2UvZ2VvanNvbl93cmFwcGVyLmpzIiwianMvc291cmNlL2ltYWdlX3NvdXJjZS5qcyIsImpzL3NvdXJjZS9yYXN0ZXJfdGlsZV9zb3VyY2UuanMiLCJqcy9zb3VyY2Uvc291cmNlLmpzIiwianMvc291cmNlL3RpbGUuanMiLCJqcy9zb3VyY2UvdGlsZV9jb29yZC5qcyIsImpzL3NvdXJjZS90aWxlX3B5cmFtaWQuanMiLCJqcy9zb3VyY2UvdmVjdG9yX3RpbGVfc291cmNlLmpzIiwianMvc291cmNlL3ZpZGVvX3NvdXJjZS5qcyIsImpzL3NvdXJjZS93b3JrZXIuanMiLCJqcy9zb3VyY2Uvd29ya2VyX3RpbGUuanMiLCJqcy9zdHlsZS9hbmltYXRpb25fbG9vcC5qcyIsImpzL3N0eWxlL2ltYWdlX3Nwcml0ZS5qcyIsImpzL3N0eWxlL2xheW91dF9wcm9wZXJ0aWVzLmpzIiwianMvc3R5bGUvcGFpbnRfcHJvcGVydGllcy5qcyIsImpzL3N0eWxlL3JlZmVyZW5jZS5qcyIsImpzL3N0eWxlL3N0eWxlLmpzIiwianMvc3R5bGUvc3R5bGVfYmF0Y2guanMiLCJqcy9zdHlsZS9zdHlsZV9kZWNsYXJhdGlvbi5qcyIsImpzL3N0eWxlL3N0eWxlX2RlY2xhcmF0aW9uX3NldC5qcyIsImpzL3N0eWxlL3N0eWxlX2xheWVyLmpzIiwianMvc3R5bGUvc3R5bGVfdHJhbnNpdGlvbi5qcyIsImpzL3N5bWJvbC9hbmNob3IuanMiLCJqcy9zeW1ib2wvYmluX3BhY2suanMiLCJqcy9zeW1ib2wvY2hlY2tfbWF4X2FuZ2xlLmpzIiwianMvc3ltYm9sL2NsaXBfbGluZS5qcyIsImpzL3N5bWJvbC9jb2xsaXNpb25fYm94LmpzIiwianMvc3ltYm9sL2NvbGxpc2lvbl9mZWF0dXJlLmpzIiwianMvc3ltYm9sL2NvbGxpc2lvbl90aWxlLmpzIiwianMvc3ltYm9sL2dldF9hbmNob3JzLmpzIiwianMvc3ltYm9sL2dseXBoX2F0bGFzLmpzIiwianMvc3ltYm9sL2dseXBoX3NvdXJjZS5qcyIsImpzL3N5bWJvbC9tZXJnZWxpbmVzLmpzIiwianMvc3ltYm9sL3F1YWRzLmpzIiwianMvc3ltYm9sL3Jlc29sdmVfdGV4dC5qcyIsImpzL3N5bWJvbC9zaGFwaW5nLmpzIiwianMvc3ltYm9sL3Nwcml0ZV9hdGxhcy5qcyIsImpzL3VpL2NhbWVyYS5qcyIsImpzL3VpL2NvbnRyb2wvYXR0cmlidXRpb24uanMiLCJqcy91aS9jb250cm9sL2NvbnRyb2wuanMiLCJqcy91aS9jb250cm9sL25hdmlnYXRpb24uanMiLCJqcy91aS9oYW5kbGVyL2JveF96b29tLmpzIiwianMvdWkvaGFuZGxlci9kYmxjbGlja196b29tLmpzIiwianMvdWkvaGFuZGxlci9kcmFnX3Bhbi5qcyIsImpzL3VpL2hhbmRsZXIvZHJhZ19yb3RhdGUuanMiLCJqcy91aS9oYW5kbGVyL2tleWJvYXJkLmpzIiwianMvdWkvaGFuZGxlci9zY3JvbGxfem9vbS5qcyIsImpzL3VpL2hhbmRsZXIvdG91Y2hfem9vbV9yb3RhdGUuanMiLCJqcy91aS9oYXNoLmpzIiwianMvdWkvaW50ZXJhY3Rpb24uanMiLCJqcy91aS9tYXAuanMiLCJqcy91aS9wb3B1cC5qcyIsImpzL3V0aWwvYWN0b3IuanMiLCJqcy91dGlsL2Jyb3dzZXIvYWpheC5qcyIsImpzL3V0aWwvYnJvd3Nlci9icm93c2VyLmpzIiwianMvdXRpbC9icm93c2VyL2NhbnZhcy5qcyIsImpzL3V0aWwvYnJvd3Nlci9kaXNwYXRjaGVyLmpzIiwianMvdXRpbC9icm93c2VyL2RvbS5qcyIsImpzL3V0aWwvY29uZmlnLmpzIiwianMvdXRpbC9ldmVudGVkLmpzIiwianMvdXRpbC9nbHlwaHMuanMiLCJqcy91dGlsL2ludGVycG9sYXRlLmpzIiwianMvdXRpbC9tYXBib3guanMiLCJqcy91dGlsL21ydV9jYWNoZS5qcyIsImpzL3V0aWwvdG9rZW4uanMiLCJqcy91dGlsL3V0aWwuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYXNzZXJ0L2Fzc2VydC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3BhdGgtYnJvd3NlcmlmeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvdXRpbC9zdXBwb3J0L2lzQnVmZmVyQnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy91dGlsL3V0aWwuanMiLCJub2RlX21vZHVsZXMvY3NzY29sb3JwYXJzZXIvY3NzY29sb3JwYXJzZXIuanMiLCJub2RlX21vZHVsZXMvZmVhdHVyZS1maWx0ZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZ2VvanNvbi12dC9zcmMvY2xpcC5qcyIsIm5vZGVfbW9kdWxlcy9nZW9qc29uLXZ0L3NyYy9jb252ZXJ0LmpzIiwibm9kZV9tb2R1bGVzL2dlb2pzb24tdnQvc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2dlb2pzb24tdnQvc3JjL3NpbXBsaWZ5LmpzIiwibm9kZV9tb2R1bGVzL2dlb2pzb24tdnQvc3JjL3RpbGUuanMiLCJub2RlX21vZHVsZXMvZ2VvanNvbi12dC9zcmMvdHJhbnNmb3JtLmpzIiwibm9kZV9tb2R1bGVzL2dlb2pzb24tdnQvc3JjL3dyYXAuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0cml4L3NyYy9nbC1tYXRyaXguanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0cml4L3NyYy9nbC1tYXRyaXgvY29tbW9uLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L21hdDIuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0cml4L3NyYy9nbC1tYXRyaXgvbWF0MmQuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0cml4L3NyYy9nbC1tYXRyaXgvbWF0My5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC9tYXQ0LmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L3F1YXQuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0cml4L3NyYy9nbC1tYXRyaXgvdmVjMi5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC92ZWMzLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L3ZlYzQuanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsLWZ1bmN0aW9uL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC1nbC1zdHlsZS1zcGVjL2xpYi92YWxpZGF0ZS9sYXRlc3QuanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsLXN0eWxlLXNwZWMvbGliL3ZhbGlkYXRlL3BhcnNlZC5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wtc3R5bGUtc3BlYy9yZWZlcmVuY2UvbGF0ZXN0LmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC1nbC1zdHlsZS1zcGVjL3JlZmVyZW5jZS9sYXRlc3QubWluLmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC1nbC1zdHlsZS1zcGVjL3JlZmVyZW5jZS92OC5qc29uIiwibm9kZV9tb2R1bGVzL21hcGJveC1nbC1zdHlsZS1zcGVjL3JlZmVyZW5jZS92OC5taW4uanNvbiIsIm5vZGVfbW9kdWxlcy9wYmYvYnVmZmVyLmpzIiwibm9kZV9tb2R1bGVzL3BiZi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wYmYvbm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcG9pbnQtZ2VvbWV0cnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmJ1c2gvcmJ1c2guanMiLCJub2RlX21vZHVsZXMvcmVzb2x2ZS11cmwvcmVzb2x2ZS11cmwuanMiLCJub2RlX21vZHVsZXMvdW5pdGJlemllci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92ZWN0b3ItdGlsZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92ZWN0b3ItdGlsZS9saWIvdmVjdG9ydGlsZS5qcyIsIm5vZGVfbW9kdWxlcy92ZWN0b3ItdGlsZS9saWIvdmVjdG9ydGlsZWZlYXR1cmUuanMiLCJub2RlX21vZHVsZXMvdmVjdG9yLXRpbGUvbGliL3ZlY3RvcnRpbGVsYXllci5qcyIsIm5vZGVfbW9kdWxlcy93ZWJ3b3JraWZ5L2luZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1UkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcFhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Z0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25JQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9NQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDanhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25ZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdldBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxa0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNud0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDemlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyc0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3poQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcmFBO0FBQ0E7O0FDREE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyMUNBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMvSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN21CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pHQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIndXNlIHN0cmljdCc7XG5cbnZhciBmZWF0dXJlRmlsdGVyID0gcmVxdWlyZSgnZmVhdHVyZS1maWx0ZXInKTtcblxudmFyIFN0eWxlRGVjbGFyYXRpb25TZXQgPSByZXF1aXJlKCcuLi9zdHlsZS9zdHlsZV9kZWNsYXJhdGlvbl9zZXQnKTtcbnZhciBMYXlvdXRQcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi4vc3R5bGUvbGF5b3V0X3Byb3BlcnRpZXMnKTtcbnZhciBFbGVtZW50R3JvdXBzID0gcmVxdWlyZSgnLi9lbGVtZW50X2dyb3VwcycpO1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJy4vYnVmZmVyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQnVja2V0O1xuXG4vKipcbiAqIEluc3RhbnRpYXRlIHRoZSBhcHByb3ByaWF0ZSBzdWJjbGFzcyBvZiBgQnVja2V0YCBmb3IgYG9wdGlvbnNgLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSBvcHRpb25zIFNlZSBgQnVja2V0YCBjb25zdHJ1Y3RvciBvcHRpb25zXG4gKiBAcmV0dXJucyB7QnVja2V0fVxuICovXG5CdWNrZXQuY3JlYXRlID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHZhciBDbGFzc2VzID0ge1xuICAgICAgICBmaWxsOiByZXF1aXJlKCcuL2ZpbGxfYnVja2V0JyksXG4gICAgICAgIGxpbmU6IHJlcXVpcmUoJy4vbGluZV9idWNrZXQnKSxcbiAgICAgICAgY2lyY2xlOiByZXF1aXJlKCcuL2NpcmNsZV9idWNrZXQnKSxcbiAgICAgICAgc3ltYm9sOiByZXF1aXJlKCcuL3N5bWJvbF9idWNrZXQnKVxuICAgIH07XG4gICAgcmV0dXJuIG5ldyBDbGFzc2VzW29wdGlvbnMubGF5ZXIudHlwZV0ob3B0aW9ucyk7XG59O1xuXG5CdWNrZXQuQXR0cmlidXRlVHlwZSA9IEJ1ZmZlci5BdHRyaWJ1dGVUeXBlO1xuXG4vKipcbiAqIFRoZSBgQnVja2V0YCBjbGFzcyBidWlsZHMgYSBzZXQgb2YgYEJ1ZmZlcmBzIGZvciBhIHNldCBvZiB2ZWN0b3IgdGlsZVxuICogZmVhdHVyZXMuXG4gKlxuICogYEJ1Y2tldGAgaXMgYW4gYWJzdHJhY3QgY2xhc3MuIEEgc3ViY2xhc3MgZXhpc3RzIGZvciBlYWNoIE1hcGJveCBHTFxuICogc3R5bGUgc3BlYyBsYXllciB0eXBlLiBCZWNhdXNlIGBCdWNrZXRgIGlzIGFuIGFic3RyYWN0IGNsYXNzLFxuICogaW5zdGFuY2VzIHNob3VsZCBiZSBjcmVhdGVkIHZpYSB0aGUgYEJ1Y2tldC5jcmVhdGVgIG1ldGhvZC5cbiAqXG4gKiBGb3IgcGVyZm9ybWFuY2UgcmVhc29ucywgYEJ1Y2tldGAgY3JlYXRlcyBpdHMgXCJhZGRcInMgbWV0aG9kcyBhdFxuICogcnVudGltZSB1c2luZyBgbmV3IEZ1bmN0aW9uKC4uLilgLlxuICpcbiAqIEBjbGFzcyBCdWNrZXRcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gb3B0aW9uc1xuICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuem9vbSBab29tIGxldmVsIG9mIHRoZSBidWZmZXJzIGJlaW5nIGJ1aWx0LiBNYXkgYmVcbiAqICAgICBhIGZyYWN0aW9uYWwgem9vbSBsZXZlbC5cbiAqIEBwYXJhbSBvcHRpb25zLmxheWVyIEEgTWFwYm94IEdMIHN0eWxlIGxheWVyIG9iamVjdFxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgQnVmZmVyPn0gb3B0aW9ucy5idWZmZXJzIFRoZSBzZXQgb2YgYEJ1ZmZlcmBzIGJlaW5nXG4gKiAgICAgYnVpbHQgZm9yIHRoaXMgdGlsZS4gVGhpcyBvYmplY3QgZmFjaWxpdGF0ZXMgc2hhcmluZyBvZiBgQnVmZmVyYHMgYmVcbiAgICAgICBiZXR3ZWVuIGBCdWNrZXRgcy5cbiAqL1xuZnVuY3Rpb24gQnVja2V0KG9wdGlvbnMpIHtcbiAgICB0aGlzLmxheWVyID0gb3B0aW9ucy5sYXllcjtcbiAgICB0aGlzLnpvb20gPSBvcHRpb25zLnpvb207XG5cbiAgICB0aGlzLmxheWVycyA9IFt0aGlzLmxheWVyLmlkXTtcbiAgICB0aGlzLnR5cGUgPSB0aGlzLmxheWVyLnR5cGU7XG4gICAgdGhpcy5mZWF0dXJlcyA9IFtdO1xuICAgIHRoaXMuaWQgPSB0aGlzLmxheWVyLmlkO1xuICAgIHRoaXNbJ3NvdXJjZS1sYXllciddID0gdGhpcy5sYXllclsnc291cmNlLWxheWVyJ107XG4gICAgdGhpcy5pbnRlcmFjdGl2ZSA9IHRoaXMubGF5ZXIuaW50ZXJhY3RpdmU7XG4gICAgdGhpcy5taW5ab29tID0gdGhpcy5sYXllci5taW56b29tO1xuICAgIHRoaXMubWF4Wm9vbSA9IHRoaXMubGF5ZXIubWF4em9vbTtcbiAgICB0aGlzLmZpbHRlciA9IGZlYXR1cmVGaWx0ZXIodGhpcy5sYXllci5maWx0ZXIpO1xuXG4gICAgdGhpcy5sYXlvdXRQcm9wZXJ0aWVzID0gY3JlYXRlTGF5b3V0UHJvcGVydGllcyh0aGlzLmxheWVyLCB0aGlzLnpvb20pO1xuXG4gICAgdGhpcy5yZXNldEJ1ZmZlcnMob3B0aW9ucy5idWZmZXJzKTtcblxuICAgIGZvciAodmFyIHNoYWRlck5hbWUgaW4gdGhpcy5zaGFkZXJzKSB7XG4gICAgICAgIHZhciBzaGFkZXIgPSB0aGlzLnNoYWRlcnNbc2hhZGVyTmFtZV07XG4gICAgICAgIHRoaXNbdGhpcy5nZXRBZGRNZXRob2ROYW1lKHNoYWRlck5hbWUsICd2ZXJ0ZXgnKV0gPSBjcmVhdGVWZXJ0ZXhBZGRNZXRob2QoXG4gICAgICAgICAgICBzaGFkZXJOYW1lLFxuICAgICAgICAgICAgc2hhZGVyLFxuICAgICAgICAgICAgdGhpcy5nZXRCdWZmZXJOYW1lKHNoYWRlck5hbWUsICd2ZXJ0ZXgnKVxuICAgICAgICApO1xuICAgIH1cbn1cblxuLyoqXG4gKiBCdWlsZCB0aGUgYnVmZmVycyEgRmVhdHVyZXMgYXJlIHNldCBkaXJlY3RseSB0byB0aGUgYGZlYXR1cmVzYCBwcm9wZXJ0eS5cbiAqIEBwcml2YXRlXG4gKi9cbkJ1Y2tldC5wcm90b3R5cGUuYWRkRmVhdHVyZXMgPSBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5hZGRGZWF0dXJlKHRoaXMuZmVhdHVyZXNbaV0pO1xuICAgIH1cbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlcmUgaXMgZW5vdWdoIHNwYWNlIGF2YWlsYWJsZSBpbiB0aGUgY3VycmVudCBlbGVtZW50IGdyb3VwIGZvclxuICogYHZlcnRleExlbmd0aGAgdmVydGljZXMuIElmIG5vdCwgYXBwZW5kIGEgbmV3IGVsZW1lbnRHcm91cC4gU2hvdWxkIGJlIGNhbGxlZFxuICogYnkgYGFkZEZlYXR1cmVzYCBhbmQgaXRzIGNhbGxlZXMuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHNoYWRlck5hbWUgdGhlIG5hbWUgb2YgdGhlIHNoYWRlciBhc3NvY2lhdGVkIHdpdGggdGhlIGJ1ZmZlciB0aGF0IHdpbGwgcmVjZWl2ZSB0aGUgdmVydGljZXNcbiAqIEBwYXJhbSB7bnVtYmVyfSB2ZXJ0ZXhMZW5ndGggVGhlIG51bWJlciBvZiB2ZXJ0aWNlcyB0aGF0IHdpbGwgYmUgaW5zZXJ0ZWQgdG8gdGhlIGJ1ZmZlci5cbiAqL1xuQnVja2V0LnByb3RvdHlwZS5tYWtlUm9vbUZvciA9IGZ1bmN0aW9uKHNoYWRlck5hbWUsIHZlcnRleExlbmd0aCkge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnRHcm91cHNbc2hhZGVyTmFtZV0ubWFrZVJvb21Gb3IodmVydGV4TGVuZ3RoKTtcbn07XG5cbi8qKlxuICogU3RhcnQgdXNpbmcgYSBuZXcgc2hhcmVkIGBidWZmZXJzYCBvYmplY3QgYW5kIHJlY3JlYXRlIGluc3RhbmNlcyBvZiBgQnVmZmVyYFxuICogYXMgbmVjZXNzYXJ5LlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIEJ1ZmZlcj59IGJ1ZmZlcnNcbiAqL1xuQnVja2V0LnByb3RvdHlwZS5yZXNldEJ1ZmZlcnMgPSBmdW5jdGlvbihidWZmZXJzKSB7XG4gICAgdGhpcy5idWZmZXJzID0gYnVmZmVycztcbiAgICB0aGlzLmVsZW1lbnRHcm91cHMgPSB7fTtcblxuICAgIGZvciAodmFyIHNoYWRlck5hbWUgaW4gdGhpcy5zaGFkZXJzKSB7XG4gICAgICAgIHZhciBzaGFkZXIgPSB0aGlzLnNoYWRlcnNbc2hhZGVyTmFtZV07XG5cbiAgICAgICAgdmFyIHZlcnRleEJ1ZmZlck5hbWUgPSB0aGlzLmdldEJ1ZmZlck5hbWUoc2hhZGVyTmFtZSwgJ3ZlcnRleCcpO1xuICAgICAgICBpZiAoc2hhZGVyLnZlcnRleEJ1ZmZlciAmJiAhYnVmZmVyc1t2ZXJ0ZXhCdWZmZXJOYW1lXSkge1xuICAgICAgICAgICAgYnVmZmVyc1t2ZXJ0ZXhCdWZmZXJOYW1lXSA9IG5ldyBCdWZmZXIoe1xuICAgICAgICAgICAgICAgIHR5cGU6IEJ1ZmZlci5CdWZmZXJUeXBlLlZFUlRFWCxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBzaGFkZXIuYXR0cmlidXRlc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2hhZGVyLmVsZW1lbnRCdWZmZXIpIHtcbiAgICAgICAgICAgIHZhciBlbGVtZW50QnVmZmVyTmFtZSA9IHRoaXMuZ2V0QnVmZmVyTmFtZShzaGFkZXJOYW1lLCAnZWxlbWVudCcpO1xuICAgICAgICAgICAgaWYgKCFidWZmZXJzW2VsZW1lbnRCdWZmZXJOYW1lXSkge1xuICAgICAgICAgICAgICAgIGJ1ZmZlcnNbZWxlbWVudEJ1ZmZlck5hbWVdID0gY3JlYXRlRWxlbWVudEJ1ZmZlcihzaGFkZXIuZWxlbWVudEJ1ZmZlckNvbXBvbmVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpc1t0aGlzLmdldEFkZE1ldGhvZE5hbWUoc2hhZGVyTmFtZSwgJ2VsZW1lbnQnKV0gPSBjcmVhdGVFbGVtZW50QWRkTWV0aG9kKHRoaXMuYnVmZmVyc1tlbGVtZW50QnVmZmVyTmFtZV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNoYWRlci5zZWNvbmRFbGVtZW50QnVmZmVyKSB7XG4gICAgICAgICAgICB2YXIgc2Vjb25kRWxlbWVudEJ1ZmZlck5hbWUgPSB0aGlzLmdldEJ1ZmZlck5hbWUoc2hhZGVyTmFtZSwgJ3NlY29uZEVsZW1lbnQnKTtcbiAgICAgICAgICAgIGlmICghYnVmZmVyc1tzZWNvbmRFbGVtZW50QnVmZmVyTmFtZV0pIHtcbiAgICAgICAgICAgICAgICBidWZmZXJzW3NlY29uZEVsZW1lbnRCdWZmZXJOYW1lXSA9IGNyZWF0ZUVsZW1lbnRCdWZmZXIoc2hhZGVyLnNlY29uZEVsZW1lbnRCdWZmZXJDb21wb25lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXNbdGhpcy5nZXRBZGRNZXRob2ROYW1lKHNoYWRlck5hbWUsICdzZWNvbmRFbGVtZW50JyldID0gY3JlYXRlRWxlbWVudEFkZE1ldGhvZCh0aGlzLmJ1ZmZlcnNbc2Vjb25kRWxlbWVudEJ1ZmZlck5hbWVdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZWxlbWVudEdyb3Vwc1tzaGFkZXJOYW1lXSA9IG5ldyBFbGVtZW50R3JvdXBzKFxuICAgICAgICAgICAgYnVmZmVyc1t0aGlzLmdldEJ1ZmZlck5hbWUoc2hhZGVyTmFtZSwgJ3ZlcnRleCcpXSxcbiAgICAgICAgICAgIGJ1ZmZlcnNbdGhpcy5nZXRCdWZmZXJOYW1lKHNoYWRlck5hbWUsICdlbGVtZW50JyldLFxuICAgICAgICAgICAgYnVmZmVyc1t0aGlzLmdldEJ1ZmZlck5hbWUoc2hhZGVyTmFtZSwgJ3NlY29uZEVsZW1lbnQnKV1cbiAgICAgICAgKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEdldCB0aGUgbmFtZSBvZiB0aGUgbWV0aG9kIHVzZWQgdG8gYWRkIGFuIGl0ZW0gdG8gYSBidWZmZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gc2hhZGVyTmFtZSBUaGUgbmFtZSBvZiB0aGUgc2hhZGVyIHRoYXQgd2lsbCB1c2UgdGhlIGJ1ZmZlclxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgT25lIG9mIFwidmVydGV4XCIsIFwiZWxlbWVudFwiLCBvciBcInNlY29uZEVsZW1lbnRcIlxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuQnVja2V0LnByb3RvdHlwZS5nZXRBZGRNZXRob2ROYW1lID0gZnVuY3Rpb24oc2hhZGVyTmFtZSwgdHlwZSkge1xuICAgIHJldHVybiAnYWRkJyArIGNhcGl0YWxpemUoc2hhZGVyTmFtZSkgKyBjYXBpdGFsaXplKHR5cGUpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIG5hbWUgb2YgYSBidWZmZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gc2hhZGVyTmFtZSBUaGUgbmFtZSBvZiB0aGUgc2hhZGVyIHRoYXQgd2lsbCB1c2UgdGhlIGJ1ZmZlclxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgT25lIG9mIFwidmVydGV4XCIsIFwiZWxlbWVudFwiLCBvciBcInNlY29uZEVsZW1lbnRcIlxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuQnVja2V0LnByb3RvdHlwZS5nZXRCdWZmZXJOYW1lID0gZnVuY3Rpb24oc2hhZGVyTmFtZSwgdHlwZSkge1xuICAgIHJldHVybiBzaGFkZXJOYW1lICsgY2FwaXRhbGl6ZSh0eXBlKTtcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUxheW91dFByb3BlcnRpZXMobGF5ZXIsIHpvb20pIHtcbiAgICB2YXIgdmFsdWVzID0gbmV3IFN0eWxlRGVjbGFyYXRpb25TZXQoJ2xheW91dCcsIGxheWVyLnR5cGUsIGxheWVyLmxheW91dCwge30pLnZhbHVlcygpO1xuICAgIHZhciBmYWtlWm9vbUhpc3RvcnkgPSB7IGxhc3RJbnRlZ2VyWm9vbTogSW5maW5pdHksIGxhc3RJbnRlZ2VyWm9vbVRpbWU6IDAsIGxhc3Rab29tOiAwIH07XG5cbiAgICB2YXIgbGF5b3V0ID0ge307XG4gICAgZm9yICh2YXIgayBpbiB2YWx1ZXMpIHtcbiAgICAgICAgbGF5b3V0W2tdID0gdmFsdWVzW2tdLmNhbGN1bGF0ZSh6b29tLCBmYWtlWm9vbUhpc3RvcnkpO1xuICAgIH1cblxuICAgIGlmIChsYXllci50eXBlID09PSAnc3ltYm9sJykge1xuICAgICAgICAvLyBUbyByZWR1Y2UgdGhlIG51bWJlciBvZiBsYWJlbHMgdGhhdCBqdW1wIGFyb3VuZCB3aGVuIHpvb21pbmcgd2UgbmVlZFxuICAgICAgICAvLyB0byB1c2UgYSB0ZXh0LXNpemUgdmFsdWUgdGhhdCBpcyB0aGUgc2FtZSBmb3IgYWxsIHpvb20gbGV2ZWxzLlxuICAgICAgICAvLyBUaGlzIGNhbGN1bGF0ZXMgdGV4dC1zaXplIGF0IGEgaGlnaCB6b29tIGxldmVsIHNvIHRoYXQgYWxsIHRpbGVzIGNhblxuICAgICAgICAvLyB1c2UgdGhlIHNhbWUgdmFsdWUgd2hlbiBjYWxjdWxhdGluZyBhbmNob3IgcG9zaXRpb25zLlxuICAgICAgICBpZiAodmFsdWVzWyd0ZXh0LXNpemUnXSkge1xuICAgICAgICAgICAgbGF5b3V0Wyd0ZXh0LW1heC1zaXplJ10gPSB2YWx1ZXNbJ3RleHQtc2l6ZSddLmNhbGN1bGF0ZSgxOCwgZmFrZVpvb21IaXN0b3J5KTtcbiAgICAgICAgICAgIGxheW91dFsndGV4dC1zaXplJ10gPSB2YWx1ZXNbJ3RleHQtc2l6ZSddLmNhbGN1bGF0ZSh6b29tICsgMSwgZmFrZVpvb21IaXN0b3J5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWVzWydpY29uLXNpemUnXSkge1xuICAgICAgICAgICAgbGF5b3V0WydpY29uLW1heC1zaXplJ10gPSB2YWx1ZXNbJ2ljb24tc2l6ZSddLmNhbGN1bGF0ZSgxOCwgZmFrZVpvb21IaXN0b3J5KTtcbiAgICAgICAgICAgIGxheW91dFsnaWNvbi1zaXplJ10gPSB2YWx1ZXNbJ2ljb24tc2l6ZSddLmNhbGN1bGF0ZSh6b29tICsgMSwgZmFrZVpvb21IaXN0b3J5KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgTGF5b3V0UHJvcGVydGllc1tsYXllci50eXBlXShsYXlvdXQpO1xufVxuXG52YXIgY3JlYXRlVmVydGV4QWRkTWV0aG9kQ2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGNyZWF0ZVZlcnRleEFkZE1ldGhvZChzaGFkZXJOYW1lLCBzaGFkZXIsIGJ1ZmZlck5hbWUpIHtcbiAgICB2YXIgcHVzaEFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNoYWRlci5hdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHB1c2hBcmdzID0gcHVzaEFyZ3MuY29uY2F0KHNoYWRlci5hdHRyaWJ1dGVzW2ldLnZhbHVlKTtcbiAgICB9XG5cbiAgICB2YXIgYm9keSA9ICdyZXR1cm4gdGhpcy5idWZmZXJzLicgKyBidWZmZXJOYW1lICsgJy5wdXNoKCcgKyBwdXNoQXJncy5qb2luKCcsICcpICsgJyk7JztcblxuICAgIGlmICghY3JlYXRlVmVydGV4QWRkTWV0aG9kQ2FjaGVbYm9keV0pIHtcbiAgICAgICAgY3JlYXRlVmVydGV4QWRkTWV0aG9kQ2FjaGVbYm9keV0gPSBuZXcgRnVuY3Rpb24oc2hhZGVyLmF0dHJpYnV0ZUFyZ3MsIGJvZHkpO1xuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVWZXJ0ZXhBZGRNZXRob2RDYWNoZVtib2R5XTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudEFkZE1ldGhvZChidWZmZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob25lLCB0d28sIHRocmVlKSB7XG4gICAgICAgIHJldHVybiBidWZmZXIucHVzaChvbmUsIHR3bywgdGhyZWUpO1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRCdWZmZXIoY29tcG9uZW50cykge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKHtcbiAgICAgICAgdHlwZTogQnVmZmVyLkJ1ZmZlclR5cGUuRUxFTUVOVCxcbiAgICAgICAgYXR0cmlidXRlczogW3tcbiAgICAgICAgICAgIG5hbWU6ICd2ZXJ0aWNlcycsXG4gICAgICAgICAgICBjb21wb25lbnRzOiBjb21wb25lbnRzIHx8IDMsXG4gICAgICAgICAgICB0eXBlOiBCdWZmZXIuRUxFTUVOVF9BVFRSSUJVVEVfVFlQRVxuICAgICAgICB9XVxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBjYXBpdGFsaXplKHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHJpbmcuc2xpY2UoMSk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIE5vdGU6IGFsbCBcInNpemVzXCIgYXJlIG1lYXN1cmVkIGluIGJ5dGVzXG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTtcblxuLyoqXG4gKiBUaGUgYEJ1ZmZlcmAgY2xhc3MgaXMgcmVzcG9uc2libGUgZm9yIG1hbmFnaW5nIG9uZSBpbnN0YW5jZSBvZiBgQXJyYXlCdWZmZXJgLiBgQXJyYXlCdWZmZXJgc1xuICogcHJvdmlkZSBsb3ctbGV2ZWwgcmVhZC93cml0ZSBhY2Nlc3MgdG8gYSBjaHVuayBvZiBtZW1vcnkuIGBBcnJheUJ1ZmZlcmBzIGFyZSBwb3B1bGF0ZWQgd2l0aFxuICogcGVyLXZlcnRleCBkYXRhLCB1cGxvYWRlZCB0byB0aGUgR1BVLCBhbmQgdXNlZCBpbiByZW5kZXJpbmcuXG4gKlxuICogYEJ1ZmZlcmAgcHJvdmlkZXMgYW4gYWJzdHJhY3Rpb24gb3ZlciBgQXJyYXlCdWZmZXJgLCBtYWtpbmcgaXQgYmVoYXZlIGxpa2UgYW4gYXJyYXkgb2ZcbiAqIHN0YXRpY2FsbHkgdHlwZWQgc3RydWN0cy4gQSBidWZmZXIgaXMgY29tcHJpc2VkIG9mIGl0ZW1zLiBBbiBpdGVtIGlzIGNvbXByaXNlZCBvZiBhIHNldCBvZlxuICogYXR0cmlidXRlcy4gQXR0cmlidXRlcyBhcmUgZGVmaW5lZCB3aGVuIHRoZSBjbGFzcyBpcyBjb25zdHJ1Y3RlZC5cbiAqXG4gKiBAY2xhc3MgQnVmZmVyXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIG9wdGlvbnNcbiAqIEBwYXJhbSB7QnVmZmVyVHlwZX0gb3B0aW9ucy50eXBlXG4gKiBAcGFyYW0ge0FycmF5LjxCdWZmZXJBdHRyaWJ1dGU+fSBvcHRpb25zLmF0dHJpYnV0ZXNcbiAqL1xuZnVuY3Rpb24gQnVmZmVyKG9wdGlvbnMpIHtcblxuICAgIHRoaXMudHlwZSA9IG9wdGlvbnMudHlwZTtcblxuICAgIC8vIENsb25lIGFuIGV4aXN0aW5nIEJ1ZmZlclxuICAgIGlmIChvcHRpb25zLmFycmF5QnVmZmVyKSB7XG5cbiAgICAgICAgdGhpcy5jYXBhY2l0eSA9IG9wdGlvbnMuY2FwYWNpdHk7XG4gICAgICAgIHRoaXMuYXJyYXlCdWZmZXIgPSBvcHRpb25zLmFycmF5QnVmZmVyO1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZXMgPSBvcHRpb25zLmF0dHJpYnV0ZXM7XG4gICAgICAgIHRoaXMuaXRlbVNpemUgPSBvcHRpb25zLml0ZW1TaXplO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IG9wdGlvbnMubGVuZ3RoO1xuXG4gICAgLy8gQ3JlYXRlIGEgbmV3IEJ1ZmZlclxuICAgIH0gZWxzZSB7XG5cbiAgICAgICAgdGhpcy5jYXBhY2l0eSA9IGFsaWduKEJ1ZmZlci5DQVBBQ0lUWV9ERUZBVUxULCBCdWZmZXIuQ0FQQUNJVFlfQUxJR05NRU5UKTtcbiAgICAgICAgdGhpcy5hcnJheUJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcih0aGlzLmNhcGFjaXR5KTtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzID0gW107XG4gICAgICAgIHRoaXMuaXRlbVNpemUgPSAwO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgICAgICAgLy8gVmVydGV4IGJ1ZmZlciBhdHRyaWJ1dGVzIG11c3QgYmUgYWxpZ25lZCB0byB3b3JkIGJvdW5kYXJpZXMgYnV0XG4gICAgICAgIC8vIGVsZW1lbnQgYnVmZmVyIGF0dHJpYnV0ZXMgZG8gbm90IG5lZWQgdG8gYmUgYWxpZ25lZC5cbiAgICAgICAgdmFyIGF0dHJpYnV0ZUFsaWdubWVudCA9IHRoaXMudHlwZSA9PT0gQnVmZmVyLkJ1ZmZlclR5cGUuVkVSVEVYID8gQnVmZmVyLlZFUlRFWF9BVFRSSUJVVEVfQUxJR05NRU5UIDogMTtcblxuICAgICAgICB0aGlzLmF0dHJpYnV0ZXMgPSBvcHRpb25zLmF0dHJpYnV0ZXMubWFwKGZ1bmN0aW9uKGF0dHJpYnV0ZU9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBhdHRyaWJ1dGUgPSB7fTtcblxuICAgICAgICAgICAgYXR0cmlidXRlLm5hbWUgPSBhdHRyaWJ1dGVPcHRpb25zLm5hbWU7XG4gICAgICAgICAgICBhdHRyaWJ1dGUuY29tcG9uZW50cyA9IGF0dHJpYnV0ZU9wdGlvbnMuY29tcG9uZW50cyB8fCAxO1xuICAgICAgICAgICAgYXR0cmlidXRlLnR5cGUgPSBhdHRyaWJ1dGVPcHRpb25zLnR5cGUgfHwgQnVmZmVyLkF0dHJpYnV0ZVR5cGUuVU5TSUdORURfQllURTtcbiAgICAgICAgICAgIGF0dHJpYnV0ZS5zaXplID0gYXR0cmlidXRlLnR5cGUuc2l6ZSAqIGF0dHJpYnV0ZS5jb21wb25lbnRzO1xuICAgICAgICAgICAgYXR0cmlidXRlLm9mZnNldCA9IHRoaXMuaXRlbVNpemU7XG5cbiAgICAgICAgICAgIHRoaXMuaXRlbVNpemUgPSBhbGlnbihhdHRyaWJ1dGUub2Zmc2V0ICsgYXR0cmlidXRlLnNpemUsIGF0dHJpYnV0ZUFsaWdubWVudCk7XG5cbiAgICAgICAgICAgIGFzc2VydCghaXNOYU4odGhpcy5pdGVtU2l6ZSkpO1xuICAgICAgICAgICAgYXNzZXJ0KCFpc05hTihhdHRyaWJ1dGUuc2l6ZSkpO1xuICAgICAgICAgICAgYXNzZXJ0KGF0dHJpYnV0ZS50eXBlLm5hbWUgaW4gQnVmZmVyLkF0dHJpYnV0ZVR5cGUpO1xuXG4gICAgICAgICAgICByZXR1cm4gYXR0cmlidXRlO1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAvLyBUaGVzZSBhcmUgZXhwZW5zaXZlIGNhbGxzLiBCZWNhdXNlIHdlIG9ubHkgcHVzaCB0aGluZ3MgdG8gYnVmZmVycyBpblxuICAgICAgICAvLyB0aGUgd29ya2VyIHRocmVhZCwgd2UgY2FuIHNraXAgaW4gdGhlIFwiY2xvbmUgYW4gZXhpc3RpbmcgYnVmZmVyXCIgY2FzZS5cbiAgICAgICAgdGhpcy5fY3JlYXRlUHVzaE1ldGhvZCgpO1xuICAgICAgICB0aGlzLl9yZWZyZXNoVmlld3MoKTtcbiAgICB9XG59XG5cbi8qKlxuICogQmluZCB0aGlzIGJ1ZmZlciB0byBhIFdlYkdMIGNvbnRleHQuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIGdsIFRoZSBXZWJHTCBjb250ZXh0XG4gKi9cbkJ1ZmZlci5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uKGdsKSB7XG4gICAgdmFyIHR5cGUgPSBnbFt0aGlzLnR5cGVdO1xuXG4gICAgaWYgKCF0aGlzLmJ1ZmZlcikge1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgICBnbC5iaW5kQnVmZmVyKHR5cGUsIHRoaXMuYnVmZmVyKTtcbiAgICAgICAgZ2wuYnVmZmVyRGF0YSh0eXBlLCB0aGlzLmFycmF5QnVmZmVyLnNsaWNlKDAsIHRoaXMubGVuZ3RoICogdGhpcy5pdGVtU2l6ZSksIGdsLlNUQVRJQ19EUkFXKTtcblxuICAgICAgICAvLyBkdW1wIGFycmF5IGJ1ZmZlciBvbmNlIGl0J3MgYm91bmQgdG8gZ2xcbiAgICAgICAgdGhpcy5hcnJheUJ1ZmZlciA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcih0eXBlLCB0aGlzLmJ1ZmZlcik7XG4gICAgfVxufTtcblxuLyoqXG4gKiBEZXN0cm95IHRoZSBHTCBidWZmZXIgYm91bmQgdG8gdGhlIGdpdmVuIFdlYkdMIGNvbnRleHRcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gZ2wgVGhlIFdlYkdMIGNvbnRleHRcbiAqL1xuQnVmZmVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oZ2wpIHtcbiAgICBpZiAodGhpcy5idWZmZXIpIHtcbiAgICAgICAgZ2wuZGVsZXRlQnVmZmVyKHRoaXMuYnVmZmVyKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFNldCB0aGUgYXR0cmlidXRlIHBvaW50ZXJzIGluIGEgV2ViR0wgY29udGV4dCBhY2NvcmRpbmcgdG8gdGhlIGJ1ZmZlcidzIGF0dHJpYnV0ZSBsYXlvdXRcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gZ2wgVGhlIFdlYkdMIGNvbnRleHRcbiAqIEBwYXJhbSBzaGFkZXIgVGhlIGFjdGl2ZSBXZWJHTCBzaGFkZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgVGhlIG9mZnNldCBvZiB0aGUgYXR0cmlidXRlIGRhdGEgaW4gdGhlIGN1cnJlbnRseSBib3VuZCBHTCBidWZmZXIuXG4gKi9cbkJ1ZmZlci5wcm90b3R5cGUuc2V0QXR0cmliUG9pbnRlcnMgPSBmdW5jdGlvbihnbCwgc2hhZGVyLCBvZmZzZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYXR0cmliID0gdGhpcy5hdHRyaWJ1dGVzW2ldO1xuXG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoXG4gICAgICAgICAgICBzaGFkZXJbJ2FfJyArIGF0dHJpYi5uYW1lXSwgYXR0cmliLmNvbXBvbmVudHMsIGdsW2F0dHJpYi50eXBlLm5hbWVdLFxuICAgICAgICAgICAgZmFsc2UsIHRoaXMuaXRlbVNpemUsIG9mZnNldCArIGF0dHJpYi5vZmZzZXQpO1xuICAgIH1cbn07XG5cbi8qKlxuICogR2V0IGFuIGl0ZW0gZnJvbSB0aGUgYEFycmF5QnVmZmVyYC4gT25seSB1c2VkIGZvciBkZWJ1Z2dpbmcuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgaXRlbSB0byBnZXRcbiAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywgQXJyYXkuPG51bWJlcj4+fVxuICovXG5CdWZmZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgdGhpcy5fcmVmcmVzaFZpZXdzKCk7XG5cbiAgICB2YXIgaXRlbSA9IHt9O1xuICAgIHZhciBvZmZzZXQgPSBpbmRleCAqIHRoaXMuaXRlbVNpemU7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYXR0cmlidXRlID0gdGhpcy5hdHRyaWJ1dGVzW2ldO1xuICAgICAgICB2YXIgdmFsdWVzID0gaXRlbVthdHRyaWJ1dGUubmFtZV0gPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGF0dHJpYnV0ZS5jb21wb25lbnRzOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBjb21wb25lbnRPZmZzZXQgPSAoKG9mZnNldCArIGF0dHJpYnV0ZS5vZmZzZXQpIC8gYXR0cmlidXRlLnR5cGUuc2l6ZSkgKyBqO1xuICAgICAgICAgICAgdmFsdWVzLnB1c2godGhpcy52aWV3c1thdHRyaWJ1dGUudHlwZS5uYW1lXVtjb21wb25lbnRPZmZzZXRdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaXRlbTtcbn07XG5cbi8qKlxuICogQ2hlY2sgdGhhdCBhIGJ1ZmZlciBpdGVtIGlzIHdlbGwgZm9ybWVkIGFuZCB0aHJvdyBhbiBlcnJvciBpZiBub3QuIE9ubHlcbiAqIHVzZWQgZm9yIGRlYnVnZ2luZy5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gYXJncyBUaGUgXCJhcmd1bWVudHNcIiBvYmplY3QgZnJvbSBCdWZmZXI6OnB1c2hcbiAqL1xuQnVmZmVyLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5hdHRyaWJ1dGVzW2ldLmNvbXBvbmVudHM7IGorKykge1xuICAgICAgICAgICAgYXNzZXJ0KCFpc05hTihhcmdzW2FyZ0luZGV4KytdKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXNzZXJ0KGFyZ0luZGV4ID09PSBhcmdzLmxlbmd0aCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLl9yZXNpemUgPSBmdW5jdGlvbihjYXBhY2l0eSkge1xuICAgIHZhciBvbGQgPSB0aGlzLnZpZXdzLlVOU0lHTkVEX0JZVEU7XG4gICAgdGhpcy5jYXBhY2l0eSA9IGFsaWduKGNhcGFjaXR5LCBCdWZmZXIuQ0FQQUNJVFlfQUxJR05NRU5UKTtcbiAgICB0aGlzLmFycmF5QnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKHRoaXMuY2FwYWNpdHkpO1xuICAgIHRoaXMuX3JlZnJlc2hWaWV3cygpO1xuICAgIHRoaXMudmlld3MuVU5TSUdORURfQllURS5zZXQob2xkKTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUuX3JlZnJlc2hWaWV3cyA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMudmlld3MgPSB7XG4gICAgICAgIFVOU0lHTkVEX0JZVEU6ICBuZXcgVWludDhBcnJheSh0aGlzLmFycmF5QnVmZmVyKSxcbiAgICAgICAgQllURTogICAgICAgICAgIG5ldyBJbnQ4QXJyYXkodGhpcy5hcnJheUJ1ZmZlciksXG4gICAgICAgIFVOU0lHTkVEX1NIT1JUOiBuZXcgVWludDE2QXJyYXkodGhpcy5hcnJheUJ1ZmZlciksXG4gICAgICAgIFNIT1JUOiAgICAgICAgICBuZXcgSW50MTZBcnJheSh0aGlzLmFycmF5QnVmZmVyKVxuICAgIH07XG59O1xuXG52YXIgY3JlYXRlUHVzaE1ldGhvZENhY2hlID0ge307XG5CdWZmZXIucHJvdG90eXBlLl9jcmVhdGVQdXNoTWV0aG9kID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGJvZHkgPSAnJztcbiAgICB2YXIgYXJnTmFtZXMgPSBbXTtcblxuICAgIGJvZHkgKz0gJ3ZhciBpID0gdGhpcy5sZW5ndGgrKztcXG4nO1xuICAgIGJvZHkgKz0gJ3ZhciBvID0gaSAqICcgKyB0aGlzLml0ZW1TaXplICsgJztcXG4nO1xuICAgIGJvZHkgKz0gJ2lmIChvICsgJyArIHRoaXMuaXRlbVNpemUgKyAnID4gdGhpcy5jYXBhY2l0eSkgeyB0aGlzLl9yZXNpemUodGhpcy5jYXBhY2l0eSAqIDEuNSk7IH1cXG4nO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IHRoaXMuYXR0cmlidXRlc1tpXTtcbiAgICAgICAgdmFyIG9mZnNldElkID0gJ28nICsgaTtcblxuICAgICAgICBib2R5ICs9ICdcXG52YXIgJyArIG9mZnNldElkICsgJyA9IChvICsgJyArIGF0dHJpYnV0ZS5vZmZzZXQgKyAnKSAvICcgKyBhdHRyaWJ1dGUudHlwZS5zaXplICsgJztcXG4nO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYXR0cmlidXRlLmNvbXBvbmVudHM7IGorKykge1xuICAgICAgICAgICAgdmFyIHJ2YWx1ZSA9ICd2JyArIGFyZ05hbWVzLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBsdmFsdWUgPSAndGhpcy52aWV3cy4nICsgYXR0cmlidXRlLnR5cGUubmFtZSArICdbJyArIG9mZnNldElkICsgJyArICcgKyBqICsgJ10nO1xuICAgICAgICAgICAgYm9keSArPSBsdmFsdWUgKyAnID0gJyArIHJ2YWx1ZSArICc7XFxuJztcbiAgICAgICAgICAgIGFyZ05hbWVzLnB1c2gocnZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGJvZHkgKz0gJ1xcbnJldHVybiBpO1xcbic7XG5cbiAgICBpZiAoIWNyZWF0ZVB1c2hNZXRob2RDYWNoZVtib2R5XSkge1xuICAgICAgICBjcmVhdGVQdXNoTWV0aG9kQ2FjaGVbYm9keV0gPSBuZXcgRnVuY3Rpb24oYXJnTmFtZXMsIGJvZHkpO1xuICAgIH1cblxuICAgIHRoaXMucHVzaCA9IGNyZWF0ZVB1c2hNZXRob2RDYWNoZVtib2R5XTtcbn07XG5cbi8qKlxuICogQHR5cGVkZWYgQnVmZmVyQXR0cmlidXRlXG4gKiBAcHJpdmF0ZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb21wb25lbnRzXG4gKiBAcHJvcGVydHkge0J1ZmZlckF0dHJpYnV0ZVR5cGV9IHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzaXplXG4gKiBAcHJvcGVydHkge251bWJlcn0gb2Zmc2V0XG4gKi9cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfSBCdWZmZXJUeXBlXG4gKiBAcHJpdmF0ZVxuICogQHJlYWRvbmx5XG4gKi9cbkJ1ZmZlci5CdWZmZXJUeXBlID0ge1xuICAgIFZFUlRFWDogJ0FSUkFZX0JVRkZFUicsXG4gICAgRUxFTUVOVDogJ0VMRU1FTlRfQVJSQVlfQlVGRkVSJ1xufTtcblxuLyoqXG4gKiBAZW51bSB7e3NpemU6IG51bWJlciwgbmFtZTogc3RyaW5nfX0gQnVmZmVyQXR0cmlidXRlVHlwZVxuICogQHByaXZhdGVcbiAqIEByZWFkb25seVxuICovXG5CdWZmZXIuQXR0cmlidXRlVHlwZSA9IHtcbiAgICBCWVRFOiAgICAgICAgICAgeyBzaXplOiAxLCBuYW1lOiAnQllURScgfSxcbiAgICBVTlNJR05FRF9CWVRFOiAgeyBzaXplOiAxLCBuYW1lOiAnVU5TSUdORURfQllURScgfSxcbiAgICBTSE9SVDogICAgICAgICAgeyBzaXplOiAyLCBuYW1lOiAnU0hPUlQnIH0sXG4gICAgVU5TSUdORURfU0hPUlQ6IHsgc2l6ZTogMiwgbmFtZTogJ1VOU0lHTkVEX1NIT1JUJyB9XG59O1xuXG4vKipcbiAqIEFuIGBCdWZmZXJUeXBlLkVMRU1FTlRgIGJ1ZmZlciBob2xkcyBpbmRpY2llcyBvZiBhIGNvcnJlc3BvbmRpbmcgYEJ1ZmZlclR5cGUuVkVSVEVYYCBidWZmZXIuXG4gKiBUaGVzZSBpbmRpY2llcyBhcmUgc3RvcmVkIGluIHRoZSBgQnVmZmVyVHlwZS5FTEVNRU5UYCBidWZmZXIgYXMgYFVOU0lHTkVEX1NIT1JUYHMuXG4gKlxuICogQHByb3BlcnR5IHtCdWZmZXJBdHRyaWJ1dGVUeXBlfVxuICogQHByaXZhdGVcbiAqIEByZWFkb25seVxuICovXG5CdWZmZXIuRUxFTUVOVF9BVFRSSUJVVEVfVFlQRSA9IEJ1ZmZlci5BdHRyaWJ1dGVUeXBlLlVOU0lHTkVEX1NIT1JUO1xuXG4vKipcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfVxuICogQHByaXZhdGVcbiAqIEByZWFkb25seVxuICovXG5CdWZmZXIuQ0FQQUNJVFlfREVGQVVMVCA9IDgxOTI7XG5cbi8qKlxuICogV2ViR0wgcGVyZm9ybXMgYmVzdCBpZiBidWZmZXIgc2l6ZXMgYXJlIGFsaWduZWQgdG8gMiBieXRlIGJvdW5kYXJpZXMuXG4gKiBAcHJvcGVydHkge251bWJlcn1cbiAqIEBwcml2YXRlXG4gKiBAcmVhZG9ubHlcbiAqL1xuQnVmZmVyLkNBUEFDSVRZX0FMSUdOTUVOVCA9IDI7XG5cbi8qKlxuICogV2ViR0wgcGVyZm9ybXMgYmVzdCBpZiB2ZXJ0ZXggYXR0cmlidXRlIG9mZnNldHMgYXJlIGFsaWduZWQgdG8gNCBieXRlIGJvdW5kYXJpZXMuXG4gKiBAcHJvcGVydHkge251bWJlcn1cbiAqIEBwcml2YXRlXG4gKiBAcmVhZG9ubHlcbiAqL1xuQnVmZmVyLlZFUlRFWF9BVFRSSUJVVEVfQUxJR05NRU5UID0gNDtcblxuZnVuY3Rpb24gYWxpZ24odmFsdWUsIGFsaWdubWVudCkge1xuICAgIGFsaWdubWVudCA9IGFsaWdubWVudCB8fCAxO1xuICAgIHZhciByZW1haW5kZXIgPSB2YWx1ZSAlIGFsaWdubWVudDtcbiAgICBpZiAoYWxpZ25tZW50ICE9PSAxICYmIHJlbWFpbmRlciAhPT0gMCkge1xuICAgICAgICB2YWx1ZSArPSAoYWxpZ25tZW50IC0gcmVtYWluZGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEJ1ZmZlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEJ1Y2tldCA9IHJlcXVpcmUoJy4vYnVja2V0Jyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENpcmNsZUJ1Y2tldDtcblxudmFyIEVYVEVOVCA9IDQwOTY7XG5cbi8qKlxuICogQ2lyY2xlcyBhcmUgcmVwcmVzZW50ZWQgYnkgdHdvIHRyaWFuZ2xlcy5cbiAqXG4gKiBFYWNoIGNvcm5lciBoYXMgYSBwb3MgdGhhdCBpcyB0aGUgY2VudGVyIG9mIHRoZSBjaXJjbGUgYW5kIGFuIGV4dHJ1c2lvblxuICogdmVjdG9yIHRoYXQgaXMgd2hlcmUgaXQgcG9pbnRzLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gQ2lyY2xlQnVja2V0KCkge1xuICAgIEJ1Y2tldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5DaXJjbGVCdWNrZXQucHJvdG90eXBlID0gdXRpbC5pbmhlcml0KEJ1Y2tldCwge30pO1xuXG5DaXJjbGVCdWNrZXQucHJvdG90eXBlLnNoYWRlcnMgPSB7XG4gICAgY2lyY2xlOiB7XG4gICAgICAgIHZlcnRleEJ1ZmZlcjogdHJ1ZSxcbiAgICAgICAgZWxlbWVudEJ1ZmZlcjogdHJ1ZSxcblxuICAgICAgICBhdHRyaWJ1dGVBcmdzOiBbJ3gnLCAneScsICdleHRydWRlWCcsICdleHRydWRlWSddLFxuXG4gICAgICAgIGF0dHJpYnV0ZXM6IFt7XG4gICAgICAgICAgICBuYW1lOiAncG9zJyxcbiAgICAgICAgICAgIGNvbXBvbmVudHM6IDIsXG4gICAgICAgICAgICB0eXBlOiBCdWNrZXQuQXR0cmlidXRlVHlwZS5TSE9SVCxcbiAgICAgICAgICAgIHZhbHVlOiBbXG4gICAgICAgICAgICAgICAgJyh4ICogMikgKyAoKGV4dHJ1ZGVYICsgMSkgLyAyKScsXG4gICAgICAgICAgICAgICAgJyh5ICogMikgKyAoKGV4dHJ1ZGVZICsgMSkgLyAyKSdcbiAgICAgICAgICAgIF1cbiAgICAgICAgfV1cbiAgICB9XG59O1xuXG5DaXJjbGVCdWNrZXQucHJvdG90eXBlLmFkZEZlYXR1cmUgPSBmdW5jdGlvbihmZWF0dXJlKSB7XG5cbiAgICB2YXIgZ2VvbWV0cmllcyA9IGZlYXR1cmUubG9hZEdlb21ldHJ5KClbMF07XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBnZW9tZXRyaWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBncm91cCA9IHRoaXMubWFrZVJvb21Gb3IoJ2NpcmNsZScsIDQpO1xuXG4gICAgICAgIHZhciB4ID0gZ2VvbWV0cmllc1tqXS54O1xuICAgICAgICB2YXIgeSA9IGdlb21ldHJpZXNbal0ueTtcblxuICAgICAgICAvLyBEbyBub3QgaW5jbHVkZSBwb2ludHMgdGhhdCBhcmUgb3V0c2lkZSB0aGUgdGlsZSBib3VuZGFyaWVzLlxuICAgICAgICBpZiAoeCA8IDAgfHwgeCA+PSBFWFRFTlQgfHwgeSA8IDAgfHwgeSA+PSBFWFRFTlQpIGNvbnRpbnVlO1xuXG4gICAgICAgIC8vIHRoaXMgZ2VvbWV0cnkgd2lsbCBiZSBvZiB0aGUgUG9pbnQgdHlwZSwgYW5kIHdlJ2xsIGRlcml2ZVxuICAgICAgICAvLyB0d28gdHJpYW5nbGVzIGZyb20gaXQuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkFxuICAgICAgICAvLyDilIIgMyAgICAgMiDilIJcbiAgICAgICAgLy8g4pSCICAgICAgICAg4pSCXG4gICAgICAgIC8vIOKUgiAwICAgICAxIOKUglxuICAgICAgICAvLyDilJTilIDilIDilIDilIDilIDilIDilIDilIDilIDilJhcblxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmFkZENpcmNsZVZlcnRleCh4LCB5LCAtMSwgLTEpIC0gZ3JvdXAudmVydGV4U3RhcnRJbmRleDtcbiAgICAgICAgdGhpcy5hZGRDaXJjbGVWZXJ0ZXgoeCwgeSwgMSwgLTEpO1xuICAgICAgICB0aGlzLmFkZENpcmNsZVZlcnRleCh4LCB5LCAxLCAxKTtcbiAgICAgICAgdGhpcy5hZGRDaXJjbGVWZXJ0ZXgoeCwgeSwgLTEsIDEpO1xuICAgICAgICBncm91cC52ZXJ0ZXhMZW5ndGggKz0gNDtcblxuICAgICAgICB0aGlzLmFkZENpcmNsZUVsZW1lbnQoaW5kZXgsIGluZGV4ICsgMSwgaW5kZXggKyAyKTtcbiAgICAgICAgdGhpcy5hZGRDaXJjbGVFbGVtZW50KGluZGV4LCBpbmRleCArIDMsIGluZGV4ICsgMik7XG4gICAgICAgIGdyb3VwLmVsZW1lbnRMZW5ndGggKz0gMjtcbiAgICB9XG5cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gRWxlbWVudEdyb3VwcztcblxuZnVuY3Rpb24gRWxlbWVudEdyb3Vwcyh2ZXJ0ZXhCdWZmZXIsIGVsZW1lbnRCdWZmZXIsIHNlY29uZEVsZW1lbnRCdWZmZXIpIHtcblxuICAgIHRoaXMudmVydGV4QnVmZmVyID0gdmVydGV4QnVmZmVyO1xuICAgIHRoaXMuZWxlbWVudEJ1ZmZlciA9IGVsZW1lbnRCdWZmZXI7XG4gICAgdGhpcy5zZWNvbmRFbGVtZW50QnVmZmVyID0gc2Vjb25kRWxlbWVudEJ1ZmZlcjtcbiAgICB0aGlzLmdyb3VwcyA9IFtdO1xufVxuXG5FbGVtZW50R3JvdXBzLnByb3RvdHlwZS5tYWtlUm9vbUZvciA9IGZ1bmN0aW9uKG51bVZlcnRpY2VzKSB7XG4gICAgaWYgKCF0aGlzLmN1cnJlbnQgfHwgdGhpcy5jdXJyZW50LnZlcnRleExlbmd0aCArIG51bVZlcnRpY2VzID4gNjU1MzUpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gbmV3IEVsZW1lbnRHcm91cCh0aGlzLnZlcnRleEJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50QnVmZmVyICYmIHRoaXMuZWxlbWVudEJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICAgICAgICAgdGhpcy5zZWNvbmRFbGVtZW50QnVmZmVyICYmIHRoaXMuc2Vjb25kRWxlbWVudEJ1ZmZlci5sZW5ndGgpO1xuICAgICAgICB0aGlzLmdyb3Vwcy5wdXNoKHRoaXMuY3VycmVudCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmN1cnJlbnQ7XG59O1xuXG5mdW5jdGlvbiBFbGVtZW50R3JvdXAodmVydGV4U3RhcnRJbmRleCwgZWxlbWVudFN0YXJ0SW5kZXgsIHNlY29uZEVsZW1lbnRTdGFydEluZGV4KSB7XG4gICAgLy8gdGhlIG9mZnNldCBpbnRvIHRoZSB2ZXJ0ZXggYnVmZmVyIG9mIHRoZSBmaXJzdCB2ZXJ0ZXggaW4gdGhpcyBncm91cFxuICAgIHRoaXMudmVydGV4U3RhcnRJbmRleCA9IHZlcnRleFN0YXJ0SW5kZXg7XG4gICAgdGhpcy5lbGVtZW50U3RhcnRJbmRleCA9IGVsZW1lbnRTdGFydEluZGV4O1xuICAgIHRoaXMuc2Vjb25kRWxlbWVudFN0YXJ0SW5kZXggPSBzZWNvbmRFbGVtZW50U3RhcnRJbmRleDtcbiAgICB0aGlzLmVsZW1lbnRMZW5ndGggPSAwO1xuICAgIHRoaXMudmVydGV4TGVuZ3RoID0gMDtcbiAgICB0aGlzLnNlY29uZEVsZW1lbnRMZW5ndGggPSAwO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmJ1c2ggPSByZXF1aXJlKCdyYnVzaCcpO1xudmFyIFBvaW50ID0gcmVxdWlyZSgncG9pbnQtZ2VvbWV0cnknKTtcbnZhciB2dCA9IHJlcXVpcmUoJ3ZlY3Rvci10aWxlJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZlYXR1cmVUcmVlO1xuXG5mdW5jdGlvbiBGZWF0dXJlVHJlZShjb29yZCwgb3ZlcnNjYWxpbmcpIHtcbiAgICB0aGlzLnggPSBjb29yZC54O1xuICAgIHRoaXMueSA9IGNvb3JkLnk7XG4gICAgdGhpcy56ID0gY29vcmQueiAtIE1hdGgubG9nKG92ZXJzY2FsaW5nKSAvIE1hdGguTE4yO1xuICAgIHRoaXMucnRyZWUgPSByYnVzaCg5KTtcbiAgICB0aGlzLnRvQmVJbnNlcnRlZCA9IFtdO1xufVxuXG5GZWF0dXJlVHJlZS5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24oYmJveCwgbGF5ZXJzLCBmZWF0dXJlKSB7XG4gICAgYmJveC5sYXllcnMgPSBsYXllcnM7XG4gICAgYmJveC5mZWF0dXJlID0gZmVhdHVyZTtcbiAgICB0aGlzLnRvQmVJbnNlcnRlZC5wdXNoKGJib3gpO1xufTtcblxuLy8gYnVsayBpbnNlcnQgaW50byB0cmVlXG5GZWF0dXJlVHJlZS5wcm90b3R5cGUuX2xvYWQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJ0cmVlLmxvYWQodGhpcy50b0JlSW5zZXJ0ZWQpO1xuICAgIHRoaXMudG9CZUluc2VydGVkID0gW107XG59O1xuXG4vLyBGaW5kcyBmZWF0dXJlcyBpbiB0aGlzIHRpbGUgYXQgYSBwYXJ0aWN1bGFyIHBvc2l0aW9uLlxuRmVhdHVyZVRyZWUucHJvdG90eXBlLnF1ZXJ5ID0gZnVuY3Rpb24oYXJncywgY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy50b0JlSW5zZXJ0ZWQubGVuZ3RoKSB0aGlzLl9sb2FkKCk7XG5cbiAgICB2YXIgcGFyYW1zID0gYXJncy5wYXJhbXMgfHwge30sXG4gICAgICAgIHggPSBhcmdzLngsXG4gICAgICAgIHkgPSBhcmdzLnksXG4gICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgdmFyIHJhZGl1cywgYm91bmRzO1xuICAgIGlmICh0eXBlb2YgeCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIGEgcG9pbnQgKG9yIHBvaW50K3JhZGl1cykgcXVlcnlcbiAgICAgICAgcmFkaXVzID0gKHBhcmFtcy5yYWRpdXMgfHwgMCkgKiAoYXJncy50aWxlRXh0ZW50IHx8IDQwOTYpIC8gYXJncy5zY2FsZTtcbiAgICAgICAgYm91bmRzID0gW3ggLSByYWRpdXMsIHkgLSByYWRpdXMsIHggKyByYWRpdXMsIHkgKyByYWRpdXNdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGEgcmVjdGFuZ2xlIHF1ZXJ5XG4gICAgICAgIGJvdW5kcyA9IFsgYXJncy5taW5YLCBhcmdzLm1pblksIGFyZ3MubWF4WCwgYXJncy5tYXhZIF07XG4gICAgfVxuXG4gICAgdmFyIG1hdGNoaW5nID0gdGhpcy5ydHJlZS5zZWFyY2goYm91bmRzKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hdGNoaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBmZWF0dXJlID0gbWF0Y2hpbmdbaV0uZmVhdHVyZSxcbiAgICAgICAgICAgIGxheWVycyA9IG1hdGNoaW5nW2ldLmxheWVycyxcbiAgICAgICAgICAgIHR5cGUgPSB2dC5WZWN0b3JUaWxlRmVhdHVyZS50eXBlc1tmZWF0dXJlLnR5cGVdO1xuXG4gICAgICAgIGlmIChwYXJhbXMuJHR5cGUgJiYgdHlwZSAhPT0gcGFyYW1zLiR0eXBlKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmIChyYWRpdXMgJiYgIWdlb21ldHJ5Q29udGFpbnNQb2ludChmZWF0dXJlLmxvYWRHZW9tZXRyeSgpLCB0eXBlLCBuZXcgUG9pbnQoeCwgeSksIHJhZGl1cykpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgZWxzZSBpZiAoIWdlb21ldHJ5SW50ZXJzZWN0c0JveChmZWF0dXJlLmxvYWRHZW9tZXRyeSgpLCB0eXBlLCBib3VuZHMpKVxuICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgdmFyIGdlb0pTT04gPSBmZWF0dXJlLnRvR2VvSlNPTih0aGlzLngsIHRoaXMueSwgdGhpcy56KTtcblxuICAgICAgICBpZiAoIXBhcmFtcy5pbmNsdWRlR2VvbWV0cnkpIHtcbiAgICAgICAgICAgIGdlb0pTT04uZ2VvbWV0cnkgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCBsYXllcnMubGVuZ3RoOyBsKyspIHtcbiAgICAgICAgICAgIHZhciBsYXllciA9IGxheWVyc1tsXTtcblxuICAgICAgICAgICAgaWYgKHBhcmFtcy5sYXllcklkcyAmJiBwYXJhbXMubGF5ZXJJZHMuaW5kZXhPZihsYXllcikgPCAwKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICByZXN1bHQucHVzaCh1dGlsLmV4dGVuZCh7bGF5ZXI6IGxheWVyfSwgZ2VvSlNPTikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdCk7XG59O1xuXG5mdW5jdGlvbiBnZW9tZXRyeUludGVyc2VjdHNCb3gocmluZ3MsIHR5cGUsIGJvdW5kcykge1xuICAgIHJldHVybiB0eXBlID09PSAnUG9pbnQnID8gcG9pbnRJbnRlcnNlY3RzQm94KHJpbmdzLCBib3VuZHMpIDpcbiAgICAgICAgICAgdHlwZSA9PT0gJ0xpbmVTdHJpbmcnID8gbGluZUludGVyc2VjdHNCb3gocmluZ3MsIGJvdW5kcykgOlxuICAgICAgICAgICB0eXBlID09PSAnUG9seWdvbicgPyBwb2x5SW50ZXJzZWN0c0JveChyaW5ncywgYm91bmRzKSB8fCBsaW5lSW50ZXJzZWN0c0JveChyaW5ncywgYm91bmRzKSA6IGZhbHNlO1xufVxuXG4vLyBUZXN0cyB3aGV0aGVyIGFueSBvZiB0aGUgZm91ciBjb3JuZXJzIG9mIHRoZSBiYm94IGFyZSBjb250YWluZWQgaW4gdGhlXG4vLyBpbnRlcmlvciBvZiB0aGUgcG9seWdvbi4gIE90aGVyd2lzZSwgZGVmZXJzIHRvIGxpbmVJbnRlcnNlY3RzQm94LlxuZnVuY3Rpb24gcG9seUludGVyc2VjdHNCb3gocmluZ3MsIGJvdW5kcykge1xuICAgIGlmIChwb2x5Q29udGFpbnNQb2ludChyaW5ncywgbmV3IFBvaW50KGJvdW5kc1swXSwgYm91bmRzWzFdKSkgfHxcbiAgICAgICAgcG9seUNvbnRhaW5zUG9pbnQocmluZ3MsIG5ldyBQb2ludChib3VuZHNbMF0sIGJvdW5kc1szXSkpIHx8XG4gICAgICAgIHBvbHlDb250YWluc1BvaW50KHJpbmdzLCBuZXcgUG9pbnQoYm91bmRzWzJdLCBib3VuZHNbMV0pKSB8fFxuICAgICAgICBwb2x5Q29udGFpbnNQb2ludChyaW5ncywgbmV3IFBvaW50KGJvdW5kc1syXSwgYm91bmRzWzNdKSkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgcmV0dXJuIGxpbmVJbnRlcnNlY3RzQm94KHJpbmdzLCBib3VuZHMpO1xufVxuXG4vLyBPbmx5IG5lZWRzIHRvIGNvdmVyIHRoZSBjYXNlIHdoZXJlIHRoZSBsaW5lIGNyb3NzZXMgdGhlIGJib3ggYm91bmRhcnkuXG4vLyBPdGhlcndpc2UsIHBvaW50SW50ZXJzZWN0c0JveCBzaG91bGQgaGF2ZSB1cyBjb3ZlcmVkLlxuZnVuY3Rpb24gbGluZUludGVyc2VjdHNCb3gocmluZ3MsIGJvdW5kcykge1xuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgcmluZ3MubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdmFyIHJpbmcgPSByaW5nc1trXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSByaW5nLmxlbmd0aCAtIDE7IGkgPCByaW5nLmxlbmd0aDsgaiA9IGkrKykge1xuICAgICAgICAgICAgdmFyIHAwID0gcmluZ1tpXTtcbiAgICAgICAgICAgIHZhciBwMSA9IHJpbmdbal07XG5cbiAgICAgICAgICAgIC8vIGludmVydCB0aGUgc2VnbWVudCBzbyBhcyB0byByZXVzZSBzZWdtZW50Q3Jvc3Nlc0hvcml6b250YWwgZm9yXG4gICAgICAgICAgICAvLyBjaGVja2luZyB3aGV0aGVyIGl0IGNyb3NzZXMgdGhlIHZlcnRpY2FsIHNpZGVzIG9mIHRoZSBiYm94LlxuICAgICAgICAgICAgdmFyIGkwID0gbmV3IFBvaW50KHAwLnksIHAwLngpO1xuICAgICAgICAgICAgdmFyIGkxID0gbmV3IFBvaW50KHAxLnksIHAxLngpO1xuXG4gICAgICAgICAgICBpZiAoc2VnbWVudENyb3NzZXNIb3Jpem9udGFsKHAwLCBwMSwgYm91bmRzWzBdLCBib3VuZHNbMl0sIGJvdW5kc1sxXSkgfHxcbiAgICAgICAgICAgICAgICBzZWdtZW50Q3Jvc3Nlc0hvcml6b250YWwocDAsIHAxLCBib3VuZHNbMF0sIGJvdW5kc1syXSwgYm91bmRzWzNdKSB8fFxuICAgICAgICAgICAgICAgIHNlZ21lbnRDcm9zc2VzSG9yaXpvbnRhbChpMCwgaTEsIGJvdW5kc1sxXSwgYm91bmRzWzNdLCBib3VuZHNbMF0pIHx8XG4gICAgICAgICAgICAgICAgc2VnbWVudENyb3NzZXNIb3Jpem9udGFsKGkwLCBpMSwgYm91bmRzWzFdLCBib3VuZHNbM10sIGJvdW5kc1syXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcG9pbnRJbnRlcnNlY3RzQm94KHJpbmdzLCBib3VuZHMpO1xufVxuXG4vKlxuICogQW5zd2VyIHdoZXRoZXIgc2VnbWVudCBwMS1wMiBpbnRlcnNlY3RzIHdpdGggKHgxLCB5KS0oeDIsIHkpXG4gKiBBc3N1bWVzIHgyID49IHgxXG4gKi9cbmZ1bmN0aW9uIHNlZ21lbnRDcm9zc2VzSG9yaXpvbnRhbChwMCwgcDEsIHgxLCB4MiwgeSkge1xuICAgIGlmIChwMS55ID09PSBwMC55KVxuICAgICAgICByZXR1cm4gcDEueSA9PT0geSAmJlxuICAgICAgICAgICAgTWF0aC5taW4ocDAueCwgcDEueCkgPD0geDIgJiZcbiAgICAgICAgICAgIE1hdGgubWF4KHAwLngsIHAxLngpID49IHgxO1xuXG4gICAgdmFyIHIgPSAoeSAtIHAwLnkpIC8gKHAxLnkgLSBwMC55KTtcbiAgICB2YXIgeCA9IHAwLnggKyByICogKHAxLnggLSBwMC54KTtcbiAgICByZXR1cm4gKHggPj0geDEgJiYgeCA8PSB4MiAmJiByIDw9IDEgJiYgciA+PSAwKTtcbn1cblxuZnVuY3Rpb24gcG9pbnRJbnRlcnNlY3RzQm94KHJpbmdzLCBib3VuZHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciByaW5nID0gcmluZ3NbaV07XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmluZy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKHJpbmdbal0ueCA+PSBib3VuZHNbMF0gJiZcbiAgICAgICAgICAgICAgICByaW5nW2pdLnkgPj0gYm91bmRzWzFdICYmXG4gICAgICAgICAgICAgICAgcmluZ1tqXS54IDw9IGJvdW5kc1syXSAmJlxuICAgICAgICAgICAgICAgIHJpbmdbal0ueSA8PSBib3VuZHNbM10pIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2VvbWV0cnlDb250YWluc1BvaW50KHJpbmdzLCB0eXBlLCBwLCByYWRpdXMpIHtcbiAgICByZXR1cm4gdHlwZSA9PT0gJ1BvaW50JyA/IHBvaW50Q29udGFpbnNQb2ludChyaW5ncywgcCwgcmFkaXVzKSA6XG4gICAgICAgICAgIHR5cGUgPT09ICdMaW5lU3RyaW5nJyA/IGxpbmVDb250YWluc1BvaW50KHJpbmdzLCBwLCByYWRpdXMpIDpcbiAgICAgICAgICAgdHlwZSA9PT0gJ1BvbHlnb24nID8gcG9seUNvbnRhaW5zUG9pbnQocmluZ3MsIHApIHx8IGxpbmVDb250YWluc1BvaW50KHJpbmdzLCBwLCByYWRpdXMpIDogZmFsc2U7XG59XG5cbi8vIENvZGUgZnJvbSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNTAxNzI1LzMzMTM3OS5cbmZ1bmN0aW9uIGRpc3RUb1NlZ21lbnRTcXVhcmVkKHAsIHYsIHcpIHtcbiAgICB2YXIgbDIgPSB2LmRpc3RTcXIodyk7XG4gICAgaWYgKGwyID09PSAwKSByZXR1cm4gcC5kaXN0U3FyKHYpO1xuICAgIHZhciB0ID0gKChwLnggLSB2LngpICogKHcueCAtIHYueCkgKyAocC55IC0gdi55KSAqICh3LnkgLSB2LnkpKSAvIGwyO1xuICAgIGlmICh0IDwgMCkgcmV0dXJuIHAuZGlzdFNxcih2KTtcbiAgICBpZiAodCA+IDEpIHJldHVybiBwLmRpc3RTcXIodyk7XG4gICAgcmV0dXJuIHAuZGlzdFNxcih3LnN1Yih2KS5fbXVsdCh0KS5fYWRkKHYpKTtcbn1cblxuZnVuY3Rpb24gbGluZUNvbnRhaW5zUG9pbnQocmluZ3MsIHAsIHJhZGl1cykge1xuICAgIHZhciByID0gcmFkaXVzICogcmFkaXVzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByaW5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcmluZyA9IHJpbmdzW2ldO1xuICAgICAgICBmb3IgKHZhciBqID0gMTsgaiA8IHJpbmcubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIC8vIEZpbmQgbGluZSBzZWdtZW50cyB0aGF0IGhhdmUgYSBkaXN0YW5jZSA8PSByYWRpdXNeMiB0byBwXG4gICAgICAgICAgICAvLyBJbiB0aGF0IGNhc2UsIHdlIHRyZWF0IHRoZSBsaW5lIGFzIFwiY29udGFpbmluZyBwb2ludCBwXCIuXG4gICAgICAgICAgICB2YXIgdiA9IHJpbmdbaiAtIDFdLCB3ID0gcmluZ1tqXTtcbiAgICAgICAgICAgIGlmIChkaXN0VG9TZWdtZW50U3F1YXJlZChwLCB2LCB3KSA8IHIpIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLy8gcG9pbnQgaW4gcG9seWdvbiByYXkgY2FzdGluZyBhbGdvcml0aG1cbmZ1bmN0aW9uIHBvbHlDb250YWluc1BvaW50KHJpbmdzLCBwKSB7XG4gICAgdmFyIGMgPSBmYWxzZSxcbiAgICAgICAgcmluZywgcDEsIHAyO1xuXG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCByaW5ncy5sZW5ndGg7IGsrKykge1xuICAgICAgICByaW5nID0gcmluZ3Nba107XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gcmluZy5sZW5ndGggLSAxOyBpIDwgcmluZy5sZW5ndGg7IGogPSBpKyspIHtcbiAgICAgICAgICAgIHAxID0gcmluZ1tpXTtcbiAgICAgICAgICAgIHAyID0gcmluZ1tqXTtcbiAgICAgICAgICAgIGlmICgoKHAxLnkgPiBwLnkpICE9PSAocDIueSA+IHAueSkpICYmIChwLnggPCAocDIueCAtIHAxLngpICogKHAueSAtIHAxLnkpIC8gKHAyLnkgLSBwMS55KSArIHAxLngpKSB7XG4gICAgICAgICAgICAgICAgYyA9ICFjO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjO1xufVxuXG5mdW5jdGlvbiBwb2ludENvbnRhaW5zUG9pbnQocmluZ3MsIHAsIHJhZGl1cykge1xuICAgIHZhciByID0gcmFkaXVzICogcmFkaXVzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByaW5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcmluZyA9IHJpbmdzW2ldO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJpbmcubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChyaW5nW2pdLmRpc3RTcXIocCkgPD0gcikgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQnVja2V0ID0gcmVxdWlyZSgnLi9idWNrZXQnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gRmlsbEJ1Y2tldDtcblxuZnVuY3Rpb24gRmlsbEJ1Y2tldCgpIHtcbiAgICBCdWNrZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuRmlsbEJ1Y2tldC5wcm90b3R5cGUgPSB1dGlsLmluaGVyaXQoQnVja2V0LCB7fSk7XG5cbkZpbGxCdWNrZXQucHJvdG90eXBlLnNoYWRlcnMgPSB7XG4gICAgZmlsbDoge1xuICAgICAgICB2ZXJ0ZXhCdWZmZXI6IHRydWUsXG4gICAgICAgIGVsZW1lbnRCdWZmZXI6IHRydWUsXG4gICAgICAgIHNlY29uZEVsZW1lbnRCdWZmZXI6IHRydWUsXG4gICAgICAgIHNlY29uZEVsZW1lbnRCdWZmZXJDb21wb25lbnRzOiAyLFxuXG4gICAgICAgIGF0dHJpYnV0ZUFyZ3M6IFsneCcsICd5J10sXG5cbiAgICAgICAgYXR0cmlidXRlczogW3tcbiAgICAgICAgICAgIG5hbWU6ICdwb3MnLFxuICAgICAgICAgICAgY29tcG9uZW50czogMixcbiAgICAgICAgICAgIHR5cGU6IEJ1Y2tldC5BdHRyaWJ1dGVUeXBlLlNIT1JULFxuICAgICAgICAgICAgdmFsdWU6IFsneCcsICd5J11cbiAgICAgICAgfV1cbiAgICB9XG59O1xuXG5GaWxsQnVja2V0LnByb3RvdHlwZS5hZGRGZWF0dXJlID0gZnVuY3Rpb24oZmVhdHVyZSkge1xuICAgIHZhciBsaW5lcyA9IGZlYXR1cmUubG9hZEdlb21ldHJ5KCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmFkZEZpbGwobGluZXNbaV0pO1xuICAgIH1cbn07XG5cbkZpbGxCdWNrZXQucHJvdG90eXBlLmFkZEZpbGwgPSBmdW5jdGlvbih2ZXJ0aWNlcykge1xuICAgIGlmICh2ZXJ0aWNlcy5sZW5ndGggPCAzKSB7XG4gICAgICAgIC8vY29uc29sZS53YXJuKCdhIGZpbGwgbXVzdCBoYXZlIGF0IGxlYXN0IHRocmVlIHZlcnRpY2VzJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDYWxjdWxhdGUgdGhlIHRvdGFsIG51bWJlciBvZiB2ZXJ0aWNlcyB3ZSdyZSBnb2luZyB0byBwcm9kdWNlIHNvIHRoYXQgd2VcbiAgICAvLyBjYW4gcmVzaXplIHRoZSBidWZmZXIgYmVmb3JlaGFuZCwgb3IgZGV0ZWN0IHdoZXRoZXIgdGhlIGN1cnJlbnQgbGluZVxuICAgIC8vIHdvbid0IGZpdCBpbnRvIHRoZSBidWZmZXIgYW55bW9yZS5cbiAgICAvLyBJbiBvcmRlciB0byBiZSBhYmxlIHRvIHVzZSB0aGUgdmVydGV4IGJ1ZmZlciBmb3IgZHJhd2luZyB0aGUgYW50aWFsaWFzZWRcbiAgICAvLyBvdXRsaW5lcywgd2Ugc2VwYXJhdGUgYWxsIHBvbHlnb24gdmVydGljZXMgd2l0aCBhIGRlZ2VuZXJhdGUgKG91dC1vZi1cbiAgICAvLyB2aWV3cGxhbmUpIHZlcnRleC5cblxuICAgIHZhciBsZW4gPSB2ZXJ0aWNlcy5sZW5ndGg7XG5cbiAgICAvLyBFeHBhbmQgdGhpcyBnZW9tZXRyeSBidWZmZXIgdG8gaG9sZCBhbGwgdGhlIHJlcXVpcmVkIHZlcnRpY2VzLlxuICAgIHZhciBncm91cCA9IHRoaXMubWFrZVJvb21Gb3IoJ2ZpbGwnLCBsZW4gKyAxKTtcblxuICAgIC8vIFdlJ3JlIGdlbmVyYXRpbmcgdHJpYW5nbGUgZmFucywgc28gd2UgYWx3YXlzIHN0YXJ0IHdpdGggdGhlIGZpcnN0IGNvb3JkaW5hdGUgaW4gdGhpcyBwb2x5Z29uLlxuICAgIHZhciBmaXJzdEluZGV4LCBwcmV2SW5kZXg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2ZXJ0aWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY3VycmVudFZlcnRleCA9IHZlcnRpY2VzW2ldO1xuXG4gICAgICAgIHZhciBjdXJyZW50SW5kZXggPSB0aGlzLmFkZEZpbGxWZXJ0ZXgoY3VycmVudFZlcnRleC54LCBjdXJyZW50VmVydGV4LnkpIC0gZ3JvdXAudmVydGV4U3RhcnRJbmRleDtcbiAgICAgICAgZ3JvdXAudmVydGV4TGVuZ3RoKys7XG4gICAgICAgIGlmIChpID09PSAwKSBmaXJzdEluZGV4ID0gY3VycmVudEluZGV4O1xuXG4gICAgICAgIC8vIE9ubHkgYWRkIHRyaWFuZ2xlcyB0aGF0IGhhdmUgZGlzdGluY3QgdmVydGljZXMuXG4gICAgICAgIGlmIChpID49IDIgJiYgKGN1cnJlbnRWZXJ0ZXgueCAhPT0gdmVydGljZXNbMF0ueCB8fCBjdXJyZW50VmVydGV4LnkgIT09IHZlcnRpY2VzWzBdLnkpKSB7XG4gICAgICAgICAgICB0aGlzLmFkZEZpbGxFbGVtZW50KGZpcnN0SW5kZXgsIHByZXZJbmRleCwgY3VycmVudEluZGV4KTtcbiAgICAgICAgICAgIGdyb3VwLmVsZW1lbnRMZW5ndGgrKztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpID49IDEpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRmlsbFNlY29uZEVsZW1lbnQocHJldkluZGV4LCBjdXJyZW50SW5kZXgpO1xuICAgICAgICAgICAgZ3JvdXAuc2Vjb25kRWxlbWVudExlbmd0aCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJldkluZGV4ID0gY3VycmVudEluZGV4O1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBCdWNrZXQgPSByZXF1aXJlKCcuL2J1Y2tldCcpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcblxuLy8gTk9URSBPTiBFWFRSVURFIFNDQUxFOlxuLy8gc2NhbGUgdGhlIGV4dHJ1c2lvbiB2ZWN0b3Igc28gdGhhdCB0aGUgbm9ybWFsIGxlbmd0aCBpcyB0aGlzIHZhbHVlLlxuLy8gY29udGFpbnMgdGhlIFwidGV4dHVyZVwiIG5vcm1hbHMgKC0xLi4xKS4gdGhpcyBpcyBkaXN0aW5jdCBmcm9tIHRoZSBleHRydWRlXG4vLyBub3JtYWxzIGZvciBsaW5lIGpvaW5zLCBiZWNhdXNlIHRoZSB4LXZhbHVlIHJlbWFpbnMgMCBmb3IgdGhlIHRleHR1cmVcbi8vIG5vcm1hbCBhcnJheSwgd2hpbGUgdGhlIGV4dHJ1ZGUgbm9ybWFsIGFjdHVhbGx5IG1vdmVzIHRoZSB2ZXJ0ZXggdG8gY3JlYXRlXG4vLyB0aGUgYWN1dGUvYmV2ZWxsZWQgbGluZSBqb2luLlxudmFyIEVYVFJVREVfU0NBTEUgPSA2MztcblxubW9kdWxlLmV4cG9ydHMgPSBMaW5lQnVja2V0O1xuXG5mdW5jdGlvbiBMaW5lQnVja2V0KCkge1xuICAgIEJ1Y2tldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5MaW5lQnVja2V0LnByb3RvdHlwZSA9IHV0aWwuaW5oZXJpdChCdWNrZXQsIHt9KTtcblxuTGluZUJ1Y2tldC5wcm90b3R5cGUuc2hhZGVycyA9IHtcbiAgICBsaW5lOiB7XG4gICAgICAgIHZlcnRleEJ1ZmZlcjogdHJ1ZSxcbiAgICAgICAgZWxlbWVudEJ1ZmZlcjogdHJ1ZSxcblxuICAgICAgICBhdHRyaWJ1dGVBcmdzOiBbJ3BvaW50JywgJ2V4dHJ1ZGUnLCAndHgnLCAndHknLCAnZGlyJywgJ2xpbmVzb2ZhciddLFxuXG4gICAgICAgIGF0dHJpYnV0ZXM6IFt7XG4gICAgICAgICAgICBuYW1lOiAncG9zJyxcbiAgICAgICAgICAgIGNvbXBvbmVudHM6IDIsXG4gICAgICAgICAgICB0eXBlOiBCdWNrZXQuQXR0cmlidXRlVHlwZS5TSE9SVCxcbiAgICAgICAgICAgIHZhbHVlOiBbXG4gICAgICAgICAgICAgICAgJyhwb2ludC54IDw8IDEpIHwgdHgnLFxuICAgICAgICAgICAgICAgICcocG9pbnQueSA8PCAxKSB8IHR5J1xuICAgICAgICAgICAgXVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiAnZGF0YScsXG4gICAgICAgICAgICBjb21wb25lbnRzOiA0LFxuICAgICAgICAgICAgdHlwZTogQnVja2V0LkF0dHJpYnV0ZVR5cGUuQllURSxcbiAgICAgICAgICAgIHZhbHVlOiBbXG4gICAgICAgICAgICAgICAgJ01hdGgucm91bmQoJyArIEVYVFJVREVfU0NBTEUgKyAnICogZXh0cnVkZS54KScsXG4gICAgICAgICAgICAgICAgJ01hdGgucm91bmQoJyArIEVYVFJVREVfU0NBTEUgKyAnICogZXh0cnVkZS55KScsXG5cbiAgICAgICAgICAgICAgICAvLyBFbmNvZGUgdGhlIC0xLzAvMSBkaXJlY3Rpb24gdmFsdWUgaW50byAuencgY29vcmRpbmF0ZXMgb2YgYV9kYXRhLCB3aGljaCBpcyBub3JtYWxseSBjb3ZlcmVkXG4gICAgICAgICAgICAgICAgLy8gYnkgbGluZXNvZmFyLCBzbyB3ZSBuZWVkIHRvIG1lcmdlIHRoZW0uXG4gICAgICAgICAgICAgICAgLy8gVGhlIHogY29tcG9uZW50J3MgZmlyc3QgYml0LCBhcyB3ZWxsIGFzIHRoZSBzaWduIGJpdCBpcyByZXNlcnZlZCBmb3IgdGhlIGRpcmVjdGlvbixcbiAgICAgICAgICAgICAgICAvLyBzbyB3ZSBuZWVkIHRvIHNoaWZ0IHRoZSBsaW5lc29mYXIuXG4gICAgICAgICAgICAgICAgJygoZGlyIDwgMCkgPyAtMSA6IDEpICogKChkaXIgPyAxIDogMCkgfCAoKGxpbmVzb2ZhciA8PCAxKSAmIDB4N0YpKScsXG4gICAgICAgICAgICAgICAgJyhsaW5lc29mYXIgPj4gNikgJiAweDdGJ1xuICAgICAgICAgICAgXVxuICAgICAgICB9XVxuICAgIH1cbn07XG5cbkxpbmVCdWNrZXQucHJvdG90eXBlLmFkZEZlYXR1cmUgPSBmdW5jdGlvbihmZWF0dXJlKSB7XG4gICAgdmFyIGxpbmVzID0gZmVhdHVyZS5sb2FkR2VvbWV0cnkoKTtcbiAgICB2YXIgbGF5b3V0UHJvcGVydGllcyA9IHRoaXMubGF5b3V0UHJvcGVydGllcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuYWRkTGluZShcbiAgICAgICAgICAgIGxpbmVzW2ldLFxuICAgICAgICAgICAgbGF5b3V0UHJvcGVydGllc1snbGluZS1qb2luJ10sXG4gICAgICAgICAgICBsYXlvdXRQcm9wZXJ0aWVzWydsaW5lLWNhcCddLFxuICAgICAgICAgICAgbGF5b3V0UHJvcGVydGllc1snbGluZS1taXRlci1saW1pdCddLFxuICAgICAgICAgICAgbGF5b3V0UHJvcGVydGllc1snbGluZS1yb3VuZC1saW1pdCddXG4gICAgICAgICk7XG4gICAgfVxufTtcblxuTGluZUJ1Y2tldC5wcm90b3R5cGUuYWRkTGluZSA9IGZ1bmN0aW9uKHZlcnRpY2VzLCBqb2luLCBjYXAsIG1pdGVyTGltaXQsIHJvdW5kTGltaXQpIHtcblxuICAgIHZhciBsZW4gPSB2ZXJ0aWNlcy5sZW5ndGg7XG4gICAgLy8gSWYgdGhlIGxpbmUgaGFzIGR1cGxpY2F0ZSB2ZXJ0aWNlcyBhdCB0aGUgZW5kLCBhZGp1c3QgbGVuZ3RoIHRvIHJlbW92ZSB0aGVtLlxuICAgIHdoaWxlIChsZW4gPiAyICYmIHZlcnRpY2VzW2xlbiAtIDFdLmVxdWFscyh2ZXJ0aWNlc1tsZW4gLSAyXSkpIHtcbiAgICAgICAgbGVuLS07XG4gICAgfVxuXG4gICAgaWYgKHZlcnRpY2VzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgLy9jb25zb2xlLndhcm4oJ2EgbGluZSBtdXN0IGhhdmUgYXQgbGVhc3QgdHdvIHZlcnRpY2VzJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoam9pbiA9PT0gJ2JldmVsJykgbWl0ZXJMaW1pdCA9IDEuMDU7XG5cbiAgICB2YXIgZmlyc3RWZXJ0ZXggPSB2ZXJ0aWNlc1swXSxcbiAgICAgICAgbGFzdFZlcnRleCA9IHZlcnRpY2VzW2xlbiAtIDFdLFxuICAgICAgICBjbG9zZWQgPSBmaXJzdFZlcnRleC5lcXVhbHMobGFzdFZlcnRleCk7XG5cbiAgICAvLyB3ZSBjb3VsZCBiZSBtb3JlIHByZWNpc2UsIGJ1dCBpdCB3b3VsZCBvbmx5IHNhdmUgYSBuZWdsaWdpYmxlIGFtb3VudCBvZiBzcGFjZVxuICAgIHRoaXMubWFrZVJvb21Gb3IoJ2xpbmUnLCBsZW4gKiAxMCk7XG5cbiAgICBpZiAobGVuID09PSAyICYmIGNsb3NlZCkge1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJ2EgbGluZSBtYXkgbm90IGhhdmUgY29pbmNpZGVudCBwb2ludHMnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBiZWdpbkNhcCA9IGNhcCxcbiAgICAgICAgZW5kQ2FwID0gY2xvc2VkID8gJ2J1dHQnIDogY2FwLFxuICAgICAgICBmbGlwID0gMSxcbiAgICAgICAgZGlzdGFuY2UgPSAwLFxuICAgICAgICBzdGFydE9mTGluZSA9IHRydWUsXG4gICAgICAgIGN1cnJlbnRWZXJ0ZXgsIHByZXZWZXJ0ZXgsIG5leHRWZXJ0ZXgsIHByZXZOb3JtYWwsIG5leHROb3JtYWwsIG9mZnNldEEsIG9mZnNldEI7XG5cbiAgICAvLyB0aGUgbGFzdCB0aHJlZSB2ZXJ0aWNlcyBhZGRlZFxuICAgIHRoaXMuZTEgPSB0aGlzLmUyID0gdGhpcy5lMyA9IC0xO1xuXG4gICAgaWYgKGNsb3NlZCkge1xuICAgICAgICBjdXJyZW50VmVydGV4ID0gdmVydGljZXNbbGVuIC0gMl07XG4gICAgICAgIG5leHROb3JtYWwgPSBmaXJzdFZlcnRleC5zdWIoY3VycmVudFZlcnRleCkuX3VuaXQoKS5fcGVycCgpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblxuICAgICAgICBuZXh0VmVydGV4ID0gY2xvc2VkICYmIGkgPT09IGxlbiAtIDEgP1xuICAgICAgICAgICAgdmVydGljZXNbMV0gOiAvLyBpZiB0aGUgbGluZSBpcyBjbG9zZWQsIHdlIHRyZWF0IHRoZSBsYXN0IHZlcnRleCBsaWtlIHRoZSBmaXJzdFxuICAgICAgICAgICAgdmVydGljZXNbaSArIDFdOyAvLyBqdXN0IHRoZSBuZXh0IHZlcnRleFxuXG4gICAgICAgIC8vIGlmIHR3byBjb25zZWN1dGl2ZSB2ZXJ0aWNlcyBleGlzdCwgc2tpcCB0aGUgY3VycmVudCBvbmVcbiAgICAgICAgaWYgKG5leHRWZXJ0ZXggJiYgdmVydGljZXNbaV0uZXF1YWxzKG5leHRWZXJ0ZXgpKSBjb250aW51ZTtcblxuICAgICAgICBpZiAobmV4dE5vcm1hbCkgcHJldk5vcm1hbCA9IG5leHROb3JtYWw7XG4gICAgICAgIGlmIChjdXJyZW50VmVydGV4KSBwcmV2VmVydGV4ID0gY3VycmVudFZlcnRleDtcblxuICAgICAgICBjdXJyZW50VmVydGV4ID0gdmVydGljZXNbaV07XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIGhvdyBmYXIgYWxvbmcgdGhlIGxpbmUgdGhlIGN1cnJlbnRWZXJ0ZXggaXNcbiAgICAgICAgaWYgKHByZXZWZXJ0ZXgpIGRpc3RhbmNlICs9IGN1cnJlbnRWZXJ0ZXguZGlzdChwcmV2VmVydGV4KTtcblxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIG5vcm1hbCB0b3dhcmRzIHRoZSBuZXh0IHZlcnRleCBpbiB0aGlzIGxpbmUuIEluIGNhc2VcbiAgICAgICAgLy8gdGhlcmUgaXMgbm8gbmV4dCB2ZXJ0ZXgsIHByZXRlbmQgdGhhdCB0aGUgbGluZSBpcyBjb250aW51aW5nIHN0cmFpZ2h0LFxuICAgICAgICAvLyBtZWFuaW5nIHRoYXQgd2UgYXJlIGp1c3QgdXNpbmcgdGhlIHByZXZpb3VzIG5vcm1hbC5cbiAgICAgICAgbmV4dE5vcm1hbCA9IG5leHRWZXJ0ZXggPyBuZXh0VmVydGV4LnN1YihjdXJyZW50VmVydGV4KS5fdW5pdCgpLl9wZXJwKCkgOiBwcmV2Tm9ybWFsO1xuXG4gICAgICAgIC8vIElmIHdlIHN0aWxsIGRvbid0IGhhdmUgYSBwcmV2aW91cyBub3JtYWwsIHRoaXMgaXMgdGhlIGJlZ2lubmluZyBvZiBhXG4gICAgICAgIC8vIG5vbi1jbG9zZWQgbGluZSwgc28gd2UncmUgZG9pbmcgYSBzdHJhaWdodCBcImpvaW5cIi5cbiAgICAgICAgcHJldk5vcm1hbCA9IHByZXZOb3JtYWwgfHwgbmV4dE5vcm1hbDtcblxuICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIG5vcm1hbCBvZiB0aGUgam9pbiBleHRydXNpb24uIEl0IGlzIHRoZSBhbmdsZSBiaXNlY3RvclxuICAgICAgICAvLyBvZiB0aGUgc2VnbWVudHMgYmV0d2VlbiB0aGUgcHJldmlvdXMgbGluZSBhbmQgdGhlIG5leHQgbGluZS5cbiAgICAgICAgdmFyIGpvaW5Ob3JtYWwgPSBwcmV2Tm9ybWFsLmFkZChuZXh0Tm9ybWFsKS5fdW5pdCgpO1xuXG4gICAgICAgIC8qICBqb2luTm9ybWFsICAgICBwcmV2Tm9ybWFsXG4gICAgICAgICAqICAgICAgICAgICAgIOKGliAgICAgIOKGkVxuICAgICAgICAgKiAgICAgICAgICAgICAgICAuX19fX19fX18uIHByZXZWZXJ0ZXhcbiAgICAgICAgICogICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiBuZXh0Tm9ybWFsICDihpAgIHwgIGN1cnJlbnRWZXJ0ZXhcbiAgICAgICAgICogICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgbmV4dFZlcnRleCAhXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgbGVuZ3RoIG9mIHRoZSBtaXRlciAodGhlIHJhdGlvIG9mIHRoZSBtaXRlciB0byB0aGUgd2lkdGgpLlxuICAgICAgICAvLyBGaW5kIHRoZSBjb3NpbmUgb2YgdGhlIGFuZ2xlIGJldHdlZW4gdGhlIG5leHQgYW5kIGpvaW4gbm9ybWFsc1xuICAgICAgICAvLyB1c2luZyBkb3QgcHJvZHVjdC4gVGhlIGludmVyc2Ugb2YgdGhhdCBpcyB0aGUgbWl0ZXIgbGVuZ3RoLlxuICAgICAgICB2YXIgY29zSGFsZkFuZ2xlID0gam9pbk5vcm1hbC54ICogbmV4dE5vcm1hbC54ICsgam9pbk5vcm1hbC55ICogbmV4dE5vcm1hbC55O1xuICAgICAgICB2YXIgbWl0ZXJMZW5ndGggPSAxIC8gY29zSGFsZkFuZ2xlO1xuXG4gICAgICAgIC8vIFRoZSBqb2luIGlmIGEgbWlkZGxlIHZlcnRleCwgb3RoZXJ3aXNlIHRoZSBjYXAuXG4gICAgICAgIHZhciBtaWRkbGVWZXJ0ZXggPSBwcmV2VmVydGV4ICYmIG5leHRWZXJ0ZXg7XG4gICAgICAgIHZhciBjdXJyZW50Sm9pbiA9IG1pZGRsZVZlcnRleCA/IGpvaW4gOiBuZXh0VmVydGV4ID8gYmVnaW5DYXAgOiBlbmRDYXA7XG5cbiAgICAgICAgaWYgKG1pZGRsZVZlcnRleCAmJiBjdXJyZW50Sm9pbiA9PT0gJ3JvdW5kJykge1xuICAgICAgICAgICAgaWYgKG1pdGVyTGVuZ3RoIDwgcm91bmRMaW1pdCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRKb2luID0gJ21pdGVyJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWl0ZXJMZW5ndGggPD0gMikge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRKb2luID0gJ2Zha2Vyb3VuZCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3VycmVudEpvaW4gPT09ICdtaXRlcicgJiYgbWl0ZXJMZW5ndGggPiBtaXRlckxpbWl0KSB7XG4gICAgICAgICAgICBjdXJyZW50Sm9pbiA9ICdiZXZlbCc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3VycmVudEpvaW4gPT09ICdiZXZlbCcpIHtcbiAgICAgICAgICAgIC8vIFRoZSBtYXhpbXVtIGV4dHJ1ZGUgbGVuZ3RoIGlzIDEyOCAvIDYzID0gMiB0aW1lcyB0aGUgd2lkdGggb2YgdGhlIGxpbmVcbiAgICAgICAgICAgIC8vIHNvIGlmIG1pdGVyTGVuZ3RoID49IDIgd2UgbmVlZCB0byBkcmF3IGEgZGlmZmVyZW50IHR5cGUgb2YgYmV2ZWwgd2hlcmUuXG4gICAgICAgICAgICBpZiAobWl0ZXJMZW5ndGggPiAyKSBjdXJyZW50Sm9pbiA9ICdmbGlwYmV2ZWwnO1xuXG4gICAgICAgICAgICAvLyBJZiB0aGUgbWl0ZXJMZW5ndGggaXMgcmVhbGx5IHNtYWxsIGFuZCB0aGUgbGluZSBiZXZlbCB3b3VsZG4ndCBiZSB2aXNpYmxlLFxuICAgICAgICAgICAgLy8ganVzdCBkcmF3IGEgbWl0ZXIgam9pbiB0byBzYXZlIGEgdHJpYW5nbGUuXG4gICAgICAgICAgICBpZiAobWl0ZXJMZW5ndGggPCBtaXRlckxpbWl0KSBjdXJyZW50Sm9pbiA9ICdtaXRlcic7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3VycmVudEpvaW4gPT09ICdtaXRlcicpIHtcblxuICAgICAgICAgICAgam9pbk5vcm1hbC5fbXVsdChtaXRlckxlbmd0aCk7XG4gICAgICAgICAgICB0aGlzLmFkZEN1cnJlbnRWZXJ0ZXgoY3VycmVudFZlcnRleCwgZmxpcCwgZGlzdGFuY2UsIGpvaW5Ob3JtYWwsIDAsIDAsIGZhbHNlKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRKb2luID09PSAnZmxpcGJldmVsJykge1xuICAgICAgICAgICAgLy8gbWl0ZXIgaXMgdG9vIGJpZywgZmxpcCB0aGUgZGlyZWN0aW9uIHRvIG1ha2UgYSBiZXZlbGVkIGpvaW5cblxuICAgICAgICAgICAgaWYgKG1pdGVyTGVuZ3RoID4gMTAwKSB7XG4gICAgICAgICAgICAgICAgLy8gQWxtb3N0IHBhcmFsbGVsIGxpbmVzXG4gICAgICAgICAgICAgICAgam9pbk5vcm1hbCA9IG5leHROb3JtYWwuY2xvbmUoKTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgZGlyZWN0aW9uID0gcHJldk5vcm1hbC54ICogbmV4dE5vcm1hbC55IC0gcHJldk5vcm1hbC55ICogbmV4dE5vcm1hbC54ID4gMCA/IC0xIDogMTtcbiAgICAgICAgICAgICAgICB2YXIgYmV2ZWxMZW5ndGggPSBtaXRlckxlbmd0aCAqIHByZXZOb3JtYWwuYWRkKG5leHROb3JtYWwpLm1hZygpIC8gcHJldk5vcm1hbC5zdWIobmV4dE5vcm1hbCkubWFnKCk7XG4gICAgICAgICAgICAgICAgam9pbk5vcm1hbC5fcGVycCgpLl9tdWx0KGJldmVsTGVuZ3RoICogZGlyZWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYWRkQ3VycmVudFZlcnRleChjdXJyZW50VmVydGV4LCBmbGlwLCBkaXN0YW5jZSwgam9pbk5vcm1hbCwgMCwgMCwgZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5hZGRDdXJyZW50VmVydGV4KGN1cnJlbnRWZXJ0ZXgsIC1mbGlwLCBkaXN0YW5jZSwgam9pbk5vcm1hbCwgMCwgMCwgZmFsc2UpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY3VycmVudEpvaW4gPT09ICdiZXZlbCcgfHwgY3VycmVudEpvaW4gPT09ICdmYWtlcm91bmQnKSB7XG4gICAgICAgICAgICB2YXIgbGluZVR1cm5zTGVmdCA9IGZsaXAgKiAocHJldk5vcm1hbC54ICogbmV4dE5vcm1hbC55IC0gcHJldk5vcm1hbC55ICogbmV4dE5vcm1hbC54KSA+IDA7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gLU1hdGguc3FydChtaXRlckxlbmd0aCAqIG1pdGVyTGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICBpZiAobGluZVR1cm5zTGVmdCkge1xuICAgICAgICAgICAgICAgIG9mZnNldEIgPSAwO1xuICAgICAgICAgICAgICAgIG9mZnNldEEgPSBvZmZzZXQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG9mZnNldEEgPSAwO1xuICAgICAgICAgICAgICAgIG9mZnNldEIgPSBvZmZzZXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENsb3NlIHByZXZpb3VzIHNlZ21lbnQgd2l0aCBhIGJldmVsXG4gICAgICAgICAgICBpZiAoIXN0YXJ0T2ZMaW5lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRDdXJyZW50VmVydGV4KGN1cnJlbnRWZXJ0ZXgsIGZsaXAsIGRpc3RhbmNlLCBwcmV2Tm9ybWFsLCBvZmZzZXRBLCBvZmZzZXRCLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjdXJyZW50Sm9pbiA9PT0gJ2Zha2Vyb3VuZCcpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgam9pbiBhbmdsZSBpcyBzaGFycCBlbm91Z2ggdGhhdCBhIHJvdW5kIGpvaW4gd291bGQgYmUgdmlzaWJsZS5cbiAgICAgICAgICAgICAgICAvLyBCZXZlbCBqb2lucyBmaWxsIHRoZSBnYXAgYmV0d2VlbiBzZWdtZW50cyB3aXRoIGEgc2luZ2xlIHBpZSBzbGljZSB0cmlhbmdsZS5cbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSByb3VuZCBqb2luIGJ5IGFkZGluZyBtdWx0aXBsZSBwaWUgc2xpY2VzLiBUaGUgam9pbiBpc24ndCBhY3R1YWxseSByb3VuZCwgYnV0XG4gICAgICAgICAgICAgICAgLy8gaXQgbG9va3MgbGlrZSBpdCBpcyBhdCB0aGUgc2l6ZXMgd2UgcmVuZGVyIGxpbmVzIGF0LlxuXG4gICAgICAgICAgICAgICAgLy8gQWRkIG1vcmUgdHJpYW5nbGVzIGZvciBzaGFycGVyIGFuZ2xlcy5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIG1hdGggaXMganVzdCBhIGdvb2QgZW5vdWdoIGFwcHJveGltYXRpb24uIEl0IGlzbid0IFwiY29ycmVjdFwiLlxuICAgICAgICAgICAgICAgIHZhciBuID0gTWF0aC5mbG9vcigoMC41IC0gKGNvc0hhbGZBbmdsZSAtIDAuNSkpICogOCk7XG4gICAgICAgICAgICAgICAgdmFyIGFwcHJveEZyYWN0aW9uYWxKb2luTm9ybWFsO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbSA9IDA7IG0gPCBuOyBtKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYXBwcm94RnJhY3Rpb25hbEpvaW5Ob3JtYWwgPSBuZXh0Tm9ybWFsLm11bHQoKG0gKyAxKSAvIChuICsgMSkpLl9hZGQocHJldk5vcm1hbCkuX3VuaXQoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRQaWVTbGljZVZlcnRleChjdXJyZW50VmVydGV4LCBmbGlwLCBkaXN0YW5jZSwgYXBwcm94RnJhY3Rpb25hbEpvaW5Ob3JtYWwsIGxpbmVUdXJuc0xlZnQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuYWRkUGllU2xpY2VWZXJ0ZXgoY3VycmVudFZlcnRleCwgZmxpcCwgZGlzdGFuY2UsIGpvaW5Ob3JtYWwsIGxpbmVUdXJuc0xlZnQpO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IG4gLSAxOyBrID49IDA7IGstLSkge1xuICAgICAgICAgICAgICAgICAgICBhcHByb3hGcmFjdGlvbmFsSm9pbk5vcm1hbCA9IHByZXZOb3JtYWwubXVsdCgoayArIDEpIC8gKG4gKyAxKSkuX2FkZChuZXh0Tm9ybWFsKS5fdW5pdCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFBpZVNsaWNlVmVydGV4KGN1cnJlbnRWZXJ0ZXgsIGZsaXAsIGRpc3RhbmNlLCBhcHByb3hGcmFjdGlvbmFsSm9pbk5vcm1hbCwgbGluZVR1cm5zTGVmdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTdGFydCBuZXh0IHNlZ21lbnRcbiAgICAgICAgICAgIGlmIChuZXh0VmVydGV4KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRDdXJyZW50VmVydGV4KGN1cnJlbnRWZXJ0ZXgsIGZsaXAsIGRpc3RhbmNlLCBuZXh0Tm9ybWFsLCAtb2Zmc2V0QSwgLW9mZnNldEIsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRKb2luID09PSAnYnV0dCcpIHtcbiAgICAgICAgICAgIGlmICghc3RhcnRPZkxpbmUpIHtcbiAgICAgICAgICAgICAgICAvLyBDbG9zZSBwcmV2aW91cyBzZWdtZW50IHdpdGggYSBidXR0XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRDdXJyZW50VmVydGV4KGN1cnJlbnRWZXJ0ZXgsIGZsaXAsIGRpc3RhbmNlLCBwcmV2Tm9ybWFsLCAwLCAwLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFN0YXJ0IG5leHQgc2VnbWVudCB3aXRoIGEgYnV0dFxuICAgICAgICAgICAgaWYgKG5leHRWZXJ0ZXgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEN1cnJlbnRWZXJ0ZXgoY3VycmVudFZlcnRleCwgZmxpcCwgZGlzdGFuY2UsIG5leHROb3JtYWwsIDAsIDAsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRKb2luID09PSAnc3F1YXJlJykge1xuXG4gICAgICAgICAgICBpZiAoIXN0YXJ0T2ZMaW5lKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2xvc2UgcHJldmlvdXMgc2VnbWVudCB3aXRoIGEgc3F1YXJlIGNhcFxuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ3VycmVudFZlcnRleChjdXJyZW50VmVydGV4LCBmbGlwLCBkaXN0YW5jZSwgcHJldk5vcm1hbCwgMSwgMSwgZmFsc2UpO1xuXG4gICAgICAgICAgICAgICAgLy8gVGhlIHNlZ21lbnQgaXMgZG9uZS4gVW5zZXQgdmVydGljZXMgdG8gZGlzY29ubmVjdCBzZWdtZW50cy5cbiAgICAgICAgICAgICAgICB0aGlzLmUxID0gdGhpcy5lMiA9IC0xO1xuICAgICAgICAgICAgICAgIGZsaXAgPSAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTdGFydCBuZXh0IHNlZ21lbnRcbiAgICAgICAgICAgIGlmIChuZXh0VmVydGV4KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRDdXJyZW50VmVydGV4KGN1cnJlbnRWZXJ0ZXgsIGZsaXAsIGRpc3RhbmNlLCBuZXh0Tm9ybWFsLCAtMSwgLTEsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRKb2luID09PSAncm91bmQnKSB7XG5cbiAgICAgICAgICAgIGlmICghc3RhcnRPZkxpbmUpIHtcbiAgICAgICAgICAgICAgICAvLyBDbG9zZSBwcmV2aW91cyBzZWdtZW50IHdpdGggYnV0dFxuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ3VycmVudFZlcnRleChjdXJyZW50VmVydGV4LCBmbGlwLCBkaXN0YW5jZSwgcHJldk5vcm1hbCwgMCwgMCwgZmFsc2UpO1xuXG4gICAgICAgICAgICAgICAgLy8gQWRkIHJvdW5kIGNhcCBvciBsaW5lam9pbiBhdCBlbmQgb2Ygc2VnbWVudFxuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ3VycmVudFZlcnRleChjdXJyZW50VmVydGV4LCBmbGlwLCBkaXN0YW5jZSwgcHJldk5vcm1hbCwgMSwgMSwgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICAvLyBUaGUgc2VnbWVudCBpcyBkb25lLiBVbnNldCB2ZXJ0aWNlcyB0byBkaXNjb25uZWN0IHNlZ21lbnRzLlxuICAgICAgICAgICAgICAgIHRoaXMuZTEgPSB0aGlzLmUyID0gLTE7XG4gICAgICAgICAgICAgICAgZmxpcCA9IDE7XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgLy8gU3RhcnQgbmV4dCBzZWdtZW50IHdpdGggYSBidXR0XG4gICAgICAgICAgICBpZiAobmV4dFZlcnRleCkge1xuICAgICAgICAgICAgICAgIC8vIEFkZCByb3VuZCBjYXAgYmVmb3JlIGZpcnN0IHNlZ21lbnRcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEN1cnJlbnRWZXJ0ZXgoY3VycmVudFZlcnRleCwgZmxpcCwgZGlzdGFuY2UsIG5leHROb3JtYWwsIC0xLCAtMSwgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmFkZEN1cnJlbnRWZXJ0ZXgoY3VycmVudFZlcnRleCwgZmxpcCwgZGlzdGFuY2UsIG5leHROb3JtYWwsIDAsIDAsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0T2ZMaW5lID0gZmFsc2U7XG4gICAgfVxuXG59O1xuXG4vKipcbiAqIEFkZCB0d28gdmVydGljZXMgdG8gdGhlIGJ1ZmZlcnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGN1cnJlbnRWZXJ0ZXggdGhlIGxpbmUgdmVydGV4IHRvIGFkZCBidWZmZXIgdmVydGljZXMgZm9yXG4gKiBAcGFyYW0ge251bWJlcn0gZmxpcCAtMSBpZiB0aGUgdmVydGljZXMgc2hvdWxkIGJlIGZsaXBwZWQsIDEgb3RoZXJ3aXNlXG4gKiBAcGFyYW0ge251bWJlcn0gZGlzdGFuY2UgdGhlIGRpc3RhbmNlIGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgbGluZSB0byB0aGUgdmVydGV4XG4gKiBAcGFyYW0ge251bWJlcn0gZW5kTGVmdCBleHRydWRlIHRvIHNoaWZ0IHRoZSBsZWZ0IHZlcnRleCBhbG9uZyB0aGUgbGluZVxuICogQHBhcmFtIHtudW1iZXJ9IGVuZFJpZ2h0IGV4dHJ1ZGUgdG8gc2hpZnQgdGhlIGxlZnQgdmVydGV4IGFsb25nIHRoZSBsaW5lXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHJvdW5kIHdoZXRoZXIgdGhpcyBpcyBhIHJvdW5kIGNhcFxuICogQHByaXZhdGVcbiAqL1xuTGluZUJ1Y2tldC5wcm90b3R5cGUuYWRkQ3VycmVudFZlcnRleCA9IGZ1bmN0aW9uKGN1cnJlbnRWZXJ0ZXgsIGZsaXAsIGRpc3RhbmNlLCBub3JtYWwsIGVuZExlZnQsIGVuZFJpZ2h0LCByb3VuZCkge1xuICAgIHZhciB0eCA9IHJvdW5kID8gMSA6IDA7XG4gICAgdmFyIGV4dHJ1ZGU7XG4gICAgdmFyIGdyb3VwID0gdGhpcy5lbGVtZW50R3JvdXBzLmxpbmUuY3VycmVudDtcbiAgICBncm91cC52ZXJ0ZXhMZW5ndGggKz0gMjtcblxuICAgIGV4dHJ1ZGUgPSBub3JtYWwubXVsdChmbGlwKTtcbiAgICBpZiAoZW5kTGVmdCkgZXh0cnVkZS5fc3ViKG5vcm1hbC5wZXJwKCkuX211bHQoZW5kTGVmdCkpO1xuICAgIHRoaXMuZTMgPSB0aGlzLmFkZExpbmVWZXJ0ZXgoY3VycmVudFZlcnRleCwgZXh0cnVkZSwgdHgsIDAsIGVuZExlZnQsIGRpc3RhbmNlKSAtIGdyb3VwLnZlcnRleFN0YXJ0SW5kZXg7XG4gICAgaWYgKHRoaXMuZTEgPj0gMCAmJiB0aGlzLmUyID49IDApIHtcbiAgICAgICAgdGhpcy5hZGRMaW5lRWxlbWVudCh0aGlzLmUxLCB0aGlzLmUyLCB0aGlzLmUzKTtcbiAgICAgICAgZ3JvdXAuZWxlbWVudExlbmd0aCsrO1xuICAgIH1cbiAgICB0aGlzLmUxID0gdGhpcy5lMjtcbiAgICB0aGlzLmUyID0gdGhpcy5lMztcblxuICAgIGV4dHJ1ZGUgPSBub3JtYWwubXVsdCgtZmxpcCk7XG4gICAgaWYgKGVuZFJpZ2h0KSBleHRydWRlLl9zdWIobm9ybWFsLnBlcnAoKS5fbXVsdChlbmRSaWdodCkpO1xuICAgIHRoaXMuZTMgPSB0aGlzLmFkZExpbmVWZXJ0ZXgoY3VycmVudFZlcnRleCwgZXh0cnVkZSwgdHgsIDEsIC1lbmRSaWdodCwgZGlzdGFuY2UpIC0gZ3JvdXAudmVydGV4U3RhcnRJbmRleDtcbiAgICBpZiAodGhpcy5lMSA+PSAwICYmIHRoaXMuZTIgPj0gMCkge1xuICAgICAgICB0aGlzLmFkZExpbmVFbGVtZW50KHRoaXMuZTEsIHRoaXMuZTIsIHRoaXMuZTMpO1xuICAgICAgICBncm91cC5lbGVtZW50TGVuZ3RoKys7XG4gICAgfVxuICAgIHRoaXMuZTEgPSB0aGlzLmUyO1xuICAgIHRoaXMuZTIgPSB0aGlzLmUzO1xufTtcblxuLyoqXG4gKiBBZGQgYSBzaW5nbGUgbmV3IHZlcnRleCBhbmQgYSB0cmlhbmdsZSB1c2luZyB0d28gcHJldmlvdXMgdmVydGljZXMuXG4gKiBUaGlzIGFkZHMgYSBwaWUgc2xpY2UgdHJpYW5nbGUgbmVhciBhIGpvaW4gdG8gc2ltdWxhdGUgcm91bmQgam9pbnNcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY3VycmVudFZlcnRleCB0aGUgbGluZSB2ZXJ0ZXggdG8gYWRkIGJ1ZmZlciB2ZXJ0aWNlcyBmb3JcbiAqIEBwYXJhbSB7bnVtYmVyfSBmbGlwIC0xIGlmIHRoZSB2ZXJ0aWNlcyBzaG91bGQgYmUgZmxpcHBlZCwgMSBvdGhlcndpc2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBkaXN0YW5jZSB0aGUgZGlzdGFuY2UgZnJvbSB0aGUgYmVnZ2luaW5nIG9mIHRoZSBsaW5lIHRvIHRoZSB2ZXJ0ZXhcbiAqIEBwYXJhbSB7T2JqZWN0fSBleHRydWRlIHRoZSBvZmZzZXQgb2YgdGhlIG5ldyB2ZXJ0ZXggZnJvbSB0aGUgY3VycmVudFZlcnRleFxuICogQHBhcmFtIHtib29sZWFufSB3aGV0aGVyIHRoZSBsaW5lIGlzIHR1cm5pbmcgbGVmdCBvciByaWdodCBhdCB0aGlzIGFuZ2xlXG4gKiBAcHJpdmF0ZVxuICovXG5MaW5lQnVja2V0LnByb3RvdHlwZS5hZGRQaWVTbGljZVZlcnRleCA9IGZ1bmN0aW9uKGN1cnJlbnRWZXJ0ZXgsIGZsaXAsIGRpc3RhbmNlLCBleHRydWRlLCBsaW5lVHVybnNMZWZ0KSB7XG4gICAgdmFyIHR5ID0gbGluZVR1cm5zTGVmdCA/IDEgOiAwO1xuICAgIGV4dHJ1ZGUgPSBleHRydWRlLm11bHQoZmxpcCAqIChsaW5lVHVybnNMZWZ0ID8gLTEgOiAxKSk7XG4gICAgdmFyIGdyb3VwID0gdGhpcy5lbGVtZW50R3JvdXBzLmxpbmUuY3VycmVudDtcblxuICAgIHRoaXMuZTMgPSB0aGlzLmFkZExpbmVWZXJ0ZXgoY3VycmVudFZlcnRleCwgZXh0cnVkZSwgMCwgdHksIDAsIGRpc3RhbmNlKSAtIGdyb3VwLnZlcnRleFN0YXJ0SW5kZXg7XG4gICAgZ3JvdXAudmVydGV4TGVuZ3RoKys7XG5cbiAgICBpZiAodGhpcy5lMSA+PSAwICYmIHRoaXMuZTIgPj0gMCkge1xuICAgICAgICB0aGlzLmFkZExpbmVFbGVtZW50KHRoaXMuZTEsIHRoaXMuZTIsIHRoaXMuZTMpO1xuICAgICAgICBncm91cC5lbGVtZW50TGVuZ3RoKys7XG4gICAgfVxuXG4gICAgaWYgKGxpbmVUdXJuc0xlZnQpIHtcbiAgICAgICAgdGhpcy5lMiA9IHRoaXMuZTM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5lMSA9IHRoaXMuZTM7XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFBvaW50ID0gcmVxdWlyZSgncG9pbnQtZ2VvbWV0cnknKTtcblxudmFyIEJ1Y2tldCA9IHJlcXVpcmUoJy4vYnVja2V0Jyk7XG52YXIgRWxlbWVudEdyb3VwcyA9IHJlcXVpcmUoJy4vZWxlbWVudF9ncm91cHMnKTtcbnZhciBBbmNob3IgPSByZXF1aXJlKCcuLi9zeW1ib2wvYW5jaG9yJyk7XG52YXIgZ2V0QW5jaG9ycyA9IHJlcXVpcmUoJy4uL3N5bWJvbC9nZXRfYW5jaG9ycycpO1xudmFyIHJlc29sdmVUb2tlbnMgPSByZXF1aXJlKCcuLi91dGlsL3Rva2VuJyk7XG52YXIgUXVhZHMgPSByZXF1aXJlKCcuLi9zeW1ib2wvcXVhZHMnKTtcbnZhciBTaGFwaW5nID0gcmVxdWlyZSgnLi4vc3ltYm9sL3NoYXBpbmcnKTtcbnZhciByZXNvbHZlVGV4dCA9IHJlcXVpcmUoJy4uL3N5bWJvbC9yZXNvbHZlX3RleHQnKTtcbnZhciBtZXJnZUxpbmVzID0gcmVxdWlyZSgnLi4vc3ltYm9sL21lcmdlbGluZXMnKTtcbnZhciBzaGFwZVRleHQgPSBTaGFwaW5nLnNoYXBlVGV4dDtcbnZhciBzaGFwZUljb24gPSBTaGFwaW5nLnNoYXBlSWNvbjtcbnZhciBnZXRHbHlwaFF1YWRzID0gUXVhZHMuZ2V0R2x5cGhRdWFkcztcbnZhciBnZXRJY29uUXVhZHMgPSBRdWFkcy5nZXRJY29uUXVhZHM7XG52YXIgY2xpcExpbmUgPSByZXF1aXJlKCcuLi9zeW1ib2wvY2xpcF9saW5lJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xuXG52YXIgQ29sbGlzaW9uRmVhdHVyZSA9IHJlcXVpcmUoJy4uL3N5bWJvbC9jb2xsaXNpb25fZmVhdHVyZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bWJvbEJ1Y2tldDtcblxuZnVuY3Rpb24gU3ltYm9sQnVja2V0KG9wdGlvbnMpIHtcbiAgICBCdWNrZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB0aGlzLmNvbGxpc2lvbkRlYnVnID0gb3B0aW9ucy5jb2xsaXNpb25EZWJ1ZztcbiAgICB0aGlzLm92ZXJzY2FsaW5nID0gb3B0aW9ucy5vdmVyc2NhbGluZztcbn1cblxuU3ltYm9sQnVja2V0LnByb3RvdHlwZSA9IHV0aWwuaW5oZXJpdChCdWNrZXQsIHt9KTtcblxudmFyIHNoYWRlckF0dHJpYnV0ZUFyZ3MgPSBbJ3gnLCAneScsICdveCcsICdveScsICd0eCcsICd0eScsICdtaW56b29tJywgJ21heHpvb20nLCAnbGFiZWxtaW56b29tJ107XG5cbnZhciBzaGFkZXJBdHRyaWJ1dGVzID0gW3tcbiAgICBuYW1lOiAncG9zJyxcbiAgICBjb21wb25lbnRzOiAyLFxuICAgIHR5cGU6IEJ1Y2tldC5BdHRyaWJ1dGVUeXBlLlNIT1JULFxuICAgIHZhbHVlOiBbJ3gnLCAneSddXG59LCB7XG4gICAgbmFtZTogJ29mZnNldCcsXG4gICAgY29tcG9uZW50czogMixcbiAgICB0eXBlOiBCdWNrZXQuQXR0cmlidXRlVHlwZS5TSE9SVCxcbiAgICB2YWx1ZTogW1xuICAgICAgICAnTWF0aC5yb3VuZChveCAqIDY0KScsIC8vIHVzZSAxLzY0IHBpeGVscyBmb3IgcGxhY2VtZW50XG4gICAgICAgICdNYXRoLnJvdW5kKG95ICogNjQpJ1xuICAgIF1cbn0sIHtcbiAgICBuYW1lOiAnZGF0YTEnLFxuICAgIGNvbXBvbmVudHM6IDQsXG4gICAgdHlwZTogQnVja2V0LkF0dHJpYnV0ZVR5cGUuVU5TSUdORURfQllURSxcbiAgICB2YWx1ZTogW1xuICAgICAgICAndHggLyA0JywgICAgICAgICAgICAgICAgICAgLy8gdGV4XG4gICAgICAgICd0eSAvIDQnLCAgICAgICAgICAgICAgICAgICAvLyB0ZXhcbiAgICAgICAgJyhsYWJlbG1pbnpvb20gfHwgMCkgKiAxMCcsIC8vIGxhYmVsbWluem9vbVxuICAgICAgICAnMCdcbiAgICBdXG59LCB7XG4gICAgbmFtZTogJ2RhdGEyJyxcbiAgICBjb21wb25lbnRzOiAyLFxuICAgIHR5cGU6IEJ1Y2tldC5BdHRyaWJ1dGVUeXBlLlVOU0lHTkVEX0JZVEUsXG4gICAgdmFsdWU6IFtcbiAgICAgICAgJyhtaW56b29tIHx8IDApICogMTAnLCAgICAgICAgICAgICAvLyBtaW56b29tXG4gICAgICAgICdNYXRoLm1pbihtYXh6b29tIHx8IDI1LCAyNSkgKiAxMCcgLy8gbWluem9vbVxuICAgIF1cbn1dO1xuXG5TeW1ib2xCdWNrZXQucHJvdG90eXBlLnNoYWRlcnMgPSB7XG5cbiAgICBnbHlwaDoge1xuICAgICAgICB2ZXJ0ZXhCdWZmZXI6IHRydWUsXG4gICAgICAgIGVsZW1lbnRCdWZmZXI6IHRydWUsXG4gICAgICAgIGF0dHJpYnV0ZUFyZ3M6IHNoYWRlckF0dHJpYnV0ZUFyZ3MsXG4gICAgICAgIGF0dHJpYnV0ZXM6IHNoYWRlckF0dHJpYnV0ZXNcbiAgICB9LFxuXG4gICAgaWNvbjoge1xuICAgICAgICB2ZXJ0ZXhCdWZmZXI6IHRydWUsXG4gICAgICAgIGVsZW1lbnRCdWZmZXI6IHRydWUsXG4gICAgICAgIGF0dHJpYnV0ZUFyZ3M6IHNoYWRlckF0dHJpYnV0ZUFyZ3MsXG4gICAgICAgIGF0dHJpYnV0ZXM6IHNoYWRlckF0dHJpYnV0ZXNcbiAgICB9LFxuXG4gICAgY29sbGlzaW9uQm94OiB7XG4gICAgICAgIHZlcnRleEJ1ZmZlcjogJ2NvbGxpc2lvbkJveFZlcnRleCcsXG5cbiAgICAgICAgYXR0cmlidXRlQXJnczogWydwb2ludCcsICdleHRydWRlJywgJ21heFpvb20nLCAncGxhY2VtZW50Wm9vbSddLFxuXG4gICAgICAgIGF0dHJpYnV0ZXM6IFt7XG4gICAgICAgICAgICBuYW1lOiAncG9zJyxcbiAgICAgICAgICAgIGNvbXBvbmVudHM6IDIsXG4gICAgICAgICAgICB0eXBlOiBCdWNrZXQuQXR0cmlidXRlVHlwZS5TSE9SVCxcbiAgICAgICAgICAgIHZhbHVlOiBbICdwb2ludC54JywgJ3BvaW50LnknIF1cbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogJ2V4dHJ1ZGUnLFxuICAgICAgICAgICAgY29tcG9uZW50czogMixcbiAgICAgICAgICAgIHR5cGU6IEJ1Y2tldC5BdHRyaWJ1dGVUeXBlLlNIT1JULFxuICAgICAgICAgICAgdmFsdWU6IFtcbiAgICAgICAgICAgICAgICAnTWF0aC5yb3VuZChleHRydWRlLngpJyxcbiAgICAgICAgICAgICAgICAnTWF0aC5yb3VuZChleHRydWRlLnkpJ1xuICAgICAgICAgICAgXVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiAnZGF0YScsXG4gICAgICAgICAgICBjb21wb25lbnRzOiAyLFxuICAgICAgICAgICAgdHlwZTogQnVja2V0LkF0dHJpYnV0ZVR5cGUuVU5TSUdORURfQllURSxcbiAgICAgICAgICAgIHZhbHVlOiBbXG4gICAgICAgICAgICAgICAgJ21heFpvb20gKiAxMCcsXG4gICAgICAgICAgICAgICAgJ3BsYWNlbWVudFpvb20gKiAxMCdcbiAgICAgICAgICAgIF1cbiAgICAgICAgfV1cbiAgICB9XG59O1xuXG5TeW1ib2xCdWNrZXQucHJvdG90eXBlLmFkZEZlYXR1cmVzID0gZnVuY3Rpb24oY29sbGlzaW9uVGlsZSwgc3RhY2tzLCBpY29ucykge1xuICAgIHZhciB0aWxlU2l6ZSA9IDUxMiAqIHRoaXMub3ZlcnNjYWxpbmc7XG4gICAgdmFyIHRpbGVFeHRlbnQgPSA0MDk2O1xuICAgIHRoaXMudGlsZVBpeGVsUmF0aW8gPSB0aWxlRXh0ZW50IC8gdGlsZVNpemU7XG4gICAgdGhpcy5jb21wYXJlVGV4dCA9IHt9O1xuICAgIHRoaXMuc3ltYm9sSW5zdGFuY2VzID0gW107XG4gICAgdGhpcy5pY29uc05lZWRMaW5lYXIgPSBmYWxzZTtcblxuICAgIHZhciBsYXlvdXQgPSB0aGlzLmxheW91dFByb3BlcnRpZXM7XG4gICAgdmFyIGZlYXR1cmVzID0gdGhpcy5mZWF0dXJlcztcbiAgICB2YXIgdGV4dEZlYXR1cmVzID0gdGhpcy50ZXh0RmVhdHVyZXM7XG5cbiAgICB2YXIgaG9yaXpvbnRhbEFsaWduID0gMC41LFxuICAgICAgICB2ZXJ0aWNhbEFsaWduID0gMC41O1xuXG4gICAgc3dpdGNoIChsYXlvdXRbJ3RleHQtYW5jaG9yJ10pIHtcbiAgICBjYXNlICdyaWdodCc6XG4gICAgY2FzZSAndG9wLXJpZ2h0JzpcbiAgICBjYXNlICdib3R0b20tcmlnaHQnOlxuICAgICAgICBob3Jpem9udGFsQWxpZ24gPSAxO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlICdsZWZ0JzpcbiAgICBjYXNlICd0b3AtbGVmdCc6XG4gICAgY2FzZSAnYm90dG9tLWxlZnQnOlxuICAgICAgICBob3Jpem9udGFsQWxpZ24gPSAwO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBzd2l0Y2ggKGxheW91dFsndGV4dC1hbmNob3InXSkge1xuICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgY2FzZSAnYm90dG9tLXJpZ2h0JzpcbiAgICBjYXNlICdib3R0b20tbGVmdCc6XG4gICAgICAgIHZlcnRpY2FsQWxpZ24gPSAxO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlICd0b3AnOlxuICAgIGNhc2UgJ3RvcC1yaWdodCc6XG4gICAgY2FzZSAndG9wLWxlZnQnOlxuICAgICAgICB2ZXJ0aWNhbEFsaWduID0gMDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIGp1c3RpZnkgPSBsYXlvdXRbJ3RleHQtanVzdGlmeSddID09PSAncmlnaHQnID8gMSA6XG4gICAgICAgIGxheW91dFsndGV4dC1qdXN0aWZ5J10gPT09ICdsZWZ0JyA/IDAgOlxuICAgICAgICAwLjU7XG5cbiAgICB2YXIgb25lRW0gPSAyNDtcbiAgICB2YXIgbGluZUhlaWdodCA9IGxheW91dFsndGV4dC1saW5lLWhlaWdodCddICogb25lRW07XG4gICAgdmFyIG1heFdpZHRoID0gbGF5b3V0WydzeW1ib2wtcGxhY2VtZW50J10gIT09ICdsaW5lJyA/IGxheW91dFsndGV4dC1tYXgtd2lkdGgnXSAqIG9uZUVtIDogMDtcbiAgICB2YXIgc3BhY2luZyA9IGxheW91dFsndGV4dC1sZXR0ZXItc3BhY2luZyddICogb25lRW07XG4gICAgdmFyIHRleHRPZmZzZXQgPSBbbGF5b3V0Wyd0ZXh0LW9mZnNldCddWzBdICogb25lRW0sIGxheW91dFsndGV4dC1vZmZzZXQnXVsxXSAqIG9uZUVtXTtcbiAgICB2YXIgZm9udHN0YWNrID0gbGF5b3V0Wyd0ZXh0LWZvbnQnXS5qb2luKCcsJyk7XG5cbiAgICB2YXIgZ2VvbWV0cmllcyA9IFtdO1xuICAgIGZvciAodmFyIGcgPSAwOyBnIDwgZmVhdHVyZXMubGVuZ3RoOyBnKyspIHtcbiAgICAgICAgZ2VvbWV0cmllcy5wdXNoKGZlYXR1cmVzW2ddLmxvYWRHZW9tZXRyeSgpKTtcbiAgICB9XG5cbiAgICBpZiAobGF5b3V0WydzeW1ib2wtcGxhY2VtZW50J10gPT09ICdsaW5lJykge1xuICAgICAgICAvLyBNZXJnZSBhZGphY2VudCBsaW5lcyB3aXRoIHRoZSBzYW1lIHRleHQgdG8gaW1wcm92ZSBsYWJlbGxpbmcuXG4gICAgICAgIC8vIEl0J3MgYmV0dGVyIHRvIHBsYWNlIGxhYmVscyBvbiBvbmUgbG9uZyBsaW5lIHRoYW4gb24gbWFueSBzaG9ydCBzZWdtZW50cy5cbiAgICAgICAgdmFyIG1lcmdlZCA9IG1lcmdlTGluZXMoZmVhdHVyZXMsIHRleHRGZWF0dXJlcywgZ2VvbWV0cmllcyk7XG5cbiAgICAgICAgZ2VvbWV0cmllcyA9IG1lcmdlZC5nZW9tZXRyaWVzO1xuICAgICAgICBmZWF0dXJlcyA9IG1lcmdlZC5mZWF0dXJlcztcbiAgICAgICAgdGV4dEZlYXR1cmVzID0gbWVyZ2VkLnRleHRGZWF0dXJlcztcbiAgICB9XG5cbiAgICB2YXIgc2hhcGVkVGV4dCwgc2hhcGVkSWNvbjtcblxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgZmVhdHVyZXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgaWYgKCFnZW9tZXRyaWVzW2tdKSBjb250aW51ZTtcblxuICAgICAgICBpZiAodGV4dEZlYXR1cmVzW2tdKSB7XG4gICAgICAgICAgICBzaGFwZWRUZXh0ID0gc2hhcGVUZXh0KHRleHRGZWF0dXJlc1trXSwgc3RhY2tzW2ZvbnRzdGFja10sIG1heFdpZHRoLFxuICAgICAgICAgICAgICAgICAgICBsaW5lSGVpZ2h0LCBob3Jpem9udGFsQWxpZ24sIHZlcnRpY2FsQWxpZ24sIGp1c3RpZnksIHNwYWNpbmcsIHRleHRPZmZzZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2hhcGVkVGV4dCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGF5b3V0WydpY29uLWltYWdlJ10pIHtcbiAgICAgICAgICAgIHZhciBpY29uTmFtZSA9IHJlc29sdmVUb2tlbnMoZmVhdHVyZXNba10ucHJvcGVydGllcywgbGF5b3V0WydpY29uLWltYWdlJ10pO1xuICAgICAgICAgICAgdmFyIGltYWdlID0gaWNvbnNbaWNvbk5hbWVdO1xuICAgICAgICAgICAgc2hhcGVkSWNvbiA9IHNoYXBlSWNvbihpbWFnZSwgbGF5b3V0KTtcblxuICAgICAgICAgICAgaWYgKGltYWdlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2RmSWNvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNkZkljb25zID0gaW1hZ2Uuc2RmO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5zZGZJY29ucyAhPT0gaW1hZ2Uuc2RmKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignU3R5bGUgc2hlZXQgd2FybmluZzogQ2Fubm90IG1peCBTREYgYW5kIG5vbi1TREYgaWNvbnMgaW4gb25lIGJ1ZmZlcicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaW1hZ2UucGl4ZWxSYXRpbyAhPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmljb25zTmVlZExpbmVhciA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2hhcGVkSWNvbiA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2hhcGVkVGV4dCB8fCBzaGFwZWRJY29uKSB7XG4gICAgICAgICAgICB0aGlzLmFkZEZlYXR1cmUoZ2VvbWV0cmllc1trXSwgc2hhcGVkVGV4dCwgc2hhcGVkSWNvbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnBsYWNlRmVhdHVyZXMoY29sbGlzaW9uVGlsZSwgdGhpcy5idWZmZXJzLCB0aGlzLmNvbGxpc2lvbkRlYnVnKTtcbn07XG5cblN5bWJvbEJ1Y2tldC5wcm90b3R5cGUuYWRkRmVhdHVyZSA9IGZ1bmN0aW9uKGxpbmVzLCBzaGFwZWRUZXh0LCBzaGFwZWRJY29uKSB7XG4gICAgdmFyIGxheW91dCA9IHRoaXMubGF5b3V0UHJvcGVydGllcztcblxuICAgIHZhciBnbHlwaFNpemUgPSAyNDtcblxuICAgIHZhciBmb250U2NhbGUgPSBsYXlvdXRbJ3RleHQtc2l6ZSddIC8gZ2x5cGhTaXplLFxuICAgICAgICB0ZXh0TWF4U2l6ZSA9IGxheW91dFsndGV4dC1tYXgtc2l6ZSddICE9PSB1bmRlZmluZWQgPyBsYXlvdXRbJ3RleHQtbWF4LXNpemUnXSA6IGxheW91dFsndGV4dC1zaXplJ10sXG4gICAgICAgIHRleHRCb3hTY2FsZSA9IHRoaXMudGlsZVBpeGVsUmF0aW8gKiBmb250U2NhbGUsXG4gICAgICAgIHRleHRNYXhCb3hTY2FsZSA9IHRoaXMudGlsZVBpeGVsUmF0aW8gKiB0ZXh0TWF4U2l6ZSAvIGdseXBoU2l6ZSxcbiAgICAgICAgaWNvbkJveFNjYWxlID0gdGhpcy50aWxlUGl4ZWxSYXRpbyAqIGxheW91dFsnaWNvbi1zaXplJ10sXG4gICAgICAgIHN5bWJvbE1pbkRpc3RhbmNlID0gdGhpcy50aWxlUGl4ZWxSYXRpbyAqIGxheW91dFsnc3ltYm9sLXNwYWNpbmcnXSxcbiAgICAgICAgYXZvaWRFZGdlcyA9IGxheW91dFsnc3ltYm9sLWF2b2lkLWVkZ2VzJ10sXG4gICAgICAgIHRleHRQYWRkaW5nID0gbGF5b3V0Wyd0ZXh0LXBhZGRpbmcnXSAqIHRoaXMudGlsZVBpeGVsUmF0aW8sXG4gICAgICAgIGljb25QYWRkaW5nID0gbGF5b3V0WydpY29uLXBhZGRpbmcnXSAqIHRoaXMudGlsZVBpeGVsUmF0aW8sXG4gICAgICAgIHRleHRNYXhBbmdsZSA9IGxheW91dFsndGV4dC1tYXgtYW5nbGUnXSAvIDE4MCAqIE1hdGguUEksXG4gICAgICAgIHRleHRBbG9uZ0xpbmUgPSBsYXlvdXRbJ3RleHQtcm90YXRpb24tYWxpZ25tZW50J10gPT09ICdtYXAnICYmIGxheW91dFsnc3ltYm9sLXBsYWNlbWVudCddID09PSAnbGluZScsXG4gICAgICAgIGljb25BbG9uZ0xpbmUgPSBsYXlvdXRbJ2ljb24tcm90YXRpb24tYWxpZ25tZW50J10gPT09ICdtYXAnICYmIGxheW91dFsnc3ltYm9sLXBsYWNlbWVudCddID09PSAnbGluZScsXG4gICAgICAgIG1heU92ZXJsYXAgPSBsYXlvdXRbJ3RleHQtYWxsb3ctb3ZlcmxhcCddIHx8IGxheW91dFsnaWNvbi1hbGxvdy1vdmVybGFwJ10gfHxcbiAgICAgICAgICAgIGxheW91dFsndGV4dC1pZ25vcmUtcGxhY2VtZW50J10gfHwgbGF5b3V0WydpY29uLWlnbm9yZS1wbGFjZW1lbnQnXSxcbiAgICAgICAgaXNMaW5lID0gbGF5b3V0WydzeW1ib2wtcGxhY2VtZW50J10gPT09ICdsaW5lJyxcbiAgICAgICAgdGV4dFJlcGVhdERpc3RhbmNlID0gc3ltYm9sTWluRGlzdGFuY2UgLyAyO1xuXG4gICAgaWYgKGlzTGluZSkge1xuICAgICAgICBsaW5lcyA9IGNsaXBMaW5lKGxpbmVzLCAwLCAwLCA0MDk2LCA0MDk2KTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBsaW5lID0gbGluZXNbaV07XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBhbmNob3IgcG9pbnRzIGFyb3VuZCB3aGljaCB5b3Ugd2FudCB0byBwbGFjZSBsYWJlbHNcbiAgICAgICAgdmFyIGFuY2hvcnMgPSBpc0xpbmUgP1xuICAgICAgICAgICAgZ2V0QW5jaG9ycyhsaW5lLCBzeW1ib2xNaW5EaXN0YW5jZSwgdGV4dE1heEFuZ2xlLCBzaGFwZWRUZXh0LCBzaGFwZWRJY29uLCBnbHlwaFNpemUsIHRleHRNYXhCb3hTY2FsZSwgdGhpcy5vdmVyc2NhbGluZykgOlxuICAgICAgICAgICAgWyBuZXcgQW5jaG9yKGxpbmVbMF0ueCwgbGluZVswXS55LCAwKSBdO1xuXG4gICAgICAgIC8vIEZvciBlYWNoIHBvdGVudGlhbCBsYWJlbCwgY3JlYXRlIHRoZSBwbGFjZW1lbnQgZmVhdHVyZXMgdXNlZCB0byBjaGVjayBmb3IgY29sbGlzaW9ucywgYW5kIHRoZSBxdWFkcyB1c2UgZm9yIHJlbmRlcmluZy5cbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIGxlbiA9IGFuY2hvcnMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBhbmNob3IgPSBhbmNob3JzW2pdO1xuXG4gICAgICAgICAgICBpZiAoc2hhcGVkVGV4dCAmJiBpc0xpbmUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hbmNob3JJc1Rvb0Nsb3NlKHNoYXBlZFRleHQudGV4dCwgdGV4dFJlcGVhdERpc3RhbmNlLCBhbmNob3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGluc2lkZSA9ICEoYW5jaG9yLnggPCAwIHx8IGFuY2hvci54ID4gNDA5NiB8fCBhbmNob3IueSA8IDAgfHwgYW5jaG9yLnkgPiA0MDk2KTtcblxuICAgICAgICAgICAgaWYgKGF2b2lkRWRnZXMgJiYgIWluc2lkZSkgY29udGludWU7XG5cbiAgICAgICAgICAgIC8vIE5vcm1hbGx5IHN5bWJvbCBsYXllcnMgYXJlIGRyYXduIGFjcm9zcyB0aWxlIGJvdW5kYXJpZXMuIE9ubHkgc3ltYm9sc1xuICAgICAgICAgICAgLy8gd2l0aCB0aGVpciBhbmNob3JzIHdpdGhpbiB0aGUgdGlsZSBib3VuZGFyaWVzIGFyZSBhZGRlZCB0byB0aGUgYnVmZmVyc1xuICAgICAgICAgICAgLy8gdG8gcHJldmVudCBzeW1ib2xzIGZyb20gYmVpbmcgZHJhd24gdHdpY2UuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gU3ltYm9scyBpbiBsYXllcnMgd2l0aCBvdmVybGFwIGFyZSBzb3J0ZWQgaW4gdGhlIHkgZGlyZWN0aW9uIHNvIHRoYXRcbiAgICAgICAgICAgIC8vIHN5bWJvbHMgbG93ZXIgb24gdGhlIGNhbnZhcyBhcmUgZHJhd24gb24gdG9wIG9mIHN5bWJvbHMgbmVhciB0aGUgdG9wLlxuICAgICAgICAgICAgLy8gVG8gcHJlc2VydmUgdGhpcyBvcmRlciBhY3Jvc3MgdGlsZSBib3VuZGFyaWVzIHRoZXNlIHN5bWJvbHMgY2FuJ3RcbiAgICAgICAgICAgIC8vIGJlIGRyYXduIGFjcm9zcyB0aWxlIGJvdW5kYXJpZXMuIEluc3RlYWQgdGhleSBuZWVkIHRvIGJlIGluY2x1ZGVkIGluXG4gICAgICAgICAgICAvLyB0aGUgYnVmZmVycyBmb3IgYm90aCB0aWxlcyBhbmQgY2xpcHBlZCB0byB0aWxlIGJvdW5kYXJpZXMgYXQgZHJhdyB0aW1lLlxuICAgICAgICAgICAgdmFyIGFkZFRvQnVmZmVycyA9IGluc2lkZSB8fCBtYXlPdmVybGFwO1xuXG4gICAgICAgICAgICB0aGlzLnN5bWJvbEluc3RhbmNlcy5wdXNoKG5ldyBTeW1ib2xJbnN0YW5jZShhbmNob3IsIGxpbmUsIHNoYXBlZFRleHQsIHNoYXBlZEljb24sIGxheW91dCwgYWRkVG9CdWZmZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dEJveFNjYWxlLCB0ZXh0UGFkZGluZywgdGV4dEFsb25nTGluZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGljb25Cb3hTY2FsZSwgaWNvblBhZGRpbmcsIGljb25BbG9uZ0xpbmUpKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblN5bWJvbEJ1Y2tldC5wcm90b3R5cGUuYW5jaG9ySXNUb29DbG9zZSA9IGZ1bmN0aW9uKHRleHQsIHJlcGVhdERpc3RhbmNlLCBhbmNob3IpIHtcbiAgICB2YXIgY29tcGFyZVRleHQgPSB0aGlzLmNvbXBhcmVUZXh0O1xuICAgIGlmICghKHRleHQgaW4gY29tcGFyZVRleHQpKSB7XG4gICAgICAgIGNvbXBhcmVUZXh0W3RleHRdID0gW107XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG90aGVyQW5jaG9ycyA9IGNvbXBhcmVUZXh0W3RleHRdO1xuICAgICAgICBmb3IgKHZhciBrID0gb3RoZXJBbmNob3JzLmxlbmd0aCAtIDE7IGsgPj0gMDsgay0tKSB7XG4gICAgICAgICAgICBpZiAoYW5jaG9yLmRpc3Qob3RoZXJBbmNob3JzW2tdKSA8IHJlcGVhdERpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgaXQncyB3aXRoaW4gcmVwZWF0RGlzdGFuY2Ugb2Ygb25lIGFuY2hvciwgc3RvcCBsb29raW5nXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSWYgYW5jaG9yIGlzIG5vdCB3aXRoaW4gcmVwZWF0RGlzdGFuY2Ugb2YgYW55IG90aGVyIGFuY2hvciwgYWRkIHRvIGFycmF5XG4gICAgY29tcGFyZVRleHRbdGV4dF0ucHVzaChhbmNob3IpO1xuICAgIHJldHVybiBmYWxzZTtcbn07XG5cblN5bWJvbEJ1Y2tldC5wcm90b3R5cGUucGxhY2VGZWF0dXJlcyA9IGZ1bmN0aW9uKGNvbGxpc2lvblRpbGUsIGJ1ZmZlcnMsIGNvbGxpc2lvbkRlYnVnKSB7XG4gICAgLy8gQ2FsY3VsYXRlIHdoaWNoIGxhYmVscyBjYW4gYmUgc2hvd24gYW5kIHdoZW4gdGhleSBjYW4gYmUgc2hvd24gYW5kXG4gICAgLy8gY3JlYXRlIHRoZSBidWZlcnMgdXNlZCBmb3IgcmVuZGVyaW5nLlxuXG4gICAgdGhpcy5yZXNldEJ1ZmZlcnMoYnVmZmVycyk7XG5cbiAgICB2YXIgZWxlbWVudEdyb3VwcyA9IHRoaXMuZWxlbWVudEdyb3VwcyA9IHtcbiAgICAgICAgZ2x5cGg6IG5ldyBFbGVtZW50R3JvdXBzKGJ1ZmZlcnMuZ2x5cGhWZXJ0ZXgsIGJ1ZmZlcnMuZ2x5cGhFbGVtZW50KSxcbiAgICAgICAgaWNvbjogbmV3IEVsZW1lbnRHcm91cHMoYnVmZmVycy5pY29uVmVydGV4LCBidWZmZXJzLmljb25FbGVtZW50KSxcbiAgICAgICAgc2RmSWNvbnM6IHRoaXMuc2RmSWNvbnMsXG4gICAgICAgIGljb25zTmVlZExpbmVhcjogdGhpcy5pY29uc05lZWRMaW5lYXJcbiAgICB9O1xuXG4gICAgdmFyIGxheW91dCA9IHRoaXMubGF5b3V0UHJvcGVydGllcztcbiAgICB2YXIgbWF4U2NhbGUgPSBjb2xsaXNpb25UaWxlLm1heFNjYWxlO1xuXG4gICAgZWxlbWVudEdyb3Vwcy5nbHlwaFsndGV4dC1zaXplJ10gPSBsYXlvdXRbJ3RleHQtc2l6ZSddO1xuICAgIGVsZW1lbnRHcm91cHMuZ2x5cGhbJ3RleHQtZm9udCddID0gbGF5b3V0Wyd0ZXh0LWZvbnQnXTtcbiAgICBlbGVtZW50R3JvdXBzLmljb25bJ2ljb24tc2l6ZSddID0gbGF5b3V0WydpY29uLXNpemUnXTtcblxuICAgIHZhciB0ZXh0QWxvbmdMaW5lID0gbGF5b3V0Wyd0ZXh0LXJvdGF0aW9uLWFsaWdubWVudCddID09PSAnbWFwJyAmJiBsYXlvdXRbJ3N5bWJvbC1wbGFjZW1lbnQnXSA9PT0gJ2xpbmUnO1xuICAgIHZhciBpY29uQWxvbmdMaW5lID0gbGF5b3V0WydpY29uLXJvdGF0aW9uLWFsaWdubWVudCddID09PSAnbWFwJyAmJiBsYXlvdXRbJ3N5bWJvbC1wbGFjZW1lbnQnXSA9PT0gJ2xpbmUnO1xuXG4gICAgdmFyIG1heU92ZXJsYXAgPSBsYXlvdXRbJ3RleHQtYWxsb3ctb3ZlcmxhcCddIHx8IGxheW91dFsnaWNvbi1hbGxvdy1vdmVybGFwJ10gfHxcbiAgICAgICAgbGF5b3V0Wyd0ZXh0LWlnbm9yZS1wbGFjZW1lbnQnXSB8fCBsYXlvdXRbJ2ljb24taWdub3JlLXBsYWNlbWVudCddO1xuXG4gICAgLy8gU29ydCBzeW1ib2xzIGJ5IHRoZWlyIHkgcG9zaXRpb24gb24gdGhlIGNhbnZhcyBzbyB0aGF0IHRoZXkgbG93ZXIgc3ltYm9sc1xuICAgIC8vIGFyZSBkcmF3biBvbiB0b3Agb2YgaGlnaGVyIHN5bWJvbHMuXG4gICAgLy8gRG9uJ3Qgc29ydCBzeW1ib2xzIHRoYXQgd29uJ3Qgb3ZlcmxhcCBiZWNhdXNlIGl0IGlzbid0IG5lY2Vzc2FyeSBhbmRcbiAgICAvLyBiZWNhdXNlIGl0IGNhdXNlcyBtb3JlIGxhYmVscyB0byBwb3AgaW4gYW5kIG91dCB3aGVuIHJvdGF0aW5nLlxuICAgIGlmIChtYXlPdmVybGFwKSB7XG4gICAgICAgIHZhciBhbmdsZSA9IGNvbGxpc2lvblRpbGUuYW5nbGU7XG4gICAgICAgIHZhciBzaW4gPSBNYXRoLnNpbihhbmdsZSksXG4gICAgICAgICAgICBjb3MgPSBNYXRoLmNvcyhhbmdsZSk7XG5cbiAgICAgICAgdGhpcy5zeW1ib2xJbnN0YW5jZXMuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICB2YXIgYVJvdGF0ZWQgPSBzaW4gKiBhLnggKyBjb3MgKiBhLnk7XG4gICAgICAgICAgICB2YXIgYlJvdGF0ZWQgPSBzaW4gKiBiLnggKyBjb3MgKiBiLnk7XG4gICAgICAgICAgICByZXR1cm4gYVJvdGF0ZWQgLSBiUm90YXRlZDtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgcCA9IDA7IHAgPCB0aGlzLnN5bWJvbEluc3RhbmNlcy5sZW5ndGg7IHArKykge1xuICAgICAgICB2YXIgc3ltYm9sSW5zdGFuY2UgPSB0aGlzLnN5bWJvbEluc3RhbmNlc1twXTtcbiAgICAgICAgdmFyIGhhc1RleHQgPSBzeW1ib2xJbnN0YW5jZS5oYXNUZXh0O1xuICAgICAgICB2YXIgaGFzSWNvbiA9IHN5bWJvbEluc3RhbmNlLmhhc0ljb247XG5cbiAgICAgICAgdmFyIGljb25XaXRob3V0VGV4dCA9IGxheW91dFsndGV4dC1vcHRpb25hbCddIHx8ICFoYXNUZXh0LFxuICAgICAgICAgICAgdGV4dFdpdGhvdXRJY29uID0gbGF5b3V0WydpY29uLW9wdGlvbmFsJ10gfHwgIWhhc0ljb247XG5cblxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIHNjYWxlcyBhdCB3aGljaCB0aGUgdGV4dCBhbmQgaWNvbiBjYW4gYmUgcGxhY2VkIHdpdGhvdXQgY29sbGlzaW9uLlxuXG4gICAgICAgIHZhciBnbHlwaFNjYWxlID0gaGFzVGV4dCAmJiAhbGF5b3V0Wyd0ZXh0LWFsbG93LW92ZXJsYXAnXSA/XG4gICAgICAgICAgICBjb2xsaXNpb25UaWxlLnBsYWNlQ29sbGlzaW9uRmVhdHVyZShzeW1ib2xJbnN0YW5jZS50ZXh0Q29sbGlzaW9uRmVhdHVyZSkgOlxuICAgICAgICAgICAgY29sbGlzaW9uVGlsZS5taW5TY2FsZTtcblxuICAgICAgICB2YXIgaWNvblNjYWxlID0gaGFzSWNvbiAmJiAhbGF5b3V0WydpY29uLWFsbG93LW92ZXJsYXAnXSA/XG4gICAgICAgICAgICBjb2xsaXNpb25UaWxlLnBsYWNlQ29sbGlzaW9uRmVhdHVyZShzeW1ib2xJbnN0YW5jZS5pY29uQ29sbGlzaW9uRmVhdHVyZSkgOlxuICAgICAgICAgICAgY29sbGlzaW9uVGlsZS5taW5TY2FsZTtcblxuXG4gICAgICAgIC8vIENvbWJpbmUgdGhlIHNjYWxlcyBmb3IgaWNvbnMgYW5kIHRleHQuXG5cbiAgICAgICAgaWYgKCFpY29uV2l0aG91dFRleHQgJiYgIXRleHRXaXRob3V0SWNvbikge1xuICAgICAgICAgICAgaWNvblNjYWxlID0gZ2x5cGhTY2FsZSA9IE1hdGgubWF4KGljb25TY2FsZSwgZ2x5cGhTY2FsZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXRleHRXaXRob3V0SWNvbiAmJiBnbHlwaFNjYWxlKSB7XG4gICAgICAgICAgICBnbHlwaFNjYWxlID0gTWF0aC5tYXgoaWNvblNjYWxlLCBnbHlwaFNjYWxlKTtcbiAgICAgICAgfSBlbHNlIGlmICghaWNvbldpdGhvdXRUZXh0ICYmIGljb25TY2FsZSkge1xuICAgICAgICAgICAgaWNvblNjYWxlID0gTWF0aC5tYXgoaWNvblNjYWxlLCBnbHlwaFNjYWxlKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgLy8gSW5zZXJ0IGZpbmFsIHBsYWNlbWVudCBpbnRvIGNvbGxpc2lvbiB0cmVlIGFuZCBhZGQgZ2x5cGhzL2ljb25zIHRvIGJ1ZmZlcnNcblxuICAgICAgICBpZiAoaGFzVGV4dCkge1xuICAgICAgICAgICAgaWYgKCFsYXlvdXRbJ3RleHQtaWdub3JlLXBsYWNlbWVudCddKSB7XG4gICAgICAgICAgICAgICAgY29sbGlzaW9uVGlsZS5pbnNlcnRDb2xsaXNpb25GZWF0dXJlKHN5bWJvbEluc3RhbmNlLnRleHRDb2xsaXNpb25GZWF0dXJlLCBnbHlwaFNjYWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChnbHlwaFNjYWxlIDw9IG1heFNjYWxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRTeW1ib2xzKCdnbHlwaCcsIHN5bWJvbEluc3RhbmNlLmdseXBoUXVhZHMsIGdseXBoU2NhbGUsIGxheW91dFsndGV4dC1rZWVwLXVwcmlnaHQnXSwgdGV4dEFsb25nTGluZSwgY29sbGlzaW9uVGlsZS5hbmdsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzSWNvbikge1xuICAgICAgICAgICAgaWYgKCFsYXlvdXRbJ2ljb24taWdub3JlLXBsYWNlbWVudCddKSB7XG4gICAgICAgICAgICAgICAgY29sbGlzaW9uVGlsZS5pbnNlcnRDb2xsaXNpb25GZWF0dXJlKHN5bWJvbEluc3RhbmNlLmljb25Db2xsaXNpb25GZWF0dXJlLCBpY29uU2NhbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGljb25TY2FsZSA8PSBtYXhTY2FsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkU3ltYm9scygnaWNvbicsIHN5bWJvbEluc3RhbmNlLmljb25RdWFkcywgaWNvblNjYWxlLCBsYXlvdXRbJ2ljb24ta2VlcC11cHJpZ2h0J10sIGljb25BbG9uZ0xpbmUsIGNvbGxpc2lvblRpbGUuYW5nbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBpZiAoY29sbGlzaW9uRGVidWcpIHRoaXMuYWRkVG9EZWJ1Z0J1ZmZlcnMoY29sbGlzaW9uVGlsZSk7XG59O1xuXG5TeW1ib2xCdWNrZXQucHJvdG90eXBlLmFkZFN5bWJvbHMgPSBmdW5jdGlvbihzaGFkZXJOYW1lLCBxdWFkcywgc2NhbGUsIGtlZXBVcHJpZ2h0LCBhbG9uZ0xpbmUsIHBsYWNlbWVudEFuZ2xlKSB7XG5cbiAgICB2YXIgZ3JvdXAgPSB0aGlzLm1ha2VSb29tRm9yKHNoYWRlck5hbWUsIDQgKiBxdWFkcy5sZW5ndGgpO1xuXG4gICAgLy8gVE9ETyBtYW51YWwgY3VycnlcbiAgICB2YXIgYWRkRWxlbWVudCA9IHRoaXNbdGhpcy5nZXRBZGRNZXRob2ROYW1lKHNoYWRlck5hbWUsICdlbGVtZW50JyldLmJpbmQodGhpcyk7XG4gICAgdmFyIGFkZFZlcnRleCA9IHRoaXNbdGhpcy5nZXRBZGRNZXRob2ROYW1lKHNoYWRlck5hbWUsICd2ZXJ0ZXgnKV0uYmluZCh0aGlzKTtcblxuICAgIHZhciB6b29tID0gdGhpcy56b29tO1xuICAgIHZhciBwbGFjZW1lbnRab29tID0gTWF0aC5tYXgoTWF0aC5sb2coc2NhbGUpIC8gTWF0aC5MTjIgKyB6b29tLCAwKTtcblxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgcXVhZHMubGVuZ3RoOyBrKyspIHtcblxuICAgICAgICB2YXIgc3ltYm9sID0gcXVhZHNba10sXG4gICAgICAgICAgICBhbmdsZSA9IHN5bWJvbC5hbmdsZTtcblxuICAgICAgICAvLyBkcm9wIHVwc2lkZSBkb3duIHZlcnNpb25zIG9mIGdseXBoc1xuICAgICAgICB2YXIgYSA9IChhbmdsZSArIHBsYWNlbWVudEFuZ2xlICsgTWF0aC5QSSkgJSAoTWF0aC5QSSAqIDIpO1xuICAgICAgICBpZiAoa2VlcFVwcmlnaHQgJiYgYWxvbmdMaW5lICYmIChhIDw9IE1hdGguUEkgLyAyIHx8IGEgPiBNYXRoLlBJICogMyAvIDIpKSBjb250aW51ZTtcblxuICAgICAgICB2YXIgdGwgPSBzeW1ib2wudGwsXG4gICAgICAgICAgICB0ciA9IHN5bWJvbC50cixcbiAgICAgICAgICAgIGJsID0gc3ltYm9sLmJsLFxuICAgICAgICAgICAgYnIgPSBzeW1ib2wuYnIsXG4gICAgICAgICAgICB0ZXggPSBzeW1ib2wudGV4LFxuICAgICAgICAgICAgYW5jaG9yUG9pbnQgPSBzeW1ib2wuYW5jaG9yUG9pbnQsXG5cbiAgICAgICAgICAgIG1pblpvb20gPSBNYXRoLm1heCh6b29tICsgTWF0aC5sb2coc3ltYm9sLm1pblNjYWxlKSAvIE1hdGguTE4yLCBwbGFjZW1lbnRab29tKSxcbiAgICAgICAgICAgIG1heFpvb20gPSBNYXRoLm1pbih6b29tICsgTWF0aC5sb2coc3ltYm9sLm1heFNjYWxlKSAvIE1hdGguTE4yLCAyNSk7XG5cbiAgICAgICAgaWYgKG1heFpvb20gPD0gbWluWm9vbSkgY29udGludWU7XG5cbiAgICAgICAgLy8gTG93ZXIgbWluIHpvb20gc28gdGhhdCB3aGlsZSBmYWRpbmcgb3V0IHRoZSBsYWJlbCBpdCBjYW4gYmUgc2hvd24gb3V0c2lkZSBvZiBjb2xsaXNpb24tZnJlZSB6b29tIGxldmVsc1xuICAgICAgICBpZiAobWluWm9vbSA9PT0gcGxhY2VtZW50Wm9vbSkgbWluWm9vbSA9IDA7XG5cbiAgICAgICAgdmFyIGluZGV4ID0gYWRkVmVydGV4KGFuY2hvclBvaW50LngsIGFuY2hvclBvaW50LnksIHRsLngsIHRsLnksIHRleC54LCB0ZXgueSwgbWluWm9vbSwgbWF4Wm9vbSwgcGxhY2VtZW50Wm9vbSkgLSBncm91cC52ZXJ0ZXhTdGFydEluZGV4O1xuICAgICAgICBhZGRWZXJ0ZXgoYW5jaG9yUG9pbnQueCwgYW5jaG9yUG9pbnQueSwgdHIueCwgdHIueSwgdGV4LnggKyB0ZXgudywgdGV4LnksIG1pblpvb20sIG1heFpvb20sIHBsYWNlbWVudFpvb20pO1xuICAgICAgICBhZGRWZXJ0ZXgoYW5jaG9yUG9pbnQueCwgYW5jaG9yUG9pbnQueSwgYmwueCwgYmwueSwgdGV4LngsIHRleC55ICsgdGV4LmgsIG1pblpvb20sIG1heFpvb20sIHBsYWNlbWVudFpvb20pO1xuICAgICAgICBhZGRWZXJ0ZXgoYW5jaG9yUG9pbnQueCwgYW5jaG9yUG9pbnQueSwgYnIueCwgYnIueSwgdGV4LnggKyB0ZXgudywgdGV4LnkgKyB0ZXguaCwgbWluWm9vbSwgbWF4Wm9vbSwgcGxhY2VtZW50Wm9vbSk7XG4gICAgICAgIGdyb3VwLnZlcnRleExlbmd0aCArPSA0O1xuXG4gICAgICAgIGFkZEVsZW1lbnQoaW5kZXgsIGluZGV4ICsgMSwgaW5kZXggKyAyKTtcbiAgICAgICAgYWRkRWxlbWVudChpbmRleCArIDEsIGluZGV4ICsgMiwgaW5kZXggKyAzKTtcbiAgICAgICAgZ3JvdXAuZWxlbWVudExlbmd0aCArPSAyO1xuICAgIH1cblxufTtcblxuU3ltYm9sQnVja2V0LnByb3RvdHlwZS51cGRhdGVJY29ucyA9IGZ1bmN0aW9uKGljb25zKSB7XG4gICAgdmFyIGljb25WYWx1ZSA9IHRoaXMubGF5b3V0UHJvcGVydGllc1snaWNvbi1pbWFnZSddO1xuICAgIGlmICghaWNvblZhbHVlKSByZXR1cm47XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGljb25OYW1lID0gcmVzb2x2ZVRva2Vucyh0aGlzLmZlYXR1cmVzW2ldLnByb3BlcnRpZXMsIGljb25WYWx1ZSk7XG4gICAgICAgIGlmIChpY29uTmFtZSlcbiAgICAgICAgICAgIGljb25zW2ljb25OYW1lXSA9IHRydWU7XG4gICAgfVxufTtcblxuU3ltYm9sQnVja2V0LnByb3RvdHlwZS51cGRhdGVGb250ID0gZnVuY3Rpb24oc3RhY2tzKSB7XG4gICAgdmFyIGZvbnROYW1lID0gdGhpcy5sYXlvdXRQcm9wZXJ0aWVzWyd0ZXh0LWZvbnQnXSxcbiAgICAgICAgc3RhY2sgPSBzdGFja3NbZm9udE5hbWVdID0gc3RhY2tzW2ZvbnROYW1lXSB8fCB7fTtcblxuICAgIHRoaXMudGV4dEZlYXR1cmVzID0gcmVzb2x2ZVRleHQodGhpcy5mZWF0dXJlcywgdGhpcy5sYXlvdXRQcm9wZXJ0aWVzLCBzdGFjayk7XG59O1xuXG5TeW1ib2xCdWNrZXQucHJvdG90eXBlLmFkZFRvRGVidWdCdWZmZXJzID0gZnVuY3Rpb24oY29sbGlzaW9uVGlsZSkge1xuICAgIHRoaXMuZWxlbWVudEdyb3Vwcy5jb2xsaXNpb25Cb3ggPSBuZXcgRWxlbWVudEdyb3Vwcyh0aGlzLmJ1ZmZlcnMuY29sbGlzaW9uQm94VmVydGV4KTtcbiAgICB2YXIgZ3JvdXAgPSB0aGlzLm1ha2VSb29tRm9yKCdjb2xsaXNpb25Cb3gnLCA4KTtcbiAgICB2YXIgYW5nbGUgPSAtY29sbGlzaW9uVGlsZS5hbmdsZTtcbiAgICB2YXIgeVN0cmV0Y2ggPSBjb2xsaXNpb25UaWxlLnlTdHJldGNoO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLnN5bWJvbEluc3RhbmNlcy5sZW5ndGg7IGorKykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI7IGkrKykge1xuICAgICAgICAgICAgdmFyIGZlYXR1cmUgPSB0aGlzLnN5bWJvbEluc3RhbmNlc1tqXVtpID09PSAwID8gJ3RleHRDb2xsaXNpb25GZWF0dXJlJyA6ICdpY29uQ29sbGlzaW9uRmVhdHVyZSddO1xuICAgICAgICAgICAgaWYgKCFmZWF0dXJlKSBjb250aW51ZTtcbiAgICAgICAgICAgIHZhciBib3hlcyA9IGZlYXR1cmUuYm94ZXM7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGIgPSAwOyBiIDwgYm94ZXMubGVuZ3RoOyBiKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgYm94ID0gYm94ZXNbYl07XG4gICAgICAgICAgICAgICAgdmFyIGFuY2hvclBvaW50ID0gYm94LmFuY2hvclBvaW50O1xuXG4gICAgICAgICAgICAgICAgdmFyIHRsID0gbmV3IFBvaW50KGJveC54MSwgYm94LnkxICogeVN0cmV0Y2gpLl9yb3RhdGUoYW5nbGUpO1xuICAgICAgICAgICAgICAgIHZhciB0ciA9IG5ldyBQb2ludChib3gueDIsIGJveC55MSAqIHlTdHJldGNoKS5fcm90YXRlKGFuZ2xlKTtcbiAgICAgICAgICAgICAgICB2YXIgYmwgPSBuZXcgUG9pbnQoYm94LngxLCBib3gueTIgKiB5U3RyZXRjaCkuX3JvdGF0ZShhbmdsZSk7XG4gICAgICAgICAgICAgICAgdmFyIGJyID0gbmV3IFBvaW50KGJveC54MiwgYm94LnkyICogeVN0cmV0Y2gpLl9yb3RhdGUoYW5nbGUpO1xuXG4gICAgICAgICAgICAgICAgdmFyIG1heFpvb20gPSBNYXRoLm1heCgwLCBNYXRoLm1pbigyNSwgdGhpcy56b29tICsgTWF0aC5sb2coYm94Lm1heFNjYWxlKSAvIE1hdGguTE4yKSk7XG4gICAgICAgICAgICAgICAgdmFyIHBsYWNlbWVudFpvb20gPSBNYXRoLm1heCgwLCBNYXRoLm1pbigyNSwgdGhpcy56b29tICsgTWF0aC5sb2coYm94LnBsYWNlbWVudFNjYWxlKSAvIE1hdGguTE4yKSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmFkZENvbGxpc2lvbkJveFZlcnRleChhbmNob3JQb2ludCwgdGwsIG1heFpvb20sIHBsYWNlbWVudFpvb20pO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ29sbGlzaW9uQm94VmVydGV4KGFuY2hvclBvaW50LCB0ciwgbWF4Wm9vbSwgcGxhY2VtZW50Wm9vbSk7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRDb2xsaXNpb25Cb3hWZXJ0ZXgoYW5jaG9yUG9pbnQsIHRyLCBtYXhab29tLCBwbGFjZW1lbnRab29tKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZENvbGxpc2lvbkJveFZlcnRleChhbmNob3JQb2ludCwgYnIsIG1heFpvb20sIHBsYWNlbWVudFpvb20pO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ29sbGlzaW9uQm94VmVydGV4KGFuY2hvclBvaW50LCBiciwgbWF4Wm9vbSwgcGxhY2VtZW50Wm9vbSk7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRDb2xsaXNpb25Cb3hWZXJ0ZXgoYW5jaG9yUG9pbnQsIGJsLCBtYXhab29tLCBwbGFjZW1lbnRab29tKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZENvbGxpc2lvbkJveFZlcnRleChhbmNob3JQb2ludCwgYmwsIG1heFpvb20sIHBsYWNlbWVudFpvb20pO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ29sbGlzaW9uQm94VmVydGV4KGFuY2hvclBvaW50LCB0bCwgbWF4Wm9vbSwgcGxhY2VtZW50Wm9vbSk7XG4gICAgICAgICAgICAgICAgZ3JvdXAudmVydGV4TGVuZ3RoICs9IDg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5mdW5jdGlvbiBTeW1ib2xJbnN0YW5jZShhbmNob3IsIGxpbmUsIHNoYXBlZFRleHQsIHNoYXBlZEljb24sIGxheW91dCwgYWRkVG9CdWZmZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dEJveFNjYWxlLCB0ZXh0UGFkZGluZywgdGV4dEFsb25nTGluZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGljb25Cb3hTY2FsZSwgaWNvblBhZGRpbmcsIGljb25BbG9uZ0xpbmUpIHtcblxuICAgIHRoaXMueCA9IGFuY2hvci54O1xuICAgIHRoaXMueSA9IGFuY2hvci55O1xuICAgIHRoaXMuaGFzVGV4dCA9ICEhc2hhcGVkVGV4dDtcbiAgICB0aGlzLmhhc0ljb24gPSAhIXNoYXBlZEljb247XG5cbiAgICBpZiAodGhpcy5oYXNUZXh0KSB7XG4gICAgICAgIHRoaXMuZ2x5cGhRdWFkcyA9IGFkZFRvQnVmZmVycyA/IGdldEdseXBoUXVhZHMoYW5jaG9yLCBzaGFwZWRUZXh0LCB0ZXh0Qm94U2NhbGUsIGxpbmUsIGxheW91dCwgdGV4dEFsb25nTGluZSkgOiBbXTtcbiAgICAgICAgdGhpcy50ZXh0Q29sbGlzaW9uRmVhdHVyZSA9IG5ldyBDb2xsaXNpb25GZWF0dXJlKGxpbmUsIGFuY2hvciwgc2hhcGVkVGV4dCwgdGV4dEJveFNjYWxlLCB0ZXh0UGFkZGluZywgdGV4dEFsb25nTGluZSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaGFzSWNvbikge1xuICAgICAgICB0aGlzLmljb25RdWFkcyA9IGFkZFRvQnVmZmVycyA/IGdldEljb25RdWFkcyhhbmNob3IsIHNoYXBlZEljb24sIGljb25Cb3hTY2FsZSwgbGluZSwgbGF5b3V0LCBpY29uQWxvbmdMaW5lKSA6IFtdO1xuICAgICAgICB0aGlzLmljb25Db2xsaXNpb25GZWF0dXJlID0gbmV3IENvbGxpc2lvbkZlYXR1cmUobGluZSwgYW5jaG9yLCBzaGFwZWRJY29uLCBpY29uQm94U2NhbGUsIGljb25QYWRkaW5nLCBpY29uQWxvbmdMaW5lKTtcbiAgICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29vcmRpbmF0ZTtcblxuLyoqXG4gKiBBIGNvb3JkaW5hdGUgaXMgYSBjb2x1bW4sIHJvdywgem9vbSBjb21iaW5hdGlvbiwgb2Z0ZW4gdXNlZFxuICogYXMgdGhlIGRhdGEgY29tcG9uZW50IG9mIGEgdGlsZS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gY29sdW1uXG4gKiBAcGFyYW0ge251bWJlcn0gcm93XG4gKiBAcGFyYW0ge251bWJlcn0gem9vbVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gQ29vcmRpbmF0ZShjb2x1bW4sIHJvdywgem9vbSkge1xuICAgIHRoaXMuY29sdW1uID0gY29sdW1uO1xuICAgIHRoaXMucm93ID0gcm93O1xuICAgIHRoaXMuem9vbSA9IHpvb207XG59XG5cbkNvb3JkaW5hdGUucHJvdG90eXBlID0ge1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgY2xvbmUgb2YgdGhpcyBjb29yZGluYXRlIHRoYXQgY2FuIGJlIG11dGF0ZWQgd2l0aG91dFxuICAgICAqIGNoYW5naW5nIHRoZSBvcmlnaW5hbCBjb29yZGluYXRlXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Q29vcmRpbmF0ZX0gY2xvbmVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIHZhciBjb29yZCA9IG5ldyBDb29yZGluYXRlKDAsIDAsIDApO1xuICAgICAqIHZhciBjMiA9IGNvb3JkLmNsb25lKCk7XG4gICAgICogLy8gc2luY2UgY29vcmQgaXMgY2xvbmVkLCBtb2RpZnlpbmcgYSBwcm9wZXJ0eSBvZiBjMiBkb2VzXG4gICAgICogLy8gbm90IG1vZGlmeSBpdC5cbiAgICAgKiBjMi56b29tID0gMjtcbiAgICAgKi9cbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29vcmRpbmF0ZSh0aGlzLmNvbHVtbiwgdGhpcy5yb3csIHRoaXMuem9vbSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFpvb20gdGhpcyBjb29yZGluYXRlIHRvIGEgZ2l2ZW4gem9vbSBsZXZlbC4gVGhpcyByZXR1cm5zIGEgbmV3XG4gICAgICogY29vcmRpbmF0ZSBvYmplY3QsIG5vdCBtdXRhdGluZyB0aGUgb2xkIG9uZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB6b29tXG4gICAgICogQHJldHVybnMge0Nvb3JkaW5hdGV9IHpvb21lZCBjb29yZGluYXRlXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciBjb29yZCA9IG5ldyBDb29yZGluYXRlKDAsIDAsIDApO1xuICAgICAqIHZhciBjMiA9IGNvb3JkLnpvb21UbygxKTtcbiAgICAgKiBjMiAvLyBlcXVhbHMgbmV3IENvb3JkaW5hdGUoMCwgMCwgMSk7XG4gICAgICovXG4gICAgem9vbVRvOiBmdW5jdGlvbih6b29tKSB7IHJldHVybiB0aGlzLmNsb25lKCkuX3pvb21Ubyh6b29tKTsgfSxcblxuICAgIC8qKlxuICAgICAqIFN1YnRyYWN0IHRoZSBjb2x1bW4gYW5kIHJvdyB2YWx1ZXMgb2YgdGhpcyBjb29yZGluYXRlIGZyb20gdGhvc2VcbiAgICAgKiBvZiBhbm90aGVyIGNvb3JkaW5hdGUuIFRoZSBvdGhlciBjb29yZGluYXQgd2lsbCBiZSB6b29tZWQgdG8gdGhlXG4gICAgICogc2FtZSBsZXZlbCBhcyBgdGhpc2AgYmVmb3JlIHRoZSBzdWJ0cmFjdGlvbiBvY2N1cnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q29vcmRpbmF0ZX0gYyBvdGhlciBjb29yZGluYXRlXG4gICAgICogQHJldHVybnMge0Nvb3JkaW5hdGV9IHJlc3VsdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgc3ViOiBmdW5jdGlvbihjKSB7IHJldHVybiB0aGlzLmNsb25lKCkuX3N1YihjKTsgfSxcblxuICAgIF96b29tVG86IGZ1bmN0aW9uKHpvb20pIHtcbiAgICAgICAgdmFyIHNjYWxlID0gTWF0aC5wb3coMiwgem9vbSAtIHRoaXMuem9vbSk7XG4gICAgICAgIHRoaXMuY29sdW1uICo9IHNjYWxlO1xuICAgICAgICB0aGlzLnJvdyAqPSBzY2FsZTtcbiAgICAgICAgdGhpcy56b29tID0gem9vbTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF9zdWI6IGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgYyA9IGMuem9vbVRvKHRoaXMuem9vbSk7XG4gICAgICAgIHRoaXMuY29sdW1uIC09IGMuY29sdW1uO1xuICAgICAgICB0aGlzLnJvdyAtPSBjLnJvdztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBMbmdMYXQ7XG5cbnZhciB3cmFwID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJykud3JhcDtcblxuLyoqXG4gKiBDcmVhdGUgYSBsb25naXR1ZGUsIGxhdGl0dWRlIG9iamVjdCBmcm9tIGEgZ2l2ZW4gbG9uZ2l0dWRlIGFuZCBsYXRpdHVkZSBwYWlyIGluIGRlZ3JlZXMuXG4gKiBNYXBib3ggR0wgdXNlcyBMb25naXR1ZGUsIExhdGl0dWRlIGNvb3JkaW5hdGUgb3JkZXIgdG8gbWF0Y2ggR2VvSlNPTi5cbiAqXG4gKiBOb3RlIHRoYXQgYW55IE1hcGJveCBHTCBtZXRob2QgdGhhdCBhY2NlcHRzIGEgYExuZ0xhdGAgb2JqZWN0IGNhbiBhbHNvIGFjY2VwdCBhblxuICogYEFycmF5YCBhbmQgd2lsbCBwZXJmb3JtIGFuIGltcGxpY2l0IGNvbnZlcnNpb24uICBUaGUgZm9sbG93aW5nIGxpbmVzIGFyZSBlcXVpdmFsZW50OlxuIGBgYFxuIG1hcC5zZXRDZW50ZXIoWy03My45NzQ5LCA0MC43NzM2XSk7XG4gbWFwLnNldENlbnRlciggbmV3IG1hcGJveGdsLkxuZ0xhdCgtNzMuOTc0OSwgNDAuNzczNikgKTtcbiBgYGBcbiAqXG4gKiBAY2xhc3MgTG5nTGF0XG4gKiBAY2xhc3NkZXNjIEEgcmVwcmVzZW50YXRpb24gb2YgYSBsb25naXR1ZGUsIGxhdGl0dWRlIHBvaW50LCBpbiBkZWdyZWVzLlxuICogQHBhcmFtIHtudW1iZXJ9IGxuZyBsb25naXR1ZGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBsYXQgbGF0aXR1ZGVcbiAqIEBleGFtcGxlXG4gKiB2YXIgbGwgPSBuZXcgbWFwYm94Z2wuTG5nTGF0KC03My45NzQ5LCA0MC43NzM2KTtcbiAqL1xuZnVuY3Rpb24gTG5nTGF0KGxuZywgbGF0KSB7XG4gICAgaWYgKGlzTmFOKGxuZykgfHwgaXNOYU4obGF0KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgTG5nTGF0IG9iamVjdDogKCcgKyBsbmcgKyAnLCAnICsgbGF0ICsgJyknKTtcbiAgICB9XG4gICAgdGhpcy5sbmcgPSArbG5nO1xuICAgIHRoaXMubGF0ID0gK2xhdDtcbiAgICBpZiAodGhpcy5sYXQgPiA5MCB8fCB0aGlzLmxhdCA8IC05MCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgTG5nTGF0IGxhdGl0dWRlIHZhbHVlOiBtdXN0IGJlIGJldHdlZW4gLTkwIGFuZCA5MCcpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBSZXR1cm4gYSBuZXcgYExuZ0xhdGAgb2JqZWN0IHdob3NlIGxvbmdpdHVkZSBpcyB3cmFwcGVkIHRvIHRoZSByYW5nZSAoLTE4MCwgMTgwKS5cbiAqXG4gKiBAcmV0dXJucyB7TG5nTGF0fSB3cmFwcGVkIExuZ0xhdCBvYmplY3RcbiAqIEBleGFtcGxlXG4gKiB2YXIgbGwgPSBuZXcgbWFwYm94Z2wuTG5nTGF0KDI4Ni4wMjUxLCA0MC43NzM2KTtcbiAqIHZhciB3cmFwcGVkID0gbGwud3JhcCgpO1xuICogd3JhcHBlZC5sbmc7IC8vID0gLTczLjk3NDlcbiAqL1xuTG5nTGF0LnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgTG5nTGF0KHdyYXAodGhpcy5sbmcsIC0xODAsIDE4MCksIHRoaXMubGF0KTtcbn07XG5cbi8qKlxuICogUmV0dXJuIGEgYExuZ0xhdGAgYXMgYW4gYXJyYXlcbiAqXG4gKiBAcmV0dXJucyB7YXJyYXl9IFtsbmcsIGxhdF1cbiAqIEBleGFtcGxlXG4gKiB2YXIgbGwgPSBuZXcgbWFwYm94Z2wuTG5nTGF0KC03My45NzQ5LCA0MC43NzM2KTtcbiAqIGxsLnRvQXJyYXkoKTsgLy8gPSBbLTczLjk3NDksIDQwLjc3MzZdXG4gKi9cbkxuZ0xhdC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gW3RoaXMubG5nLCB0aGlzLmxhdF07XG59O1xuXG4vKipcbiAqIFJldHVybiBhIGBMbmdMYXRgIGFzIGEgc3RyaW5nXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gXCJMbmdMYXQobG5nLCBsYXQpXCJcbiAqIEBleGFtcGxlXG4gKiB2YXIgbGwgPSBuZXcgbWFwYm94Z2wuTG5nTGF0KC03My45NzQ5LCA0MC43NzM2KTtcbiAqIGxsLnRvU3RyaW5nKCk7IC8vID0gXCJMbmdMYXQoLTczLjk3NDksIDQwLjc3MzYpXCJcbiAqL1xuTG5nTGF0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gJ0xuZ0xhdCgnICsgdGhpcy5sbmcgKyAnLCAnICsgdGhpcy5sYXQgKyAnKSc7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgYW4gYXJyYXkgdG8gYSBgTG5nTGF0YCBvYmplY3QsIG9yIHJldHVybiBhbiBleGlzdGluZyBgTG5nTGF0YCBvYmplY3RcbiAqIHVuY2hhbmdlZC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj58TG5nTGF0fSBpbnB1dCBgaW5wdXRgIHRvIGNvbnZlcnRcbiAqIEByZXR1cm5zIHtMbmdMYXR9IExuZ0xhdCBvYmplY3Qgb3Igb3JpZ2luYWwgaW5wdXRcbiAqIEBleGFtcGxlXG4gKiB2YXIgYXJyID0gWy03My45NzQ5LCA0MC43NzM2XTtcbiAqIHZhciBsbCA9IG1hcGJveGdsLkxuZ0xhdC5jb252ZXJ0KGFycik7XG4gKiBsbDsgICAvLyA9IExuZ0xhdCB7bG5nOiAtNzMuOTc0OSwgbGF0OiA0MC43NzM2fVxuICovXG5MbmdMYXQuY29udmVydCA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIExuZ0xhdCkge1xuICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgICByZXR1cm4gbmV3IExuZ0xhdChpbnB1dFswXSwgaW5wdXRbMV0pO1xuICAgIH1cbiAgICByZXR1cm4gaW5wdXQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExuZ0xhdEJvdW5kcztcblxudmFyIExuZ0xhdCA9IHJlcXVpcmUoJy4vbG5nX2xhdCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBib3VuZGluZyBib3ggZnJvbSB0aGUgZ2l2ZW4gcGFpciBvZiBwb2ludHMuIElmIHBhcmFtZXRlcmVzIGFyZSBvbWl0dGVkLCBhIGBudWxsYCBib3VuZGluZyBib3ggaXMgY3JlYXRlZC5cbiAqXG4gKiBAY2xhc3MgTG5nTGF0Qm91bmRzXG4gKiBAY2xhc3NkZXNjIEEgcmVwcmVzZW50YXRpb24gb2YgcmVjdGFuZ3VsYXIgYm94IG9uIHRoZSBlYXJ0aCwgZGVmaW5lZCBieSBpdHMgc291dGh3ZXN0IGFuZCBub3J0aGVhc3QgcG9pbnRzIGluIGxvbmdpdHVkZSBhbmQgbGF0aXR1ZGUuXG4gKiBAcGFyYW0ge0xuZ0xhdH0gc3cgc291dGh3ZXN0XG4gKiBAcGFyYW0ge0xuZ0xhdH0gbmUgbm9ydGhlYXN0XG4gKiBAZXhhbXBsZVxuICogdmFyIHN3ID0gbmV3IG1hcGJveGdsLkxuZ0xhdCgtNzMuOTg3NiwgNDAuNzY2MSk7XG4gKiB2YXIgbmUgPSBuZXcgbWFwYm94Z2wuTG5nTGF0KC03My45Mzk3LCA0MC44MDAyKTtcbiAqIHZhciBsbGIgPSBuZXcgbWFwYm94Z2wuTG5nTGF0Qm91bmRzKHN3LCBuZSk7XG4gKi9cbmZ1bmN0aW9uIExuZ0xhdEJvdW5kcyhzdywgbmUpIHtcbiAgICBpZiAoIXN3KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKG5lKSB7XG4gICAgICAgIHRoaXMuZXh0ZW5kKHN3KS5leHRlbmQobmUpO1xuICAgIH0gZWxzZSBpZiAoc3cubGVuZ3RoID09PSA0KSB7XG4gICAgICAgIHRoaXMuZXh0ZW5kKFtzd1swXSwgc3dbMV1dKS5leHRlbmQoW3N3WzJdLCBzd1szXV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZXh0ZW5kKHN3WzBdKS5leHRlbmQoc3dbMV0pO1xuICAgIH1cbn1cblxuTG5nTGF0Qm91bmRzLnByb3RvdHlwZSA9IHtcblxuICAgIC8qKlxuICAgICAqIEV4dGVuZCB0aGUgYm91bmRzIHRvIGluY2x1ZGUgYSBnaXZlbiBMbmdMYXQgb3IgTG5nTGF0Qm91bmRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtMbmdMYXR8TG5nTGF0Qm91bmRzfSBvYmogb2JqZWN0IHRvIGV4dGVuZCB0b1xuICAgICAqIEByZXR1cm5zIHtMbmdMYXRCb3VuZHN9IGB0aGlzYFxuICAgICAqL1xuICAgIGV4dGVuZDogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIHZhciBzdyA9IHRoaXMuX3N3LFxuICAgICAgICAgICAgbmUgPSB0aGlzLl9uZSxcbiAgICAgICAgICAgIHN3MiwgbmUyO1xuXG4gICAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBMbmdMYXQpIHtcbiAgICAgICAgICAgIHN3MiA9IG9iajtcbiAgICAgICAgICAgIG5lMiA9IG9iajtcblxuICAgICAgICB9IGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIExuZ0xhdEJvdW5kcykge1xuICAgICAgICAgICAgc3cyID0gb2JqLl9zdztcbiAgICAgICAgICAgIG5lMiA9IG9iai5fbmU7XG5cbiAgICAgICAgICAgIGlmICghc3cyIHx8ICFuZTIpIHJldHVybiB0aGlzO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqID8gdGhpcy5leHRlbmQoTG5nTGF0LmNvbnZlcnQob2JqKSB8fCBMbmdMYXRCb3VuZHMuY29udmVydChvYmopKSA6IHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXN3ICYmICFuZSkge1xuICAgICAgICAgICAgdGhpcy5fc3cgPSBuZXcgTG5nTGF0KHN3Mi5sbmcsIHN3Mi5sYXQpO1xuICAgICAgICAgICAgdGhpcy5fbmUgPSBuZXcgTG5nTGF0KG5lMi5sbmcsIG5lMi5sYXQpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdy5sbmcgPSBNYXRoLm1pbihzdzIubG5nLCBzdy5sbmcpO1xuICAgICAgICAgICAgc3cubGF0ID0gTWF0aC5taW4oc3cyLmxhdCwgc3cubGF0KTtcbiAgICAgICAgICAgIG5lLmxuZyA9IE1hdGgubWF4KG5lMi5sbmcsIG5lLmxuZyk7XG4gICAgICAgICAgICBuZS5sYXQgPSBNYXRoLm1heChuZTIubGF0LCBuZS5sYXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcG9pbnQgZXF1aWRpc3RhbnQgZnJvbSB0aGlzIGJveCdzIGNvcm5lcnNcbiAgICAgKiBAcmV0dXJucyB7TG5nTGF0fSBjZW50ZXJwb2ludFxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIGxsYiA9IG5ldyBtYXBib3hnbC5MbmdMYXRCb3VuZHMoWy03My45ODc2LCA0MC43NjYxXSwgWy03My45Mzk3LCA0MC44MDAyXSk7XG4gICAgICogbGxiLmdldENlbnRlcigpOyAvLyA9IExuZ0xhdCB7bG5nOiAtNzMuOTYzNjUsIGxhdDogNDAuNzgzMTV9XG4gICAgICovXG4gICAgZ2V0Q2VudGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMbmdMYXQoKHRoaXMuX3N3LmxuZyArIHRoaXMuX25lLmxuZykgLyAyLCAodGhpcy5fc3cubGF0ICsgdGhpcy5fbmUubGF0KSAvIDIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgc291dGh3ZXN0IGNvcm5lclxuICAgICAqIEByZXR1cm5zIHtMbmdMYXR9IHNvdXRod2VzdFxuICAgICAqL1xuICAgIGdldFNvdXRoV2VzdDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLl9zdzsgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBub3J0aGVhc3QgY29ybmVyXG4gICAgICogQHJldHVybnMge0xuZ0xhdH0gbm9ydGhlYXN0XG4gICAgICovXG4gICAgZ2V0Tm9ydGhFYXN0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuX25lOyB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IG5vcnRod2VzdCBjb3JuZXJcbiAgICAgKiBAcmV0dXJucyB7TG5nTGF0fSBub3J0aHdlc3RcbiAgICAgKi9cbiAgICBnZXROb3J0aFdlc3Q6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbmV3IExuZ0xhdCh0aGlzLmdldFdlc3QoKSwgdGhpcy5nZXROb3J0aCgpKTsgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBzb3V0aGVhc3QgY29ybmVyXG4gICAgICogQHJldHVybnMge0xuZ0xhdH0gc291dGhlYXN0XG4gICAgICovXG4gICAgZ2V0U291dGhFYXN0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG5ldyBMbmdMYXQodGhpcy5nZXRFYXN0KCksIHRoaXMuZ2V0U291dGgoKSk7IH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgd2VzdCBlZGdlIGxvbmdpdHVkZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHdlc3RcbiAgICAgKi9cbiAgICBnZXRXZXN0OiAgZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLl9zdy5sbmc7IH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgc291dGggZWRnZSBsYXRpdHVkZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHNvdXRoXG4gICAgICovXG4gICAgZ2V0U291dGg6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5fc3cubGF0OyB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGVhc3QgZWRnZSBsb25naXR1ZGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBlYXN0XG4gICAgICovXG4gICAgZ2V0RWFzdDogIGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5fbmUubG5nOyB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IG5vcnRoIGVkZ2UgbGF0aXR1ZGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBub3J0aFxuICAgICAqL1xuICAgIGdldE5vcnRoOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuX25lLmxhdDsgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIGBMbmdMYXRCb3VuZHNgIGFzIGFuIGFycmF5XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7YXJyYXl9IFtsbmcsIGxhdF1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciBsbGIgPSBuZXcgbWFwYm94Z2wuTG5nTGF0Qm91bmRzKFstNzMuOTg3NiwgNDAuNzY2MV0sIFstNzMuOTM5NywgNDAuODAwMl0pO1xuICAgICAqIGxsYi50b0FycmF5KCk7IC8vID0gW1stNzMuOTg3NiwgNDAuNzY2MV0sIFstNzMuOTM5NywgNDAuODAwMl1dXG4gICAgICovXG4gICAgdG9BcnJheTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW3RoaXMuX3N3LnRvQXJyYXkoKSwgdGhpcy5fbmUudG9BcnJheSgpXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgYExuZ0xhdEJvdW5kc2AgYXMgYSBzdHJpbmdcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFwiTG5nTGF0Qm91bmRzKExuZ0xhdChsbmcsIGxhdCksIExuZ0xhdChsbmcsIGxhdCkpXCJcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciBsbGIgPSBuZXcgbWFwYm94Z2wuTG5nTGF0Qm91bmRzKFstNzMuOTg3NiwgNDAuNzY2MV0sIFstNzMuOTM5NywgNDAuODAwMl0pO1xuICAgICAqIGxsYi50b1N0cmluZygpOyAvLyA9IFwiTG5nTGF0Qm91bmRzKExuZ0xhdCgtNzMuOTg3NiwgNDAuNzY2MSksIExuZ0xhdCgtNzMuOTM5NywgNDAuODAwMikpXCJcbiAgICAgKi9cbiAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0xuZ0xhdEJvdW5kcygnICsgdGhpcy5fc3cudG9TdHJpbmcoKSArICcsICcgKyB0aGlzLl9uZS50b1N0cmluZygpICsgJyknO1xuICAgIH1cbn07XG5cbi8qKlxuICogQ29udmVydCBhbiBhcnJheSB0byBhIGBMbmdMYXRCb3VuZHNgIG9iamVjdCwgb3IgcmV0dXJuIGFuIGV4aXN0aW5nXG4gKiBgTG5nTGF0Qm91bmRzYCBvYmplY3QgdW5jaGFuZ2VkLlxuICpcbiAqIENhbGxzIGBMbmdMYXQjY29udmVydGAgaW50ZXJuYWxseSB0byBjb252ZXJ0IGFycmF5cyBhcyBgTG5nTGF0YCB2YWx1ZXMuXG4gKlxuICogQHBhcmFtIHtMbmdMYXRCb3VuZHN8QXJyYXk8bnVtYmVyPnxBcnJheTxBcnJheTxudW1iZXI+Pn0gaW5wdXQgaW5wdXQgdG8gY29udmVydCB0byBhIExuZ0xhdEJvdW5kc1xuICogQHJldHVybnMge0xuZ0xhdEJvdW5kc30gTG5nTGF0Qm91bmRzIG9iamVjdCBvciBvcmlnaW5hbCBpbnB1dFxuICogQGV4YW1wbGVcbiAqIHZhciBhcnIgPSBbWy03My45ODc2LCA0MC43NjYxXSwgWy03My45Mzk3LCA0MC44MDAyXV07XG4gKiB2YXIgbGxiID0gbWFwYm94Z2wuTG5nTGF0Qm91bmRzLmNvbnZlcnQoYXJyKTtcbiAqIGxsYjsgICAvLyA9IExuZ0xhdEJvdW5kcyB7X3N3OiBMbmdMYXQge2xuZzogLTczLjk4NzYsIGxhdDogNDAuNzY2MX0sIF9uZTogTG5nTGF0IHtsbmc6IC03My45Mzk3LCBsYXQ6IDQwLjgwMDJ9fVxuICovXG5MbmdMYXRCb3VuZHMuY29udmVydCA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIGlmICghaW5wdXQgfHwgaW5wdXQgaW5zdGFuY2VvZiBMbmdMYXRCb3VuZHMpIHJldHVybiBpbnB1dDtcbiAgICByZXR1cm4gbmV3IExuZ0xhdEJvdW5kcyhpbnB1dCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgTG5nTGF0ID0gcmVxdWlyZSgnLi9sbmdfbGF0JyksXG4gICAgUG9pbnQgPSByZXF1aXJlKCdwb2ludC1nZW9tZXRyeScpLFxuICAgIENvb3JkaW5hdGUgPSByZXF1aXJlKCcuL2Nvb3JkaW5hdGUnKSxcbiAgICB3cmFwID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJykud3JhcCxcbiAgICBpbnRlcnAgPSByZXF1aXJlKCcuLi91dGlsL2ludGVycG9sYXRlJyksXG4gICAgZ2xtYXRyaXggPSByZXF1aXJlKCdnbC1tYXRyaXgnKTtcblxudmFyIHZlYzQgPSBnbG1hdHJpeC52ZWM0LFxuICAgIG1hdDQgPSBnbG1hdHJpeC5tYXQ0LFxuICAgIG1hdDIgPSBnbG1hdHJpeC5tYXQyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybTtcblxuLypcbiAqIEEgc2luZ2xlIHRyYW5zZm9ybSwgZ2VuZXJhbGx5IHVzZWQgZm9yIGEgc2luZ2xlIHRpbGUgdG8gYmVcbiAqIHNjYWxlZCwgcm90YXRlZCwgYW5kIHpvb21lZC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gbWluWm9vbVxuICogQHBhcmFtIHtudW1iZXJ9IG1heFpvb21cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIFRyYW5zZm9ybShtaW5ab29tLCBtYXhab29tKSB7XG4gICAgdGhpcy50aWxlU2l6ZSA9IDUxMjsgLy8gY29uc3RhbnRcblxuICAgIHRoaXMuX21pblpvb20gPSBtaW5ab29tIHx8IDA7XG4gICAgdGhpcy5fbWF4Wm9vbSA9IG1heFpvb20gfHwgMjI7XG5cbiAgICB0aGlzLmxhdFJhbmdlID0gWy04NS4wNTExMywgODUuMDUxMTNdO1xuXG4gICAgdGhpcy53aWR0aCA9IDA7XG4gICAgdGhpcy5oZWlnaHQgPSAwO1xuICAgIHRoaXMuX2NlbnRlciA9IG5ldyBMbmdMYXQoMCwgMCk7XG4gICAgdGhpcy56b29tID0gMDtcbiAgICB0aGlzLmFuZ2xlID0gMDtcbiAgICB0aGlzLl9hbHRpdHVkZSA9IDEuNTtcbiAgICB0aGlzLl9waXRjaCA9IDA7XG4gICAgdGhpcy5fdW5tb2RpZmllZCA9IHRydWU7XG59XG5cblRyYW5zZm9ybS5wcm90b3R5cGUgPSB7XG4gICAgZ2V0IG1pblpvb20oKSB7IHJldHVybiB0aGlzLl9taW5ab29tOyB9LFxuICAgIHNldCBtaW5ab29tKHpvb20pIHtcbiAgICAgICAgaWYgKHRoaXMuX21pblpvb20gPT09IHpvb20pIHJldHVybjtcbiAgICAgICAgdGhpcy5fbWluWm9vbSA9IHpvb207XG4gICAgICAgIHRoaXMuem9vbSA9IE1hdGgubWF4KHRoaXMuem9vbSwgem9vbSk7XG4gICAgfSxcblxuICAgIGdldCBtYXhab29tKCkgeyByZXR1cm4gdGhpcy5fbWF4Wm9vbTsgfSxcbiAgICBzZXQgbWF4Wm9vbSh6b29tKSB7XG4gICAgICAgIGlmICh0aGlzLl9tYXhab29tID09PSB6b29tKSByZXR1cm47XG4gICAgICAgIHRoaXMuX21heFpvb20gPSB6b29tO1xuICAgICAgICB0aGlzLnpvb20gPSBNYXRoLm1pbih0aGlzLnpvb20sIHpvb20pO1xuICAgIH0sXG5cbiAgICBnZXQgd29ybGRTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50aWxlU2l6ZSAqIHRoaXMuc2NhbGU7XG4gICAgfSxcblxuICAgIGdldCBjZW50ZXJQb2ludCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZS5fZGl2KDIpO1xuICAgIH0sXG5cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgfSxcblxuICAgIGdldCBiZWFyaW5nKCkge1xuICAgICAgICByZXR1cm4gLXRoaXMuYW5nbGUgLyBNYXRoLlBJICogMTgwO1xuICAgIH0sXG4gICAgc2V0IGJlYXJpbmcoYmVhcmluZykge1xuICAgICAgICB2YXIgYiA9IC13cmFwKGJlYXJpbmcsIC0xODAsIDE4MCkgKiBNYXRoLlBJIC8gMTgwO1xuICAgICAgICBpZiAodGhpcy5hbmdsZSA9PT0gYikgcmV0dXJuO1xuICAgICAgICB0aGlzLl91bm1vZGlmaWVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYW5nbGUgPSBiO1xuICAgICAgICB0aGlzLl9jYWxjUHJvak1hdHJpeCgpO1xuXG4gICAgICAgIC8vIDJ4MiBtYXRyaXggZm9yIHJvdGF0aW5nIHBvaW50c1xuICAgICAgICB0aGlzLnJvdGF0aW9uTWF0cml4ID0gbWF0Mi5jcmVhdGUoKTtcbiAgICAgICAgbWF0Mi5yb3RhdGUodGhpcy5yb3RhdGlvbk1hdHJpeCwgdGhpcy5yb3RhdGlvbk1hdHJpeCwgdGhpcy5hbmdsZSk7XG4gICAgfSxcblxuICAgIGdldCBwaXRjaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BpdGNoIC8gTWF0aC5QSSAqIDE4MDtcbiAgICB9LFxuICAgIHNldCBwaXRjaChwaXRjaCkge1xuICAgICAgICB2YXIgcCA9IE1hdGgubWluKDYwLCBwaXRjaCkgLyAxODAgKiBNYXRoLlBJO1xuICAgICAgICBpZiAodGhpcy5fcGl0Y2ggPT09IHApIHJldHVybjtcbiAgICAgICAgdGhpcy5fdW5tb2RpZmllZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9waXRjaCA9IHA7XG4gICAgICAgIHRoaXMuX2NhbGNQcm9qTWF0cml4KCk7XG4gICAgfSxcblxuICAgIGdldCBhbHRpdHVkZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FsdGl0dWRlO1xuICAgIH0sXG4gICAgc2V0IGFsdGl0dWRlKGFsdGl0dWRlKSB7XG4gICAgICAgIHZhciBhID0gTWF0aC5tYXgoMC43NSwgYWx0aXR1ZGUpO1xuICAgICAgICBpZiAodGhpcy5fYWx0aXR1ZGUgPT09IGEpIHJldHVybjtcbiAgICAgICAgdGhpcy5fdW5tb2RpZmllZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9hbHRpdHVkZSA9IGE7XG4gICAgICAgIHRoaXMuX2NhbGNQcm9qTWF0cml4KCk7XG4gICAgfSxcblxuICAgIGdldCB6b29tKCkgeyByZXR1cm4gdGhpcy5fem9vbTsgfSxcbiAgICBzZXQgem9vbSh6b29tKSB7XG4gICAgICAgIHZhciB6ID0gTWF0aC5taW4oTWF0aC5tYXgoem9vbSwgdGhpcy5taW5ab29tKSwgdGhpcy5tYXhab29tKTtcbiAgICAgICAgaWYgKHRoaXMuX3pvb20gPT09IHopIHJldHVybjtcbiAgICAgICAgdGhpcy5fdW5tb2RpZmllZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl96b29tID0gejtcbiAgICAgICAgdGhpcy5zY2FsZSA9IHRoaXMuem9vbVNjYWxlKHopO1xuICAgICAgICB0aGlzLnRpbGVab29tID0gTWF0aC5mbG9vcih6KTtcbiAgICAgICAgdGhpcy56b29tRnJhY3Rpb24gPSB6IC0gdGhpcy50aWxlWm9vbTtcbiAgICAgICAgdGhpcy5fY2FsY1Byb2pNYXRyaXgoKTtcbiAgICAgICAgdGhpcy5fY29uc3RyYWluKCk7XG4gICAgfSxcblxuICAgIGdldCBjZW50ZXIoKSB7IHJldHVybiB0aGlzLl9jZW50ZXI7IH0sXG4gICAgc2V0IGNlbnRlcihjZW50ZXIpIHtcbiAgICAgICAgaWYgKGNlbnRlci5sYXQgPT09IHRoaXMuX2NlbnRlci5sYXQgJiYgY2VudGVyLmxuZyA9PT0gdGhpcy5fY2VudGVyLmxuZykgcmV0dXJuO1xuICAgICAgICB0aGlzLl91bm1vZGlmaWVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2NlbnRlciA9IGNlbnRlcjtcbiAgICAgICAgdGhpcy5fY2FsY1Byb2pNYXRyaXgoKTtcbiAgICAgICAgdGhpcy5fY29uc3RyYWluKCk7XG4gICAgfSxcblxuICAgIHJlc2l6ZTogZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgICAgIC8vIFRoZSBleHRydXNpb24gbWF0cml4XG4gICAgICAgIHRoaXMuZXhNYXRyaXggPSBtYXQ0LmNyZWF0ZSgpO1xuICAgICAgICBtYXQ0Lm9ydGhvKHRoaXMuZXhNYXRyaXgsIDAsIHdpZHRoLCBoZWlnaHQsIDAsIDAsIC0xKTtcblxuICAgICAgICB0aGlzLl9jYWxjUHJvak1hdHJpeCgpO1xuICAgICAgICB0aGlzLl9jb25zdHJhaW4oKTtcbiAgICB9LFxuXG4gICAgZ2V0IHVubW9kaWZpZWQoKSB7IHJldHVybiB0aGlzLl91bm1vZGlmaWVkOyB9LFxuXG4gICAgem9vbVNjYWxlOiBmdW5jdGlvbih6b29tKSB7IHJldHVybiBNYXRoLnBvdygyLCB6b29tKTsgfSxcbiAgICBzY2FsZVpvb206IGZ1bmN0aW9uKHNjYWxlKSB7IHJldHVybiBNYXRoLmxvZyhzY2FsZSkgLyBNYXRoLkxOMjsgfSxcblxuICAgIHByb2plY3Q6IGZ1bmN0aW9uKGxuZ2xhdCwgd29ybGRTaXplKSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQoXG4gICAgICAgICAgICB0aGlzLmxuZ1gobG5nbGF0LmxuZywgd29ybGRTaXplKSxcbiAgICAgICAgICAgIHRoaXMubGF0WShsbmdsYXQubGF0LCB3b3JsZFNpemUpKTtcbiAgICB9LFxuXG4gICAgdW5wcm9qZWN0OiBmdW5jdGlvbihwb2ludCwgd29ybGRTaXplKSB7XG4gICAgICAgIHJldHVybiBuZXcgTG5nTGF0KFxuICAgICAgICAgICAgdGhpcy54TG5nKHBvaW50LngsIHdvcmxkU2l6ZSksXG4gICAgICAgICAgICB0aGlzLnlMYXQocG9pbnQueSwgd29ybGRTaXplKSk7XG4gICAgfSxcblxuICAgIGdldCB4KCkgeyByZXR1cm4gdGhpcy5sbmdYKHRoaXMuY2VudGVyLmxuZyk7IH0sXG4gICAgZ2V0IHkoKSB7IHJldHVybiB0aGlzLmxhdFkodGhpcy5jZW50ZXIubGF0KTsgfSxcblxuICAgIGdldCBwb2ludCgpIHsgcmV0dXJuIG5ldyBQb2ludCh0aGlzLngsIHRoaXMueSk7IH0sXG5cbiAgICAvKipcbiAgICAgKiBsYXRpdHVkZSB0byBhYnNvbHV0ZSB4IGNvb3JkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbd29ybGRTaXplPXRoaXMud29ybGRTaXplXVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHBpeGVsIGNvb3JkaW5hdGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGxuZ1g6IGZ1bmN0aW9uKGxuZywgd29ybGRTaXplKSB7XG4gICAgICAgIHJldHVybiAoMTgwICsgbG5nKSAqICh3b3JsZFNpemUgfHwgdGhpcy53b3JsZFNpemUpIC8gMzYwO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogbGF0aXR1ZGUgdG8gYWJzb2x1dGUgeSBjb29yZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsYXRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3dvcmxkU2l6ZT10aGlzLndvcmxkU2l6ZV1cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBwaXhlbCBjb29yZGluYXRlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBsYXRZOiBmdW5jdGlvbihsYXQsIHdvcmxkU2l6ZSkge1xuICAgICAgICB2YXIgeSA9IDE4MCAvIE1hdGguUEkgKiBNYXRoLmxvZyhNYXRoLnRhbihNYXRoLlBJIC8gNCArIGxhdCAqIE1hdGguUEkgLyAzNjApKTtcbiAgICAgICAgcmV0dXJuICgxODAgLSB5KSAqICh3b3JsZFNpemUgfHwgdGhpcy53b3JsZFNpemUpIC8gMzYwO1xuICAgIH0sXG5cbiAgICB4TG5nOiBmdW5jdGlvbih4LCB3b3JsZFNpemUpIHtcbiAgICAgICAgcmV0dXJuIHggKiAzNjAgLyAod29ybGRTaXplIHx8IHRoaXMud29ybGRTaXplKSAtIDE4MDtcbiAgICB9LFxuICAgIHlMYXQ6IGZ1bmN0aW9uKHksIHdvcmxkU2l6ZSkge1xuICAgICAgICB2YXIgeTIgPSAxODAgLSB5ICogMzYwIC8gKHdvcmxkU2l6ZSB8fCB0aGlzLndvcmxkU2l6ZSk7XG4gICAgICAgIHJldHVybiAzNjAgLyBNYXRoLlBJICogTWF0aC5hdGFuKE1hdGguZXhwKHkyICogTWF0aC5QSSAvIDE4MCkpIC0gOTA7XG4gICAgfSxcblxuICAgIHBhbkJ5OiBmdW5jdGlvbihvZmZzZXQpIHtcbiAgICAgICAgdmFyIHBvaW50ID0gdGhpcy5jZW50ZXJQb2ludC5fYWRkKG9mZnNldCk7XG4gICAgICAgIHRoaXMuY2VudGVyID0gdGhpcy5wb2ludExvY2F0aW9uKHBvaW50KTtcbiAgICB9LFxuXG4gICAgc2V0TG9jYXRpb25BdFBvaW50OiBmdW5jdGlvbihsbmdsYXQsIHBvaW50KSB7XG4gICAgICAgIHZhciBjID0gdGhpcy5sb2NhdGlvbkNvb3JkaW5hdGUobG5nbGF0KTtcbiAgICAgICAgdmFyIGNvb3JkQXRQb2ludCA9IHRoaXMucG9pbnRDb29yZGluYXRlKHBvaW50KTtcbiAgICAgICAgdmFyIGNvb3JkQ2VudGVyID0gdGhpcy5wb2ludENvb3JkaW5hdGUodGhpcy5jZW50ZXJQb2ludCk7XG4gICAgICAgIHZhciB0cmFuc2xhdGUgPSBjb29yZEF0UG9pbnQuX3N1YihjKTtcbiAgICAgICAgdGhpcy5fdW5tb2RpZmllZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNlbnRlciA9IHRoaXMuY29vcmRpbmF0ZUxvY2F0aW9uKGNvb3JkQ2VudGVyLl9zdWIodHJhbnNsYXRlKSk7XG4gICAgfSxcblxuICAgIHNldFpvb21Bcm91bmQ6IGZ1bmN0aW9uKHpvb20sIGNlbnRlcikge1xuICAgICAgICB2YXIgcDtcbiAgICAgICAgaWYgKGNlbnRlcikgcCA9IHRoaXMubG9jYXRpb25Qb2ludChjZW50ZXIpO1xuICAgICAgICB0aGlzLnpvb20gPSB6b29tO1xuICAgICAgICBpZiAoY2VudGVyKSB0aGlzLnNldExvY2F0aW9uQXRQb2ludChjZW50ZXIsIHApO1xuICAgIH0sXG5cbiAgICBzZXRCZWFyaW5nQXJvdW5kOiBmdW5jdGlvbihiZWFyaW5nLCBjZW50ZXIpIHtcbiAgICAgICAgdmFyIHA7XG4gICAgICAgIGlmIChjZW50ZXIpIHAgPSB0aGlzLmxvY2F0aW9uUG9pbnQoY2VudGVyKTtcbiAgICAgICAgdGhpcy5iZWFyaW5nID0gYmVhcmluZztcbiAgICAgICAgaWYgKGNlbnRlcikgdGhpcy5zZXRMb2NhdGlvbkF0UG9pbnQoY2VudGVyLCBwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBsb2NhdGlvbiwgcmV0dXJuIHRoZSBzY3JlZW4gcG9pbnQgdGhhdCBjb3JyZXNwb25kcyB0byBpdFxuICAgICAqIEBwYXJhbSB7TG5nTGF0fSBsbmdsYXQgbG9jYXRpb25cbiAgICAgKiBAcmV0dXJucyB7UG9pbnR9IHNjcmVlbiBwb2ludFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgbG9jYXRpb25Qb2ludDogZnVuY3Rpb24obG5nbGF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvb3JkaW5hdGVQb2ludCh0aGlzLmxvY2F0aW9uQ29vcmRpbmF0ZShsbmdsYXQpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBwb2ludCBvbiBzY3JlZW4sIHJldHVybiBpdHMgbG5nbGF0XG4gICAgICogQHBhcmFtIHtQb2ludH0gcCBzY3JlZW4gcG9pbnRcbiAgICAgKiBAcmV0dXJucyB7TG5nTGF0fSBsbmdsYXQgbG9jYXRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHBvaW50TG9jYXRpb246IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29vcmRpbmF0ZUxvY2F0aW9uKHRoaXMucG9pbnRDb29yZGluYXRlKHApKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBnZW9ncmFwaGljYWwgbG5nbGF0LCByZXR1cm4gYW4gdW5yb3VuZGVkXG4gICAgICogY29vcmRpbmF0ZSB0aGF0IHJlcHJlc2VudHMgaXQgYXQgdGhpcyB0cmFuc2Zvcm0ncyB6b29tIGxldmVsIGFuZFxuICAgICAqIHdvcmxkc2l6ZS5cbiAgICAgKiBAcGFyYW0ge0xuZ0xhdH0gbG5nbGF0XG4gICAgICogQHJldHVybnMge0Nvb3JkaW5hdGV9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBsb2NhdGlvbkNvb3JkaW5hdGU6IGZ1bmN0aW9uKGxuZ2xhdCkge1xuICAgICAgICB2YXIgayA9IHRoaXMuem9vbVNjYWxlKHRoaXMudGlsZVpvb20pIC8gdGhpcy53b3JsZFNpemUsXG4gICAgICAgICAgICBsbCA9IExuZ0xhdC5jb252ZXJ0KGxuZ2xhdCk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBDb29yZGluYXRlKFxuICAgICAgICAgICAgdGhpcy5sbmdYKGxsLmxuZykgKiBrLFxuICAgICAgICAgICAgdGhpcy5sYXRZKGxsLmxhdCkgKiBrLFxuICAgICAgICAgICAgdGhpcy50aWxlWm9vbSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgQ29vcmRpbmF0ZSwgcmV0dXJuIGl0cyBnZW9ncmFwaGljYWwgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtDb29yZGluYXRlfSBjb29yZFxuICAgICAqIEByZXR1cm5zIHtMbmdMYXR9IGxuZ2xhdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY29vcmRpbmF0ZUxvY2F0aW9uOiBmdW5jdGlvbihjb29yZCkge1xuICAgICAgICB2YXIgd29ybGRTaXplID0gdGhpcy56b29tU2NhbGUoY29vcmQuem9vbSk7XG4gICAgICAgIHJldHVybiBuZXcgTG5nTGF0KFxuICAgICAgICAgICAgdGhpcy54TG5nKGNvb3JkLmNvbHVtbiwgd29ybGRTaXplKSxcbiAgICAgICAgICAgIHRoaXMueUxhdChjb29yZC5yb3csIHdvcmxkU2l6ZSkpO1xuICAgIH0sXG5cbiAgICBwb2ludENvb3JkaW5hdGU6IGZ1bmN0aW9uKHAsIHRhcmdldFopIHtcblxuICAgICAgICBpZiAodGFyZ2V0WiA9PT0gdW5kZWZpbmVkKSB0YXJnZXRaID0gMDtcblxuICAgICAgICB2YXIgbWF0cml4ID0gdGhpcy5jb29yZGluYXRlUG9pbnRNYXRyaXgodGhpcy50aWxlWm9vbSk7XG4gICAgICAgIG1hdDQuaW52ZXJ0KG1hdHJpeCwgbWF0cml4KTtcblxuICAgICAgICBpZiAoIW1hdHJpeCkgdGhyb3cgbmV3IEVycm9yKFwiZmFpbGVkIHRvIGludmVydCBtYXRyaXhcIik7XG5cbiAgICAgICAgLy8gc2luY2Ugd2UgZG9uJ3Qga25vdyB0aGUgY29ycmVjdCBwcm9qZWN0ZWQgeiB2YWx1ZSBmb3IgdGhlIHBvaW50LFxuICAgICAgICAvLyB1bnByb2plY3QgdHdvIHBvaW50cyB0byBnZXQgYSBsaW5lIGFuZCB0aGVuIGZpbmQgdGhlIHBvaW50IG9uIHRoYXRcbiAgICAgICAgLy8gbGluZSB3aXRoIHo9MFxuXG4gICAgICAgIHZhciBjb29yZDAgPSBbcC54LCBwLnksIDAsIDFdO1xuICAgICAgICB2YXIgY29vcmQxID0gW3AueCwgcC55LCAxLCAxXTtcblxuICAgICAgICB2ZWM0LnRyYW5zZm9ybU1hdDQoY29vcmQwLCBjb29yZDAsIG1hdHJpeCk7XG4gICAgICAgIHZlYzQudHJhbnNmb3JtTWF0NChjb29yZDEsIGNvb3JkMSwgbWF0cml4KTtcblxuICAgICAgICB2YXIgdzAgPSBjb29yZDBbM107XG4gICAgICAgIHZhciB3MSA9IGNvb3JkMVszXTtcbiAgICAgICAgdmFyIHgwID0gY29vcmQwWzBdIC8gdzA7XG4gICAgICAgIHZhciB4MSA9IGNvb3JkMVswXSAvIHcxO1xuICAgICAgICB2YXIgeTAgPSBjb29yZDBbMV0gLyB3MDtcbiAgICAgICAgdmFyIHkxID0gY29vcmQxWzFdIC8gdzE7XG4gICAgICAgIHZhciB6MCA9IGNvb3JkMFsyXSAvIHcwO1xuICAgICAgICB2YXIgejEgPSBjb29yZDFbMl0gLyB3MTtcblxuXG4gICAgICAgIHZhciB0ID0gejAgPT09IHoxID8gMCA6ICh0YXJnZXRaIC0gejApIC8gKHoxIC0gejApO1xuXG4gICAgICAgIHJldHVybiBuZXcgQ29vcmRpbmF0ZShcbiAgICAgICAgICAgIGludGVycCh4MCwgeDEsIHQpLFxuICAgICAgICAgICAgaW50ZXJwKHkwLCB5MSwgdCksXG4gICAgICAgICAgICB0aGlzLnRpbGVab29tKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBjb29yZGluYXRlLCByZXR1cm4gdGhlIHNjcmVlbiBwb2ludCB0aGF0IGNvcnJlc3BvbmRzIHRvIGl0XG4gICAgICogQHBhcmFtIHtDb29yZGluYXRlfSBjb29yZFxuICAgICAqIEByZXR1cm5zIHtQb2ludH0gc2NyZWVuIHBvaW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb29yZGluYXRlUG9pbnQ6IGZ1bmN0aW9uKGNvb3JkKSB7XG4gICAgICAgIHZhciBtYXRyaXggPSB0aGlzLmNvb3JkaW5hdGVQb2ludE1hdHJpeChjb29yZC56b29tKTtcbiAgICAgICAgdmFyIHAgPSBbY29vcmQuY29sdW1uLCBjb29yZC5yb3csIDAsIDFdO1xuICAgICAgICB2ZWM0LnRyYW5zZm9ybU1hdDQocCwgcCwgbWF0cml4KTtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludChwWzBdIC8gcFszXSwgcFsxXSAvIHBbM10pO1xuICAgIH0sXG5cbiAgICBjb29yZGluYXRlUG9pbnRNYXRyaXg6IGZ1bmN0aW9uKHopIHtcbiAgICAgICAgdmFyIHByb2ogPSBtYXQ0LmNvcHkobmV3IEZsb2F0NjRBcnJheSgxNiksIHRoaXMucHJvak1hdHJpeCk7XG4gICAgICAgIHZhciBzY2FsZSA9IHRoaXMud29ybGRTaXplIC8gdGhpcy56b29tU2NhbGUoeik7XG4gICAgICAgIG1hdDQuc2NhbGUocHJvaiwgcHJvaiwgW3NjYWxlLCBzY2FsZSwgMV0pO1xuICAgICAgICBtYXQ0Lm11bHRpcGx5KHByb2osIHRoaXMuZ2V0UGl4ZWxNYXRyaXgoKSwgcHJvaik7XG4gICAgICAgIHJldHVybiBwcm9qO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjb252ZXJ0cyBnbCBjb29yZGluYXRlcyAtMS4uMSB0byBwaXhlbHMgMC4ud2lkdGhcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBtYXRyaXhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGdldFBpeGVsTWF0cml4OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG0gPSBtYXQ0LmNyZWF0ZSgpO1xuICAgICAgICBtYXQ0LnNjYWxlKG0sIG0sIFt0aGlzLndpZHRoIC8gMiwgLXRoaXMuaGVpZ2h0IC8gMiwgMV0pO1xuICAgICAgICBtYXQ0LnRyYW5zbGF0ZShtLCBtLCBbMSwgLTEsIDBdKTtcbiAgICAgICAgcmV0dXJuIG07XG4gICAgfSxcblxuICAgIF9jb25zdHJhaW46IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuY2VudGVyIHx8ICF0aGlzLndpZHRoIHx8ICF0aGlzLmhlaWdodCB8fCB0aGlzLl9jb25zdHJhaW5pbmcpIHJldHVybjtcblxuICAgICAgICB0aGlzLl9jb25zdHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgICAgIHZhciBtaW5ZLCBtYXhZLCBtaW5YLCBtYXhYLCBzeSwgc3gsIHgyLCB5MixcbiAgICAgICAgICAgIHNpemUgPSB0aGlzLnNpemUsXG4gICAgICAgICAgICB1bm1vZGlmaWVkID0gdGhpcy5fdW5tb2RpZmllZDtcblxuICAgICAgICBpZiAodGhpcy5sYXRSYW5nZSkge1xuICAgICAgICAgICAgbWluWSA9IHRoaXMubGF0WSh0aGlzLmxhdFJhbmdlWzFdKTtcbiAgICAgICAgICAgIG1heFkgPSB0aGlzLmxhdFkodGhpcy5sYXRSYW5nZVswXSk7XG4gICAgICAgICAgICBzeSA9IG1heFkgLSBtaW5ZIDwgc2l6ZS55ID8gc2l6ZS55IC8gKG1heFkgLSBtaW5ZKSA6IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5sbmdSYW5nZSkge1xuICAgICAgICAgICAgbWluWCA9IHRoaXMubG5nWCh0aGlzLmxuZ1JhbmdlWzBdKTtcbiAgICAgICAgICAgIG1heFggPSB0aGlzLmxuZ1godGhpcy5sbmdSYW5nZVsxXSk7XG4gICAgICAgICAgICBzeCA9IG1heFggLSBtaW5YIDwgc2l6ZS54ID8gc2l6ZS54IC8gKG1heFggLSBtaW5YKSA6IDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBob3cgbXVjaCB0aGUgbWFwIHNob3VsZCBzY2FsZSB0byBmaXQgdGhlIHNjcmVlbiBpbnRvIGdpdmVuIGxhdGl0dWRlL2xvbmdpdHVkZSByYW5nZXNcbiAgICAgICAgdmFyIHMgPSBNYXRoLm1heChzeCB8fCAwLCBzeSB8fCAwKTtcblxuICAgICAgICBpZiAocykge1xuICAgICAgICAgICAgdGhpcy5jZW50ZXIgPSB0aGlzLnVucHJvamVjdChuZXcgUG9pbnQoXG4gICAgICAgICAgICAgICAgc3ggPyAobWF4WCArIG1pblgpIC8gMiA6IHRoaXMueCxcbiAgICAgICAgICAgICAgICBzeSA/IChtYXhZICsgbWluWSkgLyAyIDogdGhpcy55KSk7XG4gICAgICAgICAgICB0aGlzLnpvb20gKz0gdGhpcy5zY2FsZVpvb20ocyk7XG4gICAgICAgICAgICB0aGlzLl91bm1vZGlmaWVkID0gdW5tb2RpZmllZDtcbiAgICAgICAgICAgIHRoaXMuX2NvbnN0cmFpbmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubGF0UmFuZ2UpIHtcbiAgICAgICAgICAgIHZhciB5ID0gdGhpcy55LFxuICAgICAgICAgICAgICAgIGgyID0gc2l6ZS55IC8gMjtcblxuICAgICAgICAgICAgaWYgKHkgLSBoMiA8IG1pblkpIHkyID0gbWluWSArIGgyO1xuICAgICAgICAgICAgaWYgKHkgKyBoMiA+IG1heFkpIHkyID0gbWF4WSAtIGgyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubG5nUmFuZ2UpIHtcbiAgICAgICAgICAgIHZhciB4ID0gdGhpcy54LFxuICAgICAgICAgICAgICAgIHcyID0gc2l6ZS54IC8gMjtcblxuICAgICAgICAgICAgaWYgKHggLSB3MiA8IG1pblgpIHgyID0gbWluWCArIHcyO1xuICAgICAgICAgICAgaWYgKHggKyB3MiA+IG1heFgpIHgyID0gbWF4WCAtIHcyO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcGFuIHRoZSBtYXAgaWYgdGhlIHNjcmVlbiBnb2VzIG9mZiB0aGUgcmFuZ2VcbiAgICAgICAgaWYgKHgyICE9PSB1bmRlZmluZWQgfHwgeTIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5jZW50ZXIgPSB0aGlzLnVucHJvamVjdChuZXcgUG9pbnQoXG4gICAgICAgICAgICAgICAgeDIgIT09IHVuZGVmaW5lZCA/IHgyIDogdGhpcy54LFxuICAgICAgICAgICAgICAgIHkyICE9PSB1bmRlZmluZWQgPyB5MiA6IHRoaXMueSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdW5tb2RpZmllZCA9IHVubW9kaWZpZWQ7XG4gICAgICAgIHRoaXMuX2NvbnN0cmFpbmluZyA9IGZhbHNlO1xuICAgIH0sXG5cbiAgICBfY2FsY1Byb2pNYXRyaXg6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbSA9IG5ldyBGbG9hdDY0QXJyYXkoMTYpO1xuXG4gICAgICAgIC8vIEZpbmQgdGhlIGRpc3RhbmNlIGZyb20gdGhlIGNlbnRlciBwb2ludCB0byB0aGUgY2VudGVyIHRvcCBpbiBhbHRpdHVkZSB1bml0cyB1c2luZyBsYXcgb2Ygc2luZXMuXG4gICAgICAgIHZhciBoYWxmRm92ID0gTWF0aC5hdGFuKDAuNSAvIHRoaXMuYWx0aXR1ZGUpO1xuICAgICAgICB2YXIgdG9wSGFsZlN1cmZhY2VEaXN0YW5jZSA9IE1hdGguc2luKGhhbGZGb3YpICogdGhpcy5hbHRpdHVkZSAvIE1hdGguc2luKE1hdGguUEkgLyAyIC0gdGhpcy5fcGl0Y2ggLSBoYWxmRm92KTtcblxuICAgICAgICAvLyBDYWxjdWxhdGUgeiB2YWx1ZSBvZiB0aGUgZmFydGhlc3QgZnJhZ21lbnQgdGhhdCBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAgICAgIHZhciBmYXJaID0gTWF0aC5jb3MoTWF0aC5QSSAvIDIgLSB0aGlzLl9waXRjaCkgKiB0b3BIYWxmU3VyZmFjZURpc3RhbmNlICsgdGhpcy5hbHRpdHVkZTtcblxuICAgICAgICBtYXQ0LnBlcnNwZWN0aXZlKG0sIDIgKiBNYXRoLmF0YW4oKHRoaXMuaGVpZ2h0IC8gMikgLyB0aGlzLmFsdGl0dWRlKSwgdGhpcy53aWR0aCAvIHRoaXMuaGVpZ2h0LCAwLjEsIGZhclopO1xuXG4gICAgICAgIG1hdDQudHJhbnNsYXRlKG0sIG0sIFswLCAwLCAtdGhpcy5hbHRpdHVkZV0pO1xuXG4gICAgICAgIC8vIEFmdGVyIHRoZSByb3RhdGVYLCB6IHZhbHVlcyBhcmUgaW4gcGl4ZWwgdW5pdHMuIENvbnZlcnQgdGhlbSB0b1xuICAgICAgICAvLyBhbHRpdHVkZSB1bml0ZXMuIDEgYWx0aXR1ZGUgdW5pdCA9IHRoZSBzY3JlZW4gaGVpZ2h0LlxuICAgICAgICBtYXQ0LnNjYWxlKG0sIG0sIFsxLCAtMSwgMSAvIHRoaXMuaGVpZ2h0XSk7XG5cbiAgICAgICAgbWF0NC5yb3RhdGVYKG0sIG0sIHRoaXMuX3BpdGNoKTtcbiAgICAgICAgbWF0NC5yb3RhdGVaKG0sIG0sIHRoaXMuYW5nbGUpO1xuICAgICAgICBtYXQ0LnRyYW5zbGF0ZShtLCBtLCBbLXRoaXMueCwgLXRoaXMueSwgMF0pO1xuXG4gICAgICAgIHRoaXMucHJvak1hdHJpeCA9IG07XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gRm9udCBkYXRhIEZyb20gSGVyc2hleSBTaW1wbGV4IEZvbnRcbi8vIGh0dHA6Ly9wYXVsYm91cmtlLm5ldC9kYXRhZm9ybWF0cy9oZXJzaGV5L1xudmFyIHNpbXBsZXhGb250ID0ge1xuICAgIFwiIFwiOiBbMTYsIFtdXSxcbiAgICBcIiFcIjogWzEwLCBbNSwgMjEsIDUsIDcsIC0xLCAtMSwgNSwgMiwgNCwgMSwgNSwgMCwgNiwgMSwgNSwgMl1dLFxuICAgIFwiXFxcIlwiOiBbMTYsIFs0LCAyMSwgNCwgMTQsIC0xLCAtMSwgMTIsIDIxLCAxMiwgMTRdXSxcbiAgICBcIiNcIjogWzIxLCBbMTEsIDI1LCA0LCAtNywgLTEsIC0xLCAxNywgMjUsIDEwLCAtNywgLTEsIC0xLCA0LCAxMiwgMTgsIDEyLCAtMSwgLTEsIDMsIDYsIDE3LCA2XV0sXG4gICAgXCIkXCI6IFsyMCwgWzgsIDI1LCA4LCAtNCwgLTEsIC0xLCAxMiwgMjUsIDEyLCAtNCwgLTEsIC0xLCAxNywgMTgsIDE1LCAyMCwgMTIsIDIxLCA4LCAyMSwgNSwgMjAsIDMsIDE4LCAzLCAxNiwgNCwgMTQsIDUsIDEzLCA3LCAxMiwgMTMsIDEwLCAxNSwgOSwgMTYsIDgsIDE3LCA2LCAxNywgMywgMTUsIDEsIDEyLCAwLCA4LCAwLCA1LCAxLCAzLCAzXV0sXG4gICAgXCIlXCI6IFsyNCwgWzIxLCAyMSwgMywgMCwgLTEsIC0xLCA4LCAyMSwgMTAsIDE5LCAxMCwgMTcsIDksIDE1LCA3LCAxNCwgNSwgMTQsIDMsIDE2LCAzLCAxOCwgNCwgMjAsIDYsIDIxLCA4LCAyMSwgMTAsIDIwLCAxMywgMTksIDE2LCAxOSwgMTksIDIwLCAyMSwgMjEsIC0xLCAtMSwgMTcsIDcsIDE1LCA2LCAxNCwgNCwgMTQsIDIsIDE2LCAwLCAxOCwgMCwgMjAsIDEsIDIxLCAzLCAyMSwgNSwgMTksIDcsIDE3LCA3XV0sXG4gICAgXCImXCI6IFsyNiwgWzIzLCAxMiwgMjMsIDEzLCAyMiwgMTQsIDIxLCAxNCwgMjAsIDEzLCAxOSwgMTEsIDE3LCA2LCAxNSwgMywgMTMsIDEsIDExLCAwLCA3LCAwLCA1LCAxLCA0LCAyLCAzLCA0LCAzLCA2LCA0LCA4LCA1LCA5LCAxMiwgMTMsIDEzLCAxNCwgMTQsIDE2LCAxNCwgMTgsIDEzLCAyMCwgMTEsIDIxLCA5LCAyMCwgOCwgMTgsIDgsIDE2LCA5LCAxMywgMTEsIDEwLCAxNiwgMywgMTgsIDEsIDIwLCAwLCAyMiwgMCwgMjMsIDEsIDIzLCAyXV0sXG4gICAgXCInXCI6IFsxMCwgWzUsIDE5LCA0LCAyMCwgNSwgMjEsIDYsIDIwLCA2LCAxOCwgNSwgMTYsIDQsIDE1XV0sXG4gICAgXCIoXCI6IFsxNCwgWzExLCAyNSwgOSwgMjMsIDcsIDIwLCA1LCAxNiwgNCwgMTEsIDQsIDcsIDUsIDIsIDcsIC0yLCA5LCAtNSwgMTEsIC03XV0sXG4gICAgXCIpXCI6IFsxNCwgWzMsIDI1LCA1LCAyMywgNywgMjAsIDksIDE2LCAxMCwgMTEsIDEwLCA3LCA5LCAyLCA3LCAtMiwgNSwgLTUsIDMsIC03XV0sXG4gICAgXCIqXCI6IFsxNiwgWzgsIDIxLCA4LCA5LCAtMSwgLTEsIDMsIDE4LCAxMywgMTIsIC0xLCAtMSwgMTMsIDE4LCAzLCAxMl1dLFxuICAgIFwiK1wiOiBbMjYsIFsxMywgMTgsIDEzLCAwLCAtMSwgLTEsIDQsIDksIDIyLCA5XV0sXG4gICAgXCIsXCI6IFsxMCwgWzYsIDEsIDUsIDAsIDQsIDEsIDUsIDIsIDYsIDEsIDYsIC0xLCA1LCAtMywgNCwgLTRdXSxcbiAgICBcIi1cIjogWzI2LCBbNCwgOSwgMjIsIDldXSxcbiAgICBcIi5cIjogWzEwLCBbNSwgMiwgNCwgMSwgNSwgMCwgNiwgMSwgNSwgMl1dLFxuICAgIFwiL1wiOiBbMjIsIFsyMCwgMjUsIDIsIC03XV0sXG4gICAgXCIwXCI6IFsyMCwgWzksIDIxLCA2LCAyMCwgNCwgMTcsIDMsIDEyLCAzLCA5LCA0LCA0LCA2LCAxLCA5LCAwLCAxMSwgMCwgMTQsIDEsIDE2LCA0LCAxNywgOSwgMTcsIDEyLCAxNiwgMTcsIDE0LCAyMCwgMTEsIDIxLCA5LCAyMV1dLFxuICAgIFwiMVwiOiBbMjAsIFs2LCAxNywgOCwgMTgsIDExLCAyMSwgMTEsIDBdXSxcbiAgICBcIjJcIjogWzIwLCBbNCwgMTYsIDQsIDE3LCA1LCAxOSwgNiwgMjAsIDgsIDIxLCAxMiwgMjEsIDE0LCAyMCwgMTUsIDE5LCAxNiwgMTcsIDE2LCAxNSwgMTUsIDEzLCAxMywgMTAsIDMsIDAsIDE3LCAwXV0sXG4gICAgXCIzXCI6IFsyMCwgWzUsIDIxLCAxNiwgMjEsIDEwLCAxMywgMTMsIDEzLCAxNSwgMTIsIDE2LCAxMSwgMTcsIDgsIDE3LCA2LCAxNiwgMywgMTQsIDEsIDExLCAwLCA4LCAwLCA1LCAxLCA0LCAyLCAzLCA0XV0sXG4gICAgXCI0XCI6IFsyMCwgWzEzLCAyMSwgMywgNywgMTgsIDcsIC0xLCAtMSwgMTMsIDIxLCAxMywgMF1dLFxuICAgIFwiNVwiOiBbMjAsIFsxNSwgMjEsIDUsIDIxLCA0LCAxMiwgNSwgMTMsIDgsIDE0LCAxMSwgMTQsIDE0LCAxMywgMTYsIDExLCAxNywgOCwgMTcsIDYsIDE2LCAzLCAxNCwgMSwgMTEsIDAsIDgsIDAsIDUsIDEsIDQsIDIsIDMsIDRdXSxcbiAgICBcIjZcIjogWzIwLCBbMTYsIDE4LCAxNSwgMjAsIDEyLCAyMSwgMTAsIDIxLCA3LCAyMCwgNSwgMTcsIDQsIDEyLCA0LCA3LCA1LCAzLCA3LCAxLCAxMCwgMCwgMTEsIDAsIDE0LCAxLCAxNiwgMywgMTcsIDYsIDE3LCA3LCAxNiwgMTAsIDE0LCAxMiwgMTEsIDEzLCAxMCwgMTMsIDcsIDEyLCA1LCAxMCwgNCwgN11dLFxuICAgIFwiN1wiOiBbMjAsIFsxNywgMjEsIDcsIDAsIC0xLCAtMSwgMywgMjEsIDE3LCAyMV1dLFxuICAgIFwiOFwiOiBbMjAsIFs4LCAyMSwgNSwgMjAsIDQsIDE4LCA0LCAxNiwgNSwgMTQsIDcsIDEzLCAxMSwgMTIsIDE0LCAxMSwgMTYsIDksIDE3LCA3LCAxNywgNCwgMTYsIDIsIDE1LCAxLCAxMiwgMCwgOCwgMCwgNSwgMSwgNCwgMiwgMywgNCwgMywgNywgNCwgOSwgNiwgMTEsIDksIDEyLCAxMywgMTMsIDE1LCAxNCwgMTYsIDE2LCAxNiwgMTgsIDE1LCAyMCwgMTIsIDIxLCA4LCAyMV1dLFxuICAgIFwiOVwiOiBbMjAsIFsxNiwgMTQsIDE1LCAxMSwgMTMsIDksIDEwLCA4LCA5LCA4LCA2LCA5LCA0LCAxMSwgMywgMTQsIDMsIDE1LCA0LCAxOCwgNiwgMjAsIDksIDIxLCAxMCwgMjEsIDEzLCAyMCwgMTUsIDE4LCAxNiwgMTQsIDE2LCA5LCAxNSwgNCwgMTMsIDEsIDEwLCAwLCA4LCAwLCA1LCAxLCA0LCAzXV0sXG4gICAgXCI6XCI6IFsxMCwgWzUsIDE0LCA0LCAxMywgNSwgMTIsIDYsIDEzLCA1LCAxNCwgLTEsIC0xLCA1LCAyLCA0LCAxLCA1LCAwLCA2LCAxLCA1LCAyXV0sXG4gICAgXCI7XCI6IFsxMCwgWzUsIDE0LCA0LCAxMywgNSwgMTIsIDYsIDEzLCA1LCAxNCwgLTEsIC0xLCA2LCAxLCA1LCAwLCA0LCAxLCA1LCAyLCA2LCAxLCA2LCAtMSwgNSwgLTMsIDQsIC00XV0sXG4gICAgXCI8XCI6IFsyNCwgWzIwLCAxOCwgNCwgOSwgMjAsIDBdXSxcbiAgICBcIj1cIjogWzI2LCBbNCwgMTIsIDIyLCAxMiwgLTEsIC0xLCA0LCA2LCAyMiwgNl1dLFxuICAgIFwiPlwiOiBbMjQsIFs0LCAxOCwgMjAsIDksIDQsIDBdXSxcbiAgICBcIj9cIjogWzE4LCBbMywgMTYsIDMsIDE3LCA0LCAxOSwgNSwgMjAsIDcsIDIxLCAxMSwgMjEsIDEzLCAyMCwgMTQsIDE5LCAxNSwgMTcsIDE1LCAxNSwgMTQsIDEzLCAxMywgMTIsIDksIDEwLCA5LCA3LCAtMSwgLTEsIDksIDIsIDgsIDEsIDksIDAsIDEwLCAxLCA5LCAyXV0sXG4gICAgXCJAXCI6IFsyNywgWzE4LCAxMywgMTcsIDE1LCAxNSwgMTYsIDEyLCAxNiwgMTAsIDE1LCA5LCAxNCwgOCwgMTEsIDgsIDgsIDksIDYsIDExLCA1LCAxNCwgNSwgMTYsIDYsIDE3LCA4LCAtMSwgLTEsIDEyLCAxNiwgMTAsIDE0LCA5LCAxMSwgOSwgOCwgMTAsIDYsIDExLCA1LCAtMSwgLTEsIDE4LCAxNiwgMTcsIDgsIDE3LCA2LCAxOSwgNSwgMjEsIDUsIDIzLCA3LCAyNCwgMTAsIDI0LCAxMiwgMjMsIDE1LCAyMiwgMTcsIDIwLCAxOSwgMTgsIDIwLCAxNSwgMjEsIDEyLCAyMSwgOSwgMjAsIDcsIDE5LCA1LCAxNywgNCwgMTUsIDMsIDEyLCAzLCA5LCA0LCA2LCA1LCA0LCA3LCAyLCA5LCAxLCAxMiwgMCwgMTUsIDAsIDE4LCAxLCAyMCwgMiwgMjEsIDMsIC0xLCAtMSwgMTksIDE2LCAxOCwgOCwgMTgsIDYsIDE5LCA1XV0sXG4gICAgXCJBXCI6IFsxOCwgWzksIDIxLCAxLCAwLCAtMSwgLTEsIDksIDIxLCAxNywgMCwgLTEsIC0xLCA0LCA3LCAxNCwgN11dLFxuICAgIFwiQlwiOiBbMjEsIFs0LCAyMSwgNCwgMCwgLTEsIC0xLCA0LCAyMSwgMTMsIDIxLCAxNiwgMjAsIDE3LCAxOSwgMTgsIDE3LCAxOCwgMTUsIDE3LCAxMywgMTYsIDEyLCAxMywgMTEsIC0xLCAtMSwgNCwgMTEsIDEzLCAxMSwgMTYsIDEwLCAxNywgOSwgMTgsIDcsIDE4LCA0LCAxNywgMiwgMTYsIDEsIDEzLCAwLCA0LCAwXV0sXG4gICAgXCJDXCI6IFsyMSwgWzE4LCAxNiwgMTcsIDE4LCAxNSwgMjAsIDEzLCAyMSwgOSwgMjEsIDcsIDIwLCA1LCAxOCwgNCwgMTYsIDMsIDEzLCAzLCA4LCA0LCA1LCA1LCAzLCA3LCAxLCA5LCAwLCAxMywgMCwgMTUsIDEsIDE3LCAzLCAxOCwgNV1dLFxuICAgIFwiRFwiOiBbMjEsIFs0LCAyMSwgNCwgMCwgLTEsIC0xLCA0LCAyMSwgMTEsIDIxLCAxNCwgMjAsIDE2LCAxOCwgMTcsIDE2LCAxOCwgMTMsIDE4LCA4LCAxNywgNSwgMTYsIDMsIDE0LCAxLCAxMSwgMCwgNCwgMF1dLFxuICAgIFwiRVwiOiBbMTksIFs0LCAyMSwgNCwgMCwgLTEsIC0xLCA0LCAyMSwgMTcsIDIxLCAtMSwgLTEsIDQsIDExLCAxMiwgMTEsIC0xLCAtMSwgNCwgMCwgMTcsIDBdXSxcbiAgICBcIkZcIjogWzE4LCBbNCwgMjEsIDQsIDAsIC0xLCAtMSwgNCwgMjEsIDE3LCAyMSwgLTEsIC0xLCA0LCAxMSwgMTIsIDExXV0sXG4gICAgXCJHXCI6IFsyMSwgWzE4LCAxNiwgMTcsIDE4LCAxNSwgMjAsIDEzLCAyMSwgOSwgMjEsIDcsIDIwLCA1LCAxOCwgNCwgMTYsIDMsIDEzLCAzLCA4LCA0LCA1LCA1LCAzLCA3LCAxLCA5LCAwLCAxMywgMCwgMTUsIDEsIDE3LCAzLCAxOCwgNSwgMTgsIDgsIC0xLCAtMSwgMTMsIDgsIDE4LCA4XV0sXG4gICAgXCJIXCI6IFsyMiwgWzQsIDIxLCA0LCAwLCAtMSwgLTEsIDE4LCAyMSwgMTgsIDAsIC0xLCAtMSwgNCwgMTEsIDE4LCAxMV1dLFxuICAgIFwiSVwiOiBbOCwgWzQsIDIxLCA0LCAwXV0sXG4gICAgXCJKXCI6IFsxNiwgWzEyLCAyMSwgMTIsIDUsIDExLCAyLCAxMCwgMSwgOCwgMCwgNiwgMCwgNCwgMSwgMywgMiwgMiwgNSwgMiwgN11dLFxuICAgIFwiS1wiOiBbMjEsIFs0LCAyMSwgNCwgMCwgLTEsIC0xLCAxOCwgMjEsIDQsIDcsIC0xLCAtMSwgOSwgMTIsIDE4LCAwXV0sXG4gICAgXCJMXCI6IFsxNywgWzQsIDIxLCA0LCAwLCAtMSwgLTEsIDQsIDAsIDE2LCAwXV0sXG4gICAgXCJNXCI6IFsyNCwgWzQsIDIxLCA0LCAwLCAtMSwgLTEsIDQsIDIxLCAxMiwgMCwgLTEsIC0xLCAyMCwgMjEsIDEyLCAwLCAtMSwgLTEsIDIwLCAyMSwgMjAsIDBdXSxcbiAgICBcIk5cIjogWzIyLCBbNCwgMjEsIDQsIDAsIC0xLCAtMSwgNCwgMjEsIDE4LCAwLCAtMSwgLTEsIDE4LCAyMSwgMTgsIDBdXSxcbiAgICBcIk9cIjogWzIyLCBbOSwgMjEsIDcsIDIwLCA1LCAxOCwgNCwgMTYsIDMsIDEzLCAzLCA4LCA0LCA1LCA1LCAzLCA3LCAxLCA5LCAwLCAxMywgMCwgMTUsIDEsIDE3LCAzLCAxOCwgNSwgMTksIDgsIDE5LCAxMywgMTgsIDE2LCAxNywgMTgsIDE1LCAyMCwgMTMsIDIxLCA5LCAyMV1dLFxuICAgIFwiUFwiOiBbMjEsIFs0LCAyMSwgNCwgMCwgLTEsIC0xLCA0LCAyMSwgMTMsIDIxLCAxNiwgMjAsIDE3LCAxOSwgMTgsIDE3LCAxOCwgMTQsIDE3LCAxMiwgMTYsIDExLCAxMywgMTAsIDQsIDEwXV0sXG4gICAgXCJRXCI6IFsyMiwgWzksIDIxLCA3LCAyMCwgNSwgMTgsIDQsIDE2LCAzLCAxMywgMywgOCwgNCwgNSwgNSwgMywgNywgMSwgOSwgMCwgMTMsIDAsIDE1LCAxLCAxNywgMywgMTgsIDUsIDE5LCA4LCAxOSwgMTMsIDE4LCAxNiwgMTcsIDE4LCAxNSwgMjAsIDEzLCAyMSwgOSwgMjEsIC0xLCAtMSwgMTIsIDQsIDE4LCAtMl1dLFxuICAgIFwiUlwiOiBbMjEsIFs0LCAyMSwgNCwgMCwgLTEsIC0xLCA0LCAyMSwgMTMsIDIxLCAxNiwgMjAsIDE3LCAxOSwgMTgsIDE3LCAxOCwgMTUsIDE3LCAxMywgMTYsIDEyLCAxMywgMTEsIDQsIDExLCAtMSwgLTEsIDExLCAxMSwgMTgsIDBdXSxcbiAgICBcIlNcIjogWzIwLCBbMTcsIDE4LCAxNSwgMjAsIDEyLCAyMSwgOCwgMjEsIDUsIDIwLCAzLCAxOCwgMywgMTYsIDQsIDE0LCA1LCAxMywgNywgMTIsIDEzLCAxMCwgMTUsIDksIDE2LCA4LCAxNywgNiwgMTcsIDMsIDE1LCAxLCAxMiwgMCwgOCwgMCwgNSwgMSwgMywgM11dLFxuICAgIFwiVFwiOiBbMTYsIFs4LCAyMSwgOCwgMCwgLTEsIC0xLCAxLCAyMSwgMTUsIDIxXV0sXG4gICAgXCJVXCI6IFsyMiwgWzQsIDIxLCA0LCA2LCA1LCAzLCA3LCAxLCAxMCwgMCwgMTIsIDAsIDE1LCAxLCAxNywgMywgMTgsIDYsIDE4LCAyMV1dLFxuICAgIFwiVlwiOiBbMTgsIFsxLCAyMSwgOSwgMCwgLTEsIC0xLCAxNywgMjEsIDksIDBdXSxcbiAgICBcIldcIjogWzI0LCBbMiwgMjEsIDcsIDAsIC0xLCAtMSwgMTIsIDIxLCA3LCAwLCAtMSwgLTEsIDEyLCAyMSwgMTcsIDAsIC0xLCAtMSwgMjIsIDIxLCAxNywgMF1dLFxuICAgIFwiWFwiOiBbMjAsIFszLCAyMSwgMTcsIDAsIC0xLCAtMSwgMTcsIDIxLCAzLCAwXV0sXG4gICAgXCJZXCI6IFsxOCwgWzEsIDIxLCA5LCAxMSwgOSwgMCwgLTEsIC0xLCAxNywgMjEsIDksIDExXV0sXG4gICAgXCJaXCI6IFsyMCwgWzE3LCAyMSwgMywgMCwgLTEsIC0xLCAzLCAyMSwgMTcsIDIxLCAtMSwgLTEsIDMsIDAsIDE3LCAwXV0sXG4gICAgXCJbXCI6IFsxNCwgWzQsIDI1LCA0LCAtNywgLTEsIC0xLCA1LCAyNSwgNSwgLTcsIC0xLCAtMSwgNCwgMjUsIDExLCAyNSwgLTEsIC0xLCA0LCAtNywgMTEsIC03XV0sXG4gICAgXCJcXFxcXCI6IFsxNCwgWzAsIDIxLCAxNCwgLTNdXSxcbiAgICBcIl1cIjogWzE0LCBbOSwgMjUsIDksIC03LCAtMSwgLTEsIDEwLCAyNSwgMTAsIC03LCAtMSwgLTEsIDMsIDI1LCAxMCwgMjUsIC0xLCAtMSwgMywgLTcsIDEwLCAtN11dLFxuICAgIFwiXlwiOiBbMTYsIFs2LCAxNSwgOCwgMTgsIDEwLCAxNSwgLTEsIC0xLCAzLCAxMiwgOCwgMTcsIDEzLCAxMiwgLTEsIC0xLCA4LCAxNywgOCwgMF1dLFxuICAgIFwiX1wiOiBbMTYsIFswLCAtMiwgMTYsIC0yXV0sXG4gICAgXCJgXCI6IFsxMCwgWzYsIDIxLCA1LCAyMCwgNCwgMTgsIDQsIDE2LCA1LCAxNSwgNiwgMTYsIDUsIDE3XV0sXG4gICAgXCJhXCI6IFsxOSwgWzE1LCAxNCwgMTUsIDAsIC0xLCAtMSwgMTUsIDExLCAxMywgMTMsIDExLCAxNCwgOCwgMTQsIDYsIDEzLCA0LCAxMSwgMywgOCwgMywgNiwgNCwgMywgNiwgMSwgOCwgMCwgMTEsIDAsIDEzLCAxLCAxNSwgM11dLFxuICAgIFwiYlwiOiBbMTksIFs0LCAyMSwgNCwgMCwgLTEsIC0xLCA0LCAxMSwgNiwgMTMsIDgsIDE0LCAxMSwgMTQsIDEzLCAxMywgMTUsIDExLCAxNiwgOCwgMTYsIDYsIDE1LCAzLCAxMywgMSwgMTEsIDAsIDgsIDAsIDYsIDEsIDQsIDNdXSxcbiAgICBcImNcIjogWzE4LCBbMTUsIDExLCAxMywgMTMsIDExLCAxNCwgOCwgMTQsIDYsIDEzLCA0LCAxMSwgMywgOCwgMywgNiwgNCwgMywgNiwgMSwgOCwgMCwgMTEsIDAsIDEzLCAxLCAxNSwgM11dLFxuICAgIFwiZFwiOiBbMTksIFsxNSwgMjEsIDE1LCAwLCAtMSwgLTEsIDE1LCAxMSwgMTMsIDEzLCAxMSwgMTQsIDgsIDE0LCA2LCAxMywgNCwgMTEsIDMsIDgsIDMsIDYsIDQsIDMsIDYsIDEsIDgsIDAsIDExLCAwLCAxMywgMSwgMTUsIDNdXSxcbiAgICBcImVcIjogWzE4LCBbMywgOCwgMTUsIDgsIDE1LCAxMCwgMTQsIDEyLCAxMywgMTMsIDExLCAxNCwgOCwgMTQsIDYsIDEzLCA0LCAxMSwgMywgOCwgMywgNiwgNCwgMywgNiwgMSwgOCwgMCwgMTEsIDAsIDEzLCAxLCAxNSwgM11dLFxuICAgIFwiZlwiOiBbMTIsIFsxMCwgMjEsIDgsIDIxLCA2LCAyMCwgNSwgMTcsIDUsIDAsIC0xLCAtMSwgMiwgMTQsIDksIDE0XV0sXG4gICAgXCJnXCI6IFsxOSwgWzE1LCAxNCwgMTUsIC0yLCAxNCwgLTUsIDEzLCAtNiwgMTEsIC03LCA4LCAtNywgNiwgLTYsIC0xLCAtMSwgMTUsIDExLCAxMywgMTMsIDExLCAxNCwgOCwgMTQsIDYsIDEzLCA0LCAxMSwgMywgOCwgMywgNiwgNCwgMywgNiwgMSwgOCwgMCwgMTEsIDAsIDEzLCAxLCAxNSwgM11dLFxuICAgIFwiaFwiOiBbMTksIFs0LCAyMSwgNCwgMCwgLTEsIC0xLCA0LCAxMCwgNywgMTMsIDksIDE0LCAxMiwgMTQsIDE0LCAxMywgMTUsIDEwLCAxNSwgMF1dLFxuICAgIFwiaVwiOiBbOCwgWzMsIDIxLCA0LCAyMCwgNSwgMjEsIDQsIDIyLCAzLCAyMSwgLTEsIC0xLCA0LCAxNCwgNCwgMF1dLFxuICAgIFwialwiOiBbMTAsIFs1LCAyMSwgNiwgMjAsIDcsIDIxLCA2LCAyMiwgNSwgMjEsIC0xLCAtMSwgNiwgMTQsIDYsIC0zLCA1LCAtNiwgMywgLTcsIDEsIC03XV0sXG4gICAgXCJrXCI6IFsxNywgWzQsIDIxLCA0LCAwLCAtMSwgLTEsIDE0LCAxNCwgNCwgNCwgLTEsIC0xLCA4LCA4LCAxNSwgMF1dLFxuICAgIFwibFwiOiBbOCwgWzQsIDIxLCA0LCAwXV0sXG4gICAgXCJtXCI6IFszMCwgWzQsIDE0LCA0LCAwLCAtMSwgLTEsIDQsIDEwLCA3LCAxMywgOSwgMTQsIDEyLCAxNCwgMTQsIDEzLCAxNSwgMTAsIDE1LCAwLCAtMSwgLTEsIDE1LCAxMCwgMTgsIDEzLCAyMCwgMTQsIDIzLCAxNCwgMjUsIDEzLCAyNiwgMTAsIDI2LCAwXV0sXG4gICAgXCJuXCI6IFsxOSwgWzQsIDE0LCA0LCAwLCAtMSwgLTEsIDQsIDEwLCA3LCAxMywgOSwgMTQsIDEyLCAxNCwgMTQsIDEzLCAxNSwgMTAsIDE1LCAwXV0sXG4gICAgXCJvXCI6IFsxOSwgWzgsIDE0LCA2LCAxMywgNCwgMTEsIDMsIDgsIDMsIDYsIDQsIDMsIDYsIDEsIDgsIDAsIDExLCAwLCAxMywgMSwgMTUsIDMsIDE2LCA2LCAxNiwgOCwgMTUsIDExLCAxMywgMTMsIDExLCAxNCwgOCwgMTRdXSxcbiAgICBcInBcIjogWzE5LCBbNCwgMTQsIDQsIC03LCAtMSwgLTEsIDQsIDExLCA2LCAxMywgOCwgMTQsIDExLCAxNCwgMTMsIDEzLCAxNSwgMTEsIDE2LCA4LCAxNiwgNiwgMTUsIDMsIDEzLCAxLCAxMSwgMCwgOCwgMCwgNiwgMSwgNCwgM11dLFxuICAgIFwicVwiOiBbMTksIFsxNSwgMTQsIDE1LCAtNywgLTEsIC0xLCAxNSwgMTEsIDEzLCAxMywgMTEsIDE0LCA4LCAxNCwgNiwgMTMsIDQsIDExLCAzLCA4LCAzLCA2LCA0LCAzLCA2LCAxLCA4LCAwLCAxMSwgMCwgMTMsIDEsIDE1LCAzXV0sXG4gICAgXCJyXCI6IFsxMywgWzQsIDE0LCA0LCAwLCAtMSwgLTEsIDQsIDgsIDUsIDExLCA3LCAxMywgOSwgMTQsIDEyLCAxNF1dLFxuICAgIFwic1wiOiBbMTcsIFsxNCwgMTEsIDEzLCAxMywgMTAsIDE0LCA3LCAxNCwgNCwgMTMsIDMsIDExLCA0LCA5LCA2LCA4LCAxMSwgNywgMTMsIDYsIDE0LCA0LCAxNCwgMywgMTMsIDEsIDEwLCAwLCA3LCAwLCA0LCAxLCAzLCAzXV0sXG4gICAgXCJ0XCI6IFsxMiwgWzUsIDIxLCA1LCA0LCA2LCAxLCA4LCAwLCAxMCwgMCwgLTEsIC0xLCAyLCAxNCwgOSwgMTRdXSxcbiAgICBcInVcIjogWzE5LCBbNCwgMTQsIDQsIDQsIDUsIDEsIDcsIDAsIDEwLCAwLCAxMiwgMSwgMTUsIDQsIC0xLCAtMSwgMTUsIDE0LCAxNSwgMF1dLFxuICAgIFwidlwiOiBbMTYsIFsyLCAxNCwgOCwgMCwgLTEsIC0xLCAxNCwgMTQsIDgsIDBdXSxcbiAgICBcIndcIjogWzIyLCBbMywgMTQsIDcsIDAsIC0xLCAtMSwgMTEsIDE0LCA3LCAwLCAtMSwgLTEsIDExLCAxNCwgMTUsIDAsIC0xLCAtMSwgMTksIDE0LCAxNSwgMF1dLFxuICAgIFwieFwiOiBbMTcsIFszLCAxNCwgMTQsIDAsIC0xLCAtMSwgMTQsIDE0LCAzLCAwXV0sXG4gICAgXCJ5XCI6IFsxNiwgWzIsIDE0LCA4LCAwLCAtMSwgLTEsIDE0LCAxNCwgOCwgMCwgNiwgLTQsIDQsIC02LCAyLCAtNywgMSwgLTddXSxcbiAgICBcInpcIjogWzE3LCBbMTQsIDE0LCAzLCAwLCAtMSwgLTEsIDMsIDE0LCAxNCwgMTQsIC0xLCAtMSwgMywgMCwgMTQsIDBdXSxcbiAgICBcIntcIjogWzE0LCBbOSwgMjUsIDcsIDI0LCA2LCAyMywgNSwgMjEsIDUsIDE5LCA2LCAxNywgNywgMTYsIDgsIDE0LCA4LCAxMiwgNiwgMTAsIC0xLCAtMSwgNywgMjQsIDYsIDIyLCA2LCAyMCwgNywgMTgsIDgsIDE3LCA5LCAxNSwgOSwgMTMsIDgsIDExLCA0LCA5LCA4LCA3LCA5LCA1LCA5LCAzLCA4LCAxLCA3LCAwLCA2LCAtMiwgNiwgLTQsIDcsIC02LCAtMSwgLTEsIDYsIDgsIDgsIDYsIDgsIDQsIDcsIDIsIDYsIDEsIDUsIC0xLCA1LCAtMywgNiwgLTUsIDcsIC02LCA5LCAtN11dLFxuICAgIFwifFwiOiBbOCwgWzQsIDI1LCA0LCAtN11dLFxuICAgIFwifVwiOiBbMTQsIFs1LCAyNSwgNywgMjQsIDgsIDIzLCA5LCAyMSwgOSwgMTksIDgsIDE3LCA3LCAxNiwgNiwgMTQsIDYsIDEyLCA4LCAxMCwgLTEsIC0xLCA3LCAyNCwgOCwgMjIsIDgsIDIwLCA3LCAxOCwgNiwgMTcsIDUsIDE1LCA1LCAxMywgNiwgMTEsIDEwLCA5LCA2LCA3LCA1LCA1LCA1LCAzLCA2LCAxLCA3LCAwLCA4LCAtMiwgOCwgLTQsIDcsIC02LCAtMSwgLTEsIDgsIDgsIDYsIDYsIDYsIDQsIDcsIDIsIDgsIDEsIDksIC0xLCA5LCAtMywgOCwgLTUsIDcsIC02LCA1LCAtN11dLFxuICAgIFwiflwiOiBbMjQsIFszLCA2LCAzLCA4LCA0LCAxMSwgNiwgMTIsIDgsIDEyLCAxMCwgMTEsIDE0LCA4LCAxNiwgNywgMTgsIDcsIDIwLCA4LCAyMSwgMTAsIC0xLCAtMSwgMywgOCwgNCwgMTAsIDYsIDExLCA4LCAxMSwgMTAsIDEwLCAxNCwgNywgMTYsIDYsIDE4LCA2LCAyMCwgNywgMjEsIDEwLCAyMSwgMTJdXVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0ZXh0VmVydGljZXModGV4dCwgbGVmdCwgYmFzZWxpbmUsIHNjYWxlKSB7XG4gICAgc2NhbGUgPSBzY2FsZSB8fCAxO1xuXG4gICAgdmFyIHN0cm9rZXMgPSBbXSxcbiAgICAgICAgaSwgbGVuLCBqLCBsZW4yLCBnbHlwaCwgeCwgeSwgcHJldjtcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IHRleHQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgZ2x5cGggPSBzaW1wbGV4Rm9udFt0ZXh0W2ldXTtcbiAgICAgICAgaWYgKCFnbHlwaCkgY29udGludWU7XG4gICAgICAgIHByZXYgPSBudWxsO1xuXG4gICAgICAgIGZvciAoaiA9IDAsIGxlbjIgPSBnbHlwaFsxXS5sZW5ndGg7IGogPCBsZW4yOyBqICs9IDIpIHtcbiAgICAgICAgICAgIGlmIChnbHlwaFsxXVtqXSA9PT0gLTEgJiYgZ2x5cGhbMV1baiArIDFdID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHByZXYgPSBudWxsO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHggPSBsZWZ0ICsgZ2x5cGhbMV1bal0gKiBzY2FsZTtcbiAgICAgICAgICAgICAgICB5ID0gYmFzZWxpbmUgLSBnbHlwaFsxXVtqICsgMV0gKiBzY2FsZTtcbiAgICAgICAgICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgICAgICAgICAgICBzdHJva2VzLnB1c2gocHJldi54LCBwcmV2LnksIHgsIHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcmV2ID0ge3g6IHgsIHk6IHl9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxlZnQgKz0gZ2x5cGhbMF0gKiBzY2FsZTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3Ryb2tlcztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogbWFwYm94Z2wgaXMgYSBBIFdlYkdMIEphdmFTY3JpcHQgaW50ZXJhY3RpdmUgbWFwcyBsaWJyYXJ5IHRoYXQgY2FuIHJlbmRlclxuICogW01hcGJveCB2ZWN0b3IgdGlsZXNdKGh0dHBzOi8vd3d3Lm1hcGJveC5jb20vYmxvZy92ZWN0b3ItdGlsZXMvKS5cbiAqXG4gKiBAbW9kdWxlIG1hcGJveGdsXG4gKiBAc3VtbWFyeSBXZWJHTCBKYXZhU2NyaXB0IG1hcCBsaWJyYXJ5XG4gKi9cblxuLy8ganNoaW50IC1XMDc5XG52YXIgbWFwYm94Z2wgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5tYXBib3hnbC5NYXAgPSByZXF1aXJlKCcuL3VpL21hcCcpO1xubWFwYm94Z2wuQ29udHJvbCA9IHJlcXVpcmUoJy4vdWkvY29udHJvbC9jb250cm9sJyk7XG5tYXBib3hnbC5OYXZpZ2F0aW9uID0gcmVxdWlyZSgnLi91aS9jb250cm9sL25hdmlnYXRpb24nKTtcbm1hcGJveGdsLkF0dHJpYnV0aW9uID0gcmVxdWlyZSgnLi91aS9jb250cm9sL2F0dHJpYnV0aW9uJyk7XG5tYXBib3hnbC5Qb3B1cCA9IHJlcXVpcmUoJy4vdWkvcG9wdXAnKTtcblxubWFwYm94Z2wuR2VvSlNPTlNvdXJjZSA9IHJlcXVpcmUoJy4vc291cmNlL2dlb2pzb25fc291cmNlJyk7XG5tYXBib3hnbC5WaWRlb1NvdXJjZSA9IHJlcXVpcmUoJy4vc291cmNlL3ZpZGVvX3NvdXJjZScpO1xubWFwYm94Z2wuSW1hZ2VTb3VyY2UgPSByZXF1aXJlKCcuL3NvdXJjZS9pbWFnZV9zb3VyY2UnKTtcblxubWFwYm94Z2wuU3R5bGUgPSByZXF1aXJlKCcuL3N0eWxlL3N0eWxlJyk7XG5cbm1hcGJveGdsLkxuZ0xhdCA9IHJlcXVpcmUoJy4vZ2VvL2xuZ19sYXQnKTtcbm1hcGJveGdsLkxuZ0xhdEJvdW5kcyA9IHJlcXVpcmUoJy4vZ2VvL2xuZ19sYXRfYm91bmRzJyk7XG5tYXBib3hnbC5Qb2ludCA9IHJlcXVpcmUoJ3BvaW50LWdlb21ldHJ5Jyk7XG5cbm1hcGJveGdsLkV2ZW50ZWQgPSByZXF1aXJlKCcuL3V0aWwvZXZlbnRlZCcpO1xubWFwYm94Z2wudXRpbCA9IHJlcXVpcmUoJy4vdXRpbC91dGlsJyk7XG5cbm1hcGJveGdsLnN1cHBvcnRlZCA9IHJlcXVpcmUoJy4vdXRpbC9icm93c2VyJykuc3VwcG9ydGVkO1xuXG52YXIgYWpheCA9IHJlcXVpcmUoJy4vdXRpbC9hamF4Jyk7XG5tYXBib3hnbC51dGlsLmdldEpTT04gPSBhamF4LmdldEpTT047XG5tYXBib3hnbC51dGlsLmdldEFycmF5QnVmZmVyID0gYWpheC5nZXRBcnJheUJ1ZmZlcjtcblxudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4vdXRpbC9jb25maWcnKTtcbm1hcGJveGdsLmNvbmZpZyA9IGNvbmZpZztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KG1hcGJveGdsLCAnYWNjZXNzVG9rZW4nLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIGNvbmZpZy5BQ0NFU1NfVE9LRU47IH0sXG4gICAgc2V0OiBmdW5jdGlvbih0b2tlbikgeyBjb25maWcuQUNDRVNTX1RPS0VOID0gdG9rZW47IH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVGlsZVB5cmFtaWQgPSByZXF1aXJlKCcuLi9zb3VyY2UvdGlsZV9weXJhbWlkJyk7XG52YXIgcHlyYW1pZCA9IG5ldyBUaWxlUHlyYW1pZCh7IHRpbGVTaXplOiA1MTIgfSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZHJhd0JhY2tncm91bmQ7XG5cbmZ1bmN0aW9uIGRyYXdCYWNrZ3JvdW5kKHBhaW50ZXIsIHNvdXJjZSwgbGF5ZXIpIHtcbiAgICB2YXIgZ2wgPSBwYWludGVyLmdsO1xuICAgIHZhciB0cmFuc2Zvcm0gPSBwYWludGVyLnRyYW5zZm9ybTtcbiAgICB2YXIgY29sb3IgPSBsYXllci5wYWludFsnYmFja2dyb3VuZC1jb2xvciddO1xuICAgIHZhciBpbWFnZSA9IGxheWVyLnBhaW50WydiYWNrZ3JvdW5kLXBhdHRlcm4nXTtcbiAgICB2YXIgb3BhY2l0eSA9IGxheWVyLnBhaW50WydiYWNrZ3JvdW5kLW9wYWNpdHknXTtcbiAgICB2YXIgc2hhZGVyO1xuXG4gICAgdmFyIGltYWdlUG9zQSA9IGltYWdlID8gcGFpbnRlci5zcHJpdGVBdGxhcy5nZXRQb3NpdGlvbihpbWFnZS5mcm9tLCB0cnVlKSA6IG51bGw7XG4gICAgdmFyIGltYWdlUG9zQiA9IGltYWdlID8gcGFpbnRlci5zcHJpdGVBdGxhcy5nZXRQb3NpdGlvbihpbWFnZS50bywgdHJ1ZSkgOiBudWxsO1xuXG4gICAgcGFpbnRlci5zZXREZXB0aFN1YmxheWVyKDApO1xuICAgIGlmIChpbWFnZVBvc0EgJiYgaW1hZ2VQb3NCKSB7XG5cbiAgICAgICAgaWYgKHBhaW50ZXIuaXNPcGFxdWVQYXNzKSByZXR1cm47XG5cbiAgICAgICAgLy8gRHJhdyB0ZXh0dXJlIGZpbGxcbiAgICAgICAgc2hhZGVyID0gcGFpbnRlci5wYXR0ZXJuU2hhZGVyO1xuICAgICAgICBnbC5zd2l0Y2hTaGFkZXIoc2hhZGVyKTtcbiAgICAgICAgZ2wudW5pZm9ybTFpKHNoYWRlci51X2ltYWdlLCAwKTtcbiAgICAgICAgZ2wudW5pZm9ybTJmdihzaGFkZXIudV9wYXR0ZXJuX3RsX2EsIGltYWdlUG9zQS50bCk7XG4gICAgICAgIGdsLnVuaWZvcm0yZnYoc2hhZGVyLnVfcGF0dGVybl9icl9hLCBpbWFnZVBvc0EuYnIpO1xuICAgICAgICBnbC51bmlmb3JtMmZ2KHNoYWRlci51X3BhdHRlcm5fdGxfYiwgaW1hZ2VQb3NCLnRsKTtcbiAgICAgICAgZ2wudW5pZm9ybTJmdihzaGFkZXIudV9wYXR0ZXJuX2JyX2IsIGltYWdlUG9zQi5icik7XG4gICAgICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9vcGFjaXR5LCBvcGFjaXR5KTtcblxuICAgICAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVfbWl4LCBpbWFnZS50KTtcblxuICAgICAgICB2YXIgZmFjdG9yID0gKDQwOTYgLyB0cmFuc2Zvcm0udGlsZVNpemUpIC8gTWF0aC5wb3coMiwgMCk7XG5cbiAgICAgICAgZ2wudW5pZm9ybTJmdihzaGFkZXIudV9wYXR0ZXJuc2NhbGVfYSwgW1xuICAgICAgICAgICAgMSAvIChpbWFnZVBvc0Euc2l6ZVswXSAqIGZhY3RvciAqIGltYWdlLmZyb21TY2FsZSksXG4gICAgICAgICAgICAxIC8gKGltYWdlUG9zQS5zaXplWzFdICogZmFjdG9yICogaW1hZ2UuZnJvbVNjYWxlKVxuICAgICAgICBdKTtcblxuICAgICAgICBnbC51bmlmb3JtMmZ2KHNoYWRlci51X3BhdHRlcm5zY2FsZV9iLCBbXG4gICAgICAgICAgICAxIC8gKGltYWdlUG9zQi5zaXplWzBdICogZmFjdG9yICogaW1hZ2UudG9TY2FsZSksXG4gICAgICAgICAgICAxIC8gKGltYWdlUG9zQi5zaXplWzFdICogZmFjdG9yICogaW1hZ2UudG9TY2FsZSlcbiAgICAgICAgXSk7XG5cbiAgICAgICAgcGFpbnRlci5zcHJpdGVBdGxhcy5iaW5kKGdsLCB0cnVlKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIERyYXcgZmlsbGluZyByZWN0YW5nbGUuXG4gICAgICAgIGlmIChwYWludGVyLmlzT3BhcXVlUGFzcyAhPT0gKGNvbG9yWzNdID09PSAxKSkgcmV0dXJuO1xuXG4gICAgICAgIHNoYWRlciA9IHBhaW50ZXIuZmlsbFNoYWRlcjtcbiAgICAgICAgZ2wuc3dpdGNoU2hhZGVyKHNoYWRlcik7XG4gICAgICAgIGdsLnVuaWZvcm00ZnYoc2hhZGVyLnVfY29sb3IsIGNvbG9yKTtcbiAgICB9XG5cbiAgICBnbC5kaXNhYmxlKGdsLlNURU5DSUxfVEVTVCk7XG5cbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgcGFpbnRlci50aWxlRXh0ZW50QnVmZmVyKTtcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHNoYWRlci5hX3BvcywgcGFpbnRlci50aWxlRXh0ZW50QnVmZmVyLml0ZW1TaXplLCBnbC5TSE9SVCwgZmFsc2UsIDAsIDApO1xuXG4gICAgLy8gV2UgbmVlZCB0byBkcmF3IHRoZSBiYWNrZ3JvdW5kIGluIHRpbGVzIGluIG9yZGVyIHRvIHVzZSBjYWxjdWxhdGVQb3NNYXRyaXhcbiAgICAvLyB3aGljaCBhcHBsaWVzIHRoZSBwcm9qZWN0aW9uIG1hdHJpeCAodHJhbnNmb3JtLnByb2pNYXRyaXgpLiBPdGhlcndpc2VcbiAgICAvLyB0aGUgZGVwdGggYW5kIHN0ZW5jaWwgYnVmZmVycyBnZXQgaW50byBhIGJhZCBzdGF0ZS5cbiAgICAvLyBUaGlzIGNhbiBiZSByZWZhY3RvcmVkIGludG8gYSBzaW5nbGUgZHJhdyBjYWxsIG9uY2UgZWFyY3V0IGxhbmRzIGFuZFxuICAgIC8vIHdlIGRvbid0IGhhdmUgc28gbXVjaCBnb2luZyBvbiBpbiB0aGUgc3RlbmNpbCBidWZmZXIuXG4gICAgdmFyIGNvb3JkcyA9IHB5cmFtaWQuY292ZXJpbmdUaWxlcyh0cmFuc2Zvcm0pO1xuICAgIGZvciAodmFyIGMgPSAwOyBjIDwgY29vcmRzLmxlbmd0aDsgYysrKSB7XG4gICAgICAgIGdsLnNldFBvc01hdHJpeChwYWludGVyLmNhbGN1bGF0ZVBvc01hdHJpeChjb29yZHNbY10pKTtcbiAgICAgICAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRV9TVFJJUCwgMCwgcGFpbnRlci50aWxlRXh0ZW50QnVmZmVyLml0ZW1Db3VudCk7XG4gICAgfVxuXG4gICAgZ2wuZW5hYmxlKGdsLlNURU5DSUxfVEVTVCk7XG4gICAgZ2wuc3RlbmNpbE1hc2soMHgwMCk7XG4gICAgZ2wuc3RlbmNpbEZ1bmMoZ2wuRVFVQUwsIDB4ODAsIDB4ODApO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYnJvd3NlciA9IHJlcXVpcmUoJy4uL3V0aWwvYnJvd3Nlci5qcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRyYXdDaXJjbGVzO1xuXG5mdW5jdGlvbiBkcmF3Q2lyY2xlcyhwYWludGVyLCBzb3VyY2UsIGxheWVyLCBjb29yZHMpIHtcbiAgICBpZiAocGFpbnRlci5pc09wYXF1ZVBhc3MpIHJldHVybjtcblxuICAgIHZhciBnbCA9IHBhaW50ZXIuZ2w7XG5cbiAgICB2YXIgc2hhZGVyID0gcGFpbnRlci5jaXJjbGVTaGFkZXI7XG4gICAgcGFpbnRlci5nbC5zd2l0Y2hTaGFkZXIoc2hhZGVyKTtcblxuICAgIHBhaW50ZXIuc2V0RGVwdGhTdWJsYXllcigwKTtcbiAgICBwYWludGVyLmRlcHRoTWFzayhmYWxzZSk7XG5cbiAgICAvLyBBbGxvdyBjaXJjbGVzIHRvIGJlIGRyYXduIGFjcm9zcyBib3VuZGFyaWVzLCBzbyB0aGF0XG4gICAgLy8gbGFyZ2UgY2lyY2xlcyBhcmUgbm90IGNsaXBwZWQgdG8gdGlsZXNcbiAgICBnbC5kaXNhYmxlKGdsLlNURU5DSUxfVEVTVCk7XG5cbiAgICAvLyBhbnRpYWxpYXNpbmcgZmFjdG9yOiB0aGlzIGlzIGEgbWluaW11bSBibHVyIGRpc3RhbmNlIHRoYXQgc2VydmVzIGFzXG4gICAgLy8gYSBmYXV4LWFudGlhbGlhc2luZyBmb3IgdGhlIGNpcmNsZS4gc2luY2UgYmx1ciBpcyBhIHJhdGlvIG9mIHRoZSBjaXJjbGUnc1xuICAgIC8vIHNpemUgYW5kIHRoZSBpbnRlbnQgaXMgdG8ga2VlcCB0aGUgYmx1ciBhdCByb3VnaGx5IDFweCwgdGhlIHR3b1xuICAgIC8vIGFyZSBpbnZlcnNlbHkgcmVsYXRlZC5cbiAgICB2YXIgYW50aWFsaWFzID0gMSAvIGJyb3dzZXIuZGV2aWNlUGl4ZWxSYXRpbyAvIGxheWVyLnBhaW50WydjaXJjbGUtcmFkaXVzJ107XG5cbiAgICBnbC51bmlmb3JtNGZ2KHNoYWRlci51X2NvbG9yLCBsYXllci5wYWludFsnY2lyY2xlLWNvbG9yJ10pO1xuICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9ibHVyLCBNYXRoLm1heChsYXllci5wYWludFsnY2lyY2xlLWJsdXInXSwgYW50aWFsaWFzKSk7XG4gICAgZ2wudW5pZm9ybTFmKHNoYWRlci51X3NpemUsIGxheWVyLnBhaW50WydjaXJjbGUtcmFkaXVzJ10pO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNvb3JkID0gY29vcmRzW2ldO1xuXG4gICAgICAgIHZhciB0aWxlID0gc291cmNlLmdldFRpbGUoY29vcmQpO1xuICAgICAgICBpZiAoIXRpbGUuYnVmZmVycykgY29udGludWU7XG4gICAgICAgIHZhciBlbGVtZW50R3JvdXBzID0gdGlsZS5nZXRFbGVtZW50R3JvdXBzKGxheWVyLCAnY2lyY2xlJyk7XG4gICAgICAgIGlmICghZWxlbWVudEdyb3VwcykgY29udGludWU7XG5cbiAgICAgICAgdmFyIHZlcnRleCA9IHRpbGUuYnVmZmVycy5jaXJjbGVWZXJ0ZXg7XG4gICAgICAgIHZhciBlbGVtZW50cyA9IHRpbGUuYnVmZmVycy5jaXJjbGVFbGVtZW50O1xuXG4gICAgICAgIGdsLnNldFBvc01hdHJpeChwYWludGVyLnRyYW5zbGF0ZVBvc01hdHJpeChcbiAgICAgICAgICAgIHBhaW50ZXIuY2FsY3VsYXRlUG9zTWF0cml4KGNvb3JkLCBzb3VyY2UubWF4em9vbSksXG4gICAgICAgICAgICB0aWxlLFxuICAgICAgICAgICAgbGF5ZXIucGFpbnRbJ2NpcmNsZS10cmFuc2xhdGUnXSxcbiAgICAgICAgICAgIGxheWVyLnBhaW50WydjaXJjbGUtdHJhbnNsYXRlLWFuY2hvciddXG4gICAgICAgICkpO1xuICAgICAgICBnbC5zZXRFeE1hdHJpeChwYWludGVyLnRyYW5zZm9ybS5leE1hdHJpeCk7XG5cbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBlbGVtZW50R3JvdXBzLmdyb3Vwcy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgdmFyIGdyb3VwID0gZWxlbWVudEdyb3Vwcy5ncm91cHNba107XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gZ3JvdXAudmVydGV4U3RhcnRJbmRleCAqIHZlcnRleC5pdGVtU2l6ZTtcblxuICAgICAgICAgICAgdmVydGV4LmJpbmQoZ2wpO1xuICAgICAgICAgICAgdmVydGV4LnNldEF0dHJpYlBvaW50ZXJzKGdsLCBzaGFkZXIsIG9mZnNldCk7XG5cbiAgICAgICAgICAgIGVsZW1lbnRzLmJpbmQoZ2wpO1xuXG4gICAgICAgICAgICB2YXIgY291bnQgPSBncm91cC5lbGVtZW50TGVuZ3RoICogMztcbiAgICAgICAgICAgIHZhciBlbGVtZW50T2Zmc2V0ID0gZ3JvdXAuZWxlbWVudFN0YXJ0SW5kZXggKiBlbGVtZW50cy5pdGVtU2l6ZTtcbiAgICAgICAgICAgIGdsLmRyYXdFbGVtZW50cyhnbC5UUklBTkdMRVMsIGNvdW50LCBnbC5VTlNJR05FRF9TSE9SVCwgZWxlbWVudE9mZnNldCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnbC5lbmFibGUoZ2wuU1RFTkNJTF9URVNUKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBkcmF3Q29sbGlzaW9uRGVidWc7XG5cbmZ1bmN0aW9uIGRyYXdDb2xsaXNpb25EZWJ1ZyhwYWludGVyLCBsYXllciwgY29vcmQsIHRpbGUpIHtcbiAgICBpZiAoIXRpbGUuYnVmZmVycykgcmV0dXJuO1xuICAgIHZhciBlbGVtZW50R3JvdXBzID0gdGlsZS5nZXRFbGVtZW50R3JvdXBzKGxheWVyLCAnY29sbGlzaW9uQm94Jyk7XG4gICAgaWYgKCFlbGVtZW50R3JvdXBzKSByZXR1cm47XG5cbiAgICB2YXIgZ2wgPSBwYWludGVyLmdsO1xuICAgIHZhciBidWZmZXIgPSB0aWxlLmJ1ZmZlcnMuY29sbGlzaW9uQm94VmVydGV4O1xuICAgIHZhciBzaGFkZXIgPSBwYWludGVyLmNvbGxpc2lvbkJveFNoYWRlcjtcbiAgICB2YXIgcG9zTWF0cml4ID0gcGFpbnRlci5jYWxjdWxhdGVQb3NNYXRyaXgoY29vcmQpO1xuXG4gICAgZ2wuZW5hYmxlKGdsLlNURU5DSUxfVEVTVCk7XG4gICAgcGFpbnRlci5lbmFibGVUaWxlQ2xpcHBpbmdNYXNrKGNvb3JkKTtcblxuICAgIGdsLnN3aXRjaFNoYWRlcihzaGFkZXIsIHBvc01hdHJpeCk7XG5cbiAgICBidWZmZXIuYmluZChnbCk7XG4gICAgYnVmZmVyLnNldEF0dHJpYlBvaW50ZXJzKGdsLCBzaGFkZXIsIDApO1xuXG4gICAgZ2wubGluZVdpZHRoKDEpO1xuXG4gICAgZ2wudW5pZm9ybTFmKHNoYWRlci51X3NjYWxlLCBNYXRoLnBvdygyLCBwYWludGVyLnRyYW5zZm9ybS56b29tIC0gdGlsZS5jb29yZC56KSk7XG4gICAgZ2wudW5pZm9ybTFmKHNoYWRlci51X3pvb20sIHBhaW50ZXIudHJhbnNmb3JtLnpvb20gKiAxMCk7XG4gICAgZ2wudW5pZm9ybTFmKHNoYWRlci51X21heHpvb20sICh0aWxlLmNvb3JkLnogKyAxKSAqIDEwKTtcblxuICAgIHZhciBiZWdpbiA9IGVsZW1lbnRHcm91cHMuZ3JvdXBzWzBdLnZlcnRleFN0YXJ0SW5kZXg7XG4gICAgdmFyIGxlbiA9IGVsZW1lbnRHcm91cHMuZ3JvdXBzWzBdLnZlcnRleExlbmd0aDtcbiAgICBnbC5kcmF3QXJyYXlzKGdsLkxJTkVTLCBiZWdpbiwgbGVuKTtcblxuICAgIGdsLmRpc2FibGUoZ2wuU1RFTkNJTF9URVNUKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHRleHRWZXJ0aWNlcyA9IHJlcXVpcmUoJy4uL2xpYi9kZWJ1Z3RleHQnKTtcbnZhciBicm93c2VyID0gcmVxdWlyZSgnLi4vdXRpbC9icm93c2VyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZHJhd0RlYnVnO1xuXG5mdW5jdGlvbiBkcmF3RGVidWcocGFpbnRlciwgY29vcmRzKSB7XG4gICAgaWYgKHBhaW50ZXIuaXNPcGFxdWVQYXNzKSByZXR1cm47XG4gICAgaWYgKCFwYWludGVyLm9wdGlvbnMuZGVidWcpIHJldHVybjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29vcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRyYXdEZWJ1Z1RpbGUocGFpbnRlciwgY29vcmRzW2ldKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYXdEZWJ1Z1RpbGUocGFpbnRlciwgY29vcmQpIHtcbiAgICB2YXIgZ2wgPSBwYWludGVyLmdsO1xuXG4gICAgdmFyIHNoYWRlciA9IHBhaW50ZXIuZGVidWdTaGFkZXI7XG4gICAgZ2wuc3dpdGNoU2hhZGVyKHNoYWRlciwgcGFpbnRlci5jYWxjdWxhdGVQb3NNYXRyaXgoY29vcmQpKTtcblxuICAgIC8vIGRyYXcgYm91bmRpbmcgcmVjdGFuZ2xlXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHBhaW50ZXIuZGVidWdCdWZmZXIpO1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyLmFfcG9zLCBwYWludGVyLmRlYnVnQnVmZmVyLml0ZW1TaXplLCBnbC5TSE9SVCwgZmFsc2UsIDAsIDApO1xuICAgIGdsLnVuaWZvcm00ZihzaGFkZXIudV9jb2xvciwgMSwgMCwgMCwgMSk7XG4gICAgZ2wubGluZVdpZHRoKDQpO1xuICAgIGdsLmRyYXdBcnJheXMoZ2wuTElORV9TVFJJUCwgMCwgcGFpbnRlci5kZWJ1Z0J1ZmZlci5pdGVtQ291bnQpO1xuXG4gICAgdmFyIHZlcnRpY2VzID0gdGV4dFZlcnRpY2VzKGNvb3JkLnRvU3RyaW5nKCksIDUwLCAyMDAsIDUpO1xuXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHBhaW50ZXIuZGVidWdUZXh0QnVmZmVyKTtcbiAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgbmV3IEludDE2QXJyYXkodmVydGljZXMpLCBnbC5TVFJFQU1fRFJBVyk7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXIuYV9wb3MsIHBhaW50ZXIuZGVidWdUZXh0QnVmZmVyLml0ZW1TaXplLCBnbC5TSE9SVCwgZmFsc2UsIDAsIDApO1xuICAgIGdsLmxpbmVXaWR0aCg4ICogYnJvd3Nlci5kZXZpY2VQaXhlbFJhdGlvKTtcbiAgICBnbC51bmlmb3JtNGYoc2hhZGVyLnVfY29sb3IsIDEsIDEsIDEsIDEpO1xuICAgIGdsLmRyYXdBcnJheXMoZ2wuTElORVMsIDAsIHZlcnRpY2VzLmxlbmd0aCAvIHBhaW50ZXIuZGVidWdUZXh0QnVmZmVyLml0ZW1TaXplKTtcbiAgICBnbC5saW5lV2lkdGgoMiAqIGJyb3dzZXIuZGV2aWNlUGl4ZWxSYXRpbyk7XG4gICAgZ2wudW5pZm9ybTRmKHNoYWRlci51X2NvbG9yLCAwLCAwLCAwLCAxKTtcbiAgICBnbC5kcmF3QXJyYXlzKGdsLkxJTkVTLCAwLCB2ZXJ0aWNlcy5sZW5ndGggLyBwYWludGVyLmRlYnVnVGV4dEJ1ZmZlci5pdGVtU2l6ZSk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBicm93c2VyID0gcmVxdWlyZSgnLi4vdXRpbC9icm93c2VyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZHJhdztcblxuZnVuY3Rpb24gZHJhdyhwYWludGVyLCBzb3VyY2UsIGxheWVyLCBjb29yZHMpIHtcbiAgICB2YXIgZ2wgPSBwYWludGVyLmdsO1xuXG4gICAgdmFyIGNvbG9yID0gbGF5ZXIucGFpbnRbJ2ZpbGwtY29sb3InXTtcbiAgICB2YXIgaW1hZ2UgPSBsYXllci5wYWludFsnZmlsbC1wYXR0ZXJuJ107XG4gICAgdmFyIHN0cm9rZUNvbG9yID0gbGF5ZXIucGFpbnRbJ2ZpbGwtb3V0bGluZS1jb2xvciddO1xuXG4gICAgLy8gRHJhdyBmaWxsXG4gICAgaWYgKGltYWdlID8gIXBhaW50ZXIuaXNPcGFxdWVQYXNzIDogcGFpbnRlci5pc09wYXF1ZVBhc3MgPT09IChjb2xvclszXSA9PT0gMSkpIHtcbiAgICAgICAgLy8gT25jZSB3ZSBzd2l0Y2ggdG8gZWFyY3V0IGRyYXdpbmcgd2UgY2FuIHB1bGwgbW9zdCBvZiB0aGUgV2ViR0wgc2V0dXBcbiAgICAgICAgLy8gb3V0c2lkZSBvZiB0aGlzIGNvb3JkcyBsb29wLlxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZHJhd0ZpbGwocGFpbnRlciwgc291cmNlLCBsYXllciwgY29vcmRzW2ldKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIERyYXcgc3Ryb2tlXG4gICAgaWYgKCFwYWludGVyLmlzT3BhcXVlUGFzcyAmJiBsYXllci5wYWludFsnZmlsbC1hbnRpYWxpYXMnXSAmJiAhKGxheWVyLnBhaW50WydmaWxsLXBhdHRlcm4nXSAmJiAhc3Ryb2tlQ29sb3IpKSB7XG4gICAgICAgIGdsLnN3aXRjaFNoYWRlcihwYWludGVyLm91dGxpbmVTaGFkZXIpO1xuICAgICAgICBnbC5saW5lV2lkdGgoMiAqIGJyb3dzZXIuZGV2aWNlUGl4ZWxSYXRpbyAqIDEwKTtcblxuICAgICAgICBpZiAoc3Ryb2tlQ29sb3IpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGRlZmluZWQgYSBkaWZmZXJlbnQgY29sb3IgZm9yIHRoZSBmaWxsIG91dGxpbmUsIHdlIGFyZVxuICAgICAgICAgICAgLy8gZ29pbmcgdG8gaWdub3JlIHRoZSBiaXRzIGluIDB4MDcgYW5kIGp1c3QgY2FyZSBhYm91dCB0aGUgZ2xvYmFsXG4gICAgICAgICAgICAvLyBjbGlwcGluZyBtYXNrLlxuICAgICAgICAgICAgcGFpbnRlci5zZXREZXB0aFN1YmxheWVyKDIpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIHdlIG9ubHkgd2FudCB0byBkcmF3RmlsbCB0aGUgYW50aWFsaWFzZWQgcGFydHMgdGhhdCBhcmVcbiAgICAgICAgICAgIC8vICpvdXRzaWRlKiB0aGUgY3VycmVudCBzaGFwZS4gVGhpcyBpcyBpbXBvcnRhbnQgaW4gY2FzZSB0aGUgZmlsbFxuICAgICAgICAgICAgLy8gb3Igc3Ryb2tlIGNvbG9yIGlzIHRyYW5zbHVjZW50LiBJZiB3ZSB3b3VsZG4ndCBjbGlwIHRvIG91dHNpZGVcbiAgICAgICAgICAgIC8vIHRoZSBjdXJyZW50IHNoYXBlLCBzb21lIHBpeGVscyBmcm9tIHRoZSBvdXRsaW5lIHN0cm9rZSBvdmVybGFwcGVkXG4gICAgICAgICAgICAvLyB0aGUgKG5vbi1hbnRpYWxpYXNlZCkgZmlsbC5cbiAgICAgICAgICAgIHBhaW50ZXIuc2V0RGVwdGhTdWJsYXllcigwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdsLnVuaWZvcm0yZihwYWludGVyLm91dGxpbmVTaGFkZXIudV93b3JsZCwgZ2wuZHJhd2luZ0J1ZmZlcldpZHRoLCBnbC5kcmF3aW5nQnVmZmVySGVpZ2h0KTtcbiAgICAgICAgZ2wudW5pZm9ybTRmdihwYWludGVyLm91dGxpbmVTaGFkZXIudV9jb2xvciwgc3Ryb2tlQ29sb3IgPyBzdHJva2VDb2xvciA6IGNvbG9yKTtcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvb3Jkcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgZHJhd1N0cm9rZShwYWludGVyLCBzb3VyY2UsIGxheWVyLCBjb29yZHNbal0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmF3RmlsbChwYWludGVyLCBzb3VyY2UsIGxheWVyLCBjb29yZCkge1xuICAgIHZhciB0aWxlID0gc291cmNlLmdldFRpbGUoY29vcmQpO1xuICAgIGlmICghdGlsZS5idWZmZXJzKSByZXR1cm47XG4gICAgdmFyIGVsZW1lbnRHcm91cHMgPSB0aWxlLmdldEVsZW1lbnRHcm91cHMobGF5ZXIsICdmaWxsJyk7XG4gICAgaWYgKCFlbGVtZW50R3JvdXBzKSByZXR1cm47XG5cbiAgICB2YXIgZ2wgPSBwYWludGVyLmdsO1xuXG4gICAgdmFyIGNvbG9yID0gbGF5ZXIucGFpbnRbJ2ZpbGwtY29sb3InXTtcbiAgICB2YXIgaW1hZ2UgPSBsYXllci5wYWludFsnZmlsbC1wYXR0ZXJuJ107XG4gICAgdmFyIG9wYWNpdHkgPSBsYXllci5wYWludFsnZmlsbC1vcGFjaXR5J107XG5cbiAgICB2YXIgcG9zTWF0cml4ID0gcGFpbnRlci5jYWxjdWxhdGVQb3NNYXRyaXgoY29vcmQsIHNvdXJjZS5tYXh6b29tKTtcbiAgICB2YXIgdHJhbnNsYXRlZFBvc01hdHJpeCA9IHBhaW50ZXIudHJhbnNsYXRlUG9zTWF0cml4KHBvc01hdHJpeCwgdGlsZSwgbGF5ZXIucGFpbnRbJ2ZpbGwtdHJhbnNsYXRlJ10sIGxheWVyLnBhaW50WydmaWxsLXRyYW5zbGF0ZS1hbmNob3InXSk7XG5cbiAgICAvLyBEcmF3IHRoZSBzdGVuY2lsIG1hc2suXG4gICAgcGFpbnRlci5zZXREZXB0aFN1YmxheWVyKDEpO1xuXG4gICAgLy8gV2UncmUgb25seSBkcmF3RmlsbGluZyB0byB0aGUgZmlyc3Qgc2V2ZW4gYml0cyAoPT0gc3VwcG9ydCBhIG1heGltdW0gb2ZcbiAgICAvLyA4IG92ZXJsYXBwaW5nIHBvbHlnb25zIGluIG9uZSBwbGFjZSBiZWZvcmUgd2UgZ2V0IHJlbmRlcmluZyBlcnJvcnMpLlxuICAgIGdsLnN0ZW5jaWxNYXNrKDB4MDcpO1xuICAgIGdsLmNsZWFyKGdsLlNURU5DSUxfQlVGRkVSX0JJVCk7XG5cbiAgICAvLyBEcmF3IGZyb250IGZhY2luZyB0cmlhbmdsZXMuIFdoZXJldmVyIHRoZSAweDgwIGJpdCBpcyAxLCB3ZSBhcmVcbiAgICAvLyBpbmNyZWFzaW5nIHRoZSBsb3dlciA3IGJpdHMgYnkgb25lIGlmIHRoZSB0cmlhbmdsZSBpcyBhIGZyb250LWZhY2luZ1xuICAgIC8vIHRyaWFuZ2xlLiBUaGlzIG1lYW5zIHRoYXQgYWxsIHZpc2libGUgcG9seWdvbnMgc2hvdWxkIGJlIGluIENDV1xuICAgIC8vIG9yaWVudGF0aW9uLCB3aGlsZSBhbGwgaG9sZXMgKHNlZSBiZWxvdykgYXJlIGluIENXIG9yaWVudGF0aW9uLlxuICAgIHBhaW50ZXIuZW5hYmxlVGlsZUNsaXBwaW5nTWFzayhjb29yZCk7XG5cbiAgICAvLyBXaGVuIHdlIGRvIGEgbm9uemVybyBmaWxsLCB3ZSBjb3VudCB0aGUgbnVtYmVyIG9mIHRpbWVzIGEgcGl4ZWwgaXNcbiAgICAvLyBjb3ZlcmVkIGJ5IGEgY291bnRlcmNsb2Nrd2lzZSBwb2x5Z29uLCBhbmQgc3VidHJhY3QgdGhlIG51bWJlciBvZlxuICAgIC8vIHRpbWVzIGl0IGlzIFwidW5jb3ZlcmVkXCIgYnkgYSBjbG9ja3dpc2UgcG9seWdvbi5cbiAgICBnbC5zdGVuY2lsT3BTZXBhcmF0ZShnbC5GUk9OVCwgZ2wuS0VFUCwgZ2wuS0VFUCwgZ2wuSU5DUl9XUkFQKTtcbiAgICBnbC5zdGVuY2lsT3BTZXBhcmF0ZShnbC5CQUNLLCBnbC5LRUVQLCBnbC5LRUVQLCBnbC5ERUNSX1dSQVApO1xuXG4gICAgLy8gV2hlbiBkcmF3RmlsbGluZyBhIHNoYXBlLCB3ZSBmaXJzdCBkcmF3RmlsbCBhbGwgc2hhcGVzIHRvIHRoZSBzdGVuY2lsIGJ1ZmZlclxuICAgIC8vIGFuZCBpbmNyZW1lbnRpbmcgYWxsIGFyZWFzIHdoZXJlIHBvbHlnb25zIGFyZVxuICAgIGdsLmNvbG9yTWFzayhmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSk7XG4gICAgcGFpbnRlci5kZXB0aE1hc2soZmFsc2UpO1xuXG4gICAgLy8gRHJhdyB0aGUgYWN0dWFsIHRyaWFuZ2xlIGZhbiBpbnRvIHRoZSBzdGVuY2lsIGJ1ZmZlci5cbiAgICBnbC5zd2l0Y2hTaGFkZXIocGFpbnRlci5maWxsU2hhZGVyLCB0cmFuc2xhdGVkUG9zTWF0cml4KTtcblxuICAgIC8vIERyYXcgYWxsIGJ1ZmZlcnNcbiAgICB2YXIgdmVydGV4ID0gdGlsZS5idWZmZXJzLmZpbGxWZXJ0ZXg7XG4gICAgdmVydGV4LmJpbmQoZ2wpO1xuXG4gICAgdmFyIGVsZW1lbnRzID0gdGlsZS5idWZmZXJzLmZpbGxFbGVtZW50O1xuICAgIGVsZW1lbnRzLmJpbmQoZ2wpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50R3JvdXBzLmdyb3Vwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZ3JvdXAgPSBlbGVtZW50R3JvdXBzLmdyb3Vwc1tpXTtcbiAgICAgICAgdmFyIG9mZnNldCA9IGdyb3VwLnZlcnRleFN0YXJ0SW5kZXggKiB2ZXJ0ZXguaXRlbVNpemU7XG4gICAgICAgIHZlcnRleC5zZXRBdHRyaWJQb2ludGVycyhnbCwgcGFpbnRlci5maWxsU2hhZGVyLCBvZmZzZXQpO1xuXG4gICAgICAgIHZhciBjb3VudCA9IGdyb3VwLmVsZW1lbnRMZW5ndGggKiAzO1xuICAgICAgICB2YXIgZWxlbWVudE9mZnNldCA9IGdyb3VwLmVsZW1lbnRTdGFydEluZGV4ICogZWxlbWVudHMuaXRlbVNpemU7XG4gICAgICAgIGdsLmRyYXdFbGVtZW50cyhnbC5UUklBTkdMRVMsIGNvdW50LCBnbC5VTlNJR05FRF9TSE9SVCwgZWxlbWVudE9mZnNldCk7XG4gICAgfVxuXG4gICAgLy8gTm93IHRoYXQgd2UgaGF2ZSB0aGUgc3RlbmNpbCBtYXNrIGluIHRoZSBzdGVuY2lsIGJ1ZmZlciwgd2UgY2FuIHN0YXJ0XG4gICAgLy8gd3JpdGluZyB0byB0aGUgY29sb3IgYnVmZmVyLlxuICAgIGdsLmNvbG9yTWFzayh0cnVlLCB0cnVlLCB0cnVlLCB0cnVlKTtcbiAgICBwYWludGVyLmRlcHRoTWFzayh0cnVlKTtcblxuICAgIC8vIEZyb20gbm93IG9uLCB3ZSBkb24ndCB3YW50IHRvIHVwZGF0ZSB0aGUgc3RlbmNpbCBidWZmZXIgYW55bW9yZS5cbiAgICBnbC5zdGVuY2lsT3AoZ2wuS0VFUCwgZ2wuS0VFUCwgZ2wuS0VFUCk7XG4gICAgZ2wuc3RlbmNpbE1hc2soMHgwKTtcbiAgICB2YXIgc2hhZGVyO1xuXG4gICAgaWYgKGltYWdlKSB7XG4gICAgICAgIC8vIERyYXcgdGV4dHVyZSBmaWxsXG4gICAgICAgIHZhciBpbWFnZVBvc0EgPSBwYWludGVyLnNwcml0ZUF0bGFzLmdldFBvc2l0aW9uKGltYWdlLmZyb20sIHRydWUpO1xuICAgICAgICB2YXIgaW1hZ2VQb3NCID0gcGFpbnRlci5zcHJpdGVBdGxhcy5nZXRQb3NpdGlvbihpbWFnZS50bywgdHJ1ZSk7XG4gICAgICAgIGlmICghaW1hZ2VQb3NBIHx8ICFpbWFnZVBvc0IpIHJldHVybjtcblxuICAgICAgICBzaGFkZXIgPSBwYWludGVyLnBhdHRlcm5TaGFkZXI7XG4gICAgICAgIGdsLnN3aXRjaFNoYWRlcihzaGFkZXIsIHBvc01hdHJpeCk7XG4gICAgICAgIGdsLnVuaWZvcm0xaShzaGFkZXIudV9pbWFnZSwgMCk7XG4gICAgICAgIGdsLnVuaWZvcm0yZnYoc2hhZGVyLnVfcGF0dGVybl90bF9hLCBpbWFnZVBvc0EudGwpO1xuICAgICAgICBnbC51bmlmb3JtMmZ2KHNoYWRlci51X3BhdHRlcm5fYnJfYSwgaW1hZ2VQb3NBLmJyKTtcbiAgICAgICAgZ2wudW5pZm9ybTJmdihzaGFkZXIudV9wYXR0ZXJuX3RsX2IsIGltYWdlUG9zQi50bCk7XG4gICAgICAgIGdsLnVuaWZvcm0yZnYoc2hhZGVyLnVfcGF0dGVybl9icl9iLCBpbWFnZVBvc0IuYnIpO1xuICAgICAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVfb3BhY2l0eSwgb3BhY2l0eSk7XG4gICAgICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9taXgsIGltYWdlLnQpO1xuXG4gICAgICAgIHZhciBzY2FsZSA9IE1hdGgucG93KDIsIHBhaW50ZXIudHJhbnNmb3JtLnRpbGVab29tIC0gdGlsZS5jb29yZC56KTtcbiAgICAgICAgdmFyIGZhY3RvciA9IDQwOTYgLyB0aWxlLnRpbGVTaXplO1xuXG4gICAgICAgIHZhciBpbWFnZVNpemVTY2FsZWRBID0gW1xuICAgICAgICAgICAgKGltYWdlUG9zQS5zaXplWzBdICogaW1hZ2UuZnJvbVNjYWxlKSAvIHNjYWxlLFxuICAgICAgICAgICAgKGltYWdlUG9zQS5zaXplWzFdICogaW1hZ2UuZnJvbVNjYWxlKSAvIHNjYWxlXG4gICAgICAgIF07XG4gICAgICAgIHZhciBpbWFnZVNpemVTY2FsZWRCID0gW1xuICAgICAgICAgICAgKGltYWdlUG9zQi5zaXplWzBdICogaW1hZ2UudG9TY2FsZSkgLyBzY2FsZSxcbiAgICAgICAgICAgIChpbWFnZVBvc0Iuc2l6ZVsxXSAqIGltYWdlLnRvU2NhbGUpIC8gc2NhbGVcbiAgICAgICAgXTtcblxuICAgICAgICBnbC51bmlmb3JtMmZ2KHNoYWRlci51X3BhdHRlcm5zY2FsZV9hLCBbXG4gICAgICAgICAgICAxIC8gKGltYWdlU2l6ZVNjYWxlZEFbMF0gKiBmYWN0b3IpLFxuICAgICAgICAgICAgMSAvIChpbWFnZVNpemVTY2FsZWRBWzFdICogZmFjdG9yKVxuICAgICAgICBdKTtcblxuICAgICAgICBnbC51bmlmb3JtMmZ2KHNoYWRlci51X3BhdHRlcm5zY2FsZV9iLCBbXG4gICAgICAgICAgICAxIC8gKGltYWdlU2l6ZVNjYWxlZEJbMF0gKiBmYWN0b3IpLFxuICAgICAgICAgICAgMSAvIChpbWFnZVNpemVTY2FsZWRCWzFdICogZmFjdG9yKVxuICAgICAgICBdKTtcblxuICAgICAgICAvLyBzaGlmdCBpbWFnZXMgdG8gbWF0Y2ggYXQgdGlsZSBib3VuZGFyaWVzXG4gICAgICAgIHZhciBvZmZzZXRBeCA9ICgodGlsZS50aWxlU2l6ZSAlIGltYWdlU2l6ZVNjYWxlZEFbMF0pICogKHRpbGUuY29vcmQueCArIGNvb3JkLncgKiBNYXRoLnBvdygyLCB0aWxlLmNvb3JkLnopKSkgLyBpbWFnZVNpemVTY2FsZWRBWzBdO1xuICAgICAgICB2YXIgb2Zmc2V0QXkgPSAoKHRpbGUudGlsZVNpemUgJSBpbWFnZVNpemVTY2FsZWRBWzFdKSAqIHRpbGUuY29vcmQueSkgLyBpbWFnZVNpemVTY2FsZWRBWzFdO1xuXG4gICAgICAgIHZhciBvZmZzZXRCeCA9ICgodGlsZS50aWxlU2l6ZSAlIGltYWdlU2l6ZVNjYWxlZEJbMF0pICogKHRpbGUuY29vcmQueCArIGNvb3JkLncgKiBNYXRoLnBvdygyLCB0aWxlLmNvb3JkLnopKSkgLyBpbWFnZVNpemVTY2FsZWRCWzBdO1xuICAgICAgICB2YXIgb2Zmc2V0QnkgPSAoKHRpbGUudGlsZVNpemUgJSBpbWFnZVNpemVTY2FsZWRCWzFdKSAqIHRpbGUuY29vcmQueSkgLyBpbWFnZVNpemVTY2FsZWRCWzFdO1xuXG4gICAgICAgIGdsLnVuaWZvcm0yZnYoc2hhZGVyLnVfb2Zmc2V0X2EsIFtvZmZzZXRBeCwgb2Zmc2V0QXldKTtcbiAgICAgICAgZ2wudW5pZm9ybTJmdihzaGFkZXIudV9vZmZzZXRfYiwgW29mZnNldEJ4LCBvZmZzZXRCeV0pO1xuXG4gICAgICAgIHBhaW50ZXIuc3ByaXRlQXRsYXMuYmluZChnbCwgdHJ1ZSk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBEcmF3IGZpbGxpbmcgcmVjdGFuZ2xlLlxuICAgICAgICBzaGFkZXIgPSBwYWludGVyLmZpbGxTaGFkZXI7XG4gICAgICAgIGdsLnN3aXRjaFNoYWRlcihzaGFkZXIsIHBvc01hdHJpeCk7XG4gICAgICAgIGdsLnVuaWZvcm00ZnYoc2hhZGVyLnVfY29sb3IsIGNvbG9yKTtcbiAgICB9XG5cbiAgICAvLyBPbmx5IGRyYXcgcmVnaW9ucyB0aGF0IHdlIG1hcmtlZFxuICAgIGdsLnN0ZW5jaWxGdW5jKGdsLk5PVEVRVUFMLCAweDAsIDB4MDcpO1xuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBwYWludGVyLnRpbGVFeHRlbnRCdWZmZXIpO1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyLmFfcG9zLCBwYWludGVyLnRpbGVFeHRlbnRCdWZmZXIuaXRlbVNpemUsIGdsLlNIT1JULCBmYWxzZSwgMCwgMCk7XG4gICAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRV9TVFJJUCwgMCwgcGFpbnRlci50aWxlRXh0ZW50QnVmZmVyLml0ZW1Db3VudCk7XG5cbiAgICBnbC5zdGVuY2lsTWFzaygweDAwKTtcbn1cblxuZnVuY3Rpb24gZHJhd1N0cm9rZShwYWludGVyLCBzb3VyY2UsIGxheWVyLCBjb29yZCkge1xuICAgIHZhciB0aWxlID0gc291cmNlLmdldFRpbGUoY29vcmQpO1xuICAgIGlmICghdGlsZS5idWZmZXJzKSByZXR1cm47XG4gICAgaWYgKCF0aWxlLmVsZW1lbnRHcm91cHNbbGF5ZXIucmVmIHx8IGxheWVyLmlkXSkgcmV0dXJuO1xuXG4gICAgdmFyIGdsID0gcGFpbnRlci5nbDtcbiAgICB2YXIgZWxlbWVudEdyb3VwcyA9IHRpbGUuZWxlbWVudEdyb3Vwc1tsYXllci5yZWYgfHwgbGF5ZXIuaWRdLmZpbGw7XG5cbiAgICBnbC5zZXRQb3NNYXRyaXgocGFpbnRlci50cmFuc2xhdGVQb3NNYXRyaXgoXG4gICAgICAgIHBhaW50ZXIuY2FsY3VsYXRlUG9zTWF0cml4KGNvb3JkLCBzb3VyY2UubWF4em9vbSksXG4gICAgICAgIHRpbGUsXG4gICAgICAgIGxheWVyLnBhaW50WydmaWxsLXRyYW5zbGF0ZSddLFxuICAgICAgICBsYXllci5wYWludFsnZmlsbC10cmFuc2xhdGUtYW5jaG9yJ11cbiAgICApKTtcblxuICAgIC8vIERyYXcgYWxsIGJ1ZmZlcnNcbiAgICB2YXIgdmVydGV4ID0gdGlsZS5idWZmZXJzLmZpbGxWZXJ0ZXg7XG4gICAgdmFyIGVsZW1lbnRzID0gdGlsZS5idWZmZXJzLmZpbGxTZWNvbmRFbGVtZW50O1xuICAgIHZlcnRleC5iaW5kKGdsKTtcbiAgICBlbGVtZW50cy5iaW5kKGdsKTtcblxuICAgIHBhaW50ZXIuZW5hYmxlVGlsZUNsaXBwaW5nTWFzayhjb29yZCk7XG5cbiAgICBmb3IgKHZhciBrID0gMDsgayA8IGVsZW1lbnRHcm91cHMuZ3JvdXBzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIHZhciBncm91cCA9IGVsZW1lbnRHcm91cHMuZ3JvdXBzW2tdO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gZ3JvdXAudmVydGV4U3RhcnRJbmRleCAqIHZlcnRleC5pdGVtU2l6ZTtcbiAgICAgICAgdmVydGV4LnNldEF0dHJpYlBvaW50ZXJzKGdsLCBwYWludGVyLm91dGxpbmVTaGFkZXIsIG9mZnNldCk7XG5cbiAgICAgICAgdmFyIGNvdW50ID0gZ3JvdXAuc2Vjb25kRWxlbWVudExlbmd0aCAqIDI7XG4gICAgICAgIHZhciBlbGVtZW50T2Zmc2V0ID0gZ3JvdXAuc2Vjb25kRWxlbWVudFN0YXJ0SW5kZXggKiBlbGVtZW50cy5pdGVtU2l6ZTtcbiAgICAgICAgZ2wuZHJhd0VsZW1lbnRzKGdsLkxJTkVTLCBjb3VudCwgZ2wuVU5TSUdORURfU0hPUlQsIGVsZW1lbnRPZmZzZXQpO1xuICAgIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGJyb3dzZXIgPSByZXF1aXJlKCcuLi91dGlsL2Jyb3dzZXInKTtcbnZhciBtYXQyID0gcmVxdWlyZSgnZ2wtbWF0cml4JykubWF0MjtcblxuLyoqXG4gKiBEcmF3IGEgbGluZS4gVW5kZXIgdGhlIGhvb2QgdGhpcyB3aWxsIHJlYWQgZWxlbWVudHMgZnJvbVxuICogYSB0aWxlLCBkYXNoIHRleHR1cmVzIGZyb20gYSBsaW5lQXRsYXMsIGFuZCBzdHlsZSBwcm9wZXJ0aWVzIGZyb20gYSBsYXllci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWludGVyXG4gKiBAcGFyYW0ge09iamVjdH0gbGF5ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBwb3NNYXRyaXhcbiAqIEBwYXJhbSB7VGlsZX0gdGlsZVxuICogQHJldHVybnMge3VuZGVmaW5lZH0gZHJhd3Mgd2l0aCB0aGUgcGFpbnRlclxuICogQHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkcmF3TGluZShwYWludGVyLCBzb3VyY2UsIGxheWVyLCBjb29yZHMpIHtcbiAgICBpZiAocGFpbnRlci5pc09wYXF1ZVBhc3MpIHJldHVybjtcbiAgICBwYWludGVyLnNldERlcHRoU3VibGF5ZXIoMCk7XG4gICAgcGFpbnRlci5kZXB0aE1hc2soZmFsc2UpO1xuXG4gICAgdmFyIGhhc0RhdGEgPSBjb29yZHMuc29tZShmdW5jdGlvbihjb29yZCkge1xuICAgICAgICByZXR1cm4gc291cmNlLmdldFRpbGUoY29vcmQpLmdldEVsZW1lbnRHcm91cHMobGF5ZXIsICdsaW5lJyk7XG4gICAgfSk7XG4gICAgaWYgKCFoYXNEYXRhKSByZXR1cm47XG5cbiAgICB2YXIgZ2wgPSBwYWludGVyLmdsO1xuXG4gICAgLy8gZG9uJ3QgZHJhdyB6ZXJvLXdpZHRoIGxpbmVzXG4gICAgaWYgKGxheWVyLnBhaW50WydsaW5lLXdpZHRoJ10gPD0gMCkgcmV0dXJuO1xuXG4gICAgLy8gdGhlIGRpc3RhbmNlIG92ZXIgd2hpY2ggdGhlIGxpbmUgZWRnZSBmYWRlcyBvdXQuXG4gICAgLy8gUmV0aW5hIGRldmljZXMgbmVlZCBhIHNtYWxsZXIgZGlzdGFuY2UgdG8gYXZvaWQgYWxpYXNpbmcuXG4gICAgdmFyIGFudGlhbGlhc2luZyA9IDEgLyBicm93c2VyLmRldmljZVBpeGVsUmF0aW87XG5cbiAgICB2YXIgYmx1ciA9IGxheWVyLnBhaW50WydsaW5lLWJsdXInXSArIGFudGlhbGlhc2luZztcbiAgICB2YXIgZWRnZVdpZHRoID0gbGF5ZXIucGFpbnRbJ2xpbmUtd2lkdGgnXSAvIDI7XG4gICAgdmFyIGluc2V0ID0gLTE7XG4gICAgdmFyIG9mZnNldCA9IDA7XG4gICAgdmFyIHNoaWZ0ID0gMDtcblxuICAgIGlmIChsYXllci5wYWludFsnbGluZS1nYXAtd2lkdGgnXSA+IDApIHtcbiAgICAgICAgaW5zZXQgPSBsYXllci5wYWludFsnbGluZS1nYXAtd2lkdGgnXSAvIDIgKyBhbnRpYWxpYXNpbmcgKiAwLjU7XG4gICAgICAgIGVkZ2VXaWR0aCA9IGxheWVyLnBhaW50WydsaW5lLXdpZHRoJ107XG5cbiAgICAgICAgLy8gc2hpZnQgb3V0ZXIgbGluZXMgaGFsZiBhIHBpeGVsIHRvd2FyZHMgdGhlIG1pZGRsZSB0byBlbGltaW5hdGUgdGhlIGNyYWNrXG4gICAgICAgIG9mZnNldCA9IGluc2V0IC0gYW50aWFsaWFzaW5nIC8gMjtcbiAgICB9XG5cbiAgICB2YXIgb3V0c2V0ID0gb2Zmc2V0ICsgZWRnZVdpZHRoICsgYW50aWFsaWFzaW5nIC8gMiArIHNoaWZ0O1xuICAgIHZhciBjb2xvciA9IGxheWVyLnBhaW50WydsaW5lLWNvbG9yJ107XG5cbiAgICB2YXIgdHIgPSBwYWludGVyLnRyYW5zZm9ybTtcblxuICAgIHZhciBhbnRpYWxpYXNpbmdNYXRyaXggPSBtYXQyLmNyZWF0ZSgpO1xuICAgIG1hdDIuc2NhbGUoYW50aWFsaWFzaW5nTWF0cml4LCBhbnRpYWxpYXNpbmdNYXRyaXgsIFsxLCBNYXRoLmNvcyh0ci5fcGl0Y2gpXSk7XG4gICAgbWF0Mi5yb3RhdGUoYW50aWFsaWFzaW5nTWF0cml4LCBhbnRpYWxpYXNpbmdNYXRyaXgsIHBhaW50ZXIudHJhbnNmb3JtLmFuZ2xlKTtcblxuICAgIC8vIGNhbGN1bGF0ZSBob3cgbXVjaCBsb25nZXIgdGhlIHJlYWwgd29ybGQgZGlzdGFuY2UgaXMgYXQgdGhlIHRvcCBvZiB0aGUgc2NyZWVuXG4gICAgLy8gdGhhbiBhdCB0aGUgbWlkZGxlIG9mIHRoZSBzY3JlZW4uXG4gICAgdmFyIHRvcGVkZ2VsZW5ndGggPSBNYXRoLnNxcnQodHIuaGVpZ2h0ICogdHIuaGVpZ2h0IC8gNCAgKiAoMSArIHRyLmFsdGl0dWRlICogdHIuYWx0aXR1ZGUpKTtcbiAgICB2YXIgeCA9IHRyLmhlaWdodCAvIDIgKiBNYXRoLnRhbih0ci5fcGl0Y2gpO1xuICAgIHZhciBleHRyYSA9ICh0b3BlZGdlbGVuZ3RoICsgeCkgLyB0b3BlZGdlbGVuZ3RoIC0gMTtcblxuICAgIHZhciBkYXNoYXJyYXkgPSBsYXllci5wYWludFsnbGluZS1kYXNoYXJyYXknXTtcbiAgICB2YXIgaW1hZ2UgPSBsYXllci5wYWludFsnbGluZS1wYXR0ZXJuJ107XG4gICAgdmFyIHNoYWRlciwgcG9zQSwgcG9zQiwgaW1hZ2VQb3NBLCBpbWFnZVBvc0I7XG5cbiAgICBpZiAoZGFzaGFycmF5KSB7XG4gICAgICAgIHNoYWRlciA9IHBhaW50ZXIubGluZXNkZnBhdHRlcm5TaGFkZXI7XG4gICAgICAgIGdsLnN3aXRjaFNoYWRlcihzaGFkZXIpO1xuXG4gICAgICAgIGdsLnVuaWZvcm0yZnYoc2hhZGVyLnVfbGluZXdpZHRoLCBbIG91dHNldCwgaW5zZXQgXSk7XG4gICAgICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9ibHVyLCBibHVyKTtcbiAgICAgICAgZ2wudW5pZm9ybTRmdihzaGFkZXIudV9jb2xvciwgY29sb3IpO1xuXG4gICAgICAgIHBvc0EgPSBwYWludGVyLmxpbmVBdGxhcy5nZXREYXNoKGRhc2hhcnJheS5mcm9tLCBsYXllci5sYXlvdXRbJ2xpbmUtY2FwJ10gPT09ICdyb3VuZCcpO1xuICAgICAgICBwb3NCID0gcGFpbnRlci5saW5lQXRsYXMuZ2V0RGFzaChkYXNoYXJyYXkudG8sIGxheWVyLmxheW91dFsnbGluZS1jYXAnXSA9PT0gJ3JvdW5kJyk7XG4gICAgICAgIHBhaW50ZXIubGluZUF0bGFzLmJpbmQoZ2wpO1xuXG4gICAgICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV90ZXhfeV9hLCBwb3NBLnkpO1xuICAgICAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVfdGV4X3lfYiwgcG9zQi55KTtcbiAgICAgICAgZ2wudW5pZm9ybTFpKHNoYWRlci51X2ltYWdlLCAwKTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHNoYWRlci51X21peCwgZGFzaGFycmF5LnQpO1xuXG4gICAgICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9leHRyYSwgZXh0cmEpO1xuICAgICAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVfb2Zmc2V0LCAtbGF5ZXIucGFpbnRbJ2xpbmUtb2Zmc2V0J10pO1xuICAgICAgICBnbC51bmlmb3JtTWF0cml4MmZ2KHNoYWRlci51X2FudGlhbGlhc2luZ21hdHJpeCwgZmFsc2UsIGFudGlhbGlhc2luZ01hdHJpeCk7XG5cbiAgICB9IGVsc2UgaWYgKGltYWdlKSB7XG4gICAgICAgIGltYWdlUG9zQSA9IHBhaW50ZXIuc3ByaXRlQXRsYXMuZ2V0UG9zaXRpb24oaW1hZ2UuZnJvbSwgdHJ1ZSk7XG4gICAgICAgIGltYWdlUG9zQiA9IHBhaW50ZXIuc3ByaXRlQXRsYXMuZ2V0UG9zaXRpb24oaW1hZ2UudG8sIHRydWUpO1xuICAgICAgICBpZiAoIWltYWdlUG9zQSB8fCAhaW1hZ2VQb3NCKSByZXR1cm47XG5cbiAgICAgICAgcGFpbnRlci5zcHJpdGVBdGxhcy5iaW5kKGdsLCB0cnVlKTtcblxuICAgICAgICBzaGFkZXIgPSBwYWludGVyLmxpbmVwYXR0ZXJuU2hhZGVyO1xuICAgICAgICBnbC5zd2l0Y2hTaGFkZXIoc2hhZGVyKTtcblxuICAgICAgICBnbC51bmlmb3JtMmZ2KHNoYWRlci51X2xpbmV3aWR0aCwgWyBvdXRzZXQsIGluc2V0IF0pO1xuICAgICAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVfYmx1ciwgYmx1cik7XG4gICAgICAgIGdsLnVuaWZvcm0yZnYoc2hhZGVyLnVfcGF0dGVybl90bF9hLCBpbWFnZVBvc0EudGwpO1xuICAgICAgICBnbC51bmlmb3JtMmZ2KHNoYWRlci51X3BhdHRlcm5fYnJfYSwgaW1hZ2VQb3NBLmJyKTtcbiAgICAgICAgZ2wudW5pZm9ybTJmdihzaGFkZXIudV9wYXR0ZXJuX3RsX2IsIGltYWdlUG9zQi50bCk7XG4gICAgICAgIGdsLnVuaWZvcm0yZnYoc2hhZGVyLnVfcGF0dGVybl9icl9iLCBpbWFnZVBvc0IuYnIpO1xuICAgICAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVfZmFkZSwgaW1hZ2UudCk7XG4gICAgICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9vcGFjaXR5LCBsYXllci5wYWludFsnbGluZS1vcGFjaXR5J10pO1xuXG4gICAgICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9leHRyYSwgZXh0cmEpO1xuICAgICAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVfb2Zmc2V0LCAtbGF5ZXIucGFpbnRbJ2xpbmUtb2Zmc2V0J10pO1xuICAgICAgICBnbC51bmlmb3JtTWF0cml4MmZ2KHNoYWRlci51X2FudGlhbGlhc2luZ21hdHJpeCwgZmFsc2UsIGFudGlhbGlhc2luZ01hdHJpeCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICBzaGFkZXIgPSBwYWludGVyLmxpbmVTaGFkZXI7XG4gICAgICAgIGdsLnN3aXRjaFNoYWRlcihzaGFkZXIpO1xuXG4gICAgICAgIGdsLnVuaWZvcm0yZnYoc2hhZGVyLnVfbGluZXdpZHRoLCBbIG91dHNldCwgaW5zZXQgXSk7XG4gICAgICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9ibHVyLCBibHVyKTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHNoYWRlci51X2V4dHJhLCBleHRyYSk7XG4gICAgICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9vZmZzZXQsIC1sYXllci5wYWludFsnbGluZS1vZmZzZXQnXSk7XG4gICAgICAgIGdsLnVuaWZvcm1NYXRyaXgyZnYoc2hhZGVyLnVfYW50aWFsaWFzaW5nbWF0cml4LCBmYWxzZSwgYW50aWFsaWFzaW5nTWF0cml4KTtcbiAgICAgICAgZ2wudW5pZm9ybTRmdihzaGFkZXIudV9jb2xvciwgY29sb3IpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgY29vcmRzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIHZhciBjb29yZCA9IGNvb3Jkc1trXTtcbiAgICAgICAgdmFyIHRpbGUgPSBzb3VyY2UuZ2V0VGlsZShjb29yZCk7XG5cbiAgICAgICAgdmFyIGVsZW1lbnRHcm91cHMgPSB0aWxlLmdldEVsZW1lbnRHcm91cHMobGF5ZXIsICdsaW5lJyk7XG4gICAgICAgIGlmICghZWxlbWVudEdyb3VwcykgY29udGludWU7XG5cbiAgICAgICAgcGFpbnRlci5lbmFibGVUaWxlQ2xpcHBpbmdNYXNrKGNvb3JkKTtcblxuICAgICAgICAvLyBzZXQgdW5pZm9ybXMgdGhhdCBhcmUgZGlmZmVyZW50IGZvciBlYWNoIHRpbGVcbiAgICAgICAgdmFyIHBvc01hdHJpeCA9IHBhaW50ZXIudHJhbnNsYXRlUG9zTWF0cml4KHBhaW50ZXIuY2FsY3VsYXRlUG9zTWF0cml4KGNvb3JkLCBzb3VyY2UubWF4em9vbSksIHRpbGUsIGxheWVyLnBhaW50WydsaW5lLXRyYW5zbGF0ZSddLCBsYXllci5wYWludFsnbGluZS10cmFuc2xhdGUtYW5jaG9yJ10pO1xuXG4gICAgICAgIGdsLnNldFBvc01hdHJpeChwb3NNYXRyaXgpO1xuICAgICAgICBnbC5zZXRFeE1hdHJpeChwYWludGVyLnRyYW5zZm9ybS5leE1hdHJpeCk7XG4gICAgICAgIHZhciByYXRpbyA9IHBhaW50ZXIudHJhbnNmb3JtLnNjYWxlIC8gKDEgPDwgY29vcmQueikgLyAoNDA5NiAvIHRpbGUudGlsZVNpemUpO1xuXG5cbiAgICAgICAgaWYgKGRhc2hhcnJheSkge1xuICAgICAgICAgICAgLy8gaG93IG11Y2ggdGhlIHRpbGUgaXMgb3ZlcnNjYWxlZCBieVxuICAgICAgICAgICAgdmFyIG92ZXJzY2FsaW5nID0gdGlsZS50aWxlU2l6ZSAvIHBhaW50ZXIudHJhbnNmb3JtLnRpbGVTaXplO1xuXG4gICAgICAgICAgICB2YXIgcGF0dGVybnJhdGlvID0gTWF0aC5wb3coMiwgTWF0aC5mbG9vcihNYXRoLmxvZyhwYWludGVyLnRyYW5zZm9ybS5zY2FsZSkgLyBNYXRoLkxOMikgLSBjb29yZC56KSAvIDggKiBvdmVyc2NhbGluZztcbiAgICAgICAgICAgIHZhciBzY2FsZUEgPSBbcGF0dGVybnJhdGlvIC8gcG9zQS53aWR0aCAvIGRhc2hhcnJheS5mcm9tU2NhbGUsIC1wb3NBLmhlaWdodCAvIDJdO1xuICAgICAgICAgICAgdmFyIGdhbW1hQSA9IHBhaW50ZXIubGluZUF0bGFzLndpZHRoIC8gKGRhc2hhcnJheS5mcm9tU2NhbGUgKiBwb3NBLndpZHRoICogMjU2ICogYnJvd3Nlci5kZXZpY2VQaXhlbFJhdGlvKSAvIDI7XG4gICAgICAgICAgICB2YXIgc2NhbGVCID0gW3BhdHRlcm5yYXRpbyAvIHBvc0Iud2lkdGggLyBkYXNoYXJyYXkudG9TY2FsZSwgLXBvc0IuaGVpZ2h0IC8gMl07XG4gICAgICAgICAgICB2YXIgZ2FtbWFCID0gcGFpbnRlci5saW5lQXRsYXMud2lkdGggLyAoZGFzaGFycmF5LnRvU2NhbGUgKiBwb3NCLndpZHRoICogMjU2ICogYnJvd3Nlci5kZXZpY2VQaXhlbFJhdGlvKSAvIDI7XG4gICAgICAgICAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVfcmF0aW8sIHJhdGlvKTtcbiAgICAgICAgICAgIGdsLnVuaWZvcm0yZnYoc2hhZGVyLnVfcGF0dGVybnNjYWxlX2EsIHNjYWxlQSk7XG4gICAgICAgICAgICBnbC51bmlmb3JtMmZ2KHNoYWRlci51X3BhdHRlcm5zY2FsZV9iLCBzY2FsZUIpO1xuICAgICAgICAgICAgZ2wudW5pZm9ybTFmKHNoYWRlci51X3NkZmdhbW1hLCBNYXRoLm1heChnYW1tYUEsIGdhbW1hQikpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoaW1hZ2UpIHtcbiAgICAgICAgICAgIHZhciBmYWN0b3IgPSA0MDk2IC8gdGlsZS50aWxlU2l6ZSAvIE1hdGgucG93KDIsIHBhaW50ZXIudHJhbnNmb3JtLnRpbGVab29tIC0gY29vcmQueik7XG4gICAgICAgICAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVfcmF0aW8sIHJhdGlvKTtcbiAgICAgICAgICAgIGdsLnVuaWZvcm0yZnYoc2hhZGVyLnVfcGF0dGVybl9zaXplX2EsIFtpbWFnZVBvc0Euc2l6ZVswXSAqIGZhY3RvciAqIGltYWdlLmZyb21TY2FsZSwgaW1hZ2VQb3NCLnNpemVbMV0gXSk7XG4gICAgICAgICAgICBnbC51bmlmb3JtMmZ2KHNoYWRlci51X3BhdHRlcm5fc2l6ZV9iLCBbaW1hZ2VQb3NCLnNpemVbMF0gKiBmYWN0b3IgKiBpbWFnZS50b1NjYWxlLCBpbWFnZVBvc0Iuc2l6ZVsxXSBdKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2wudW5pZm9ybTFmKHNoYWRlci51X3JhdGlvLCByYXRpbyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdmVydGV4ID0gdGlsZS5idWZmZXJzLmxpbmVWZXJ0ZXg7XG4gICAgICAgIHZlcnRleC5iaW5kKGdsKTtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aWxlLmJ1ZmZlcnMubGluZUVsZW1lbnQ7XG4gICAgICAgIGVsZW1lbnQuYmluZChnbCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50R3JvdXBzLmdyb3Vwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGdyb3VwID0gZWxlbWVudEdyb3Vwcy5ncm91cHNbaV07XG4gICAgICAgICAgICB2YXIgdnR4T2Zmc2V0ID0gZ3JvdXAudmVydGV4U3RhcnRJbmRleCAqIHZlcnRleC5pdGVtU2l6ZTtcbiAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyLmFfcG9zLCAyLCBnbC5TSE9SVCwgZmFsc2UsIDgsIHZ0eE9mZnNldCArIDApO1xuICAgICAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXIuYV9kYXRhLCA0LCBnbC5CWVRFLCBmYWxzZSwgOCwgdnR4T2Zmc2V0ICsgNCk7XG5cbiAgICAgICAgICAgIHZhciBjb3VudCA9IGdyb3VwLmVsZW1lbnRMZW5ndGggKiAzO1xuICAgICAgICAgICAgdmFyIGVsZW1lbnRPZmZzZXQgPSBncm91cC5lbGVtZW50U3RhcnRJbmRleCAqIGVsZW1lbnQuaXRlbVNpemU7XG4gICAgICAgICAgICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVTLCBjb3VudCwgZ2wuVU5TSUdORURfU0hPUlQsIGVsZW1lbnRPZmZzZXQpO1xuICAgICAgICB9XG4gICAgfVxuXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRyYXdSYXN0ZXI7XG5cbmZ1bmN0aW9uIGRyYXdSYXN0ZXIocGFpbnRlciwgc291cmNlLCBsYXllciwgY29vcmRzKSB7XG4gICAgaWYgKHBhaW50ZXIuaXNPcGFxdWVQYXNzKSByZXR1cm47XG5cbiAgICB2YXIgZ2wgPSBwYWludGVyLmdsO1xuXG4gICAgLy8gQ2hhbmdlIGRlcHRoIGZ1bmN0aW9uIHRvIHByZXZlbnQgZG91YmxlIGRyYXdpbmcgaW4gYXJlYXMgd2hlcmUgdGlsZXMgb3ZlcmxhcC5cbiAgICBnbC5kZXB0aEZ1bmMoZ2wuTEVTUyk7XG5cbiAgICBmb3IgKHZhciBpID0gY29vcmRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGRyYXdSYXN0ZXJUaWxlKHBhaW50ZXIsIHNvdXJjZSwgbGF5ZXIsIGNvb3Jkc1tpXSk7XG4gICAgfVxuXG4gICAgZ2wuZGVwdGhGdW5jKGdsLkxFUVVBTCk7XG59XG5cbmZ1bmN0aW9uIGRyYXdSYXN0ZXJUaWxlKHBhaW50ZXIsIHNvdXJjZSwgbGF5ZXIsIGNvb3JkKSB7XG5cbiAgICBwYWludGVyLnNldERlcHRoU3VibGF5ZXIoMCk7XG5cbiAgICB2YXIgZ2wgPSBwYWludGVyLmdsO1xuXG4gICAgZ2wuZGlzYWJsZShnbC5TVEVOQ0lMX1RFU1QpO1xuXG4gICAgdmFyIHRpbGUgPSBzb3VyY2UuZ2V0VGlsZShjb29yZCk7XG4gICAgdmFyIHBvc01hdHJpeCA9IHBhaW50ZXIuY2FsY3VsYXRlUG9zTWF0cml4KGNvb3JkLCBzb3VyY2UubWF4em9vbSk7XG5cbiAgICB2YXIgc2hhZGVyID0gcGFpbnRlci5yYXN0ZXJTaGFkZXI7XG4gICAgZ2wuc3dpdGNoU2hhZGVyKHNoYWRlciwgcG9zTWF0cml4KTtcblxuICAgIC8vIGNvbG9yIHBhcmFtZXRlcnNcbiAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVfYnJpZ2h0bmVzc19sb3csIGxheWVyLnBhaW50WydyYXN0ZXItYnJpZ2h0bmVzcy1taW4nXSk7XG4gICAgZ2wudW5pZm9ybTFmKHNoYWRlci51X2JyaWdodG5lc3NfaGlnaCwgbGF5ZXIucGFpbnRbJ3Jhc3Rlci1icmlnaHRuZXNzLW1heCddKTtcbiAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVfc2F0dXJhdGlvbl9mYWN0b3IsIHNhdHVyYXRpb25GYWN0b3IobGF5ZXIucGFpbnRbJ3Jhc3Rlci1zYXR1cmF0aW9uJ10pKTtcbiAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVfY29udHJhc3RfZmFjdG9yLCBjb250cmFzdEZhY3RvcihsYXllci5wYWludFsncmFzdGVyLWNvbnRyYXN0J10pKTtcbiAgICBnbC51bmlmb3JtM2Z2KHNoYWRlci51X3NwaW5fd2VpZ2h0cywgc3BpbldlaWdodHMobGF5ZXIucGFpbnRbJ3Jhc3Rlci1odWUtcm90YXRlJ10pKTtcblxuICAgIHZhciBwYXJlbnRUaWxlID0gdGlsZS5zb3VyY2UgJiYgdGlsZS5zb3VyY2UuX3B5cmFtaWQuZmluZExvYWRlZFBhcmVudChjb29yZCwgMCwge30pLFxuICAgICAgICBvcGFjaXRpZXMgPSBnZXRPcGFjaXRpZXModGlsZSwgcGFyZW50VGlsZSwgbGF5ZXIsIHBhaW50ZXIudHJhbnNmb3JtKTtcblxuICAgIHZhciBwYXJlbnRTY2FsZUJ5LCBwYXJlbnRUTDtcblxuICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTApO1xuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRpbGUudGV4dHVyZSk7XG5cbiAgICBpZiAocGFyZW50VGlsZSkge1xuICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUxKTtcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgcGFyZW50VGlsZS50ZXh0dXJlKTtcblxuICAgICAgICBwYXJlbnRTY2FsZUJ5ID0gTWF0aC5wb3coMiwgcGFyZW50VGlsZS5jb29yZC56IC0gdGlsZS5jb29yZC56KTtcbiAgICAgICAgcGFyZW50VEwgPSBbdGlsZS5jb29yZC54ICogcGFyZW50U2NhbGVCeSAlIDEsIHRpbGUuY29vcmQueSAqIHBhcmVudFNjYWxlQnkgJSAxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvcGFjaXRpZXNbMV0gPSAwO1xuICAgIH1cblxuICAgIC8vIGNyb3NzLWZhZGUgcGFyYW1ldGVyc1xuICAgIGdsLnVuaWZvcm0yZnYoc2hhZGVyLnVfdGxfcGFyZW50LCBwYXJlbnRUTCB8fCBbMCwgMF0pO1xuICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9zY2FsZV9wYXJlbnQsIHBhcmVudFNjYWxlQnkgfHwgMSk7XG4gICAgZ2wudW5pZm9ybTFmKHNoYWRlci51X2J1ZmZlcl9zY2FsZSwgMSk7XG4gICAgZ2wudW5pZm9ybTFmKHNoYWRlci51X29wYWNpdHkwLCBvcGFjaXRpZXNbMF0pO1xuICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9vcGFjaXR5MSwgb3BhY2l0aWVzWzFdKTtcbiAgICBnbC51bmlmb3JtMWkoc2hhZGVyLnVfaW1hZ2UwLCAwKTtcbiAgICBnbC51bmlmb3JtMWkoc2hhZGVyLnVfaW1hZ2UxLCAxKTtcblxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aWxlLmJvdW5kc0J1ZmZlciB8fCBwYWludGVyLnRpbGVFeHRlbnRCdWZmZXIpO1xuXG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXIuYV9wb3MsICAgICAgICAgMiwgZ2wuU0hPUlQsIGZhbHNlLCA4LCAwKTtcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHNoYWRlci5hX3RleHR1cmVfcG9zLCAyLCBnbC5TSE9SVCwgZmFsc2UsIDgsIDQpO1xuICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQpO1xuXG4gICAgZ2wuZW5hYmxlKGdsLlNURU5DSUxfVEVTVCk7XG59XG5cbmZ1bmN0aW9uIHNwaW5XZWlnaHRzKGFuZ2xlKSB7XG4gICAgYW5nbGUgKj0gTWF0aC5QSSAvIDE4MDtcbiAgICB2YXIgcyA9IE1hdGguc2luKGFuZ2xlKTtcbiAgICB2YXIgYyA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICByZXR1cm4gW1xuICAgICAgICAoMiAqIGMgKyAxKSAvIDMsXG4gICAgICAgICgtTWF0aC5zcXJ0KDMpICogcyAtIGMgKyAxKSAvIDMsXG4gICAgICAgIChNYXRoLnNxcnQoMykgKiBzIC0gYyArIDEpIC8gM1xuICAgIF07XG59XG5cbmZ1bmN0aW9uIGNvbnRyYXN0RmFjdG9yKGNvbnRyYXN0KSB7XG4gICAgcmV0dXJuIGNvbnRyYXN0ID4gMCA/XG4gICAgICAgIDEgLyAoMSAtIGNvbnRyYXN0KSA6XG4gICAgICAgIDEgKyBjb250cmFzdDtcbn1cblxuZnVuY3Rpb24gc2F0dXJhdGlvbkZhY3RvcihzYXR1cmF0aW9uKSB7XG4gICAgcmV0dXJuIHNhdHVyYXRpb24gPiAwID9cbiAgICAgICAgMSAtIDEgLyAoMS4wMDEgLSBzYXR1cmF0aW9uKSA6XG4gICAgICAgIC1zYXR1cmF0aW9uO1xufVxuXG5mdW5jdGlvbiBnZXRPcGFjaXRpZXModGlsZSwgcGFyZW50VGlsZSwgbGF5ZXIsIHRyYW5zZm9ybSkge1xuICAgIHZhciBvcGFjaXR5ID0gWzEsIDBdO1xuICAgIHZhciBmYWRlRHVyYXRpb24gPSBsYXllci5wYWludFsncmFzdGVyLWZhZGUtZHVyYXRpb24nXTtcblxuICAgIGlmICh0aWxlLnNvdXJjZSAmJiBmYWRlRHVyYXRpb24gPiAwKSB7XG4gICAgICAgIHZhciBub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuICAgICAgICB2YXIgc2luY2VUaWxlID0gKG5vdyAtIHRpbGUudGltZUFkZGVkKSAvIGZhZGVEdXJhdGlvbjtcbiAgICAgICAgdmFyIHNpbmNlUGFyZW50ID0gcGFyZW50VGlsZSA/IChub3cgLSBwYXJlbnRUaWxlLnRpbWVBZGRlZCkgLyBmYWRlRHVyYXRpb24gOiAtMTtcblxuICAgICAgICB2YXIgaWRlYWxaID0gdGlsZS5zb3VyY2UuX3B5cmFtaWQuY292ZXJpbmdab29tTGV2ZWwodHJhbnNmb3JtKTtcbiAgICAgICAgdmFyIHBhcmVudEZ1cnRoZXIgPSBwYXJlbnRUaWxlID8gTWF0aC5hYnMocGFyZW50VGlsZS5jb29yZC56IC0gaWRlYWxaKSA+IE1hdGguYWJzKHRpbGUuY29vcmQueiAtIGlkZWFsWikgOiBmYWxzZTtcblxuICAgICAgICBpZiAoIXBhcmVudFRpbGUgfHwgcGFyZW50RnVydGhlcikge1xuICAgICAgICAgICAgLy8gaWYgbm8gcGFyZW50IG9yIHBhcmVudCBpcyBvbGRlclxuICAgICAgICAgICAgb3BhY2l0eVswXSA9IHV0aWwuY2xhbXAoc2luY2VUaWxlLCAwLCAxKTtcbiAgICAgICAgICAgIG9wYWNpdHlbMV0gPSAxIC0gb3BhY2l0eVswXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHBhcmVudCBpcyB5b3VuZ2VyLCB6b29taW5nIG91dFxuICAgICAgICAgICAgb3BhY2l0eVswXSA9IHV0aWwuY2xhbXAoMSAtIHNpbmNlUGFyZW50LCAwLCAxKTtcbiAgICAgICAgICAgIG9wYWNpdHlbMV0gPSAxIC0gb3BhY2l0eVswXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBvcCA9IGxheWVyLnBhaW50WydyYXN0ZXItb3BhY2l0eSddO1xuICAgIG9wYWNpdHlbMF0gKj0gb3A7XG4gICAgb3BhY2l0eVsxXSAqPSBvcDtcblxuICAgIHJldHVybiBvcGFjaXR5O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgbWF0NCA9IHJlcXVpcmUoJ2dsLW1hdHJpeCcpLm1hdDQ7XG5cbnZhciBicm93c2VyID0gcmVxdWlyZSgnLi4vdXRpbC9icm93c2VyJyk7XG52YXIgZHJhd0NvbGxpc2lvbkRlYnVnID0gcmVxdWlyZSgnLi9kcmF3X2NvbGxpc2lvbl9kZWJ1ZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRyYXdTeW1ib2xzO1xuXG5mdW5jdGlvbiBkcmF3U3ltYm9scyhwYWludGVyLCBzb3VyY2UsIGxheWVyLCBjb29yZHMpIHtcbiAgICBpZiAocGFpbnRlci5pc09wYXF1ZVBhc3MpIHJldHVybjtcblxuICAgIHZhciBkcmF3QWNyb3NzRWRnZXMgPSAhKGxheWVyLmxheW91dFsndGV4dC1hbGxvdy1vdmVybGFwJ10gfHwgbGF5ZXIubGF5b3V0WydpY29uLWFsbG93LW92ZXJsYXAnXSB8fFxuICAgICAgICBsYXllci5sYXlvdXRbJ3RleHQtaWdub3JlLXBsYWNlbWVudCddIHx8IGxheWVyLmxheW91dFsnaWNvbi1pZ25vcmUtcGxhY2VtZW50J10pO1xuXG4gICAgdmFyIGdsID0gcGFpbnRlci5nbDtcblxuICAgIGlmIChkcmF3QWNyb3NzRWRnZXMpIHtcbiAgICAgICAgLy8gRGlzYWJsZSB0aGUgc3RlbmNpbCB0ZXN0IHNvIHRoYXQgbGFiZWxzIGFyZW4ndCBjbGlwcGVkIHRvIHRpbGUgYm91bmRhcmllcy5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gTGF5ZXJzIHdpdGggZmVhdHVyZXMgdGhhdCBtYXkgYmUgZHJhd24gb3ZlcmxhcHBpbmcgYXJlbid0IGNsaXBwZWQuIFRoZXNlXG4gICAgICAgIC8vIGxheWVycyBhcmUgc29ydGVkIGluIHRoZSB5IGRpcmVjdGlvbiwgYW5kIHRvIGRyYXcgdGhlIGNvcnJlY3Qgb3JkZXJpbmcgbmVhclxuICAgICAgICAvLyB0aWxlIGVkZ2VzIHRoZSBpY29ucyBhcmUgaW5jbHVkZWQgaW4gYm90aCB0aWxlcyBhbmQgY2xpcHBlZCB3aGVuIGRyYXdpbmcuXG4gICAgICAgIGdsLmRpc2FibGUoZ2wuU1RFTkNJTF9URVNUKTtcbiAgICB9XG5cbiAgICBwYWludGVyLnNldERlcHRoU3VibGF5ZXIoMCk7XG4gICAgcGFpbnRlci5kZXB0aE1hc2soZmFsc2UpO1xuICAgIGdsLmRpc2FibGUoZ2wuREVQVEhfVEVTVCk7XG5cbiAgICB2YXIgdGlsZSwgZWxlbWVudEdyb3VwcywgcG9zTWF0cml4O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGlsZSA9IHNvdXJjZS5nZXRUaWxlKGNvb3Jkc1tpXSk7XG5cbiAgICAgICAgaWYgKCF0aWxlLmJ1ZmZlcnMpIGNvbnRpbnVlO1xuICAgICAgICBlbGVtZW50R3JvdXBzID0gdGlsZS5lbGVtZW50R3JvdXBzW2xheWVyLnJlZiB8fCBsYXllci5pZF07XG4gICAgICAgIGlmICghZWxlbWVudEdyb3VwcykgY29udGludWU7XG4gICAgICAgIGlmICghZWxlbWVudEdyb3Vwcy5pY29uLmdyb3Vwcy5sZW5ndGgpIGNvbnRpbnVlO1xuXG4gICAgICAgIHBvc01hdHJpeCA9IHBhaW50ZXIuY2FsY3VsYXRlUG9zTWF0cml4KGNvb3Jkc1tpXSwgc291cmNlLm1heHpvb20pO1xuICAgICAgICBwYWludGVyLmVuYWJsZVRpbGVDbGlwcGluZ01hc2soY29vcmRzW2ldKTtcbiAgICAgICAgZHJhd1N5bWJvbChwYWludGVyLCBsYXllciwgcG9zTWF0cml4LCB0aWxlLCBlbGVtZW50R3JvdXBzLmljb24sICdpY29uJywgZWxlbWVudEdyb3Vwcy5zZGZJY29ucywgZWxlbWVudEdyb3Vwcy5pY29uc05lZWRMaW5lYXIpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29vcmRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHRpbGUgPSBzb3VyY2UuZ2V0VGlsZShjb29yZHNbal0pO1xuXG4gICAgICAgIGlmICghdGlsZS5idWZmZXJzKSBjb250aW51ZTtcbiAgICAgICAgZWxlbWVudEdyb3VwcyA9IHRpbGUuZWxlbWVudEdyb3Vwc1tsYXllci5yZWYgfHwgbGF5ZXIuaWRdO1xuICAgICAgICBpZiAoIWVsZW1lbnRHcm91cHMpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIWVsZW1lbnRHcm91cHMuZ2x5cGguZ3JvdXBzLmxlbmd0aCkgY29udGludWU7XG5cbiAgICAgICAgcG9zTWF0cml4ID0gcGFpbnRlci5jYWxjdWxhdGVQb3NNYXRyaXgoY29vcmRzW2pdLCBzb3VyY2UubWF4em9vbSk7XG4gICAgICAgIHBhaW50ZXIuZW5hYmxlVGlsZUNsaXBwaW5nTWFzayhjb29yZHNbal0pO1xuICAgICAgICBkcmF3U3ltYm9sKHBhaW50ZXIsIGxheWVyLCBwb3NNYXRyaXgsIHRpbGUsIGVsZW1lbnRHcm91cHMuZ2x5cGgsICd0ZXh0JywgdHJ1ZSwgZmFsc2UpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgY29vcmRzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIHRpbGUgPSBzb3VyY2UuZ2V0VGlsZShjb29yZHNba10pO1xuICAgICAgICBwYWludGVyLmVuYWJsZVRpbGVDbGlwcGluZ01hc2soY29vcmRzW2tdKTtcbiAgICAgICAgZHJhd0NvbGxpc2lvbkRlYnVnKHBhaW50ZXIsIGxheWVyLCBjb29yZHNba10sIHRpbGUpO1xuICAgIH1cblxuICAgIGlmIChkcmF3QWNyb3NzRWRnZXMpIHtcbiAgICAgICAgZ2wuZW5hYmxlKGdsLlNURU5DSUxfVEVTVCk7XG4gICAgfVxuICAgIGdsLmVuYWJsZShnbC5ERVBUSF9URVNUKTtcbn1cblxudmFyIGRlZmF1bHRTaXplcyA9IHtcbiAgICBpY29uOiAxLFxuICAgIHRleHQ6IDI0XG59O1xuXG5mdW5jdGlvbiBkcmF3U3ltYm9sKHBhaW50ZXIsIGxheWVyLCBwb3NNYXRyaXgsIHRpbGUsIGVsZW1lbnRHcm91cHMsIHByZWZpeCwgc2RmLCBpY29uc05lZWRMaW5lYXIpIHtcbiAgICB2YXIgZ2wgPSBwYWludGVyLmdsO1xuXG4gICAgcG9zTWF0cml4ID0gcGFpbnRlci50cmFuc2xhdGVQb3NNYXRyaXgocG9zTWF0cml4LCB0aWxlLCBsYXllci5wYWludFtwcmVmaXggKyAnLXRyYW5zbGF0ZSddLCBsYXllci5wYWludFtwcmVmaXggKyAnLXRyYW5zbGF0ZS1hbmNob3InXSk7XG5cbiAgICB2YXIgdHIgPSBwYWludGVyLnRyYW5zZm9ybTtcbiAgICB2YXIgYWxpZ25lZFdpdGhNYXAgPSBsYXllci5sYXlvdXRbcHJlZml4ICsgJy1yb3RhdGlvbi1hbGlnbm1lbnQnXSA9PT0gJ21hcCc7XG4gICAgdmFyIHNrZXdlZCA9IGFsaWduZWRXaXRoTWFwO1xuICAgIHZhciBleE1hdHJpeCwgcywgZ2FtbWFTY2FsZTtcblxuICAgIGlmIChza2V3ZWQpIHtcbiAgICAgICAgZXhNYXRyaXggPSBtYXQ0LmNyZWF0ZSgpO1xuICAgICAgICBzID0gdGlsZS50aWxlRXh0ZW50IC8gdGlsZS50aWxlU2l6ZSAvIE1hdGgucG93KDIsIHBhaW50ZXIudHJhbnNmb3JtLnpvb20gLSB0aWxlLmNvb3JkLnopO1xuICAgICAgICBnYW1tYVNjYWxlID0gMSAvIE1hdGguY29zKHRyLl9waXRjaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZXhNYXRyaXggPSBtYXQ0LmNsb25lKHBhaW50ZXIudHJhbnNmb3JtLmV4TWF0cml4KTtcbiAgICAgICAgcyA9IHBhaW50ZXIudHJhbnNmb3JtLmFsdGl0dWRlO1xuICAgICAgICBnYW1tYVNjYWxlID0gMTtcbiAgICB9XG4gICAgbWF0NC5zY2FsZShleE1hdHJpeCwgZXhNYXRyaXgsIFtzLCBzLCAxXSk7XG5cbiAgICB2YXIgZm9udFNpemUgPSBsYXllci5wYWludFtwcmVmaXggKyAnLXNpemUnXTtcbiAgICB2YXIgZm9udFNjYWxlID0gZm9udFNpemUgLyBkZWZhdWx0U2l6ZXNbcHJlZml4XTtcbiAgICBtYXQ0LnNjYWxlKGV4TWF0cml4LCBleE1hdHJpeCwgWyBmb250U2NhbGUsIGZvbnRTY2FsZSwgMSBdKTtcblxuICAgIC8vIGNhbGN1bGF0ZSBob3cgbXVjaCBsb25nZXIgdGhlIHJlYWwgd29ybGQgZGlzdGFuY2UgaXMgYXQgdGhlIHRvcCBvZiB0aGUgc2NyZWVuXG4gICAgLy8gdGhhbiBhdCB0aGUgbWlkZGxlIG9mIHRoZSBzY3JlZW4uXG4gICAgdmFyIHRvcGVkZ2VsZW5ndGggPSBNYXRoLnNxcnQodHIuaGVpZ2h0ICogdHIuaGVpZ2h0IC8gNCAgKiAoMSArIHRyLmFsdGl0dWRlICogdHIuYWx0aXR1ZGUpKTtcbiAgICB2YXIgeCA9IHRyLmhlaWdodCAvIDIgKiBNYXRoLnRhbih0ci5fcGl0Y2gpO1xuICAgIHZhciBleHRyYSA9ICh0b3BlZGdlbGVuZ3RoICsgeCkgLyB0b3BlZGdlbGVuZ3RoIC0gMTtcblxuICAgIHZhciB0ZXh0ID0gcHJlZml4ID09PSAndGV4dCc7XG4gICAgdmFyIHNoYWRlciwgdmVydGV4LCBlbGVtZW50cywgdGV4c2l6ZTtcblxuICAgIGlmICghdGV4dCAmJiAhcGFpbnRlci5zdHlsZS5zcHJpdGUubG9hZGVkKCkpXG4gICAgICAgIHJldHVybjtcblxuICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTApO1xuXG4gICAgaWYgKHNkZikge1xuICAgICAgICBzaGFkZXIgPSBwYWludGVyLnNkZlNoYWRlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzaGFkZXIgPSBwYWludGVyLmljb25TaGFkZXI7XG4gICAgfVxuXG4gICAgaWYgKHRleHQpIHtcbiAgICAgICAgdmFyIHRleHRmb250ID0gZWxlbWVudEdyb3Vwc1sndGV4dC1mb250J107XG4gICAgICAgIHZhciBmb250c3RhY2sgPSB0ZXh0Zm9udCAmJiB0ZXh0Zm9udC5qb2luKCcsJyk7XG4gICAgICAgIHZhciBnbHlwaEF0bGFzID0gZm9udHN0YWNrICYmIHBhaW50ZXIuZ2x5cGhTb3VyY2UuZ2V0R2x5cGhBdGxhcyhmb250c3RhY2spO1xuICAgICAgICBpZiAoIWdseXBoQXRsYXMpIHJldHVybjtcblxuICAgICAgICBnbHlwaEF0bGFzLnVwZGF0ZVRleHR1cmUoZ2wpO1xuICAgICAgICB2ZXJ0ZXggPSB0aWxlLmJ1ZmZlcnMuZ2x5cGhWZXJ0ZXg7XG4gICAgICAgIGVsZW1lbnRzID0gdGlsZS5idWZmZXJzLmdseXBoRWxlbWVudDtcbiAgICAgICAgdGV4c2l6ZSA9IFtnbHlwaEF0bGFzLndpZHRoIC8gNCwgZ2x5cGhBdGxhcy5oZWlnaHQgLyA0XTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbWFwTW92aW5nID0gcGFpbnRlci5vcHRpb25zLnJvdGF0aW5nIHx8IHBhaW50ZXIub3B0aW9ucy56b29taW5nO1xuICAgICAgICB2YXIgaWNvblNjYWxlZCA9IGZvbnRTY2FsZSAhPT0gMSB8fCBicm93c2VyLmRldmljZVBpeGVsUmF0aW8gIT09IHBhaW50ZXIuc3ByaXRlQXRsYXMucGl4ZWxSYXRpbyB8fCBpY29uc05lZWRMaW5lYXI7XG4gICAgICAgIHZhciBpY29uVHJhbnNmb3JtZWQgPSBhbGlnbmVkV2l0aE1hcCB8fCBwYWludGVyLnRyYW5zZm9ybS5waXRjaDtcbiAgICAgICAgcGFpbnRlci5zcHJpdGVBdGxhcy5iaW5kKGdsLCBzZGYgfHwgbWFwTW92aW5nIHx8IGljb25TY2FsZWQgfHwgaWNvblRyYW5zZm9ybWVkKTtcbiAgICAgICAgdmVydGV4ID0gdGlsZS5idWZmZXJzLmljb25WZXJ0ZXg7XG4gICAgICAgIGVsZW1lbnRzID0gdGlsZS5idWZmZXJzLmljb25FbGVtZW50O1xuICAgICAgICB0ZXhzaXplID0gW3BhaW50ZXIuc3ByaXRlQXRsYXMud2lkdGggLyA0LCBwYWludGVyLnNwcml0ZUF0bGFzLmhlaWdodCAvIDRdO1xuICAgIH1cblxuICAgIGdsLnN3aXRjaFNoYWRlcihzaGFkZXIsIHBvc01hdHJpeCwgZXhNYXRyaXgpO1xuICAgIGdsLnVuaWZvcm0xaShzaGFkZXIudV90ZXh0dXJlLCAwKTtcbiAgICBnbC51bmlmb3JtMmZ2KHNoYWRlci51X3RleHNpemUsIHRleHNpemUpO1xuICAgIGdsLnVuaWZvcm0xaShzaGFkZXIudV9za2V3ZWQsIHNrZXdlZCk7XG4gICAgZ2wudW5pZm9ybTFmKHNoYWRlci51X2V4dHJhLCBleHRyYSk7XG5cbiAgICAvLyBhZGp1c3QgbWluL21heCB6b29tcyBmb3IgdmFyaWFibGUgZm9udCBzaXplc1xuICAgIHZhciB6b29tQWRqdXN0ID0gTWF0aC5sb2coZm9udFNpemUgLyBlbGVtZW50R3JvdXBzW3ByZWZpeCArICctc2l6ZSddKSAvIE1hdGguTE4yIHx8IDA7XG5cblxuICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV96b29tLCAocGFpbnRlci50cmFuc2Zvcm0uem9vbSAtIHpvb21BZGp1c3QpICogMTApOyAvLyBjdXJyZW50IHpvb20gbGV2ZWxcblxuICAgIHZhciBmID0gcGFpbnRlci5mcmFtZUhpc3RvcnkuZ2V0RmFkZVByb3BlcnRpZXMoMzAwKTtcbiAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVfZmFkZWRpc3QsIGYuZmFkZWRpc3QgKiAxMCk7XG4gICAgZ2wudW5pZm9ybTFmKHNoYWRlci51X21pbmZhZGV6b29tLCBNYXRoLmZsb29yKGYubWluZmFkZXpvb20gKiAxMCkpO1xuICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9tYXhmYWRlem9vbSwgTWF0aC5mbG9vcihmLm1heGZhZGV6b29tICogMTApKTtcbiAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVfZmFkZXpvb20sIChwYWludGVyLnRyYW5zZm9ybS56b29tICsgZi5idW1wKSAqIDEwKTtcblxuICAgIHZhciBncm91cCwgb2Zmc2V0LCBjb3VudCwgZWxlbWVudE9mZnNldDtcblxuICAgIGVsZW1lbnRzLmJpbmQoZ2wpO1xuXG4gICAgaWYgKHNkZikge1xuICAgICAgICB2YXIgc2RmUHggPSA4O1xuICAgICAgICB2YXIgYmx1ck9mZnNldCA9IDEuMTk7XG4gICAgICAgIHZhciBoYWxvT2Zmc2V0ID0gNjtcbiAgICAgICAgdmFyIGdhbW1hID0gMC4xMDUgKiBkZWZhdWx0U2l6ZXNbcHJlZml4XSAvIGZvbnRTaXplIC8gYnJvd3Nlci5kZXZpY2VQaXhlbFJhdGlvO1xuXG4gICAgICAgIGlmIChsYXllci5wYWludFtwcmVmaXggKyAnLWhhbG8td2lkdGgnXSkge1xuICAgICAgICAgICAgLy8gRHJhdyBoYWxvIHVuZGVybmVhdGggdGhlIHRleHQuXG4gICAgICAgICAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVfZ2FtbWEsIChsYXllci5wYWludFtwcmVmaXggKyAnLWhhbG8tYmx1ciddICogYmx1ck9mZnNldCAvIGZvbnRTY2FsZSAvIHNkZlB4ICsgZ2FtbWEpICogZ2FtbWFTY2FsZSk7XG4gICAgICAgICAgICBnbC51bmlmb3JtNGZ2KHNoYWRlci51X2NvbG9yLCBsYXllci5wYWludFtwcmVmaXggKyAnLWhhbG8tY29sb3InXSk7XG4gICAgICAgICAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVfYnVmZmVyLCAoaGFsb09mZnNldCAtIGxheWVyLnBhaW50W3ByZWZpeCArICctaGFsby13aWR0aCddIC8gZm9udFNjYWxlKSAvIHNkZlB4KTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBlbGVtZW50R3JvdXBzLmdyb3Vwcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGdyb3VwID0gZWxlbWVudEdyb3Vwcy5ncm91cHNbal07XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gZ3JvdXAudmVydGV4U3RhcnRJbmRleCAqIHZlcnRleC5pdGVtU2l6ZTtcbiAgICAgICAgICAgICAgICB2ZXJ0ZXguYmluZChnbCk7XG4gICAgICAgICAgICAgICAgdmVydGV4LnNldEF0dHJpYlBvaW50ZXJzKGdsLCBzaGFkZXIsIG9mZnNldCk7XG5cbiAgICAgICAgICAgICAgICBjb3VudCA9IGdyb3VwLmVsZW1lbnRMZW5ndGggKiAzO1xuICAgICAgICAgICAgICAgIGVsZW1lbnRPZmZzZXQgPSBncm91cC5lbGVtZW50U3RhcnRJbmRleCAqIGVsZW1lbnRzLml0ZW1TaXplO1xuICAgICAgICAgICAgICAgIGdsLmRyYXdFbGVtZW50cyhnbC5UUklBTkdMRVMsIGNvdW50LCBnbC5VTlNJR05FRF9TSE9SVCwgZWxlbWVudE9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVfZ2FtbWEsIGdhbW1hICogZ2FtbWFTY2FsZSk7XG4gICAgICAgIGdsLnVuaWZvcm00ZnYoc2hhZGVyLnVfY29sb3IsIGxheWVyLnBhaW50W3ByZWZpeCArICctY29sb3InXSk7XG4gICAgICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9idWZmZXIsICgyNTYgLSA2NCkgLyAyNTYpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudEdyb3Vwcy5ncm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGdyb3VwID0gZWxlbWVudEdyb3Vwcy5ncm91cHNbaV07XG4gICAgICAgICAgICBvZmZzZXQgPSBncm91cC52ZXJ0ZXhTdGFydEluZGV4ICogdmVydGV4Lml0ZW1TaXplO1xuICAgICAgICAgICAgdmVydGV4LmJpbmQoZ2wpO1xuICAgICAgICAgICAgdmVydGV4LnNldEF0dHJpYlBvaW50ZXJzKGdsLCBzaGFkZXIsIG9mZnNldCk7XG5cbiAgICAgICAgICAgIGNvdW50ID0gZ3JvdXAuZWxlbWVudExlbmd0aCAqIDM7XG4gICAgICAgICAgICBlbGVtZW50T2Zmc2V0ID0gZ3JvdXAuZWxlbWVudFN0YXJ0SW5kZXggKiBlbGVtZW50cy5pdGVtU2l6ZTtcbiAgICAgICAgICAgIGdsLmRyYXdFbGVtZW50cyhnbC5UUklBTkdMRVMsIGNvdW50LCBnbC5VTlNJR05FRF9TSE9SVCwgZWxlbWVudE9mZnNldCk7XG4gICAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9vcGFjaXR5LCBsYXllci5wYWludFsnaWNvbi1vcGFjaXR5J10pO1xuICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGVsZW1lbnRHcm91cHMuZ3JvdXBzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICBncm91cCA9IGVsZW1lbnRHcm91cHMuZ3JvdXBzW2tdO1xuICAgICAgICAgICAgb2Zmc2V0ID0gZ3JvdXAudmVydGV4U3RhcnRJbmRleCAqIHZlcnRleC5pdGVtU2l6ZTtcbiAgICAgICAgICAgIHZlcnRleC5iaW5kKGdsKTtcbiAgICAgICAgICAgIHZlcnRleC5zZXRBdHRyaWJQb2ludGVycyhnbCwgc2hhZGVyLCBvZmZzZXQpO1xuXG4gICAgICAgICAgICBjb3VudCA9IGdyb3VwLmVsZW1lbnRMZW5ndGggKiAzO1xuICAgICAgICAgICAgZWxlbWVudE9mZnNldCA9IGdyb3VwLmVsZW1lbnRTdGFydEluZGV4ICogZWxlbWVudHMuaXRlbVNpemU7XG4gICAgICAgICAgICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVTLCBjb3VudCwgZ2wuVU5TSUdORURfU0hPUlQsIGVsZW1lbnRPZmZzZXQpO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZyYW1lSGlzdG9yeTtcblxuZnVuY3Rpb24gRnJhbWVIaXN0b3J5KCkge1xuICAgIHRoaXMuZnJhbWVIaXN0b3J5ID0gW107XG59XG5cbkZyYW1lSGlzdG9yeS5wcm90b3R5cGUuZ2V0RmFkZVByb3BlcnRpZXMgPSBmdW5jdGlvbihkdXJhdGlvbikge1xuICAgIGlmIChkdXJhdGlvbiA9PT0gdW5kZWZpbmVkKSBkdXJhdGlvbiA9IDMwMDtcbiAgICB2YXIgY3VycmVudFRpbWUgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuXG4gICAgLy8gUmVtb3ZlIGZyYW1lcyB1bnRpbCBvbmx5IG9uZSBpcyBvdXRzaWRlIHRoZSBkdXJhdGlvbiwgb3IgdW50aWwgdGhlcmUgYXJlIG9ubHkgdGhyZWVcbiAgICB3aGlsZSAodGhpcy5mcmFtZUhpc3RvcnkubGVuZ3RoID4gMyAmJiB0aGlzLmZyYW1lSGlzdG9yeVsxXS50aW1lICsgZHVyYXRpb24gPCBjdXJyZW50VGltZSkge1xuICAgICAgICB0aGlzLmZyYW1lSGlzdG9yeS5zaGlmdCgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmZyYW1lSGlzdG9yeVsxXS50aW1lICsgZHVyYXRpb24gPCBjdXJyZW50VGltZSkge1xuICAgICAgICB0aGlzLmZyYW1lSGlzdG9yeVswXS56ID0gdGhpcy5mcmFtZUhpc3RvcnlbMV0uejtcbiAgICB9XG5cbiAgICB2YXIgZnJhbWVMZW4gPSB0aGlzLmZyYW1lSGlzdG9yeS5sZW5ndGg7XG4gICAgaWYgKGZyYW1lTGVuIDwgMykgY29uc29sZS53YXJuKCd0aGVyZSBzaG91bGQgbmV2ZXIgYmUgbGVzcyB0aGFuIHRocmVlIGZyYW1lcyBpbiB0aGUgaGlzdG9yeScpO1xuXG4gICAgLy8gRmluZCB0aGUgcmFuZ2Ugb2Ygem9vbSBsZXZlbHMgd2Ugd2FudCB0byBmYWRlIGJldHdlZW5cbiAgICB2YXIgc3RhcnRpbmdaID0gdGhpcy5mcmFtZUhpc3RvcnlbMF0ueixcbiAgICAgICAgbGFzdEZyYW1lID0gdGhpcy5mcmFtZUhpc3RvcnlbZnJhbWVMZW4gLSAxXSxcbiAgICAgICAgZW5kaW5nWiA9IGxhc3RGcmFtZS56LFxuICAgICAgICBsb3daID0gTWF0aC5taW4oc3RhcnRpbmdaLCBlbmRpbmdaKSxcbiAgICAgICAgaGlnaFogPSBNYXRoLm1heChzdGFydGluZ1osIGVuZGluZ1opO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBzcGVlZCBvZiB6b29taW5nLCBhbmQgaG93IGZhciBpdCB3b3VsZCB6b29tIGluIHRlcm1zIG9mIHpvb20gbGV2ZWxzIGluIG9uZSBkdXJhdGlvblxuICAgIHZhciB6b29tRGlmZiA9IGxhc3RGcmFtZS56IC0gdGhpcy5mcmFtZUhpc3RvcnlbMV0ueixcbiAgICAgICAgdGltZURpZmYgPSBsYXN0RnJhbWUudGltZSAtIHRoaXMuZnJhbWVIaXN0b3J5WzFdLnRpbWU7XG4gICAgdmFyIGZhZGVkaXN0ID0gem9vbURpZmYgLyAodGltZURpZmYgLyBkdXJhdGlvbik7XG5cbiAgICBpZiAoaXNOYU4oZmFkZWRpc3QpKSBjb25zb2xlLndhcm4oJ2ZhZGVkaXN0IHNob3VsZCBuZXZlciBiZSBOYU4nKTtcblxuICAgIC8vIEF0IGVuZCBvZiBhIHpvb20gd2hlbiB0aGUgem9vbSBzdG9wcyBjaGFuZ2luZyBjb250aW51ZSBwcmV0ZW5kaW5nIHRvIHpvb20gYXQgdGhhdCBzcGVlZFxuICAgIC8vIGJ1bXAgaXMgaG93IG11Y2ggZmFydGhlciBpdCB3b3VsZCBoYXZlIGJlZW4gaWYgaXQgaGFkIGNvbnRpbnVlZCB6b29taW5nIGF0IHRoZSBzYW1lIHJhdGVcbiAgICB2YXIgYnVtcCA9IChjdXJyZW50VGltZSAtIGxhc3RGcmFtZS50aW1lKSAvIGR1cmF0aW9uICogZmFkZWRpc3Q7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBmYWRlZGlzdDogZmFkZWRpc3QsXG4gICAgICAgIG1pbmZhZGV6b29tOiBsb3daLFxuICAgICAgICBtYXhmYWRlem9vbTogaGlnaFosXG4gICAgICAgIGJ1bXA6IGJ1bXBcbiAgICB9O1xufTtcblxuLy8gUmVjb3JkIGZyYW1lIGhpc3RvcnkgdGhhdCB3aWxsIGJlIHVzZWQgdG8gY2FsY3VsYXRlIGZhZGluZyBwYXJhbXNcbkZyYW1lSGlzdG9yeS5wcm90b3R5cGUucmVjb3JkID0gZnVuY3Rpb24oem9vbSkge1xuICAgIHZhciBjdXJyZW50VGltZSA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG5cbiAgICAvLyBmaXJzdCBmcmFtZSBldmVyXG4gICAgaWYgKCF0aGlzLmZyYW1lSGlzdG9yeS5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5mcmFtZUhpc3RvcnkucHVzaCh7dGltZTogMCwgejogem9vbSB9LCB7dGltZTogMCwgejogem9vbSB9KTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5mcmFtZUhpc3RvcnkubGVuZ3RoID09PSAyIHx8IHRoaXMuZnJhbWVIaXN0b3J5W3RoaXMuZnJhbWVIaXN0b3J5Lmxlbmd0aCAtIDFdLnogIT09IHpvb20pIHtcbiAgICAgICAgdGhpcy5mcmFtZUhpc3RvcnkucHVzaCh7XG4gICAgICAgICAgICB0aW1lOiBjdXJyZW50VGltZSxcbiAgICAgICAgICAgIHo6IHpvb21cbiAgICAgICAgfSk7XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHNoYWRlcnMgPSByZXF1aXJlKCcuL3NoYWRlcnMnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJyk7XG5cbmV4cG9ydHMuZXh0ZW5kID0gZnVuY3Rpb24oY29udGV4dCkge1xuICAgIHZhciBvcmlnTGluZVdpZHRoID0gY29udGV4dC5saW5lV2lkdGgsXG4gICAgICAgIGxpbmVXaWR0aFJhbmdlID0gY29udGV4dC5nZXRQYXJhbWV0ZXIoY29udGV4dC5BTElBU0VEX0xJTkVfV0lEVEhfUkFOR0UpO1xuXG4gICAgY29udGV4dC5saW5lV2lkdGggPSBmdW5jdGlvbih3aWR0aCkge1xuICAgICAgICBvcmlnTGluZVdpZHRoLmNhbGwoY29udGV4dCwgdXRpbC5jbGFtcCh3aWR0aCwgbGluZVdpZHRoUmFuZ2VbMF0sIGxpbmVXaWR0aFJhbmdlWzFdKSk7XG4gICAgfTtcblxuICAgIGNvbnRleHQuZ2V0U2hhZGVyID0gZnVuY3Rpb24obmFtZSwgdHlwZSkge1xuICAgICAgICB2YXIga2luZCA9IHR5cGUgPT09IHRoaXMuRlJBR01FTlRfU0hBREVSID8gJ2ZyYWdtZW50JyA6ICd2ZXJ0ZXgnO1xuICAgICAgICBpZiAoIXNoYWRlcnNbbmFtZV0gfHwgIXNoYWRlcnNbbmFtZV1ba2luZF0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIHNoYWRlciBcIiArIG5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNoYWRlciA9IHRoaXMuY3JlYXRlU2hhZGVyKHR5cGUpO1xuICAgICAgICB2YXIgc2hhZGVyU291cmNlID0gc2hhZGVyc1tuYW1lXVtraW5kXTtcblxuICAgICAgICBpZiAodHlwZW9mIG9yaWVudGF0aW9uID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgLy8gb25seSB1c2UgaGlnaHAgcHJlY2lzaW9uIG9uIG1vYmlsZSBicm93c2Vyc1xuICAgICAgICAgICAgc2hhZGVyU291cmNlID0gc2hhZGVyU291cmNlLnJlcGxhY2UoLyBoaWdocCAvZywgJyAnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2hhZGVyU291cmNlKHNoYWRlciwgc2hhZGVyU291cmNlKTtcbiAgICAgICAgdGhpcy5jb21waWxlU2hhZGVyKHNoYWRlcik7XG4gICAgICAgIGlmICghdGhpcy5nZXRTaGFkZXJQYXJhbWV0ZXIoc2hhZGVyLCB0aGlzLkNPTVBJTEVfU1RBVFVTKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRoaXMuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2hhZGVyO1xuICAgIH07XG5cbiAgICBjb250ZXh0LmluaXRpYWxpemVTaGFkZXIgPSBmdW5jdGlvbihuYW1lLCBhdHRyaWJ1dGVzLCB1bmlmb3Jtcykge1xuICAgICAgICB2YXIgc2hhZGVyID0ge1xuICAgICAgICAgICAgcHJvZ3JhbTogdGhpcy5jcmVhdGVQcm9ncmFtKCksXG4gICAgICAgICAgICBmcmFnbWVudDogdGhpcy5nZXRTaGFkZXIobmFtZSwgdGhpcy5GUkFHTUVOVF9TSEFERVIpLFxuICAgICAgICAgICAgdmVydGV4OiB0aGlzLmdldFNoYWRlcihuYW1lLCB0aGlzLlZFUlRFWF9TSEFERVIpLFxuICAgICAgICAgICAgYXR0cmlidXRlczogW11cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hdHRhY2hTaGFkZXIoc2hhZGVyLnByb2dyYW0sIHNoYWRlci52ZXJ0ZXgpO1xuICAgICAgICB0aGlzLmF0dGFjaFNoYWRlcihzaGFkZXIucHJvZ3JhbSwgc2hhZGVyLmZyYWdtZW50KTtcbiAgICAgICAgdGhpcy5saW5rUHJvZ3JhbShzaGFkZXIucHJvZ3JhbSk7XG5cbiAgICAgICAgaWYgKCF0aGlzLmdldFByb2dyYW1QYXJhbWV0ZXIoc2hhZGVyLnByb2dyYW0sIHRoaXMuTElOS19TVEFUVVMpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKHRoaXMuZ2V0UHJvZ3JhbUluZm9Mb2coc2hhZGVyLnByb2dyYW0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHNoYWRlclthdHRyaWJ1dGVzW2ldXSA9IHRoaXMuZ2V0QXR0cmliTG9jYXRpb24oc2hhZGVyLnByb2dyYW0sIGF0dHJpYnV0ZXNbaV0pO1xuICAgICAgICAgICAgICAgIHNoYWRlci5hdHRyaWJ1dGVzLnB1c2goc2hhZGVyW2F0dHJpYnV0ZXNbaV1dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdW5pZm9ybXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICBzaGFkZXJbdW5pZm9ybXNba11dID0gdGhpcy5nZXRVbmlmb3JtTG9jYXRpb24oc2hhZGVyLnByb2dyYW0sIHVuaWZvcm1zW2tdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzaGFkZXI7XG4gICAgfTtcblxuICAgIC8vIFN3aXRjaGVzIHRvIGEgZGlmZmVyZW50IHNoYWRlciBwcm9ncmFtLlxuICAgIGNvbnRleHQuc3dpdGNoU2hhZGVyID0gZnVuY3Rpb24oc2hhZGVyLCBwb3NNYXRyaXgsIGV4TWF0cml4KSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRTaGFkZXIgIT09IHNoYWRlcikge1xuICAgICAgICAgICAgdGhpcy51c2VQcm9ncmFtKHNoYWRlci5wcm9ncmFtKTtcblxuICAgICAgICAgICAgLy8gRGlzYWJsZSBhbGwgYXR0cmlidXRlcyBmcm9tIHRoZSBleGlzdGluZyBzaGFkZXIgdGhhdCBhcmVuJ3QgdXNlZCBpblxuICAgICAgICAgICAgLy8gdGhlIG5ldyBzaGFkZXIuIE5vdGU6IGF0dHJpYnV0ZSBpbmRpY2VzIGFyZSAqbm90KiBwcm9ncmFtIHNwZWNpZmljIVxuICAgICAgICAgICAgdmFyIGVuYWJsZWQgPSB0aGlzLmN1cnJlbnRTaGFkZXIgPyB0aGlzLmN1cnJlbnRTaGFkZXIuYXR0cmlidXRlcyA6IFtdO1xuICAgICAgICAgICAgdmFyIHJlcXVpcmVkID0gc2hhZGVyLmF0dHJpYnV0ZXM7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5hYmxlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChyZXF1aXJlZC5pbmRleE9mKGVuYWJsZWRbaV0pIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheShlbmFibGVkW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEVuYWJsZSBhbGwgYXR0cmlidXRlcyBmb3IgdGhlIG5ldyBzaGFkZXIuXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJlcXVpcmVkLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVuYWJsZWQuaW5kZXhPZihyZXF1aXJlZFtqXSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkocmVxdWlyZWRbal0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5jdXJyZW50U2hhZGVyID0gc2hhZGVyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvc01hdHJpeCAhPT0gdW5kZWZpbmVkKSBjb250ZXh0LnNldFBvc01hdHJpeChwb3NNYXRyaXgpO1xuICAgICAgICBpZiAoZXhNYXRyaXggIT09IHVuZGVmaW5lZCkgY29udGV4dC5zZXRFeE1hdHJpeChleE1hdHJpeCk7XG4gICAgfTtcblxuICAgIC8vIFVwZGF0ZSB0aGUgbWF0cmljZXMgaWYgbmVjZXNzYXJ5LiBOb3RlOiBUaGlzIHJlbGllcyBvbiBvYmplY3QgaWRlbnRpdHkhXG4gICAgLy8gVGhpcyBtZWFucyBjaGFuZ2luZyB0aGUgbWF0cml4IHZhbHVlcyB3aXRob3V0IHRoZSBhY3R1YWwgbWF0cml4IG9iamVjdFxuICAgIC8vIHdpbGwgRkFJTCB0byB1cGRhdGUgdGhlIG1hdHJpeCBwcm9wZXJseS5cbiAgICBjb250ZXh0LnNldFBvc01hdHJpeCA9IGZ1bmN0aW9uKHBvc01hdHJpeCkge1xuICAgICAgICB2YXIgc2hhZGVyID0gdGhpcy5jdXJyZW50U2hhZGVyO1xuICAgICAgICBpZiAoc2hhZGVyLnBvc01hdHJpeCAhPT0gcG9zTWF0cml4KSB7XG4gICAgICAgICAgICB0aGlzLnVuaWZvcm1NYXRyaXg0ZnYoc2hhZGVyLnVfbWF0cml4LCBmYWxzZSwgcG9zTWF0cml4KTtcbiAgICAgICAgICAgIHNoYWRlci5wb3NNYXRyaXggPSBwb3NNYXRyaXg7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gVXBkYXRlIHRoZSBtYXRyaWNlcyBpZiBuZWNlc3NhcnkuIE5vdGU6IFRoaXMgcmVsaWVzIG9uIG9iamVjdCBpZGVudGl0eSFcbiAgICAvLyBUaGlzIG1lYW5zIGNoYW5naW5nIHRoZSBtYXRyaXggdmFsdWVzIHdpdGhvdXQgdGhlIGFjdHVhbCBtYXRyaXggb2JqZWN0XG4gICAgLy8gd2lsbCBGQUlMIHRvIHVwZGF0ZSB0aGUgbWF0cml4IHByb3Blcmx5LlxuICAgIGNvbnRleHQuc2V0RXhNYXRyaXggPSBmdW5jdGlvbihleE1hdHJpeCkge1xuICAgICAgICB2YXIgc2hhZGVyID0gdGhpcy5jdXJyZW50U2hhZGVyO1xuICAgICAgICBpZiAoZXhNYXRyaXggJiYgc2hhZGVyLmV4TWF0cml4ICE9PSBleE1hdHJpeCAmJiBzaGFkZXIudV9leG1hdHJpeCkge1xuICAgICAgICAgICAgdGhpcy51bmlmb3JtTWF0cml4NGZ2KHNoYWRlci51X2V4bWF0cml4LCBmYWxzZSwgZXhNYXRyaXgpO1xuICAgICAgICAgICAgc2hhZGVyLmV4TWF0cml4ID0gZXhNYXRyaXg7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgY29udGV4dC52ZXJ0ZXhBdHRyaWIyZnYgPSBmdW5jdGlvbihhdHRyaWJ1dGUsIHZhbHVlcykge1xuICAgICAgICBjb250ZXh0LnZlcnRleEF0dHJpYjJmKGF0dHJpYnV0ZSwgdmFsdWVzWzBdLCB2YWx1ZXNbMV0pO1xuICAgIH07XG5cbiAgICBjb250ZXh0LnZlcnRleEF0dHJpYjNmdiA9IGZ1bmN0aW9uKGF0dHJpYnV0ZSwgdmFsdWVzKSB7XG4gICAgICAgIGNvbnRleHQudmVydGV4QXR0cmliM2YoYXR0cmlidXRlLCB2YWx1ZXNbMF0sIHZhbHVlc1sxXSwgdmFsdWVzWzJdKTtcbiAgICB9O1xuXG4gICAgY29udGV4dC52ZXJ0ZXhBdHRyaWI0ZnYgPSBmdW5jdGlvbihhdHRyaWJ1dGUsIHZhbHVlcykge1xuICAgICAgICBjb250ZXh0LnZlcnRleEF0dHJpYjRmKGF0dHJpYnV0ZSwgdmFsdWVzWzBdLCB2YWx1ZXNbMV0sIHZhbHVlc1syXSwgdmFsdWVzWzNdKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGNvbnRleHQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpbmVBdGxhcztcblxuLyoqXG4gKiBBIExpbmVBdGxhcyBsZXRzIHVzIHJldXNlIHJlbmRlcmVkIGRhc2hlZCBsaW5lc1xuICogYnkgd3JpdGluZyBtYW55IG9mIHRoZW0gdG8gYSB0ZXh0dXJlIGFuZCB0aGVuIGZldGNoaW5nIHRoZWlyIHBvc2l0aW9uc1xuICogdXNpbmcgLmdldERhc2guXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoXG4gKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBMaW5lQXRsYXMod2lkdGgsIGhlaWdodCkge1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLm5leHRSb3cgPSAwO1xuXG4gICAgdGhpcy5ieXRlcyA9IDQ7XG4gICAgdGhpcy5kYXRhID0gbmV3IFVpbnQ4QXJyYXkodGhpcy53aWR0aCAqIHRoaXMuaGVpZ2h0ICogdGhpcy5ieXRlcyk7XG5cbiAgICB0aGlzLnBvc2l0aW9ucyA9IHt9O1xufVxuXG5MaW5lQXRsYXMucHJvdG90eXBlLnNldFNwcml0ZSA9IGZ1bmN0aW9uKHNwcml0ZSkge1xuICAgIHRoaXMuc3ByaXRlID0gc3ByaXRlO1xufTtcblxuLyoqXG4gKiBHZXQgb3IgY3JlYXRlIGEgZGFzaCBsaW5lIHBhdHRlcm4uXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBkYXNoYXJyYXlcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcm91bmQgd2hldGhlciB0byBhZGQgY2lyY2xlIGNhcHMgaW4gYmV0d2VlbiBkYXNoIHNlZ21lbnRzXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBwb3NpdGlvbiBvZiBkYXNoIHRleHR1cmUgaW4geyB5LCBoZWlnaHQsIHdpZHRoIH1cbiAqIEBwcml2YXRlXG4gKi9cbkxpbmVBdGxhcy5wcm90b3R5cGUuZ2V0RGFzaCA9IGZ1bmN0aW9uKGRhc2hhcnJheSwgcm91bmQpIHtcbiAgICB2YXIga2V5ID0gZGFzaGFycmF5LmpvaW4oXCIsXCIpICsgcm91bmQ7XG5cbiAgICBpZiAoIXRoaXMucG9zaXRpb25zW2tleV0pIHtcbiAgICAgICAgdGhpcy5wb3NpdGlvbnNba2V5XSA9IHRoaXMuYWRkRGFzaChkYXNoYXJyYXksIHJvdW5kKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucG9zaXRpb25zW2tleV07XG59O1xuXG5MaW5lQXRsYXMucHJvdG90eXBlLmFkZERhc2ggPSBmdW5jdGlvbihkYXNoYXJyYXksIHJvdW5kKSB7XG5cbiAgICB2YXIgbiA9IHJvdW5kID8gNyA6IDA7XG4gICAgdmFyIGhlaWdodCA9IDIgKiBuICsgMTtcbiAgICB2YXIgb2Zmc2V0ID0gMTI4O1xuXG4gICAgaWYgKHRoaXMubmV4dFJvdyArIGhlaWdodCA+IHRoaXMuaGVpZ2h0KSB7XG4gICAgICAgIGNvbnNvbGUud2FybignTGluZUF0bGFzIG91dCBvZiBzcGFjZScpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgbGVuZ3RoID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhc2hhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZW5ndGggKz0gZGFzaGFycmF5W2ldO1xuICAgIH1cblxuICAgIHZhciBzdHJldGNoID0gdGhpcy53aWR0aCAvIGxlbmd0aDtcbiAgICB2YXIgaGFsZldpZHRoID0gc3RyZXRjaCAvIDI7XG5cbiAgICAvLyBJZiBkYXNoYXJyYXkgaGFzIGFuIG9kZCBsZW5ndGgsIGJvdGggdGhlIGZpcnN0IGFuZCBsYXN0IHBhcnRzXG4gICAgLy8gYXJlIGRhc2hlcyBhbmQgc2hvdWxkIGJlIGpvaW5lZCBzZWFtbGVzc2x5LlxuICAgIHZhciBvZGRMZW5ndGggPSBkYXNoYXJyYXkubGVuZ3RoICUgMiA9PT0gMTtcblxuICAgIGZvciAodmFyIHkgPSAtbjsgeSA8PSBuOyB5KyspIHtcbiAgICAgICAgdmFyIHJvdyA9IHRoaXMubmV4dFJvdyArIG4gKyB5O1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLndpZHRoICogcm93O1xuXG4gICAgICAgIHZhciBsZWZ0ID0gb2RkTGVuZ3RoID8gLWRhc2hhcnJheVtkYXNoYXJyYXkubGVuZ3RoIC0gMV0gOiAwO1xuICAgICAgICB2YXIgcmlnaHQgPSBkYXNoYXJyYXlbMF07XG4gICAgICAgIHZhciBwYXJ0SW5kZXggPSAxO1xuXG4gICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgdGhpcy53aWR0aDsgeCsrKSB7XG5cbiAgICAgICAgICAgIHdoaWxlIChyaWdodCA8IHggLyBzdHJldGNoKSB7XG4gICAgICAgICAgICAgICAgbGVmdCA9IHJpZ2h0O1xuICAgICAgICAgICAgICAgIHJpZ2h0ID0gcmlnaHQgKyBkYXNoYXJyYXlbcGFydEluZGV4XTtcblxuICAgICAgICAgICAgICAgIGlmIChvZGRMZW5ndGggJiYgcGFydEluZGV4ID09PSBkYXNoYXJyYXkubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICByaWdodCArPSBkYXNoYXJyYXlbMF07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcGFydEluZGV4Kys7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBkaXN0TGVmdCA9IE1hdGguYWJzKHggLSBsZWZ0ICogc3RyZXRjaCk7XG4gICAgICAgICAgICB2YXIgZGlzdFJpZ2h0ID0gTWF0aC5hYnMoeCAtIHJpZ2h0ICogc3RyZXRjaCk7XG4gICAgICAgICAgICB2YXIgZGlzdCA9IE1hdGgubWluKGRpc3RMZWZ0LCBkaXN0UmlnaHQpO1xuICAgICAgICAgICAgdmFyIGluc2lkZSA9IChwYXJ0SW5kZXggJSAyKSA9PT0gMTtcbiAgICAgICAgICAgIHZhciBzaWduZWREaXN0YW5jZTtcblxuICAgICAgICAgICAgaWYgKHJvdW5kKSB7XG4gICAgICAgICAgICAgICAgLy8gQWRkIGNpcmNsZSBjYXBzXG4gICAgICAgICAgICAgICAgdmFyIGRpc3RNaWRkbGUgPSBuID8geSAvIG4gKiAoaGFsZldpZHRoICsgMSkgOiAwO1xuICAgICAgICAgICAgICAgIGlmIChpbnNpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpc3RFZGdlID0gaGFsZldpZHRoIC0gTWF0aC5hYnMoZGlzdE1pZGRsZSk7XG4gICAgICAgICAgICAgICAgICAgIHNpZ25lZERpc3RhbmNlID0gTWF0aC5zcXJ0KGRpc3QgKiBkaXN0ICsgZGlzdEVkZ2UgKiBkaXN0RWRnZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2lnbmVkRGlzdGFuY2UgPSBoYWxmV2lkdGggLSBNYXRoLnNxcnQoZGlzdCAqIGRpc3QgKyBkaXN0TWlkZGxlICogZGlzdE1pZGRsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzaWduZWREaXN0YW5jZSA9IChpbnNpZGUgPyAxIDogLTEpICogZGlzdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5kYXRhWzMgKyAoaW5kZXggKyB4KSAqIDRdID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCBzaWduZWREaXN0YW5jZSArIG9mZnNldCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHBvcyA9IHtcbiAgICAgICAgeTogKHRoaXMubmV4dFJvdyArIG4gKyAwLjUpIC8gdGhpcy5oZWlnaHQsXG4gICAgICAgIGhlaWdodDogMiAqIG4gLyB0aGlzLmhlaWdodCxcbiAgICAgICAgd2lkdGg6IGxlbmd0aFxuICAgIH07XG5cbiAgICB0aGlzLm5leHRSb3cgKz0gaGVpZ2h0O1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuXG4gICAgcmV0dXJuIHBvcztcbn07XG5cbkxpbmVBdGxhcy5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uKGdsKSB7XG4gICAgaWYgKCF0aGlzLnRleHR1cmUpIHtcbiAgICAgICAgdGhpcy50ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLnRleHR1cmUpO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5SRVBFQVQpO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5SRVBFQVQpO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTElORUFSKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLkxJTkVBUik7XG4gICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHRoaXMuZGF0YSk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLnRleHR1cmUpO1xuXG4gICAgICAgIGlmICh0aGlzLmRpcnR5KSB7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgICAgICBnbC50ZXhTdWJJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCB0aGlzLmRhdGEpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuTGluZUF0bGFzLnByb3RvdHlwZS5kZWJ1ZyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjYW52YXMpO1xuICAgIGNhbnZhcy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgY2FudmFzLnN0eWxlLnRvcCA9IDA7XG4gICAgY2FudmFzLnN0eWxlLmxlZnQgPSAwO1xuICAgIGNhbnZhcy5zdHlsZS5iYWNrZ3JvdW5kID0gJyNmZjAnO1xuXG4gICAgY2FudmFzLndpZHRoID0gdGhpcy53aWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG5cbiAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgdmFyIGRhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodGhpcy5zZGYpIHtcbiAgICAgICAgICAgIHZhciBrID0gaSAqIDQ7XG4gICAgICAgICAgICBkYXRhLmRhdGFba10gPSBkYXRhLmRhdGFbayArIDFdID0gZGF0YS5kYXRhW2sgKyAyXSA9IDA7XG4gICAgICAgICAgICBkYXRhLmRhdGFbayArIDNdID0gdGhpcy5kYXRhW2ldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0YS5kYXRhW2ldID0gdGhpcy5kYXRhW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIGN0eC5wdXRJbWFnZURhdGEoZGF0YSwgMCwgMCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2x1dGlsID0gcmVxdWlyZSgnLi9nbF91dGlsJyk7XG52YXIgYnJvd3NlciA9IHJlcXVpcmUoJy4uL3V0aWwvYnJvd3NlcicpO1xudmFyIG1hdDQgPSByZXF1aXJlKCdnbC1tYXRyaXgnKS5tYXQ0O1xudmFyIEZyYW1lSGlzdG9yeSA9IHJlcXVpcmUoJy4vZnJhbWVfaGlzdG9yeScpO1xudmFyIFRpbGVDb29yZCA9IHJlcXVpcmUoJy4uL3NvdXJjZS90aWxlX2Nvb3JkJyk7XG5cbi8qXG4gKiBJbml0aWFsaXplIGEgbmV3IHBhaW50ZXIgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7Q2FudmFzfSBnbCBhbiBleHBlcmltZW50YWwtd2ViZ2wgZHJhd2luZyBjb250ZXh0XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gUGFpbnRlcjtcbmZ1bmN0aW9uIFBhaW50ZXIoZ2wsIHRyYW5zZm9ybSkge1xuICAgIHRoaXMuZ2wgPSBnbHV0aWwuZXh0ZW5kKGdsKTtcbiAgICB0aGlzLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcblxuICAgIHRoaXMucmV1c2FibGVUZXh0dXJlcyA9IHt9O1xuICAgIHRoaXMucHJlRmJvcyA9IHt9O1xuXG4gICAgdGhpcy5mcmFtZUhpc3RvcnkgPSBuZXcgRnJhbWVIaXN0b3J5KCk7XG5cbiAgICB0aGlzLnNldHVwKCk7XG5cbiAgICAvLyBXaXRoaW4gZWFjaCBsYXllciB0aGVyZSBhcmUgMyBkaXN0aW5jdCB6LXBsYW5lcyB0aGF0IGNhbiBiZSBkcmF3biB0by5cbiAgICAvLyBUaGlzIGlzIGltcGxlbWVudGVkIHVzaW5nIHRoZSBXZWJHTCBkZXB0aCBidWZmZXIuXG4gICAgdGhpcy5udW1TdWJsYXllcnMgPSAzO1xuICAgIHRoaXMuZGVwdGhFcHNpbG9uID0gMSAvIE1hdGgucG93KDIsIDE2KTtcbn1cblxuLypcbiAqIFVwZGF0ZSB0aGUgR0wgdmlld3BvcnQsIHByb2plY3Rpb24gbWF0cml4LCBhbmQgdHJhbnNmb3JtcyB0byBjb21wZW5zYXRlXG4gKiBmb3IgYSBuZXcgd2lkdGggYW5kIGhlaWdodCB2YWx1ZS5cbiAqL1xuUGFpbnRlci5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG5cbiAgICB0aGlzLndpZHRoID0gd2lkdGggKiBicm93c2VyLmRldmljZVBpeGVsUmF0aW87XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQgKiBicm93c2VyLmRldmljZVBpeGVsUmF0aW87XG4gICAgZ2wudmlld3BvcnQoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuXG59O1xuXG5cblBhaW50ZXIucHJvdG90eXBlLnNldHVwID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcblxuICAgIGdsLnZlcmJvc2UgPSB0cnVlO1xuXG4gICAgLy8gV2UgYXJlIGJsZW5kaW5nIHRoZSBuZXcgcGl4ZWxzICpiZWhpbmQqIHRoZSBleGlzdGluZyBwaXhlbHMuIFRoYXQgd2F5IHdlIGNhblxuICAgIC8vIGRyYXcgZnJvbnQtdG8tYmFjayBhbmQgdXNlIHRoZW4gc3RlbmNpbCBidWZmZXIgdG8gY3VsbCBvcGFxdWUgcGl4ZWxzIGVhcmx5LlxuICAgIGdsLmVuYWJsZShnbC5CTEVORCk7XG4gICAgZ2wuYmxlbmRGdW5jKGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSk7XG5cbiAgICBnbC5lbmFibGUoZ2wuU1RFTkNJTF9URVNUKTtcblxuICAgIGdsLmVuYWJsZShnbC5ERVBUSF9URVNUKTtcbiAgICBnbC5kZXB0aEZ1bmMoZ2wuTEVRVUFMKTtcblxuICAgIHRoaXMuX2RlcHRoTWFzayA9IGZhbHNlO1xuICAgIGdsLmRlcHRoTWFzayhmYWxzZSk7XG5cbiAgICAvLyBJbml0aWFsaXplIHNoYWRlcnNcbiAgICB0aGlzLmRlYnVnU2hhZGVyID0gZ2wuaW5pdGlhbGl6ZVNoYWRlcignZGVidWcnLFxuICAgICAgICBbJ2FfcG9zJ10sXG4gICAgICAgIFsndV9tYXRyaXgnLCAndV9jb2xvciddKTtcblxuICAgIHRoaXMucmFzdGVyU2hhZGVyID0gZ2wuaW5pdGlhbGl6ZVNoYWRlcigncmFzdGVyJyxcbiAgICAgICAgWydhX3BvcycsICdhX3RleHR1cmVfcG9zJ10sXG4gICAgICAgIFsndV9tYXRyaXgnLCAndV9icmlnaHRuZXNzX2xvdycsICd1X2JyaWdodG5lc3NfaGlnaCcsICd1X3NhdHVyYXRpb25fZmFjdG9yJywgJ3Vfc3Bpbl93ZWlnaHRzJywgJ3VfY29udHJhc3RfZmFjdG9yJywgJ3Vfb3BhY2l0eTAnLCAndV9vcGFjaXR5MScsICd1X2ltYWdlMCcsICd1X2ltYWdlMScsICd1X3RsX3BhcmVudCcsICd1X3NjYWxlX3BhcmVudCcsICd1X2J1ZmZlcl9zY2FsZSddKTtcblxuICAgIHRoaXMuY2lyY2xlU2hhZGVyID0gZ2wuaW5pdGlhbGl6ZVNoYWRlcignY2lyY2xlJyxcbiAgICAgICAgWydhX3BvcyddLFxuICAgICAgICBbJ3VfbWF0cml4JywgJ3VfZXhtYXRyaXgnLCAndV9ibHVyJywgJ3Vfc2l6ZScsICd1X2NvbG9yJ10pO1xuXG4gICAgdGhpcy5saW5lU2hhZGVyID0gZ2wuaW5pdGlhbGl6ZVNoYWRlcignbGluZScsXG4gICAgICAgIFsnYV9wb3MnLCAnYV9kYXRhJ10sXG4gICAgICAgIFsndV9tYXRyaXgnLCAndV9saW5ld2lkdGgnLCAndV9jb2xvcicsICd1X3JhdGlvJywgJ3VfYmx1cicsICd1X2V4dHJhJywgJ3VfYW50aWFsaWFzaW5nbWF0cml4JywgJ3Vfb2Zmc2V0JywgJ3VfZXhtYXRyaXgnXSk7XG5cbiAgICB0aGlzLmxpbmVwYXR0ZXJuU2hhZGVyID0gZ2wuaW5pdGlhbGl6ZVNoYWRlcignbGluZXBhdHRlcm4nLFxuICAgICAgICBbJ2FfcG9zJywgJ2FfZGF0YSddLFxuICAgICAgICBbJ3VfbWF0cml4JywgJ3VfbGluZXdpZHRoJywgJ3VfcmF0aW8nLCAndV9wYXR0ZXJuX3NpemVfYScsICd1X3BhdHRlcm5fc2l6ZV9iJywgJ3VfcGF0dGVybl90bF9hJywgJ3VfcGF0dGVybl9icl9hJywgJ3VfcGF0dGVybl90bF9iJywgJ3VfcGF0dGVybl9icl9iJywgJ3VfYmx1cicsICd1X2ZhZGUnLCAndV9vcGFjaXR5JywgJ3VfZXh0cmEnLCAndV9hbnRpYWxpYXNpbmdtYXRyaXgnLCAndV9vZmZzZXQnXSk7XG5cbiAgICB0aGlzLmxpbmVzZGZwYXR0ZXJuU2hhZGVyID0gZ2wuaW5pdGlhbGl6ZVNoYWRlcignbGluZXNkZnBhdHRlcm4nLFxuICAgICAgICBbJ2FfcG9zJywgJ2FfZGF0YSddLFxuICAgICAgICBbJ3VfbWF0cml4JywgJ3VfbGluZXdpZHRoJywgJ3VfY29sb3InLCAndV9yYXRpbycsICd1X2JsdXInLCAndV9wYXR0ZXJuc2NhbGVfYScsICd1X3RleF95X2EnLCAndV9wYXR0ZXJuc2NhbGVfYicsICd1X3RleF95X2InLCAndV9pbWFnZScsICd1X3NkZmdhbW1hJywgJ3VfbWl4JywgJ3VfZXh0cmEnLCAndV9hbnRpYWxpYXNpbmdtYXRyaXgnLCAndV9vZmZzZXQnXSk7XG5cbiAgICB0aGlzLmRvdFNoYWRlciA9IGdsLmluaXRpYWxpemVTaGFkZXIoJ2RvdCcsXG4gICAgICAgIFsnYV9wb3MnXSxcbiAgICAgICAgWyd1X21hdHJpeCcsICd1X3NpemUnLCAndV9jb2xvcicsICd1X2JsdXInXSk7XG5cbiAgICB0aGlzLnNkZlNoYWRlciA9IGdsLmluaXRpYWxpemVTaGFkZXIoJ3NkZicsXG4gICAgICAgIFsnYV9wb3MnLCAnYV9vZmZzZXQnLCAnYV9kYXRhMScsICdhX2RhdGEyJ10sXG4gICAgICAgIFsndV9tYXRyaXgnLCAndV9leG1hdHJpeCcsICd1X3RleHR1cmUnLCAndV90ZXhzaXplJywgJ3VfY29sb3InLCAndV9nYW1tYScsICd1X2J1ZmZlcicsICd1X3pvb20nLCAndV9mYWRlZGlzdCcsICd1X21pbmZhZGV6b29tJywgJ3VfbWF4ZmFkZXpvb20nLCAndV9mYWRlem9vbScsICd1X3NrZXdlZCcsICd1X2V4dHJhJ10pO1xuXG4gICAgdGhpcy5pY29uU2hhZGVyID0gZ2wuaW5pdGlhbGl6ZVNoYWRlcignaWNvbicsXG4gICAgICAgIFsnYV9wb3MnLCAnYV9vZmZzZXQnLCAnYV9kYXRhMScsICdhX2RhdGEyJ10sXG4gICAgICAgIFsndV9tYXRyaXgnLCAndV9leG1hdHJpeCcsICd1X3RleHR1cmUnLCAndV90ZXhzaXplJywgJ3Vfem9vbScsICd1X2ZhZGVkaXN0JywgJ3VfbWluZmFkZXpvb20nLCAndV9tYXhmYWRlem9vbScsICd1X2ZhZGV6b29tJywgJ3Vfb3BhY2l0eScsICd1X3NrZXdlZCcsICd1X2V4dHJhJ10pO1xuXG4gICAgdGhpcy5vdXRsaW5lU2hhZGVyID0gZ2wuaW5pdGlhbGl6ZVNoYWRlcignb3V0bGluZScsXG4gICAgICAgIFsnYV9wb3MnXSxcbiAgICAgICAgWyd1X21hdHJpeCcsICd1X2NvbG9yJywgJ3Vfd29ybGQnXVxuICAgICk7XG5cbiAgICB0aGlzLnBhdHRlcm5TaGFkZXIgPSBnbC5pbml0aWFsaXplU2hhZGVyKCdwYXR0ZXJuJyxcbiAgICAgICAgWydhX3BvcyddLFxuICAgICAgICBbJ3VfbWF0cml4JywgJ3VfcGF0dGVybl90bF9hJywgJ3VfcGF0dGVybl9icl9hJywgJ3VfcGF0dGVybl90bF9iJywgJ3VfcGF0dGVybl9icl9iJywgJ3VfbWl4JywgJ3VfcGF0dGVybnNjYWxlX2EnLCAndV9wYXR0ZXJuc2NhbGVfYicsICd1X29wYWNpdHknLCAndV9pbWFnZScsICd1X29mZnNldF9hJywgJ3Vfb2Zmc2V0X2InXVxuICAgICk7XG5cbiAgICB0aGlzLmZpbGxTaGFkZXIgPSBnbC5pbml0aWFsaXplU2hhZGVyKCdmaWxsJyxcbiAgICAgICAgWydhX3BvcyddLFxuICAgICAgICBbJ3VfbWF0cml4JywgJ3VfY29sb3InXVxuICAgICk7XG5cbiAgICB0aGlzLmNvbGxpc2lvbkJveFNoYWRlciA9IGdsLmluaXRpYWxpemVTaGFkZXIoJ2NvbGxpc2lvbmJveCcsXG4gICAgICAgIFsnYV9wb3MnLCAnYV9leHRydWRlJywgJ2FfZGF0YSddLFxuICAgICAgICBbJ3VfbWF0cml4JywgJ3Vfc2NhbGUnLCAndV96b29tJywgJ3VfbWF4em9vbSddXG4gICAgKTtcblxuICAgIHRoaXMuaWRlbnRpdHlNYXRyaXggPSBtYXQ0LmNyZWF0ZSgpO1xuXG4gICAgLy8gVGhlIGJhY2tncm91bmRCdWZmZXIgaXMgdXNlZCB3aGVuIGRyYXdpbmcgdG8gdGhlIGZ1bGwgKmNhbnZhcypcbiAgICB0aGlzLmJhY2tncm91bmRCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICB0aGlzLmJhY2tncm91bmRCdWZmZXIuaXRlbVNpemUgPSAyO1xuICAgIHRoaXMuYmFja2dyb3VuZEJ1ZmZlci5pdGVtQ291bnQgPSA0O1xuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLmJhY2tncm91bmRCdWZmZXIpO1xuICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBuZXcgSW50MTZBcnJheShbLTEsIC0xLCAxLCAtMSwgLTEsIDEsIDEsIDFdKSwgZ2wuU1RBVElDX0RSQVcpO1xuXG4gICAgdGhpcy5zZXRFeHRlbnQoNDA5Nik7XG5cbiAgICAvLyBUaGUgZGVidWdUZXh0QnVmZmVyIGlzIHVzZWQgdG8gZHJhdyB0aWxlIElEcyBmb3IgZGVidWdnaW5nXG4gICAgdGhpcy5kZWJ1Z1RleHRCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICB0aGlzLmRlYnVnVGV4dEJ1ZmZlci5pdGVtU2l6ZSA9IDI7XG59O1xuXG4vKipcbiAqIFJlYmluZCB0aGUgbmVjZXNzYXJ5IGJ1ZmZlcnMgdG8gcmVuZGVyIGF0IGEgZGlmZmVyZW50IGV4dGVudCB0aGFuXG4gKiB0aGUgY3VycmVudCBvbmUuIE5vLW9wcyBpZiB0aGUgZXh0ZW50IGlzIG5vdCBjaGFuZ2luZy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gbmV3RXh0ZW50XG4gKiBAZXhhbXBsZVxuICogdGhpcy5zZXRFeHRlbnQoNDA5Nik7XG4gKiBAcHJpdmF0ZVxuICovXG5QYWludGVyLnByb3RvdHlwZS5zZXRFeHRlbnQgPSBmdW5jdGlvbihuZXdFeHRlbnQpIHtcbiAgICBpZiAoIW5ld0V4dGVudCB8fCBuZXdFeHRlbnQgPT09IHRoaXMudGlsZUV4dGVudCkgcmV0dXJuO1xuXG4gICAgdGhpcy50aWxlRXh0ZW50ID0gbmV3RXh0ZW50O1xuXG4gICAgdmFyIGdsID0gdGhpcy5nbDtcblxuICAgIC8vIFRoZSB0aWxlRXh0ZW50QnVmZmVyIGlzIHVzZWQgd2hlbiBkcmF3aW5nIHRvIGEgZnVsbCAqdGlsZSpcbiAgICB0aGlzLnRpbGVFeHRlbnRCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICB0aGlzLnRpbGVFeHRlbnRCdWZmZXIuaXRlbVNpemUgPSA0O1xuICAgIHRoaXMudGlsZUV4dGVudEJ1ZmZlci5pdGVtQ291bnQgPSA0O1xuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLnRpbGVFeHRlbnRCdWZmZXIpO1xuICAgIGdsLmJ1ZmZlckRhdGEoXG4gICAgICAgIGdsLkFSUkFZX0JVRkZFUixcbiAgICAgICAgbmV3IEludDE2QXJyYXkoW1xuICAgICAgICAgICAgLy8gdGlsZSBjb29yZCB4LCB0aWxlIGNvb3JkIHksIHRleHR1cmUgY29vcmQgeCwgdGV4dHVyZSBjb29yZCB5XG4gICAgICAgICAgICAwLCAwLCAwLCAwLFxuICAgICAgICAgICAgdGhpcy50aWxlRXh0ZW50LCAwLCAzMjc2NywgMCxcbiAgICAgICAgICAgIDAsIHRoaXMudGlsZUV4dGVudCwgMCwgMzI3NjcsXG4gICAgICAgICAgICB0aGlzLnRpbGVFeHRlbnQsIHRoaXMudGlsZUV4dGVudCwgIDMyNzY3LCAzMjc2N1xuICAgICAgICBdKSxcbiAgICAgICAgZ2wuU1RBVElDX0RSQVcpO1xuXG4gICAgLy8gVGhlIGRlYnVnQnVmZmVyIGlzIHVzZWQgdG8gZHJhdyB0aWxlIG91dGxpbmVzIGZvciBkZWJ1Z2dpbmdcbiAgICB0aGlzLmRlYnVnQnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgdGhpcy5kZWJ1Z0J1ZmZlci5pdGVtU2l6ZSA9IDI7XG4gICAgdGhpcy5kZWJ1Z0J1ZmZlci5pdGVtQ291bnQgPSA1O1xuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLmRlYnVnQnVmZmVyKTtcbiAgICBnbC5idWZmZXJEYXRhKFxuICAgICAgICBnbC5BUlJBWV9CVUZGRVIsXG4gICAgICAgIG5ldyBJbnQxNkFycmF5KFtcbiAgICAgICAgICAgIDAsIDAsIHRoaXMudGlsZUV4dGVudCAtIDEsIDAsIHRoaXMudGlsZUV4dGVudCAtIDEsIHRoaXMudGlsZUV4dGVudCAtIDEsIDAsIHRoaXMudGlsZUV4dGVudCAtIDEsIDAsIDBdKSxcbiAgICAgICAgZ2wuU1RBVElDX0RSQVcpO1xufTtcblxuLypcbiAqIFJlc2V0IHRoZSBjb2xvciBidWZmZXJzIG9mIHRoZSBkcmF3aW5nIGNhbnZhcy5cbiAqL1xuUGFpbnRlci5wcm90b3R5cGUuY2xlYXJDb2xvciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgZ2wuY2xlYXJDb2xvcigwLCAwLCAwLCAwKTtcbiAgICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUKTtcbn07XG5cbi8qXG4gKiBSZXNldCB0aGUgZHJhd2luZyBjYW52YXMgYnkgY2xlYXJpbmcgdGhlIHN0ZW5jaWwgYnVmZmVyIHNvIHRoYXQgd2UgY2FuIGRyYXdcbiAqIG5ldyB0aWxlcyBhdCB0aGUgc2FtZSBsb2NhdGlvbiwgd2hpbGUgcmV0YWluaW5nIHByZXZpb3VzbHkgZHJhd24gcGl4ZWxzLlxuICovXG5QYWludGVyLnByb3RvdHlwZS5jbGVhclN0ZW5jaWwgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgIGdsLmNsZWFyU3RlbmNpbCgweDApO1xuICAgIGdsLnN0ZW5jaWxNYXNrKDB4RkYpO1xuICAgIGdsLmNsZWFyKGdsLlNURU5DSUxfQlVGRkVSX0JJVCk7XG59O1xuXG5QYWludGVyLnByb3RvdHlwZS5jbGVhckRlcHRoID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICBnbC5jbGVhckRlcHRoKDEpO1xuICAgIHRoaXMuZGVwdGhNYXNrKHRydWUpO1xuICAgIGdsLmNsZWFyKGdsLkRFUFRIX0JVRkZFUl9CSVQpO1xufTtcblxuUGFpbnRlci5wcm90b3R5cGUuX3JlbmRlclRpbGVDbGlwcGluZ01hc2tzID0gZnVuY3Rpb24oY29vcmRzLCBzb3VyY2VNYXhab29tKSB7XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICBnbC5jb2xvck1hc2soZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UpO1xuICAgIHRoaXMuZGVwdGhNYXNrKGZhbHNlKTtcbiAgICBnbC5kaXNhYmxlKGdsLkRFUFRIX1RFU1QpO1xuXG4gICAgLy8gT25seSB3cml0ZSBjbGlwcGluZyBJRHMgdG8gdGhlIGxhc3QgNSBiaXRzLiBUaGUgZmlyc3QgdGhyZWUgYXJlIHVzZWQgZm9yIGRyYXdpbmcgZmlsbHMuXG4gICAgZ2wuc3RlbmNpbE1hc2soMHhGOCk7XG4gICAgLy8gVGVzdHMgd2lsbCBhbHdheXMgcGFzcywgYW5kIHJlZiB2YWx1ZSB3aWxsIGJlIHdyaXR0ZW4gdG8gc3RlbmNpbCBidWZmZXIuXG4gICAgZ2wuc3RlbmNpbE9wKGdsLktFRVAsIGdsLktFRVAsIGdsLlJFUExBQ0UpO1xuXG4gICAgdmFyIGlkTmV4dCA9IDE7XG4gICAgdGhpcy5fdGlsZUNsaXBwaW5nTWFza0lEcyA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29vcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjb29yZCA9IGNvb3Jkc1tpXTtcbiAgICAgICAgdmFyIGlkID0gdGhpcy5fdGlsZUNsaXBwaW5nTWFza0lEc1tjb29yZC5pZF0gPSAoaWROZXh0KyspIDw8IDM7XG5cbiAgICAgICAgZ2wuc3RlbmNpbEZ1bmMoZ2wuQUxXQVlTLCBpZCwgMHhGOCk7XG5cbiAgICAgICAgZ2wuc3dpdGNoU2hhZGVyKHRoaXMuZmlsbFNoYWRlciwgdGhpcy5jYWxjdWxhdGVQb3NNYXRyaXgoY29vcmQsIHNvdXJjZU1heFpvb20pKTtcblxuICAgICAgICAvLyBEcmF3IHRoZSBjbGlwcGluZyBtYXNrXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLnRpbGVFeHRlbnRCdWZmZXIpO1xuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMuZmlsbFNoYWRlci5hX3BvcywgdGhpcy50aWxlRXh0ZW50QnVmZmVyLml0ZW1TaXplLCBnbC5TSE9SVCwgZmFsc2UsIDgsIDApO1xuICAgICAgICBnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFX1NUUklQLCAwLCB0aGlzLnRpbGVFeHRlbnRCdWZmZXIuaXRlbUNvdW50KTtcbiAgICB9XG5cbiAgICBnbC5zdGVuY2lsTWFzaygweDAwKTtcbiAgICBnbC5jb2xvck1hc2sodHJ1ZSwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgdGhpcy5kZXB0aE1hc2sodHJ1ZSk7XG4gICAgZ2wuZW5hYmxlKGdsLkRFUFRIX1RFU1QpO1xufTtcblxuUGFpbnRlci5wcm90b3R5cGUuZW5hYmxlVGlsZUNsaXBwaW5nTWFzayA9IGZ1bmN0aW9uKGNvb3JkKSB7XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICBnbC5zdGVuY2lsRnVuYyhnbC5FUVVBTCwgdGhpcy5fdGlsZUNsaXBwaW5nTWFza0lEc1tjb29yZC5pZF0sIDB4RjgpO1xufTtcblxuLy8gT3ZlcnJpZGRlbiBieSBoZWFkbGVzcyB0ZXN0cy5cblBhaW50ZXIucHJvdG90eXBlLnByZXBhcmVCdWZmZXJzID0gZnVuY3Rpb24oKSB7fTtcblBhaW50ZXIucHJvdG90eXBlLmJpbmREZWZhdWx0RnJhbWVidWZmZXIgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7XG59O1xuXG52YXIgZHJhdyA9IHtcbiAgICBzeW1ib2w6IHJlcXVpcmUoJy4vZHJhd19zeW1ib2wnKSxcbiAgICBjaXJjbGU6IHJlcXVpcmUoJy4vZHJhd19jaXJjbGUnKSxcbiAgICBsaW5lOiByZXF1aXJlKCcuL2RyYXdfbGluZScpLFxuICAgIGZpbGw6IHJlcXVpcmUoJy4vZHJhd19maWxsJyksXG4gICAgcmFzdGVyOiByZXF1aXJlKCcuL2RyYXdfcmFzdGVyJyksXG4gICAgYmFja2dyb3VuZDogcmVxdWlyZSgnLi9kcmF3X2JhY2tncm91bmQnKSxcbiAgICBkZWJ1ZzogcmVxdWlyZSgnLi9kcmF3X2RlYnVnJylcbn07XG5cblBhaW50ZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKHN0eWxlLCBvcHRpb25zKSB7XG4gICAgdGhpcy5zdHlsZSA9IHN0eWxlO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cbiAgICB0aGlzLmxpbmVBdGxhcyA9IHN0eWxlLmxpbmVBdGxhcztcblxuICAgIHRoaXMuc3ByaXRlQXRsYXMgPSBzdHlsZS5zcHJpdGVBdGxhcztcbiAgICB0aGlzLnNwcml0ZUF0bGFzLnNldFNwcml0ZShzdHlsZS5zcHJpdGUpO1xuXG4gICAgdGhpcy5nbHlwaFNvdXJjZSA9IHN0eWxlLmdseXBoU291cmNlO1xuXG4gICAgdGhpcy5mcmFtZUhpc3RvcnkucmVjb3JkKHRoaXMudHJhbnNmb3JtLnpvb20pO1xuXG4gICAgdGhpcy5wcmVwYXJlQnVmZmVycygpO1xuICAgIHRoaXMuY2xlYXJDb2xvcigpO1xuICAgIHRoaXMuY2xlYXJEZXB0aCgpO1xuXG4gICAgdGhpcy5kZXB0aFJhbmdlID0gKHN0eWxlLl9vcmRlci5sZW5ndGggKyAyKSAqIHRoaXMubnVtU3VibGF5ZXJzICogdGhpcy5kZXB0aEVwc2lsb247XG5cbiAgICB0aGlzLnJlbmRlclBhc3Moe2lzT3BhcXVlUGFzczogdHJ1ZX0pO1xuICAgIHRoaXMucmVuZGVyUGFzcyh7aXNPcGFxdWVQYXNzOiBmYWxzZX0pO1xufTtcblxuUGFpbnRlci5wcm90b3R5cGUucmVuZGVyUGFzcyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB2YXIgZ3JvdXBzID0gdGhpcy5zdHlsZS5fZ3JvdXBzO1xuICAgIHZhciBpc09wYXF1ZVBhc3MgPSBvcHRpb25zLmlzT3BhcXVlUGFzcztcbiAgICB0aGlzLmN1cnJlbnRMYXllciA9IGlzT3BhcXVlUGFzcyA/IHRoaXMuc3R5bGUuX29yZGVyLmxlbmd0aCA6IC0xO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGdyb3VwID0gZ3JvdXBzW2lzT3BhcXVlUGFzcyA/IGdyb3Vwcy5sZW5ndGggLSAxIC0gaSA6IGldO1xuICAgICAgICB2YXIgc291cmNlID0gdGhpcy5zdHlsZS5zb3VyY2VzW2dyb3VwLnNvdXJjZV07XG5cbiAgICAgICAgdmFyIGNvb3JkcyA9IFtdO1xuICAgICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgICAgICBjb29yZHMgPSBzb3VyY2UuZ2V0VmlzaWJsZUNvb3JkaW5hdGVzKCk7XG4gICAgICAgICAgICB0aGlzLmNsZWFyU3RlbmNpbCgpO1xuICAgICAgICAgICAgaWYgKHNvdXJjZS5wcmVwYXJlKSBzb3VyY2UucHJlcGFyZSgpO1xuICAgICAgICAgICAgaWYgKHNvdXJjZS5pc1RpbGVDbGlwcGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyVGlsZUNsaXBwaW5nTWFza3MoY29vcmRzLCBzb3VyY2UubWF4em9vbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNPcGFxdWVQYXNzKSB7XG4gICAgICAgICAgICB0aGlzLmdsLmRpc2FibGUodGhpcy5nbC5CTEVORCk7XG4gICAgICAgICAgICB0aGlzLmlzT3BhcXVlUGFzcyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmdsLmVuYWJsZSh0aGlzLmdsLkJMRU5EKTtcbiAgICAgICAgICAgIHRoaXMuaXNPcGFxdWVQYXNzID0gZmFsc2U7XG4gICAgICAgICAgICBjb29yZHMucmV2ZXJzZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBncm91cC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIGxheWVyID0gZ3JvdXBbaXNPcGFxdWVQYXNzID8gZ3JvdXAubGVuZ3RoIC0gMSAtIGogOiBqXTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudExheWVyICs9IGlzT3BhcXVlUGFzcyA/IC0xIDogMTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyTGF5ZXIodGhpcywgc291cmNlLCBsYXllciwgY29vcmRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRyYXcuZGVidWcodGhpcywgY29vcmRzKTtcbiAgICB9XG59O1xuXG5QYWludGVyLnByb3RvdHlwZS5kZXB0aE1hc2sgPSBmdW5jdGlvbihtYXNrKSB7XG4gICAgaWYgKG1hc2sgIT09IHRoaXMuX2RlcHRoTWFzaykge1xuICAgICAgICB0aGlzLl9kZXB0aE1hc2sgPSBtYXNrO1xuICAgICAgICB0aGlzLmdsLmRlcHRoTWFzayhtYXNrKTtcbiAgICB9XG59O1xuXG5QYWludGVyLnByb3RvdHlwZS5yZW5kZXJMYXllciA9IGZ1bmN0aW9uKHBhaW50ZXIsIHNvdXJjZSwgbGF5ZXIsIGNvb3Jkcykge1xuICAgIGlmIChsYXllci5oaWRkZW4pIHJldHVybjtcbiAgICBpZiAobGF5ZXIudHlwZSAhPT0gJ2JhY2tncm91bmQnICYmICFjb29yZHMubGVuZ3RoKSByZXR1cm47XG4gICAgZHJhd1tsYXllci50eXBlXShwYWludGVyLCBzb3VyY2UsIGxheWVyLCBjb29yZHMpO1xufTtcblxuLy8gRHJhd3Mgbm9uLW9wYXF1ZSBhcmVhcy4gVGhpcyBpcyBmb3IgZGVidWdnaW5nIHB1cnBvc2VzLlxuUGFpbnRlci5wcm90b3R5cGUuZHJhd1N0ZW5jaWxCdWZmZXIgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgIGdsLnN3aXRjaFNoYWRlcih0aGlzLmZpbGxTaGFkZXIsIHRoaXMuaWRlbnRpdHlNYXRyaXgpO1xuXG4gICAgZ2wuc3RlbmNpbE1hc2soMHgwMCk7XG4gICAgZ2wuc3RlbmNpbEZ1bmMoZ2wuRVFVQUwsIDB4ODAsIDB4ODApO1xuXG4gICAgLy8gRHJ3IHRoZSBmaWxsaW5nIHF1YWQgd2hlcmUgdGhlIHN0ZW5jaWwgYnVmZmVyIGlzbid0IHNldC5cbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5iYWNrZ3JvdW5kQnVmZmVyKTtcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMuZmlsbFNoYWRlci5hX3BvcywgdGhpcy5iYWNrZ3JvdW5kQnVmZmVyLml0ZW1TaXplLCBnbC5TSE9SVCwgZmFsc2UsIDAsIDApO1xuXG4gICAgZ2wudW5pZm9ybTRmdih0aGlzLmZpbGxTaGFkZXIudV9jb2xvciwgWzAsIDAsIDAsIDAuNV0pO1xuICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIHRoaXMudGlsZUV4dGVudEJ1ZmZlci5pdGVtQ291bnQpO1xufTtcblxuUGFpbnRlci5wcm90b3R5cGUuc2V0RGVwdGhTdWJsYXllciA9IGZ1bmN0aW9uKG4pIHtcbiAgICB2YXIgZmFyRGVwdGggPSAxIC0gKCgxICsgdGhpcy5jdXJyZW50TGF5ZXIpICogdGhpcy5udW1TdWJsYXllcnMgKyBuKSAqIHRoaXMuZGVwdGhFcHNpbG9uO1xuICAgIHZhciBuZWFyRGVwdGggPSBmYXJEZXB0aCAtIDEgKyB0aGlzLmRlcHRoUmFuZ2U7XG4gICAgdGhpcy5nbC5kZXB0aFJhbmdlKG5lYXJEZXB0aCwgZmFyRGVwdGgpO1xufTtcblxuUGFpbnRlci5wcm90b3R5cGUudHJhbnNsYXRlUG9zTWF0cml4ID0gZnVuY3Rpb24obWF0cml4LCB0aWxlLCB0cmFuc2xhdGUsIGFuY2hvcikge1xuICAgIGlmICghdHJhbnNsYXRlWzBdICYmICF0cmFuc2xhdGVbMV0pIHJldHVybiBtYXRyaXg7XG5cbiAgICBpZiAoYW5jaG9yID09PSAndmlld3BvcnQnKSB7XG4gICAgICAgIHZhciBzaW5BID0gTWF0aC5zaW4oLXRoaXMudHJhbnNmb3JtLmFuZ2xlKTtcbiAgICAgICAgdmFyIGNvc0EgPSBNYXRoLmNvcygtdGhpcy50cmFuc2Zvcm0uYW5nbGUpO1xuICAgICAgICB0cmFuc2xhdGUgPSBbXG4gICAgICAgICAgICB0cmFuc2xhdGVbMF0gKiBjb3NBIC0gdHJhbnNsYXRlWzFdICogc2luQSxcbiAgICAgICAgICAgIHRyYW5zbGF0ZVswXSAqIHNpbkEgKyB0cmFuc2xhdGVbMV0gKiBjb3NBXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgdmFyIHRpbGVQaXhlbFJhdGlvID0gdGhpcy50cmFuc2Zvcm0uc2NhbGUgLyAoMSA8PCB0aWxlLmNvb3JkLnopIC8gKHRpbGUudGlsZUV4dGVudCAvIHRpbGUudGlsZVNpemUpO1xuICAgIHZhciB0cmFuc2xhdGlvbiA9IFtcbiAgICAgICAgdHJhbnNsYXRlWzBdIC8gdGlsZVBpeGVsUmF0aW8sXG4gICAgICAgIHRyYW5zbGF0ZVsxXSAvIHRpbGVQaXhlbFJhdGlvLFxuICAgICAgICAwXG4gICAgXTtcblxuICAgIHZhciB0cmFuc2xhdGVkTWF0cml4ID0gbmV3IEZsb2F0MzJBcnJheSgxNik7XG4gICAgbWF0NC50cmFuc2xhdGUodHJhbnNsYXRlZE1hdHJpeCwgbWF0cml4LCB0cmFuc2xhdGlvbik7XG4gICAgcmV0dXJuIHRyYW5zbGF0ZWRNYXRyaXg7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgcG9zTWF0cml4IHRoYXQgdGhpcyB0aWxlIHVzZXMgdG8gZGlzcGxheSBpdHNlbGYgaW4gYSBtYXAsXG4gKiBnaXZlbiBhIGNvb3JkaW5hdGUgYXMgKHosIHgsIHkpIGFuZCBhIHRyYW5zZm9ybVxuICogQHBhcmFtIHtPYmplY3R9IHRyYW5zZm9ybVxuICogQHByaXZhdGVcbiAqL1xuUGFpbnRlci5wcm90b3R5cGUuY2FsY3VsYXRlUG9zTWF0cml4ID0gZnVuY3Rpb24oY29vcmQsIG1heFpvb20pIHtcbiAgICB2YXIgdGlsZUV4dGVudCA9IDQwOTY7XG4gICAgaWYgKGNvb3JkIGluc3RhbmNlb2YgVGlsZUNvb3JkKSB7XG4gICAgICAgIGNvb3JkID0gY29vcmQudG9Db29yZGluYXRlKCk7XG4gICAgfVxuICAgIHZhciB0cmFuc2Zvcm0gPSB0aGlzLnRyYW5zZm9ybTtcblxuICAgIGlmIChtYXhab29tID09PSB1bmRlZmluZWQpIG1heFpvb20gPSBJbmZpbml0eTtcblxuICAgIC8vIEluaXRpYWxpemUgbW9kZWwtdmlldyBtYXRyaXggdGhhdCBjb252ZXJ0cyBmcm9tIHRoZSB0aWxlIGNvb3JkaW5hdGVzXG4gICAgLy8gdG8gc2NyZWVuIGNvb3JkaW5hdGVzLlxuXG4gICAgLy8gaWYgeiA+IG1heHpvb20gdGhlbiB0aGUgdGlsZSBpcyBhY3R1YWxseSBhIG92ZXJzY2FsZWQgbWF4em9vbSB0aWxlLFxuICAgIC8vIHNvIGNhbGN1bGF0ZSB0aGUgbWF0cml4IHRoZSBtYXh6b29tIHRpbGUgd291bGQgdXNlLlxuICAgIHZhciB6ID0gTWF0aC5taW4oY29vcmQuem9vbSwgbWF4Wm9vbSk7XG4gICAgdmFyIHggPSBjb29yZC5jb2x1bW47XG4gICAgdmFyIHkgPSBjb29yZC5yb3c7XG5cbiAgICB2YXIgc2NhbGUgPSB0cmFuc2Zvcm0ud29ybGRTaXplIC8gTWF0aC5wb3coMiwgeik7XG5cbiAgICAvLyBUaGUgcG9zaXRpb24gbWF0cml4XG4gICAgdmFyIHBvc01hdHJpeCA9IG5ldyBGbG9hdDY0QXJyYXkoMTYpO1xuXG4gICAgbWF0NC5pZGVudGl0eShwb3NNYXRyaXgpO1xuICAgIG1hdDQudHJhbnNsYXRlKHBvc01hdHJpeCwgcG9zTWF0cml4LCBbeCAqIHNjYWxlLCB5ICogc2NhbGUsIDBdKTtcbiAgICBtYXQ0LnNjYWxlKHBvc01hdHJpeCwgcG9zTWF0cml4LCBbIHNjYWxlIC8gdGlsZUV4dGVudCwgc2NhbGUgLyB0aWxlRXh0ZW50LCAxIF0pO1xuICAgIG1hdDQubXVsdGlwbHkocG9zTWF0cml4LCB0cmFuc2Zvcm0ucHJvak1hdHJpeCwgcG9zTWF0cml4KTtcblxuICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KHBvc01hdHJpeCk7XG59O1xuXG5QYWludGVyLnByb3RvdHlwZS5zYXZlVGV4dHVyZSA9IGZ1bmN0aW9uKHRleHR1cmUpIHtcbiAgICB2YXIgdGV4dHVyZXMgPSB0aGlzLnJldXNhYmxlVGV4dHVyZXNbdGV4dHVyZS5zaXplXTtcbiAgICBpZiAoIXRleHR1cmVzKSB7XG4gICAgICAgIHRoaXMucmV1c2FibGVUZXh0dXJlc1t0ZXh0dXJlLnNpemVdID0gW3RleHR1cmVdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRleHR1cmVzLnB1c2godGV4dHVyZSk7XG4gICAgfVxufTtcblxuXG5QYWludGVyLnByb3RvdHlwZS5nZXRUZXh0dXJlID0gZnVuY3Rpb24oc2l6ZSkge1xuICAgIHZhciB0ZXh0dXJlcyA9IHRoaXMucmV1c2FibGVUZXh0dXJlc1tzaXplXTtcbiAgICByZXR1cm4gdGV4dHVyZXMgJiYgdGV4dHVyZXMubGVuZ3RoID4gMCA/IHRleHR1cmVzLnBvcCgpIDogbnVsbDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cblxudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5cbi8vIE11c3QgYmUgd3JpdHRlbiBvdXQgbG9uZy1mb3JtIGZvciBicmZzLlxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZGVidWc6IHtcbiAgICAgICAgZnJhZ21lbnQ6IFwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuXFxudW5pZm9ybSB2ZWM0IHVfY29sb3I7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgICBnbF9GcmFnQ29sb3IgPSB1X2NvbG9yO1xcbn1cXG5cIixcbiAgICAgICAgdmVydGV4OiBcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcblxcbmF0dHJpYnV0ZSB2ZWMyIGFfcG9zO1xcblxcbnVuaWZvcm0gaGlnaHAgbWF0NCB1X21hdHJpeDtcXG5cXG52b2lkIG1haW4oKSB7XFxuICAgIGdsX1Bvc2l0aW9uID0gdV9tYXRyaXggKiB2ZWM0KGFfcG9zLCBzdGVwKDMyNzY3LjAsIGFfcG9zLngpLCAxKTtcXG59XFxuXCJcbiAgICB9LFxuICAgIGRvdDoge1xuICAgICAgICBmcmFnbWVudDogXCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5cXG51bmlmb3JtIHZlYzQgdV9jb2xvcjtcXG51bmlmb3JtIGZsb2F0IHVfYmx1cjtcXG5cXG52b2lkIG1haW4oKSB7XFxuICAgIGZsb2F0IGRpc3QgPSBsZW5ndGgoZ2xfUG9pbnRDb29yZCAtIDAuNSk7XFxuICAgIGZsb2F0IHQgPSBzbW9vdGhzdGVwKDAuNSwgMC41IC0gdV9ibHVyLCBkaXN0KTtcXG5cXG4gICAgZ2xfRnJhZ0NvbG9yID0gdV9jb2xvciAqIHQ7XFxufVxcblwiLFxuICAgICAgICB2ZXJ0ZXg6IFwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuXFxudW5pZm9ybSBoaWdocCBtYXQ0IHVfbWF0cml4O1xcbnVuaWZvcm0gZmxvYXQgdV9zaXplO1xcblxcbmF0dHJpYnV0ZSB2ZWMyIGFfcG9zO1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAgIGdsX1Bvc2l0aW9uID0gdV9tYXRyaXggKiB2ZWM0KGFfcG9zLCAwLCAxKTtcXG4gICAgZ2xfUG9pbnRTaXplID0gdV9zaXplO1xcbn1cXG5cIlxuICAgIH0sXG4gICAgZmlsbDoge1xuICAgICAgICBmcmFnbWVudDogXCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5cXG51bmlmb3JtIHZlYzQgdV9jb2xvcjtcXG5cXG52b2lkIG1haW4oKSB7XFxuICAgIGdsX0ZyYWdDb2xvciA9IHVfY29sb3I7XFxufVxcblwiLFxuICAgICAgICB2ZXJ0ZXg6IFwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuXFxuYXR0cmlidXRlIHZlYzIgYV9wb3M7XFxudW5pZm9ybSBoaWdocCBtYXQ0IHVfbWF0cml4O1xcblxcbnZvaWQgbWFpbigpIHtcXG4gICAgZ2xfUG9zaXRpb24gPSB1X21hdHJpeCAqIHZlYzQoYV9wb3MsIDAsIDEpO1xcbn1cXG5cIlxuICAgIH0sXG4gICAgY2lyY2xlOiB7XG4gICAgICAgIGZyYWdtZW50OiBcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcblxcbnVuaWZvcm0gdmVjNCB1X2NvbG9yO1xcbnVuaWZvcm0gZmxvYXQgdV9ibHVyO1xcbnVuaWZvcm0gZmxvYXQgdV9zaXplO1xcblxcbnZhcnlpbmcgdmVjMiB2X2V4dHJ1ZGU7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgICBmbG9hdCB0ID0gc21vb3Roc3RlcCgxLjAgLSB1X2JsdXIsIDEuMCwgbGVuZ3RoKHZfZXh0cnVkZSkpO1xcbiAgICBnbF9GcmFnQ29sb3IgPSB1X2NvbG9yICogKDEuMCAtIHQpO1xcbn1cXG5cIixcbiAgICAgICAgdmVydGV4OiBcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcblxcbi8vIHNldCBieSBnbF91dGlsXFxudW5pZm9ybSBmbG9hdCB1X3NpemU7XFxuXFxuYXR0cmlidXRlIHZlYzIgYV9wb3M7XFxuXFxudW5pZm9ybSBoaWdocCBtYXQ0IHVfbWF0cml4O1xcbnVuaWZvcm0gbWF0NCB1X2V4bWF0cml4O1xcblxcbnZhcnlpbmcgdmVjMiB2X2V4dHJ1ZGU7XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gICAgLy8gdW5lbmNvZGUgdGhlIGV4dHJ1c2lvbiB2ZWN0b3IgdGhhdCB3ZSBzbnVjayBpbnRvIHRoZSBhX3BvcyB2ZWN0b3JcXG4gICAgdl9leHRydWRlID0gdmVjMihtb2QoYV9wb3MsIDIuMCkgKiAyLjAgLSAxLjApO1xcblxcbiAgICB2ZWM0IGV4dHJ1ZGUgPSB1X2V4bWF0cml4ICogdmVjNCh2X2V4dHJ1ZGUgKiB1X3NpemUsIDAsIDApO1xcbiAgICAvLyBtdWx0aXBseSBhX3BvcyBieSAwLjUsIHNpbmNlIHdlIGhhZCBpdCAqIDIgaW4gb3JkZXIgdG8gc25lYWtcXG4gICAgLy8gaW4gZXh0cnVzaW9uIGRhdGFcXG4gICAgZ2xfUG9zaXRpb24gPSB1X21hdHJpeCAqIHZlYzQoZmxvb3IoYV9wb3MgKiAwLjUpLCAwLCAxKTtcXG5cXG4gICAgLy8gZ2xfUG9zaXRpb24gaXMgZGl2aWRlZCBieSBnbF9Qb3NpdGlvbi53IGFmdGVyIHRoaXMgc2hhZGVyIHJ1bnMuXFxuICAgIC8vIE11bHRpcGx5IHRoZSBleHRydWRlIGJ5IGl0IHNvIHRoYXQgaXQgaXNuJ3QgYWZmZWN0ZWQgYnkgaXQuXFxuICAgIGdsX1Bvc2l0aW9uICs9IGV4dHJ1ZGUgKiBnbF9Qb3NpdGlvbi53O1xcbn1cXG5cIlxuICAgIH0sXG4gICAgbGluZToge1xuICAgICAgICBmcmFnbWVudDogXCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5cXG51bmlmb3JtIHZlYzIgdV9saW5ld2lkdGg7XFxudW5pZm9ybSB2ZWM0IHVfY29sb3I7XFxudW5pZm9ybSBmbG9hdCB1X2JsdXI7XFxuXFxudmFyeWluZyB2ZWMyIHZfbm9ybWFsO1xcbnZhcnlpbmcgZmxvYXQgdl9saW5lc29mYXI7XFxudmFyeWluZyBmbG9hdCB2X2dhbW1hX3NjYWxlO1xcblxcbnZvaWQgbWFpbigpIHtcXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBvZiB0aGUgcGl4ZWwgZnJvbSB0aGUgbGluZSBpbiBwaXhlbHMuXFxuICAgIGZsb2F0IGRpc3QgPSBsZW5ndGgodl9ub3JtYWwpICogdV9saW5ld2lkdGgucztcXG5cXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBhbnRpYWxpYXNpbmcgZmFkZSBmYWN0b3IuIFRoaXMgaXMgZWl0aGVyIHdoZW4gZmFkaW5nIGluXFxuICAgIC8vIHRoZSBsaW5lIGluIGNhc2Ugb2YgYW4gb2Zmc2V0IGxpbmUgKHZfbGluZXdpZHRoLnQpIG9yIHdoZW4gZmFkaW5nIG91dFxcbiAgICAvLyAodl9saW5ld2lkdGgucylcXG4gICAgZmxvYXQgYmx1ciA9IHVfYmx1ciAqIHZfZ2FtbWFfc2NhbGU7XFxuICAgIGZsb2F0IGFscGhhID0gY2xhbXAobWluKGRpc3QgLSAodV9saW5ld2lkdGgudCAtIGJsdXIpLCB1X2xpbmV3aWR0aC5zIC0gZGlzdCkgLyBibHVyLCAwLjAsIDEuMCk7XFxuXFxuICAgIGdsX0ZyYWdDb2xvciA9IHVfY29sb3IgKiBhbHBoYTtcXG59XFxuXCIsXG4gICAgICAgIHZlcnRleDogXCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5cXG4vLyBmbG9vcigxMjcgLyAyKSA9PSA2My4wXFxuLy8gdGhlIG1heGltdW0gYWxsb3dlZCBtaXRlciBsaW1pdCBpcyAyLjAgYXQgdGhlIG1vbWVudC4gdGhlIGV4dHJ1ZGUgbm9ybWFsIGlzXFxuLy8gc3RvcmVkIGluIGEgYnl0ZSAoLTEyOC4uMTI3KS4gd2Ugc2NhbGUgcmVndWxhciBub3JtYWxzIHVwIHRvIGxlbmd0aCA2MywgYnV0XFxuLy8gdGhlcmUgYXJlIGFsc28gXFxcInNwZWNpYWxcXFwiIG5vcm1hbHMgdGhhdCBoYXZlIGEgYmlnZ2VyIGxlbmd0aCAob2YgdXAgdG8gMTI2IGluXFxuLy8gdGhpcyBjYXNlKS5cXG4vLyAjZGVmaW5lIHNjYWxlIDYzLjBcXG4jZGVmaW5lIHNjYWxlIDAuMDE1ODczMDE2XFxuXFxuYXR0cmlidXRlIHZlYzIgYV9wb3M7XFxuYXR0cmlidXRlIHZlYzQgYV9kYXRhO1xcblxcbnVuaWZvcm0gaGlnaHAgbWF0NCB1X21hdHJpeDtcXG51bmlmb3JtIGZsb2F0IHVfcmF0aW87XFxudW5pZm9ybSB2ZWMyIHVfbGluZXdpZHRoO1xcbnVuaWZvcm0gZmxvYXQgdV9leHRyYTtcXG51bmlmb3JtIG1hdDIgdV9hbnRpYWxpYXNpbmdtYXRyaXg7XFxudW5pZm9ybSBmbG9hdCB1X29mZnNldDtcXG5cXG52YXJ5aW5nIHZlYzIgdl9ub3JtYWw7XFxudmFyeWluZyBmbG9hdCB2X2xpbmVzb2ZhcjtcXG52YXJ5aW5nIGZsb2F0IHZfZ2FtbWFfc2NhbGU7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgICB2ZWMyIGFfZXh0cnVkZSA9IGFfZGF0YS54eTtcXG4gICAgZmxvYXQgYV9kaXJlY3Rpb24gPSBzaWduKGFfZGF0YS56KSAqIG1vZChhX2RhdGEueiwgMi4wKTtcXG5cXG4gICAgLy8gV2Ugc3RvcmUgdGhlIHRleHR1cmUgbm9ybWFscyBpbiB0aGUgbW9zdCBpbnNpZ25pZmljYW50IGJpdFxcbiAgICAvLyB0cmFuc2Zvcm0geSBzbyB0aGF0IDAgPT4gLTEgYW5kIDEgPT4gMVxcbiAgICAvLyBJbiB0aGUgdGV4dHVyZSBub3JtYWwsIHggaXMgMCBpZiB0aGUgbm9ybWFsIHBvaW50cyBzdHJhaWdodCB1cC9kb3duIGFuZCAxIGlmIGl0J3MgYSByb3VuZCBjYXBcXG4gICAgLy8geSBpcyAxIGlmIHRoZSBub3JtYWwgcG9pbnRzIHVwLCBhbmQgLTEgaWYgaXQgcG9pbnRzIGRvd25cXG4gICAgdmVjMiBub3JtYWwgPSBtb2QoYV9wb3MsIDIuMCk7XFxuICAgIG5vcm1hbC55ID0gc2lnbihub3JtYWwueSAtIDAuNSk7XFxuICAgIHZfbm9ybWFsID0gbm9ybWFsO1xcblxcbiAgICAvLyBTY2FsZSB0aGUgZXh0cnVzaW9uIHZlY3RvciBkb3duIHRvIGEgbm9ybWFsIGFuZCB0aGVuIHVwIGJ5IHRoZSBsaW5lIHdpZHRoXFxuICAgIC8vIG9mIHRoaXMgdmVydGV4LlxcbiAgICB2ZWM0IGRpc3QgPSB2ZWM0KHVfbGluZXdpZHRoLnMgKiBhX2V4dHJ1ZGUgKiBzY2FsZSwgMC4wLCAwLjApO1xcblxcbiAgICAvLyBDYWxjdWxhdGUgdGhlIG9mZnNldCB3aGVuIGRyYXdpbmcgYSBsaW5lIHRoYXQgaXMgdG8gdGhlIHNpZGUgb2YgdGhlIGFjdHVhbCBsaW5lLlxcbiAgICAvLyBXZSBkbyB0aGlzIGJ5IGNyZWF0aW5nIGEgdmVjdG9yIHRoYXQgcG9pbnRzIHRvd2FyZHMgdGhlIGV4dHJ1ZGUsIGJ1dCByb3RhdGVcXG4gICAgLy8gaXQgd2hlbiB3ZSdyZSBkcmF3aW5nIHJvdW5kIGVuZCBwb2ludHMgKGFfZGlyZWN0aW9uID0gLTEgb3IgMSkgc2luY2UgdGhlaXJcXG4gICAgLy8gZXh0cnVkZSB2ZWN0b3IgcG9pbnRzIGluIGFub3RoZXIgZGlyZWN0aW9uLlxcbiAgICBmbG9hdCB1ID0gMC41ICogYV9kaXJlY3Rpb247XFxuICAgIGZsb2F0IHQgPSAxLjAgLSBhYnModSk7XFxuICAgIHZlYzIgb2Zmc2V0ID0gdV9vZmZzZXQgKiBhX2V4dHJ1ZGUgKiBzY2FsZSAqIG5vcm1hbC55ICogbWF0Mih0LCAtdSwgdSwgdCk7XFxuXFxuICAgIC8vIFJlbW92ZSB0aGUgdGV4dHVyZSBub3JtYWwgYml0IG9mIHRoZSBwb3NpdGlvbiBiZWZvcmUgc2NhbGluZyBpdCB3aXRoIHRoZVxcbiAgICAvLyBtb2RlbC92aWV3IG1hdHJpeC5cXG4gICAgZ2xfUG9zaXRpb24gPSB1X21hdHJpeCAqIHZlYzQoZmxvb3IoYV9wb3MgKiAwLjUpICsgKG9mZnNldCArIGRpc3QueHkpIC8gdV9yYXRpbywgMC4wLCAxLjApO1xcblxcbiAgICAvLyBwb3NpdGlvbiBvZiB5IG9uIHRoZSBzY3JlZW5cXG4gICAgZmxvYXQgeSA9IGdsX1Bvc2l0aW9uLnkgLyBnbF9Qb3NpdGlvbi53O1xcblxcbiAgICAvLyBob3cgbXVjaCBmZWF0dXJlcyBhcmUgc3F1aXNoZWQgaW4gdGhlIHkgZGlyZWN0aW9uIGJ5IHRoZSB0aWx0XFxuICAgIGZsb2F0IHNxdWlzaF9zY2FsZSA9IGxlbmd0aChhX2V4dHJ1ZGUpIC8gbGVuZ3RoKHVfYW50aWFsaWFzaW5nbWF0cml4ICogYV9leHRydWRlKTtcXG5cXG4gICAgLy8gaG93IG11Y2ggZmVhdHVyZXMgYXJlIHNxdWlzaGVkIGluIGFsbCBkaXJlY3Rpb25zIGJ5IHRoZSBwZXJzcGVjdGl2ZW5lc3NcXG4gICAgZmxvYXQgcGVyc3BlY3RpdmVfc2NhbGUgPSAxLjAgLyAoMS4wIC0gbWluKHkgKiB1X2V4dHJhLCAwLjkpKTtcXG5cXG4gICAgdl9nYW1tYV9zY2FsZSA9IHBlcnNwZWN0aXZlX3NjYWxlICogc3F1aXNoX3NjYWxlO1xcbn1cXG5cIlxuICAgIH0sXG4gICAgbGluZXBhdHRlcm46IHtcbiAgICAgICAgZnJhZ21lbnQ6IFwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuXFxudW5pZm9ybSB2ZWMyIHVfbGluZXdpZHRoO1xcbnVuaWZvcm0gZmxvYXQgdV9wb2ludDtcXG51bmlmb3JtIGZsb2F0IHVfYmx1cjtcXG5cXG51bmlmb3JtIHZlYzIgdV9wYXR0ZXJuX3NpemVfYTtcXG51bmlmb3JtIHZlYzIgdV9wYXR0ZXJuX3NpemVfYjtcXG51bmlmb3JtIHZlYzIgdV9wYXR0ZXJuX3RsX2E7XFxudW5pZm9ybSB2ZWMyIHVfcGF0dGVybl9icl9hO1xcbnVuaWZvcm0gdmVjMiB1X3BhdHRlcm5fdGxfYjtcXG51bmlmb3JtIHZlYzIgdV9wYXR0ZXJuX2JyX2I7XFxudW5pZm9ybSBmbG9hdCB1X2ZhZGU7XFxudW5pZm9ybSBmbG9hdCB1X29wYWNpdHk7XFxuXFxudW5pZm9ybSBzYW1wbGVyMkQgdV9pbWFnZTtcXG5cXG52YXJ5aW5nIHZlYzIgdl9ub3JtYWw7XFxudmFyeWluZyBmbG9hdCB2X2xpbmVzb2ZhcjtcXG52YXJ5aW5nIGZsb2F0IHZfZ2FtbWFfc2NhbGU7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgICAvLyBDYWxjdWxhdGUgdGhlIGRpc3RhbmNlIG9mIHRoZSBwaXhlbCBmcm9tIHRoZSBsaW5lIGluIHBpeGVscy5cXG4gICAgZmxvYXQgZGlzdCA9IGxlbmd0aCh2X25vcm1hbCkgKiB1X2xpbmV3aWR0aC5zO1xcblxcbiAgICAvLyBDYWxjdWxhdGUgdGhlIGFudGlhbGlhc2luZyBmYWRlIGZhY3Rvci4gVGhpcyBpcyBlaXRoZXIgd2hlbiBmYWRpbmcgaW5cXG4gICAgLy8gdGhlIGxpbmUgaW4gY2FzZSBvZiBhbiBvZmZzZXQgbGluZSAodl9saW5ld2lkdGgudCkgb3Igd2hlbiBmYWRpbmcgb3V0XFxuICAgIC8vICh2X2xpbmV3aWR0aC5zKVxcbiAgICBmbG9hdCBibHVyID0gdV9ibHVyICogdl9nYW1tYV9zY2FsZTtcXG4gICAgZmxvYXQgYWxwaGEgPSBjbGFtcChtaW4oZGlzdCAtICh1X2xpbmV3aWR0aC50IC0gYmx1ciksIHVfbGluZXdpZHRoLnMgLSBkaXN0KSAvIGJsdXIsIDAuMCwgMS4wKTtcXG5cXG4gICAgZmxvYXQgeF9hID0gbW9kKHZfbGluZXNvZmFyIC8gdV9wYXR0ZXJuX3NpemVfYS54LCAxLjApO1xcbiAgICBmbG9hdCB4X2IgPSBtb2Qodl9saW5lc29mYXIgLyB1X3BhdHRlcm5fc2l6ZV9iLngsIDEuMCk7XFxuICAgIGZsb2F0IHlfYSA9IDAuNSArICh2X25vcm1hbC55ICogdV9saW5ld2lkdGgucyAvIHVfcGF0dGVybl9zaXplX2EueSk7XFxuICAgIGZsb2F0IHlfYiA9IDAuNSArICh2X25vcm1hbC55ICogdV9saW5ld2lkdGgucyAvIHVfcGF0dGVybl9zaXplX2IueSk7XFxuICAgIHZlYzIgcG9zID0gbWl4KHVfcGF0dGVybl90bF9hLCB1X3BhdHRlcm5fYnJfYSwgdmVjMih4X2EsIHlfYSkpO1xcbiAgICB2ZWMyIHBvczIgPSBtaXgodV9wYXR0ZXJuX3RsX2IsIHVfcGF0dGVybl9icl9iLCB2ZWMyKHhfYiwgeV9iKSk7XFxuXFxuICAgIHZlYzQgY29sb3IgPSBtaXgodGV4dHVyZTJEKHVfaW1hZ2UsIHBvcyksIHRleHR1cmUyRCh1X2ltYWdlLCBwb3MyKSwgdV9mYWRlKTtcXG5cXG4gICAgYWxwaGEgKj0gdV9vcGFjaXR5O1xcblxcbiAgICBnbF9GcmFnQ29sb3IgPSBjb2xvciAqIGFscGhhO1xcbn1cXG5cIixcbiAgICAgICAgdmVydGV4OiBcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcblxcbi8vIGZsb29yKDEyNyAvIDIpID09IDYzLjBcXG4vLyB0aGUgbWF4aW11bSBhbGxvd2VkIG1pdGVyIGxpbWl0IGlzIDIuMCBhdCB0aGUgbW9tZW50LiB0aGUgZXh0cnVkZSBub3JtYWwgaXNcXG4vLyBzdG9yZWQgaW4gYSBieXRlICgtMTI4Li4xMjcpLiB3ZSBzY2FsZSByZWd1bGFyIG5vcm1hbHMgdXAgdG8gbGVuZ3RoIDYzLCBidXRcXG4vLyB0aGVyZSBhcmUgYWxzbyBcXFwic3BlY2lhbFxcXCIgbm9ybWFscyB0aGF0IGhhdmUgYSBiaWdnZXIgbGVuZ3RoIChvZiB1cCB0byAxMjYgaW5cXG4vLyB0aGlzIGNhc2UpLlxcbi8vICNkZWZpbmUgc2NhbGUgNjMuMFxcbiNkZWZpbmUgc2NhbGUgMC4wMTU4NzMwMTZcXG5cXG5hdHRyaWJ1dGUgdmVjMiBhX3BvcztcXG5hdHRyaWJ1dGUgdmVjNCBhX2RhdGE7XFxuXFxudW5pZm9ybSBoaWdocCBtYXQ0IHVfbWF0cml4O1xcbnVuaWZvcm0gZmxvYXQgdV9yYXRpbztcXG51bmlmb3JtIHZlYzIgdV9saW5ld2lkdGg7XFxudW5pZm9ybSB2ZWM0IHVfY29sb3I7XFxudW5pZm9ybSBmbG9hdCB1X2V4dHJhO1xcbnVuaWZvcm0gbWF0MiB1X2FudGlhbGlhc2luZ21hdHJpeDtcXG51bmlmb3JtIGZsb2F0IHVfb2Zmc2V0O1xcblxcbnZhcnlpbmcgdmVjMiB2X25vcm1hbDtcXG52YXJ5aW5nIGZsb2F0IHZfbGluZXNvZmFyO1xcbnZhcnlpbmcgZmxvYXQgdl9nYW1tYV9zY2FsZTtcXG5cXG52b2lkIG1haW4oKSB7XFxuICAgIHZlYzIgYV9leHRydWRlID0gYV9kYXRhLnh5O1xcbiAgICBmbG9hdCBhX2RpcmVjdGlvbiA9IHNpZ24oYV9kYXRhLnopICogbW9kKGFfZGF0YS56LCAyLjApO1xcbiAgICBmbG9hdCBhX2xpbmVzb2ZhciA9IGFicyhmbG9vcihhX2RhdGEueiAvIDIuMCkpICsgYV9kYXRhLncgKiA2NC4wO1xcblxcbiAgICAvLyBXZSBzdG9yZSB0aGUgdGV4dHVyZSBub3JtYWxzIGluIHRoZSBtb3N0IGluc2lnbmlmaWNhbnQgYml0XFxuICAgIC8vIHRyYW5zZm9ybSB5IHNvIHRoYXQgMCA9PiAtMSBhbmQgMSA9PiAxXFxuICAgIC8vIEluIHRoZSB0ZXh0dXJlIG5vcm1hbCwgeCBpcyAwIGlmIHRoZSBub3JtYWwgcG9pbnRzIHN0cmFpZ2h0IHVwL2Rvd24gYW5kIDEgaWYgaXQncyBhIHJvdW5kIGNhcFxcbiAgICAvLyB5IGlzIDEgaWYgdGhlIG5vcm1hbCBwb2ludHMgdXAsIGFuZCAtMSBpZiBpdCBwb2ludHMgZG93blxcbiAgICB2ZWMyIG5vcm1hbCA9IG1vZChhX3BvcywgMi4wKTtcXG4gICAgbm9ybWFsLnkgPSBzaWduKG5vcm1hbC55IC0gMC41KTtcXG4gICAgdl9ub3JtYWwgPSBub3JtYWw7XFxuXFxuICAgIC8vIFNjYWxlIHRoZSBleHRydXNpb24gdmVjdG9yIGRvd24gdG8gYSBub3JtYWwgYW5kIHRoZW4gdXAgYnkgdGhlIGxpbmUgd2lkdGhcXG4gICAgLy8gb2YgdGhpcyB2ZXJ0ZXguXFxuICAgIHZlYzIgZXh0cnVkZSA9IGFfZXh0cnVkZSAqIHNjYWxlO1xcbiAgICB2ZWMyIGRpc3QgPSB1X2xpbmV3aWR0aC5zICogZXh0cnVkZTtcXG5cXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBvZmZzZXQgd2hlbiBkcmF3aW5nIGEgbGluZSB0aGF0IGlzIHRvIHRoZSBzaWRlIG9mIHRoZSBhY3R1YWwgbGluZS5cXG4gICAgLy8gV2UgZG8gdGhpcyBieSBjcmVhdGluZyBhIHZlY3RvciB0aGF0IHBvaW50cyB0b3dhcmRzIHRoZSBleHRydWRlLCBidXQgcm90YXRlXFxuICAgIC8vIGl0IHdoZW4gd2UncmUgZHJhd2luZyByb3VuZCBlbmQgcG9pbnRzIChhX2RpcmVjdGlvbiA9IC0xIG9yIDEpIHNpbmNlIHRoZWlyXFxuICAgIC8vIGV4dHJ1ZGUgdmVjdG9yIHBvaW50cyBpbiBhbm90aGVyIGRpcmVjdGlvbi5cXG4gICAgZmxvYXQgdSA9IDAuNSAqIGFfZGlyZWN0aW9uO1xcbiAgICBmbG9hdCB0ID0gMS4wIC0gYWJzKHUpO1xcbiAgICB2ZWMyIG9mZnNldCA9IHVfb2Zmc2V0ICogYV9leHRydWRlICogc2NhbGUgKiBub3JtYWwueSAqIG1hdDIodCwgLXUsIHUsIHQpO1xcblxcbiAgICAvLyBSZW1vdmUgdGhlIHRleHR1cmUgbm9ybWFsIGJpdCBvZiB0aGUgcG9zaXRpb24gYmVmb3JlIHNjYWxpbmcgaXQgd2l0aCB0aGVcXG4gICAgLy8gbW9kZWwvdmlldyBtYXRyaXguXFxuICAgIGdsX1Bvc2l0aW9uID0gdV9tYXRyaXggKiB2ZWM0KGZsb29yKGFfcG9zICogMC41KSArIChvZmZzZXQgKyBkaXN0Lnh5KSAvIHVfcmF0aW8sIDAuMCwgMS4wKTtcXG4gICAgdl9saW5lc29mYXIgPSBhX2xpbmVzb2ZhcjtcXG5cXG4gICAgLy8gcG9zaXRpb24gb2YgeSBvbiB0aGUgc2NyZWVuXFxuICAgIGZsb2F0IHkgPSBnbF9Qb3NpdGlvbi55IC8gZ2xfUG9zaXRpb24udztcXG5cXG4gICAgLy8gaG93IG11Y2ggZmVhdHVyZXMgYXJlIHNxdWlzaGVkIGluIHRoZSB5IGRpcmVjdGlvbiBieSB0aGUgdGlsdFxcbiAgICBmbG9hdCBzcXVpc2hfc2NhbGUgPSBsZW5ndGgoYV9leHRydWRlKSAvIGxlbmd0aCh1X2FudGlhbGlhc2luZ21hdHJpeCAqIGFfZXh0cnVkZSk7XFxuXFxuICAgIC8vIGhvdyBtdWNoIGZlYXR1cmVzIGFyZSBzcXVpc2hlZCBpbiBhbGwgZGlyZWN0aW9ucyBieSB0aGUgcGVyc3BlY3RpdmVuZXNzXFxuICAgIGZsb2F0IHBlcnNwZWN0aXZlX3NjYWxlID0gMS4wIC8gKDEuMCAtIG1pbih5ICogdV9leHRyYSwgMC45KSk7XFxuXFxuICAgIHZfZ2FtbWFfc2NhbGUgPSBwZXJzcGVjdGl2ZV9zY2FsZSAqIHNxdWlzaF9zY2FsZTtcXG59XFxuXCJcbiAgICB9LFxuICAgIGxpbmVzZGZwYXR0ZXJuOiB7XG4gICAgICAgIGZyYWdtZW50OiBcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcblxcbnVuaWZvcm0gdmVjMiB1X2xpbmV3aWR0aDtcXG51bmlmb3JtIHZlYzQgdV9jb2xvcjtcXG51bmlmb3JtIGZsb2F0IHVfYmx1cjtcXG51bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlO1xcbnVuaWZvcm0gZmxvYXQgdV9zZGZnYW1tYTtcXG51bmlmb3JtIGZsb2F0IHVfbWl4O1xcblxcbnZhcnlpbmcgdmVjMiB2X25vcm1hbDtcXG52YXJ5aW5nIHZlYzIgdl90ZXhfYTtcXG52YXJ5aW5nIHZlYzIgdl90ZXhfYjtcXG52YXJ5aW5nIGZsb2F0IHZfZ2FtbWFfc2NhbGU7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgICAvLyBDYWxjdWxhdGUgdGhlIGRpc3RhbmNlIG9mIHRoZSBwaXhlbCBmcm9tIHRoZSBsaW5lIGluIHBpeGVscy5cXG4gICAgZmxvYXQgZGlzdCA9IGxlbmd0aCh2X25vcm1hbCkgKiB1X2xpbmV3aWR0aC5zO1xcblxcbiAgICAvLyBDYWxjdWxhdGUgdGhlIGFudGlhbGlhc2luZyBmYWRlIGZhY3Rvci4gVGhpcyBpcyBlaXRoZXIgd2hlbiBmYWRpbmcgaW5cXG4gICAgLy8gdGhlIGxpbmUgaW4gY2FzZSBvZiBhbiBvZmZzZXQgbGluZSAodl9saW5ld2lkdGgudCkgb3Igd2hlbiBmYWRpbmcgb3V0XFxuICAgIC8vICh2X2xpbmV3aWR0aC5zKVxcbiAgICBmbG9hdCBibHVyID0gdV9ibHVyICogdl9nYW1tYV9zY2FsZTtcXG4gICAgZmxvYXQgYWxwaGEgPSBjbGFtcChtaW4oZGlzdCAtICh1X2xpbmV3aWR0aC50IC0gYmx1ciksIHVfbGluZXdpZHRoLnMgLSBkaXN0KSAvIGJsdXIsIDAuMCwgMS4wKTtcXG5cXG4gICAgZmxvYXQgc2RmZGlzdF9hID0gdGV4dHVyZTJEKHVfaW1hZ2UsIHZfdGV4X2EpLmE7XFxuICAgIGZsb2F0IHNkZmRpc3RfYiA9IHRleHR1cmUyRCh1X2ltYWdlLCB2X3RleF9iKS5hO1xcbiAgICBmbG9hdCBzZGZkaXN0ID0gbWl4KHNkZmRpc3RfYSwgc2RmZGlzdF9iLCB1X21peCk7XFxuICAgIGFscGhhICo9IHNtb290aHN0ZXAoMC41IC0gdV9zZGZnYW1tYSwgMC41ICsgdV9zZGZnYW1tYSwgc2RmZGlzdCk7XFxuXFxuICAgIGdsX0ZyYWdDb2xvciA9IHVfY29sb3IgKiBhbHBoYTtcXG59XFxuXCIsXG4gICAgICAgIHZlcnRleDogXCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5cXG4vLyBmbG9vcigxMjcgLyAyKSA9PSA2My4wXFxuLy8gdGhlIG1heGltdW0gYWxsb3dlZCBtaXRlciBsaW1pdCBpcyAyLjAgYXQgdGhlIG1vbWVudC4gdGhlIGV4dHJ1ZGUgbm9ybWFsIGlzXFxuLy8gc3RvcmVkIGluIGEgYnl0ZSAoLTEyOC4uMTI3KS4gd2Ugc2NhbGUgcmVndWxhciBub3JtYWxzIHVwIHRvIGxlbmd0aCA2MywgYnV0XFxuLy8gdGhlcmUgYXJlIGFsc28gXFxcInNwZWNpYWxcXFwiIG5vcm1hbHMgdGhhdCBoYXZlIGEgYmlnZ2VyIGxlbmd0aCAob2YgdXAgdG8gMTI2IGluXFxuLy8gdGhpcyBjYXNlKS5cXG4vLyAjZGVmaW5lIHNjYWxlIDYzLjBcXG4jZGVmaW5lIHNjYWxlIDAuMDE1ODczMDE2XFxuXFxuYXR0cmlidXRlIHZlYzIgYV9wb3M7XFxuYXR0cmlidXRlIHZlYzQgYV9kYXRhO1xcblxcbnVuaWZvcm0gaGlnaHAgbWF0NCB1X21hdHJpeDtcXG51bmlmb3JtIHZlYzIgdV9saW5ld2lkdGg7XFxudW5pZm9ybSBmbG9hdCB1X3JhdGlvO1xcbnVuaWZvcm0gdmVjMiB1X3BhdHRlcm5zY2FsZV9hO1xcbnVuaWZvcm0gZmxvYXQgdV90ZXhfeV9hO1xcbnVuaWZvcm0gdmVjMiB1X3BhdHRlcm5zY2FsZV9iO1xcbnVuaWZvcm0gZmxvYXQgdV90ZXhfeV9iO1xcbnVuaWZvcm0gZmxvYXQgdV9leHRyYTtcXG51bmlmb3JtIG1hdDIgdV9hbnRpYWxpYXNpbmdtYXRyaXg7XFxudW5pZm9ybSBmbG9hdCB1X29mZnNldDtcXG5cXG52YXJ5aW5nIHZlYzIgdl9ub3JtYWw7XFxudmFyeWluZyB2ZWMyIHZfdGV4X2E7XFxudmFyeWluZyB2ZWMyIHZfdGV4X2I7XFxudmFyeWluZyBmbG9hdCB2X2dhbW1hX3NjYWxlO1xcblxcbnZvaWQgbWFpbigpIHtcXG4gICAgdmVjMiBhX2V4dHJ1ZGUgPSBhX2RhdGEueHk7XFxuICAgIGZsb2F0IGFfZGlyZWN0aW9uID0gc2lnbihhX2RhdGEueikgKiBtb2QoYV9kYXRhLnosIDIuMCk7XFxuICAgIGZsb2F0IGFfbGluZXNvZmFyID0gYWJzKGZsb29yKGFfZGF0YS56IC8gMi4wKSkgKyBhX2RhdGEudyAqIDY0LjA7XFxuXFxuICAgIC8vIFdlIHN0b3JlIHRoZSB0ZXh0dXJlIG5vcm1hbHMgaW4gdGhlIG1vc3QgaW5zaWduaWZpY2FudCBiaXRcXG4gICAgLy8gdHJhbnNmb3JtIHkgc28gdGhhdCAwID0+IC0xIGFuZCAxID0+IDFcXG4gICAgLy8gSW4gdGhlIHRleHR1cmUgbm9ybWFsLCB4IGlzIDAgaWYgdGhlIG5vcm1hbCBwb2ludHMgc3RyYWlnaHQgdXAvZG93biBhbmQgMSBpZiBpdCdzIGEgcm91bmQgY2FwXFxuICAgIC8vIHkgaXMgMSBpZiB0aGUgbm9ybWFsIHBvaW50cyB1cCwgYW5kIC0xIGlmIGl0IHBvaW50cyBkb3duXFxuICAgIHZlYzIgbm9ybWFsID0gbW9kKGFfcG9zLCAyLjApO1xcbiAgICBub3JtYWwueSA9IHNpZ24obm9ybWFsLnkgLSAwLjUpO1xcbiAgICB2X25vcm1hbCA9IG5vcm1hbDtcXG5cXG4gICAgLy8gU2NhbGUgdGhlIGV4dHJ1c2lvbiB2ZWN0b3IgZG93biB0byBhIG5vcm1hbCBhbmQgdGhlbiB1cCBieSB0aGUgbGluZSB3aWR0aFxcbiAgICAvLyBvZiB0aGlzIHZlcnRleC5cXG4gICAgdmVjNCBkaXN0ID0gdmVjNCh1X2xpbmV3aWR0aC5zICogYV9leHRydWRlICogc2NhbGUsIDAuMCwgMC4wKTtcXG5cXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBvZmZzZXQgd2hlbiBkcmF3aW5nIGEgbGluZSB0aGF0IGlzIHRvIHRoZSBzaWRlIG9mIHRoZSBhY3R1YWwgbGluZS5cXG4gICAgLy8gV2UgZG8gdGhpcyBieSBjcmVhdGluZyBhIHZlY3RvciB0aGF0IHBvaW50cyB0b3dhcmRzIHRoZSBleHRydWRlLCBidXQgcm90YXRlXFxuICAgIC8vIGl0IHdoZW4gd2UncmUgZHJhd2luZyByb3VuZCBlbmQgcG9pbnRzIChhX2RpcmVjdGlvbiA9IC0xIG9yIDEpIHNpbmNlIHRoZWlyXFxuICAgIC8vIGV4dHJ1ZGUgdmVjdG9yIHBvaW50cyBpbiBhbm90aGVyIGRpcmVjdGlvbi5cXG4gICAgZmxvYXQgdSA9IDAuNSAqIGFfZGlyZWN0aW9uO1xcbiAgICBmbG9hdCB0ID0gMS4wIC0gYWJzKHUpO1xcbiAgICB2ZWMyIG9mZnNldCA9IHVfb2Zmc2V0ICogYV9leHRydWRlICogc2NhbGUgKiBub3JtYWwueSAqIG1hdDIodCwgLXUsIHUsIHQpO1xcblxcbiAgICAvLyBSZW1vdmUgdGhlIHRleHR1cmUgbm9ybWFsIGJpdCBvZiB0aGUgcG9zaXRpb24gYmVmb3JlIHNjYWxpbmcgaXQgd2l0aCB0aGVcXG4gICAgLy8gbW9kZWwvdmlldyBtYXRyaXguXFxuICAgIGdsX1Bvc2l0aW9uID0gdV9tYXRyaXggKiB2ZWM0KGZsb29yKGFfcG9zICogMC41KSArIChvZmZzZXQgKyBkaXN0Lnh5KSAvIHVfcmF0aW8sIDAuMCwgMS4wKTtcXG5cXG4gICAgdl90ZXhfYSA9IHZlYzIoYV9saW5lc29mYXIgKiB1X3BhdHRlcm5zY2FsZV9hLngsIG5vcm1hbC55ICogdV9wYXR0ZXJuc2NhbGVfYS55ICsgdV90ZXhfeV9hKTtcXG4gICAgdl90ZXhfYiA9IHZlYzIoYV9saW5lc29mYXIgKiB1X3BhdHRlcm5zY2FsZV9iLngsIG5vcm1hbC55ICogdV9wYXR0ZXJuc2NhbGVfYi55ICsgdV90ZXhfeV9iKTtcXG5cXG4gICAgLy8gcG9zaXRpb24gb2YgeSBvbiB0aGUgc2NyZWVuXFxuICAgIGZsb2F0IHkgPSBnbF9Qb3NpdGlvbi55IC8gZ2xfUG9zaXRpb24udztcXG5cXG4gICAgLy8gaG93IG11Y2ggZmVhdHVyZXMgYXJlIHNxdWlzaGVkIGluIHRoZSB5IGRpcmVjdGlvbiBieSB0aGUgdGlsdFxcbiAgICBmbG9hdCBzcXVpc2hfc2NhbGUgPSBsZW5ndGgoYV9leHRydWRlKSAvIGxlbmd0aCh1X2FudGlhbGlhc2luZ21hdHJpeCAqIGFfZXh0cnVkZSk7XFxuXFxuICAgIC8vIGhvdyBtdWNoIGZlYXR1cmVzIGFyZSBzcXVpc2hlZCBpbiBhbGwgZGlyZWN0aW9ucyBieSB0aGUgcGVyc3BlY3RpdmVuZXNzXFxuICAgIGZsb2F0IHBlcnNwZWN0aXZlX3NjYWxlID0gMS4wIC8gKDEuMCAtIG1pbih5ICogdV9leHRyYSwgMC45KSk7XFxuXFxuICAgIHZfZ2FtbWFfc2NhbGUgPSBwZXJzcGVjdGl2ZV9zY2FsZSAqIHNxdWlzaF9zY2FsZTtcXG59XFxuXCJcbiAgICB9LFxuICAgIG91dGxpbmU6IHtcbiAgICAgICAgZnJhZ21lbnQ6IFwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuXFxudW5pZm9ybSB2ZWM0IHVfY29sb3I7XFxuXFxudmFyeWluZyB2ZWMyIHZfcG9zO1xcblxcbnZvaWQgbWFpbigpIHtcXG4gICAgZmxvYXQgZGlzdCA9IGxlbmd0aCh2X3BvcyAtIGdsX0ZyYWdDb29yZC54eSk7XFxuICAgIGZsb2F0IGFscGhhID0gc21vb3Roc3RlcCgxLjAsIDAuMCwgZGlzdCk7XFxuICAgIGdsX0ZyYWdDb2xvciA9IHVfY29sb3IgKiBhbHBoYTtcXG59XFxuXCIsXG4gICAgICAgIHZlcnRleDogXCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5cXG5hdHRyaWJ1dGUgdmVjMiBhX3BvcztcXG5cXG51bmlmb3JtIGhpZ2hwIG1hdDQgdV9tYXRyaXg7XFxudW5pZm9ybSB2ZWMyIHVfd29ybGQ7XFxuXFxudmFyeWluZyB2ZWMyIHZfcG9zO1xcblxcbnZvaWQgbWFpbigpIHtcXG4gICAgZ2xfUG9zaXRpb24gPSB1X21hdHJpeCAqIHZlYzQoYV9wb3MsIDAsIDEpO1xcbiAgICB2X3BvcyA9IChnbF9Qb3NpdGlvbi54eS9nbF9Qb3NpdGlvbi53ICsgMS4wKSAvIDIuMCAqIHVfd29ybGQ7XFxufVxcblwiXG4gICAgfSxcbiAgICBwYXR0ZXJuOiB7XG4gICAgICAgIGZyYWdtZW50OiBcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcblxcbnVuaWZvcm0gZmxvYXQgdV9vcGFjaXR5O1xcbnVuaWZvcm0gdmVjMiB1X3BhdHRlcm5fdGxfYTtcXG51bmlmb3JtIHZlYzIgdV9wYXR0ZXJuX2JyX2E7XFxudW5pZm9ybSB2ZWMyIHVfcGF0dGVybl90bF9iO1xcbnVuaWZvcm0gdmVjMiB1X3BhdHRlcm5fYnJfYjtcXG51bmlmb3JtIGZsb2F0IHVfbWl4O1xcblxcbnVuaWZvcm0gc2FtcGxlcjJEIHVfaW1hZ2U7XFxuXFxudmFyeWluZyB2ZWMyIHZfcG9zX2E7XFxudmFyeWluZyB2ZWMyIHZfcG9zX2I7XFxuXFxudm9pZCBtYWluKCkge1xcblxcbiAgICB2ZWMyIGltYWdlY29vcmQgPSBtb2Qodl9wb3NfYSwgMS4wKTtcXG4gICAgdmVjMiBwb3MgPSBtaXgodV9wYXR0ZXJuX3RsX2EsIHVfcGF0dGVybl9icl9hLCBpbWFnZWNvb3JkKTtcXG4gICAgdmVjNCBjb2xvcjEgPSB0ZXh0dXJlMkQodV9pbWFnZSwgcG9zKTtcXG5cXG4gICAgdmVjMiBpbWFnZWNvb3JkX2IgPSBtb2Qodl9wb3NfYiwgMS4wKTtcXG4gICAgdmVjMiBwb3MyID0gbWl4KHVfcGF0dGVybl90bF9iLCB1X3BhdHRlcm5fYnJfYiwgaW1hZ2Vjb29yZF9iKTtcXG4gICAgdmVjNCBjb2xvcjIgPSB0ZXh0dXJlMkQodV9pbWFnZSwgcG9zMik7XFxuXFxuICAgIGdsX0ZyYWdDb2xvciA9IG1peChjb2xvcjEsIGNvbG9yMiwgdV9taXgpICogdV9vcGFjaXR5O1xcbn1cXG5cIixcbiAgICAgICAgdmVydGV4OiBcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcblxcbnVuaWZvcm0gaGlnaHAgbWF0NCB1X21hdHJpeDtcXG51bmlmb3JtIHZlYzIgdV9wYXR0ZXJuc2NhbGVfYTtcXG51bmlmb3JtIHZlYzIgdV9wYXR0ZXJuc2NhbGVfYjtcXG51bmlmb3JtIHZlYzIgdV9vZmZzZXRfYTtcXG51bmlmb3JtIHZlYzIgdV9vZmZzZXRfYjtcXG5cXG5hdHRyaWJ1dGUgdmVjMiBhX3BvcztcXG5cXG52YXJ5aW5nIHZlYzIgdl9wb3NfYTtcXG52YXJ5aW5nIHZlYzIgdl9wb3NfYjtcXG5cXG52b2lkIG1haW4oKSB7XFxuICAgIGdsX1Bvc2l0aW9uID0gdV9tYXRyaXggKiB2ZWM0KGFfcG9zLCAwLCAxKTtcXG4gICAgdl9wb3NfYSA9IHVfcGF0dGVybnNjYWxlX2EgKiBhX3BvcyArIHVfb2Zmc2V0X2E7XFxuICAgIHZfcG9zX2IgPSB1X3BhdHRlcm5zY2FsZV9iICogYV9wb3MgKyB1X29mZnNldF9iO1xcbn1cXG5cIlxuICAgIH0sXG4gICAgcmFzdGVyOiB7XG4gICAgICAgIGZyYWdtZW50OiBcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcblxcbnVuaWZvcm0gZmxvYXQgdV9vcGFjaXR5MDtcXG51bmlmb3JtIGZsb2F0IHVfb3BhY2l0eTE7XFxudW5pZm9ybSBzYW1wbGVyMkQgdV9pbWFnZTA7XFxudW5pZm9ybSBzYW1wbGVyMkQgdV9pbWFnZTE7XFxudmFyeWluZyB2ZWMyIHZfcG9zMDtcXG52YXJ5aW5nIHZlYzIgdl9wb3MxO1xcblxcbnVuaWZvcm0gZmxvYXQgdV9icmlnaHRuZXNzX2xvdztcXG51bmlmb3JtIGZsb2F0IHVfYnJpZ2h0bmVzc19oaWdoO1xcblxcbnVuaWZvcm0gZmxvYXQgdV9zYXR1cmF0aW9uX2ZhY3RvcjtcXG51bmlmb3JtIGZsb2F0IHVfY29udHJhc3RfZmFjdG9yO1xcbnVuaWZvcm0gdmVjMyB1X3NwaW5fd2VpZ2h0cztcXG5cXG52b2lkIG1haW4oKSB7XFxuXFxuICAgIC8vIHJlYWQgYW5kIGNyb3NzLWZhZGUgY29sb3JzIGZyb20gdGhlIG1haW4gYW5kIHBhcmVudCB0aWxlc1xcbiAgICB2ZWM0IGNvbG9yMCA9IHRleHR1cmUyRCh1X2ltYWdlMCwgdl9wb3MwKTtcXG4gICAgdmVjNCBjb2xvcjEgPSB0ZXh0dXJlMkQodV9pbWFnZTEsIHZfcG9zMSk7XFxuICAgIHZlYzQgY29sb3IgPSBjb2xvcjAgKiB1X29wYWNpdHkwICsgY29sb3IxICogdV9vcGFjaXR5MTtcXG4gICAgdmVjMyByZ2IgPSBjb2xvci5yZ2I7XFxuXFxuICAgIC8vIHNwaW5cXG4gICAgcmdiID0gdmVjMyhcXG4gICAgICAgIGRvdChyZ2IsIHVfc3Bpbl93ZWlnaHRzLnh5eiksXFxuICAgICAgICBkb3QocmdiLCB1X3NwaW5fd2VpZ2h0cy56eHkpLFxcbiAgICAgICAgZG90KHJnYiwgdV9zcGluX3dlaWdodHMueXp4KSk7XFxuXFxuICAgIC8vIHNhdHVyYXRpb25cXG4gICAgZmxvYXQgYXZlcmFnZSA9IChjb2xvci5yICsgY29sb3IuZyArIGNvbG9yLmIpIC8gMy4wO1xcbiAgICByZ2IgKz0gKGF2ZXJhZ2UgLSByZ2IpICogdV9zYXR1cmF0aW9uX2ZhY3RvcjtcXG5cXG4gICAgLy8gY29udHJhc3RcXG4gICAgcmdiID0gKHJnYiAtIDAuNSkgKiB1X2NvbnRyYXN0X2ZhY3RvciArIDAuNTtcXG5cXG4gICAgLy8gYnJpZ2h0bmVzc1xcbiAgICB2ZWMzIHVfaGlnaF92ZWMgPSB2ZWMzKHVfYnJpZ2h0bmVzc19sb3csIHVfYnJpZ2h0bmVzc19sb3csIHVfYnJpZ2h0bmVzc19sb3cpO1xcbiAgICB2ZWMzIHVfbG93X3ZlYyA9IHZlYzModV9icmlnaHRuZXNzX2hpZ2gsIHVfYnJpZ2h0bmVzc19oaWdoLCB1X2JyaWdodG5lc3NfaGlnaCk7XFxuXFxuICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQobWl4KHVfaGlnaF92ZWMsIHVfbG93X3ZlYywgcmdiKSwgY29sb3IuYSk7XFxufVxcblwiLFxuICAgICAgICB2ZXJ0ZXg6IFwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuXFxudW5pZm9ybSBoaWdocCBtYXQ0IHVfbWF0cml4O1xcbnVuaWZvcm0gdmVjMiB1X3RsX3BhcmVudDtcXG51bmlmb3JtIGZsb2F0IHVfc2NhbGVfcGFyZW50O1xcbnVuaWZvcm0gZmxvYXQgdV9idWZmZXJfc2NhbGU7XFxuXFxuYXR0cmlidXRlIHZlYzIgYV9wb3M7XFxuYXR0cmlidXRlIHZlYzIgYV90ZXh0dXJlX3BvcztcXG5cXG52YXJ5aW5nIHZlYzIgdl9wb3MwO1xcbnZhcnlpbmcgdmVjMiB2X3BvczE7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgICBnbF9Qb3NpdGlvbiA9IHVfbWF0cml4ICogdmVjNChhX3BvcywgMCwgMSk7XFxuICAgIHZfcG9zMCA9ICgoKGFfdGV4dHVyZV9wb3MgLyAzMjc2Ny4wKSAtIDAuNSkgLyB1X2J1ZmZlcl9zY2FsZSApICsgMC41O1xcbiAgICB2X3BvczEgPSAodl9wb3MwICogdV9zY2FsZV9wYXJlbnQpICsgdV90bF9wYXJlbnQ7XFxufVxcblwiXG4gICAgfSxcbiAgICBpY29uOiB7XG4gICAgICAgIGZyYWdtZW50OiBcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcblxcbnVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTtcXG5cXG52YXJ5aW5nIHZlYzIgdl90ZXg7XFxudmFyeWluZyBmbG9hdCB2X2FscGhhO1xcblxcbnZvaWQgbWFpbigpIHtcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVfdGV4dHVyZSwgdl90ZXgpICogdl9hbHBoYTtcXG59XFxuXCIsXG4gICAgICAgIHZlcnRleDogXCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5cXG5hdHRyaWJ1dGUgdmVjMiBhX3BvcztcXG5hdHRyaWJ1dGUgdmVjMiBhX29mZnNldDtcXG5hdHRyaWJ1dGUgdmVjNCBhX2RhdGExO1xcbmF0dHJpYnV0ZSB2ZWM0IGFfZGF0YTI7XFxuXFxuXFxuLy8gbWF0cml4IGlzIGZvciB0aGUgdmVydGV4IHBvc2l0aW9uLCBleG1hdHJpeCBpcyBmb3Igcm90YXRpbmcgYW5kIHByb2plY3RpbmdcXG4vLyB0aGUgZXh0cnVzaW9uIHZlY3Rvci5cXG51bmlmb3JtIGhpZ2hwIG1hdDQgdV9tYXRyaXg7XFxudW5pZm9ybSBtYXQ0IHVfZXhtYXRyaXg7XFxudW5pZm9ybSBmbG9hdCB1X3pvb207XFxudW5pZm9ybSBmbG9hdCB1X2ZhZGVkaXN0O1xcbnVuaWZvcm0gZmxvYXQgdV9taW5mYWRlem9vbTtcXG51bmlmb3JtIGZsb2F0IHVfbWF4ZmFkZXpvb207XFxudW5pZm9ybSBmbG9hdCB1X2ZhZGV6b29tO1xcbnVuaWZvcm0gZmxvYXQgdV9vcGFjaXR5O1xcbnVuaWZvcm0gYm9vbCB1X3NrZXdlZDtcXG51bmlmb3JtIGZsb2F0IHVfZXh0cmE7XFxuXFxudW5pZm9ybSB2ZWMyIHVfdGV4c2l6ZTtcXG5cXG52YXJ5aW5nIHZlYzIgdl90ZXg7XFxudmFyeWluZyBmbG9hdCB2X2FscGhhO1xcblxcbnZvaWQgbWFpbigpIHtcXG4gICAgdmVjMiBhX3RleCA9IGFfZGF0YTEueHk7XFxuICAgIGZsb2F0IGFfbGFiZWxtaW56b29tID0gYV9kYXRhMVsyXTtcXG4gICAgdmVjMiBhX3pvb20gPSBhX2RhdGEyLnN0O1xcbiAgICBmbG9hdCBhX21pbnpvb20gPSBhX3pvb21bMF07XFxuICAgIGZsb2F0IGFfbWF4em9vbSA9IGFfem9vbVsxXTtcXG5cXG4gICAgZmxvYXQgYV9mYWRlZGlzdCA9IDEwLjA7XFxuXFxuICAgIC8vIHVfem9vbSBpcyB0aGUgY3VycmVudCB6b29tIGxldmVsIGFkanVzdGVkIGZvciB0aGUgY2hhbmdlIGluIGZvbnQgc2l6ZVxcbiAgICBmbG9hdCB6ID0gMi4wIC0gc3RlcChhX21pbnpvb20sIHVfem9vbSkgLSAoMS4wIC0gc3RlcChhX21heHpvb20sIHVfem9vbSkpO1xcblxcbiAgICAvLyBmYWRlIG91dCBsYWJlbHNcXG4gICAgZmxvYXQgYWxwaGEgPSBjbGFtcCgodV9mYWRlem9vbSAtIGFfbGFiZWxtaW56b29tKSAvIHVfZmFkZWRpc3QsIDAuMCwgMS4wKTtcXG5cXG4gICAgaWYgKHVfZmFkZWRpc3QgPj0gMC4wKSB7XFxuICAgICAgICB2X2FscGhhID0gYWxwaGE7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICB2X2FscGhhID0gMS4wIC0gYWxwaGE7XFxuICAgIH1cXG4gICAgaWYgKHVfbWF4ZmFkZXpvb20gPCBhX2xhYmVsbWluem9vbSkge1xcbiAgICAgICAgdl9hbHBoYSA9IDAuMDtcXG4gICAgfVxcbiAgICBpZiAodV9taW5mYWRlem9vbSA+PSBhX2xhYmVsbWluem9vbSkge1xcbiAgICAgICAgdl9hbHBoYSA9IDEuMDtcXG4gICAgfVxcblxcbiAgICAvLyBpZiBsYWJlbCBoYXMgYmVlbiBmYWRlZCBvdXQsIGNsaXAgaXRcXG4gICAgeiArPSBzdGVwKHZfYWxwaGEsIDAuMCk7XFxuXFxuICAgIGlmICh1X3NrZXdlZCkge1xcbiAgICAgICAgdmVjNCBleHRydWRlID0gdV9leG1hdHJpeCAqIHZlYzQoYV9vZmZzZXQgLyA2NC4wLCAwLCAwKTtcXG4gICAgICAgIGdsX1Bvc2l0aW9uID0gdV9tYXRyaXggKiB2ZWM0KGFfcG9zICsgZXh0cnVkZS54eSwgMCwgMSk7XFxuICAgICAgICBnbF9Qb3NpdGlvbi56ICs9IHogKiBnbF9Qb3NpdGlvbi53O1xcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgdmVjNCBleHRydWRlID0gdV9leG1hdHJpeCAqIHZlYzQoYV9vZmZzZXQgLyA2NC4wLCB6LCAwKTtcXG4gICAgICAgIGdsX1Bvc2l0aW9uID0gdV9tYXRyaXggKiB2ZWM0KGFfcG9zLCAwLCAxKSArIGV4dHJ1ZGU7XFxuICAgIH1cXG5cXG4gICAgdl90ZXggPSBhX3RleCAvIHVfdGV4c2l6ZTtcXG5cXG4gICAgdl9hbHBoYSAqPSB1X29wYWNpdHk7XFxufVxcblwiXG4gICAgfSxcbiAgICBzZGY6IHtcbiAgICAgICAgZnJhZ21lbnQ6IFwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuXFxudW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlO1xcbnVuaWZvcm0gdmVjNCB1X2NvbG9yO1xcbnVuaWZvcm0gZmxvYXQgdV9idWZmZXI7XFxudW5pZm9ybSBmbG9hdCB1X2dhbW1hO1xcblxcbnZhcnlpbmcgdmVjMiB2X3RleDtcXG52YXJ5aW5nIGZsb2F0IHZfYWxwaGE7XFxudmFyeWluZyBmbG9hdCB2X2dhbW1hX3NjYWxlO1xcblxcbnZvaWQgbWFpbigpIHtcXG4gICAgZmxvYXQgZ2FtbWEgPSB1X2dhbW1hICogdl9nYW1tYV9zY2FsZTtcXG4gICAgZmxvYXQgZGlzdCA9IHRleHR1cmUyRCh1X3RleHR1cmUsIHZfdGV4KS5hO1xcbiAgICBmbG9hdCBhbHBoYSA9IHNtb290aHN0ZXAodV9idWZmZXIgLSBnYW1tYSwgdV9idWZmZXIgKyBnYW1tYSwgZGlzdCkgKiB2X2FscGhhO1xcbiAgICBnbF9GcmFnQ29sb3IgPSB1X2NvbG9yICogYWxwaGE7XFxufVxcblwiLFxuICAgICAgICB2ZXJ0ZXg6IFwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuXFxuYXR0cmlidXRlIHZlYzIgYV9wb3M7XFxuYXR0cmlidXRlIHZlYzIgYV9vZmZzZXQ7XFxuYXR0cmlidXRlIHZlYzQgYV9kYXRhMTtcXG5hdHRyaWJ1dGUgdmVjNCBhX2RhdGEyO1xcblxcblxcbi8vIG1hdHJpeCBpcyBmb3IgdGhlIHZlcnRleCBwb3NpdGlvbiwgZXhtYXRyaXggaXMgZm9yIHJvdGF0aW5nIGFuZCBwcm9qZWN0aW5nXFxuLy8gdGhlIGV4dHJ1c2lvbiB2ZWN0b3IuXFxudW5pZm9ybSBoaWdocCBtYXQ0IHVfbWF0cml4O1xcbnVuaWZvcm0gbWF0NCB1X2V4bWF0cml4O1xcblxcbnVuaWZvcm0gZmxvYXQgdV96b29tO1xcbnVuaWZvcm0gZmxvYXQgdV9mYWRlZGlzdDtcXG51bmlmb3JtIGZsb2F0IHVfbWluZmFkZXpvb207XFxudW5pZm9ybSBmbG9hdCB1X21heGZhZGV6b29tO1xcbnVuaWZvcm0gZmxvYXQgdV9mYWRlem9vbTtcXG51bmlmb3JtIGJvb2wgdV9za2V3ZWQ7XFxudW5pZm9ybSBmbG9hdCB1X2V4dHJhO1xcblxcbnVuaWZvcm0gdmVjMiB1X3RleHNpemU7XFxuXFxudmFyeWluZyB2ZWMyIHZfdGV4O1xcbnZhcnlpbmcgZmxvYXQgdl9hbHBoYTtcXG52YXJ5aW5nIGZsb2F0IHZfZ2FtbWFfc2NhbGU7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgICB2ZWMyIGFfdGV4ID0gYV9kYXRhMS54eTtcXG4gICAgZmxvYXQgYV9sYWJlbG1pbnpvb20gPSBhX2RhdGExWzJdO1xcbiAgICB2ZWMyIGFfem9vbSA9IGFfZGF0YTIuc3Q7XFxuICAgIGZsb2F0IGFfbWluem9vbSA9IGFfem9vbVswXTtcXG4gICAgZmxvYXQgYV9tYXh6b29tID0gYV96b29tWzFdO1xcblxcbiAgICAvLyB1X3pvb20gaXMgdGhlIGN1cnJlbnQgem9vbSBsZXZlbCBhZGp1c3RlZCBmb3IgdGhlIGNoYW5nZSBpbiBmb250IHNpemVcXG4gICAgZmxvYXQgeiA9IDIuMCAtIHN0ZXAoYV9taW56b29tLCB1X3pvb20pIC0gKDEuMCAtIHN0ZXAoYV9tYXh6b29tLCB1X3pvb20pKTtcXG5cXG4gICAgLy8gZmFkZSBvdXQgbGFiZWxzXFxuICAgIGZsb2F0IGFscGhhID0gY2xhbXAoKHVfZmFkZXpvb20gLSBhX2xhYmVsbWluem9vbSkgLyB1X2ZhZGVkaXN0LCAwLjAsIDEuMCk7XFxuXFxuICAgIGlmICh1X2ZhZGVkaXN0ID49IDAuMCkge1xcbiAgICAgICAgdl9hbHBoYSA9IGFscGhhO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgdl9hbHBoYSA9IDEuMCAtIGFscGhhO1xcbiAgICB9XFxuICAgIGlmICh1X21heGZhZGV6b29tIDwgYV9sYWJlbG1pbnpvb20pIHtcXG4gICAgICAgIHZfYWxwaGEgPSAwLjA7XFxuICAgIH1cXG4gICAgaWYgKHVfbWluZmFkZXpvb20gPj0gYV9sYWJlbG1pbnpvb20pIHtcXG4gICAgICAgIHZfYWxwaGEgPSAxLjA7XFxuICAgIH1cXG5cXG4gICAgLy8gaWYgbGFiZWwgaGFzIGJlZW4gZmFkZWQgb3V0LCBjbGlwIGl0XFxuICAgIHogKz0gc3RlcCh2X2FscGhhLCAwLjApO1xcblxcbiAgICBpZiAodV9za2V3ZWQpIHtcXG4gICAgICAgIHZlYzQgZXh0cnVkZSA9IHVfZXhtYXRyaXggKiB2ZWM0KGFfb2Zmc2V0IC8gNjQuMCwgMCwgMCk7XFxuICAgICAgICBnbF9Qb3NpdGlvbiA9IHVfbWF0cml4ICogdmVjNChhX3BvcyArIGV4dHJ1ZGUueHksIDAsIDEpO1xcbiAgICAgICAgZ2xfUG9zaXRpb24ueiArPSB6ICogZ2xfUG9zaXRpb24udztcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIHZlYzQgZXh0cnVkZSA9IHVfZXhtYXRyaXggKiB2ZWM0KGFfb2Zmc2V0IC8gNjQuMCwgeiwgMCk7XFxuICAgICAgICBnbF9Qb3NpdGlvbiA9IHVfbWF0cml4ICogdmVjNChhX3BvcywgMCwgMSkgKyBleHRydWRlO1xcbiAgICB9XFxuXFxuICAgIC8vIHBvc2l0aW9uIG9mIHkgb24gdGhlIHNjcmVlblxcbiAgICBmbG9hdCB5ID0gZ2xfUG9zaXRpb24ueSAvIGdsX1Bvc2l0aW9uLnc7XFxuICAgIC8vIGhvdyBtdWNoIGZlYXR1cmVzIGFyZSBzcXVpc2hlZCBpbiBhbGwgZGlyZWN0aW9ucyBieSB0aGUgcGVyc3BlY3RpdmVuZXNzXFxuICAgIGZsb2F0IHBlcnNwZWN0aXZlX3NjYWxlID0gMS4wIC8gKDEuMCAtIHkgKiB1X2V4dHJhKTtcXG4gICAgdl9nYW1tYV9zY2FsZSA9IHBlcnNwZWN0aXZlX3NjYWxlO1xcblxcbiAgICB2X3RleCA9IGFfdGV4IC8gdV90ZXhzaXplO1xcbn1cXG5cIlxuICAgIH0sXG4gICAgY29sbGlzaW9uYm94OiB7XG4gICAgICAgIGZyYWdtZW50OiBcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcblxcbnVuaWZvcm0gZmxvYXQgdV96b29tO1xcbnVuaWZvcm0gZmxvYXQgdV9tYXh6b29tO1xcblxcbnZhcnlpbmcgZmxvYXQgdl9tYXhfem9vbTtcXG52YXJ5aW5nIGZsb2F0IHZfcGxhY2VtZW50X3pvb207XFxuXFxudm9pZCBtYWluKCkge1xcblxcbiAgICBmbG9hdCBhbHBoYSA9IDAuNTtcXG5cXG4gICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLjAsIDEuMCwgMC4wLCAxLjApICogYWxwaGE7XFxuXFxuICAgIGlmICh2X3BsYWNlbWVudF96b29tID4gdV96b29tKSB7XFxuICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDEuMCwgMC4wLCAwLjAsIDEuMCkgKiBhbHBoYTtcXG4gICAgfVxcblxcbiAgICBpZiAodV96b29tID49IHZfbWF4X3pvb20pIHtcXG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMC4wLCAwLjAsIDAuMCwgMS4wKSAqIGFscGhhICogMC4yNTtcXG4gICAgfVxcblxcbiAgICBpZiAodl9wbGFjZW1lbnRfem9vbSA+PSB1X21heHpvb20pIHtcXG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMC4wLCAwLjAsIDEuMCwgMS4wKSAqIGFscGhhICogMC4yO1xcbiAgICB9XFxufVxcblwiLFxuICAgICAgICB2ZXJ0ZXg6IFwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuXFxuYXR0cmlidXRlIHZlYzIgYV9wb3M7XFxuYXR0cmlidXRlIHZlYzIgYV9leHRydWRlO1xcbmF0dHJpYnV0ZSB2ZWMyIGFfZGF0YTtcXG5cXG51bmlmb3JtIGhpZ2hwIG1hdDQgdV9tYXRyaXg7XFxudW5pZm9ybSBmbG9hdCB1X3NjYWxlO1xcblxcbnZhcnlpbmcgZmxvYXQgdl9tYXhfem9vbTtcXG52YXJ5aW5nIGZsb2F0IHZfcGxhY2VtZW50X3pvb207XFxuXFxudm9pZCBtYWluKCkge1xcbiAgICAgZ2xfUG9zaXRpb24gPSB1X21hdHJpeCAqIHZlYzQoYV9wb3MgKyBhX2V4dHJ1ZGUgLyB1X3NjYWxlLCAwLjAsIDEuMCk7XFxuXFxuICAgICB2X21heF96b29tID0gYV9kYXRhLng7XFxuICAgICB2X3BsYWNlbWVudF96b29tID0gYV9kYXRhLnk7XFxufVxcblwiXG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcbnZhciBFdmVudGVkID0gcmVxdWlyZSgnLi4vdXRpbC9ldmVudGVkJyk7XG52YXIgVGlsZVB5cmFtaWQgPSByZXF1aXJlKCcuL3RpbGVfcHlyYW1pZCcpO1xudmFyIFNvdXJjZSA9IHJlcXVpcmUoJy4vc291cmNlJyk7XG52YXIgdXJsUmVzb2x2ZSA9IHJlcXVpcmUoJ3Jlc29sdmUtdXJsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gR2VvSlNPTlNvdXJjZTtcblxuLyoqXG4gKiBDcmVhdGUgYSBHZW9KU09OIGRhdGEgc291cmNlIGluc3RhbmNlIGdpdmVuIGFuIG9wdGlvbnMgb2JqZWN0XG4gKiBAY2xhc3MgR2VvSlNPTlNvdXJjZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBvcHRpb25zLmRhdGEgQSBHZW9KU09OIGRhdGEgb2JqZWN0IG9yIFVSTCB0byBpdC4gVGhlIGxhdHRlciBpcyBwcmVmZXJhYmxlIGluIGNhc2Ugb2YgbGFyZ2UgR2VvSlNPTiBmaWxlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXh6b29tPTE0XSBNYXhpbXVtIHpvb20gdG8gcHJlc2VydmUgZGV0YWlsIGF0LlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmJ1ZmZlcl0gVGlsZSBidWZmZXIgb24gZWFjaCBzaWRlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnRvbGVyYW5jZV0gU2ltcGxpZmljYXRpb24gdG9sZXJhbmNlIChoaWdoZXIgbWVhbnMgc2ltcGxlcikuXG4gKiBAZXhhbXBsZVxuICogdmFyIHNvdXJjZU9iaiA9IG5ldyBtYXBib3hnbC5HZW9KU09OU291cmNlKHtcbiAqICAgIGRhdGE6IHtcbiAqICAgICAgICBcInR5cGVcIjogXCJGZWF0dXJlQ29sbGVjdGlvblwiLFxuICogICAgICAgIFwiZmVhdHVyZXNcIjogW3tcbiAqICAgICAgICAgICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICAgICAgICAgICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgICAgICAgICAgICBcImNvb3JkaW5hdGVzXCI6IFtcbiAqICAgICAgICAgICAgICAgICAgICAtNzYuNTMwNjMyOTcyNzE3MjksXG4gKiAgICAgICAgICAgICAgICAgICAgMzkuMTgxNzQwNzc5OTQxMDhcbiAqICAgICAgICAgICAgICAgIF1cbiAqICAgICAgICAgICAgfVxuICogICAgICAgIH1dXG4gKiAgICB9XG4gKiB9KTtcbiAqIG1hcC5hZGRTb3VyY2UoJ3NvbWUgaWQnLCBzb3VyY2VPYmopOyAvLyBhZGRcbiAqIG1hcC5yZW1vdmVTb3VyY2UoJ3NvbWUgaWQnKTsgIC8vIHJlbW92ZVxuICovXG5mdW5jdGlvbiBHZW9KU09OU291cmNlKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHRoaXMuX2RhdGEgPSBvcHRpb25zLmRhdGE7XG5cbiAgICBpZiAob3B0aW9ucy5tYXh6b29tICE9PSB1bmRlZmluZWQpIHRoaXMubWF4em9vbSA9IG9wdGlvbnMubWF4em9vbTtcblxuICAgIHRoaXMuZ2VvanNvblZ0T3B0aW9ucyA9IHsgbWF4Wm9vbTogdGhpcy5tYXh6b29tIH07XG4gICAgaWYgKG9wdGlvbnMuYnVmZmVyICE9PSB1bmRlZmluZWQpIHRoaXMuZ2VvanNvblZ0T3B0aW9ucy5idWZmZXIgPSBvcHRpb25zLmJ1ZmZlcjtcbiAgICBpZiAob3B0aW9ucy50b2xlcmFuY2UgIT09IHVuZGVmaW5lZCkgdGhpcy5nZW9qc29uVnRPcHRpb25zLnRvbGVyYW5jZSA9IG9wdGlvbnMudG9sZXJhbmNlO1xuXG4gICAgdGhpcy5fcHlyYW1pZCA9IG5ldyBUaWxlUHlyYW1pZCh7XG4gICAgICAgIHRpbGVTaXplOiA1MTIsXG4gICAgICAgIG1pbnpvb206IHRoaXMubWluem9vbSxcbiAgICAgICAgbWF4em9vbTogdGhpcy5tYXh6b29tLFxuICAgICAgICBjYWNoZVNpemU6IDIwLFxuICAgICAgICBsb2FkOiB0aGlzLl9sb2FkVGlsZS5iaW5kKHRoaXMpLFxuICAgICAgICBhYm9ydDogdGhpcy5fYWJvcnRUaWxlLmJpbmQodGhpcyksXG4gICAgICAgIHVubG9hZDogdGhpcy5fdW5sb2FkVGlsZS5iaW5kKHRoaXMpLFxuICAgICAgICBhZGQ6IHRoaXMuX2FkZFRpbGUuYmluZCh0aGlzKSxcbiAgICAgICAgcmVtb3ZlOiB0aGlzLl9yZW1vdmVUaWxlLmJpbmQodGhpcyksXG4gICAgICAgIHJlZG9QbGFjZW1lbnQ6IHRoaXMuX3JlZG9UaWxlUGxhY2VtZW50LmJpbmQodGhpcylcbiAgICB9KTtcbn1cblxuR2VvSlNPTlNvdXJjZS5wcm90b3R5cGUgPSB1dGlsLmluaGVyaXQoRXZlbnRlZCwgLyoqIEBsZW5kcyBHZW9KU09OU291cmNlLnByb3RvdHlwZSAqL3tcbiAgICBtaW56b29tOiAwLFxuICAgIG1heHpvb206IDE0LFxuICAgIF9kaXJ0eTogdHJ1ZSxcbiAgICBpc1RpbGVDbGlwcGVkOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHNvdXJjZSBnZW9qc29uIGRhdGEgYW5kIHJlcmVuZGVyIG1hcFxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBkYXRhIEEgR2VvSlNPTiBkYXRhIG9iamVjdCBvciBVUkwgdG8gaXQuIFRoZSBsYXR0ZXIgaXMgcHJlZmVyYWJsZSBpbiBjYXNlIG9mIGxhcmdlIEdlb0pTT04gZmlsZXMuXG4gICAgICogQHJldHVybnMge0dlb0pTT05Tb3VyY2V9IHRoaXNcbiAgICAgKi9cbiAgICBzZXREYXRhOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5maXJlKCdjaGFuZ2UnKTtcblxuICAgICAgICBpZiAodGhpcy5tYXApXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSh0aGlzLm1hcC50cmFuc2Zvcm0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBvbkFkZDogZnVuY3Rpb24obWFwKSB7XG4gICAgICAgIHRoaXMubWFwID0gbWFwO1xuICAgIH0sXG5cbiAgICBsb2FkZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9hZGVkICYmIHRoaXMuX3B5cmFtaWQubG9hZGVkKCk7XG4gICAgfSxcblxuICAgIHVwZGF0ZTogZnVuY3Rpb24odHJhbnNmb3JtKSB7XG4gICAgICAgIGlmICh0aGlzLl9kaXJ0eSkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlRGF0YSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2xvYWRlZCkge1xuICAgICAgICAgICAgdGhpcy5fcHlyYW1pZC51cGRhdGUodGhpcy51c2VkLCB0cmFuc2Zvcm0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHJlbG9hZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9sb2FkZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3B5cmFtaWQucmVsb2FkKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0VmlzaWJsZUNvb3JkaW5hdGVzOiBTb3VyY2UuX2dldFZpc2libGVDb29yZGluYXRlcyxcbiAgICBnZXRUaWxlOiBTb3VyY2UuX2dldFRpbGUsXG5cbiAgICBmZWF0dXJlc0F0OiBTb3VyY2UuX3ZlY3RvckZlYXR1cmVzQXQsXG4gICAgZmVhdHVyZXNJbjogU291cmNlLl92ZWN0b3JGZWF0dXJlc0luLFxuXG4gICAgX3VwZGF0ZURhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9kaXJ0eSA9IGZhbHNlO1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgZGF0YSA9IHVybFJlc29sdmUod2luZG93LmxvY2F0aW9uLmhyZWYsIGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud29ya2VySUQgPSB0aGlzLmRpc3BhdGNoZXIuc2VuZCgncGFyc2UgZ2VvanNvbicsIHtcbiAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICB0aWxlU2l6ZTogNTEyLFxuICAgICAgICAgICAgc291cmNlOiB0aGlzLmlkLFxuICAgICAgICAgICAgZ2VvanNvblZ0T3B0aW9uczogdGhpcy5nZW9qc29uVnRPcHRpb25zXG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgdGhpcy5fbG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmUoJ2Vycm9yJywge2Vycm9yOiBlcnJ9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHlyYW1pZC5yZWxvYWQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmUoJ2NoYW5nZScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfSxcblxuICAgIF9sb2FkVGlsZTogZnVuY3Rpb24odGlsZSkge1xuICAgICAgICB2YXIgb3ZlcnNjYWxpbmcgPSB0aWxlLmNvb3JkLnogPiB0aGlzLm1heHpvb20gPyBNYXRoLnBvdygyLCB0aWxlLmNvb3JkLnogLSB0aGlzLm1heHpvb20pIDogMTtcbiAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICAgIHVpZDogdGlsZS51aWQsXG4gICAgICAgICAgICBjb29yZDogdGlsZS5jb29yZCxcbiAgICAgICAgICAgIHpvb206IHRpbGUuY29vcmQueixcbiAgICAgICAgICAgIG1heFpvb206IHRoaXMubWF4em9vbSxcbiAgICAgICAgICAgIHRpbGVTaXplOiA1MTIsXG4gICAgICAgICAgICBzb3VyY2U6IHRoaXMuaWQsXG4gICAgICAgICAgICBvdmVyc2NhbGluZzogb3ZlcnNjYWxpbmcsXG4gICAgICAgICAgICBhbmdsZTogdGhpcy5tYXAudHJhbnNmb3JtLmFuZ2xlLFxuICAgICAgICAgICAgcGl0Y2g6IHRoaXMubWFwLnRyYW5zZm9ybS5waXRjaCxcbiAgICAgICAgICAgIGNvbGxpc2lvbkRlYnVnOiB0aGlzLm1hcC5jb2xsaXNpb25EZWJ1Z1xuICAgICAgICB9O1xuXG4gICAgICAgIHRpbGUud29ya2VySUQgPSB0aGlzLmRpc3BhdGNoZXIuc2VuZCgnbG9hZCBnZW9qc29uIHRpbGUnLCBwYXJhbXMsIGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuXG4gICAgICAgICAgICB0aWxlLnVubG9hZFZlY3RvckRhdGEodGhpcy5tYXAucGFpbnRlcik7XG5cbiAgICAgICAgICAgIGlmICh0aWxlLmFib3J0ZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlKCd0aWxlLmVycm9yJywge3RpbGU6IHRpbGV9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRpbGUubG9hZFZlY3RvckRhdGEoZGF0YSk7XG5cbiAgICAgICAgICAgIGlmICh0aWxlLnJlZG9XaGVuRG9uZSkge1xuICAgICAgICAgICAgICAgIHRpbGUucmVkb1doZW5Eb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGlsZS5yZWRvUGxhY2VtZW50KHRoaXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmZpcmUoJ3RpbGUubG9hZCcsIHt0aWxlOiB0aWxlfSk7XG5cbiAgICAgICAgfS5iaW5kKHRoaXMpLCB0aGlzLndvcmtlcklEKTtcbiAgICB9LFxuXG4gICAgX2Fib3J0VGlsZTogZnVuY3Rpb24odGlsZSkge1xuICAgICAgICB0aWxlLmFib3J0ZWQgPSB0cnVlO1xuICAgIH0sXG5cbiAgICBfYWRkVGlsZTogZnVuY3Rpb24odGlsZSkge1xuICAgICAgICB0aGlzLmZpcmUoJ3RpbGUuYWRkJywge3RpbGU6IHRpbGV9KTtcbiAgICB9LFxuXG4gICAgX3JlbW92ZVRpbGU6IGZ1bmN0aW9uKHRpbGUpIHtcbiAgICAgICAgdGhpcy5maXJlKCd0aWxlLnJlbW92ZScsIHt0aWxlOiB0aWxlfSk7XG4gICAgfSxcblxuICAgIF91bmxvYWRUaWxlOiBmdW5jdGlvbih0aWxlKSB7XG4gICAgICAgIHRpbGUudW5sb2FkVmVjdG9yRGF0YSh0aGlzLm1hcC5wYWludGVyKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaGVyLnNlbmQoJ3JlbW92ZSB0aWxlJywgeyB1aWQ6IHRpbGUudWlkLCBzb3VyY2U6IHRoaXMuaWQgfSwgbnVsbCwgdGlsZS53b3JrZXJJRCk7XG4gICAgfSxcblxuICAgIHJlZG9QbGFjZW1lbnQ6IFNvdXJjZS5yZWRvUGxhY2VtZW50LFxuXG4gICAgX3JlZG9UaWxlUGxhY2VtZW50OiBmdW5jdGlvbih0aWxlKSB7XG4gICAgICAgIHRpbGUucmVkb1BsYWNlbWVudCh0aGlzKTtcbiAgICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFBvaW50ID0gcmVxdWlyZSgncG9pbnQtZ2VvbWV0cnknKTtcbnZhciBWZWN0b3JUaWxlRmVhdHVyZSA9IHJlcXVpcmUoJ3ZlY3Rvci10aWxlJykuVmVjdG9yVGlsZUZlYXR1cmU7XG5cbm1vZHVsZS5leHBvcnRzID0gR2VvSlNPTldyYXBwZXI7XG5cbi8vIGNvbmZvcm0gdG8gdmVjdG9ydGlsZSBhcGlcbmZ1bmN0aW9uIEdlb0pTT05XcmFwcGVyKGZlYXR1cmVzKSB7XG4gICAgdGhpcy5mZWF0dXJlcyA9IGZlYXR1cmVzO1xuICAgIHRoaXMubGVuZ3RoID0gZmVhdHVyZXMubGVuZ3RoO1xufVxuXG5HZW9KU09OV3JhcHBlci5wcm90b3R5cGUuZmVhdHVyZSA9IGZ1bmN0aW9uKGkpIHtcbiAgICByZXR1cm4gbmV3IEZlYXR1cmVXcmFwcGVyKHRoaXMuZmVhdHVyZXNbaV0pO1xufTtcblxuZnVuY3Rpb24gRmVhdHVyZVdyYXBwZXIoZmVhdHVyZSkge1xuICAgIHRoaXMudHlwZSA9IGZlYXR1cmUudHlwZTtcbiAgICB0aGlzLnJhd0dlb21ldHJ5ID0gZmVhdHVyZS50eXBlID09PSAxID8gW2ZlYXR1cmUuZ2VvbWV0cnldIDogZmVhdHVyZS5nZW9tZXRyeTtcbiAgICB0aGlzLnByb3BlcnRpZXMgPSBmZWF0dXJlLnRhZ3M7XG4gICAgdGhpcy5leHRlbnQgPSA0MDk2O1xufVxuXG5GZWF0dXJlV3JhcHBlci5wcm90b3R5cGUubG9hZEdlb21ldHJ5ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJpbmdzID0gdGhpcy5yYXdHZW9tZXRyeTtcbiAgICB0aGlzLmdlb21ldHJ5ID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciByaW5nID0gcmluZ3NbaV0sXG4gICAgICAgICAgICBuZXdSaW5nID0gW107XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmluZy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgbmV3UmluZy5wdXNoKG5ldyBQb2ludChyaW5nW2pdWzBdLCByaW5nW2pdWzFdKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5nZW9tZXRyeS5wdXNoKG5ld1JpbmcpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZW9tZXRyeTtcbn07XG5cbkZlYXR1cmVXcmFwcGVyLnByb3RvdHlwZS5iYm94ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLmdlb21ldHJ5KSB0aGlzLmxvYWRHZW9tZXRyeSgpO1xuXG4gICAgdmFyIHJpbmdzID0gdGhpcy5nZW9tZXRyeSxcbiAgICAgICAgeDEgPSBJbmZpbml0eSxcbiAgICAgICAgeDIgPSAtSW5maW5pdHksXG4gICAgICAgIHkxID0gSW5maW5pdHksXG4gICAgICAgIHkyID0gLUluZmluaXR5O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByaW5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcmluZyA9IHJpbmdzW2ldO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmluZy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIGNvb3JkID0gcmluZ1tqXTtcblxuICAgICAgICAgICAgeDEgPSBNYXRoLm1pbih4MSwgY29vcmQueCk7XG4gICAgICAgICAgICB4MiA9IE1hdGgubWF4KHgyLCBjb29yZC54KTtcbiAgICAgICAgICAgIHkxID0gTWF0aC5taW4oeTEsIGNvb3JkLnkpO1xuICAgICAgICAgICAgeTIgPSBNYXRoLm1heCh5MiwgY29vcmQueSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gW3gxLCB5MSwgeDIsIHkyXTtcbn07XG5cbkZlYXR1cmVXcmFwcGVyLnByb3RvdHlwZS50b0dlb0pTT04gPSBWZWN0b3JUaWxlRmVhdHVyZS5wcm90b3R5cGUudG9HZW9KU09OO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xudmFyIFRpbGUgPSByZXF1aXJlKCcuL3RpbGUnKTtcbnZhciBMbmdMYXQgPSByZXF1aXJlKCcuLi9nZW8vbG5nX2xhdCcpO1xudmFyIFBvaW50ID0gcmVxdWlyZSgncG9pbnQtZ2VvbWV0cnknKTtcbnZhciBFdmVudGVkID0gcmVxdWlyZSgnLi4vdXRpbC9ldmVudGVkJyk7XG52YXIgYWpheCA9IHJlcXVpcmUoJy4uL3V0aWwvYWpheCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEltYWdlU291cmNlO1xuXG4vKipcbiAqIENyZWF0ZSBhbiBJbWFnZSBzb3VyY2UgaW5zdGFuY2UgZ2l2ZW4gYW4gb3B0aW9ucyBvYmplY3RcbiAqIEBjbGFzcyBJbWFnZVNvdXJjZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudXJsIEEgc3RyaW5nIFVSTCBvZiBhbiBpbWFnZSBmaWxlXG4gKiBAcGFyYW0ge0FycmF5fSBvcHRpb25zLmNvb3JkaW5hdGVzIGxuZywgbGF0IGNvb3JkaW5hdGVzIGluIG9yZGVyIGNsb2Nrd2lzZVxuICogc3RhcnRpbmcgYXQgdGhlIHRvcCBsZWZ0OiB0bCwgdHIsIGJyLCBibFxuICogQGV4YW1wbGVcbiAqIHZhciBzb3VyY2VPYmogPSBuZXcgbWFwYm94Z2wuSW1hZ2VTb3VyY2Uoe1xuICogICAgdXJsOiAnaHR0cHM6Ly93d3cubWFwYm94LmNvbS9pbWFnZXMvZm9vLnBuZycsXG4gKiAgICBjb29yZGluYXRlczogW1xuICogICAgICAgIFstNzYuNTQzMzU3MzcyMjgzOTQsIDM5LjE4NTc5OTA3MjI5NzQ4XSxcbiAqICAgICAgICBbLTc2LjUyODAzNjU5NDM5MDg3LCAzOS4xODM4MzY0ODQ3NTg3XSxcbiAqICAgICAgICBbLTc2LjUyOTUzODYzMTQzOTIsIDM5LjE3NjgzMzkyNTA3NjA2XSxcbiAqICAgICAgICBbLTc2LjU0NTIwMjczMjA4NjE4LCAzOS4xNzg3NjM0NDEwNjY0Ml1cbiAqICAgIF1cbiAqIH0pO1xuICogbWFwLmFkZFNvdXJjZSgnc29tZSBpZCcsIHNvdXJjZU9iaik7IC8vIGFkZFxuICogbWFwLnJlbW92ZVNvdXJjZSgnc29tZSBpZCcpOyAgLy8gcmVtb3ZlXG4gKi9cbmZ1bmN0aW9uIEltYWdlU291cmNlKG9wdGlvbnMpIHtcbiAgICBhamF4LmdldEltYWdlKG9wdGlvbnMudXJsLCBmdW5jdGlvbihlcnIsIGltYWdlKSB7XG4gICAgICAgIC8vIEBUT0RPIGhhbmRsZSBlcnJvcnMgdmlhIGV2ZW50LlxuICAgICAgICBpZiAoZXJyKSByZXR1cm47XG5cbiAgICAgICAgdGhpcy5pbWFnZSA9IGltYWdlO1xuXG4gICAgICAgIHRoaXMuaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5tYXAuX3JlcmVuZGVyKCk7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgICAgdGhpcy5fbG9hZGVkID0gdHJ1ZTtcblxuICAgICAgICBpZiAodGhpcy5tYXApIHtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlVGlsZShvcHRpb25zLmNvb3JkaW5hdGVzKTtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnY2hhbmdlJyk7XG4gICAgICAgIH1cbiAgICB9LmJpbmQodGhpcykpO1xufVxuXG5JbWFnZVNvdXJjZS5wcm90b3R5cGUgPSB1dGlsLmluaGVyaXQoRXZlbnRlZCwge1xuICAgIG9uQWRkOiBmdW5jdGlvbihtYXApIHtcbiAgICAgICAgdGhpcy5tYXAgPSBtYXA7XG4gICAgICAgIGlmICh0aGlzLmltYWdlKSB7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZVRpbGUoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgd2hpY2ggbWVyY2F0b3IgdGlsZSBpcyBzdWl0YWJsZSBmb3IgcmVuZGVyaW5nIHRoZSBpbWFnZSBpblxuICAgICAqIGFuZCBjcmVhdGUgYSBidWZmZXIgd2l0aCB0aGUgY29ybmVyIGNvb3JkaW5hdGVzLiBUaGVzZSBjb29yZGluYXRlc1xuICAgICAqIG1heSBiZSBvdXRzaWRlIHRoZSB0aWxlLCBiZWNhdXNlIHJhc3RlciB0aWxlcyBhcmVuJ3QgY2xpcHBlZCB3aGVuIHJlbmRlcmluZy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNyZWF0ZVRpbGU6IGZ1bmN0aW9uKGNvcm5lckdlb0Nvb3Jkcykge1xuICAgICAgICB2YXIgbWFwID0gdGhpcy5tYXA7XG4gICAgICAgIHZhciBjb3JuZXJaMENvb3JkcyA9IGNvcm5lckdlb0Nvb3Jkcy5tYXAoZnVuY3Rpb24oY29vcmQpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXAudHJhbnNmb3JtLmxvY2F0aW9uQ29vcmRpbmF0ZShMbmdMYXQuY29udmVydChjb29yZCkpLnpvb21UbygwKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGNlbnRlckNvb3JkID0gdGhpcy5jZW50ZXJDb29yZCA9IHV0aWwuZ2V0Q29vcmRpbmF0ZXNDZW50ZXIoY29ybmVyWjBDb29yZHMpO1xuXG4gICAgICAgIHZhciB0aWxlRXh0ZW50ID0gNDA5NjtcbiAgICAgICAgdmFyIHRpbGVDb29yZHMgPSBjb3JuZXJaMENvb3Jkcy5tYXAoZnVuY3Rpb24oY29vcmQpIHtcbiAgICAgICAgICAgIHZhciB6b29tZWRDb29yZCA9IGNvb3JkLnpvb21UbyhjZW50ZXJDb29yZC56b29tKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoXG4gICAgICAgICAgICAgICAgTWF0aC5yb3VuZCgoem9vbWVkQ29vcmQuY29sdW1uIC0gY2VudGVyQ29vcmQuY29sdW1uKSAqIHRpbGVFeHRlbnQpLFxuICAgICAgICAgICAgICAgIE1hdGgucm91bmQoKHpvb21lZENvb3JkLnJvdyAtIGNlbnRlckNvb3JkLnJvdykgKiB0aWxlRXh0ZW50KSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBnbCA9IG1hcC5wYWludGVyLmdsO1xuICAgICAgICB2YXIgbWF4SW50MTYgPSAzMjc2NztcbiAgICAgICAgdmFyIGFycmF5ID0gbmV3IEludDE2QXJyYXkoW1xuICAgICAgICAgICAgdGlsZUNvb3Jkc1swXS54LCB0aWxlQ29vcmRzWzBdLnksIDAsIDAsXG4gICAgICAgICAgICB0aWxlQ29vcmRzWzFdLngsIHRpbGVDb29yZHNbMV0ueSwgbWF4SW50MTYsIDAsXG4gICAgICAgICAgICB0aWxlQ29vcmRzWzNdLngsIHRpbGVDb29yZHNbM10ueSwgMCwgbWF4SW50MTYsXG4gICAgICAgICAgICB0aWxlQ29vcmRzWzJdLngsIHRpbGVDb29yZHNbMl0ueSwgbWF4SW50MTYsIG1heEludDE2XG4gICAgICAgIF0pO1xuXG4gICAgICAgIHRoaXMudGlsZSA9IG5ldyBUaWxlKCk7XG4gICAgICAgIHRoaXMudGlsZS5idWNrZXRzID0ge307XG5cbiAgICAgICAgdGhpcy50aWxlLmJvdW5kc0J1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy50aWxlLmJvdW5kc0J1ZmZlcik7XG4gICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBhcnJheSwgZ2wuU1RBVElDX0RSQVcpO1xuICAgIH0sXG5cbiAgICBsb2FkZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbWFnZSAmJiB0aGlzLmltYWdlLmNvbXBsZXRlO1xuICAgIH0sXG5cbiAgICB1cGRhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBub29wXG4gICAgfSxcblxuICAgIHJlbG9hZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIG5vb3BcbiAgICB9LFxuXG4gICAgcHJlcGFyZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5fbG9hZGVkIHx8ICF0aGlzLmxvYWRlZCgpKSByZXR1cm47XG5cbiAgICAgICAgdmFyIHBhaW50ZXIgPSB0aGlzLm1hcC5wYWludGVyO1xuICAgICAgICB2YXIgZ2wgPSBwYWludGVyLmdsO1xuXG4gICAgICAgIGlmICghdGhpcy50aWxlLnRleHR1cmUpIHtcbiAgICAgICAgICAgIHRoaXMudGlsZS50ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50aWxlLnRleHR1cmUpO1xuICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVIpO1xuICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLkxJTkVBUik7XG4gICAgICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHRoaXMuaW1hZ2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50aWxlLnRleHR1cmUpO1xuICAgICAgICAgICAgZ2wudGV4U3ViSW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCAwLCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCB0aGlzLmltYWdlKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRWaXNpYmxlQ29vcmRpbmF0ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5jZW50ZXJDb29yZCkgcmV0dXJuIFt0aGlzLmNlbnRlckNvb3JkXTtcbiAgICAgICAgZWxzZSByZXR1cm4gW107XG4gICAgfSxcblxuICAgIGdldFRpbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50aWxlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBbiBJbWFnZVNvdXJjZSBkb2Vzbid0IGhhdmUgYW55IHZlY3RvciBmZWF0dXJlcyB0aGF0IGNvdWxkXG4gICAgICogYmUgc2VsZWN0YWJsZSwgc28gYWx3YXlzIHJldHVybiBhbiBlbXB0eSBhcnJheS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZlYXR1cmVzQXQ6IGZ1bmN0aW9uKHBvaW50LCBwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBbXSk7XG4gICAgfSxcblxuICAgIGZlYXR1cmVzSW46IGZ1bmN0aW9uKGJib3gsIHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIFtdKTtcbiAgICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcbnZhciBhamF4ID0gcmVxdWlyZSgnLi4vdXRpbC9hamF4Jyk7XG52YXIgRXZlbnRlZCA9IHJlcXVpcmUoJy4uL3V0aWwvZXZlbnRlZCcpO1xudmFyIFNvdXJjZSA9IHJlcXVpcmUoJy4vc291cmNlJyk7XG52YXIgbm9ybWFsaXplVVJMID0gcmVxdWlyZSgnLi4vdXRpbC9tYXBib3gnKS5ub3JtYWxpemVUaWxlVVJMO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJhc3RlclRpbGVTb3VyY2U7XG5cbmZ1bmN0aW9uIFJhc3RlclRpbGVTb3VyY2Uob3B0aW9ucykge1xuICAgIHV0aWwuZXh0ZW5kKHRoaXMsIHV0aWwucGljayhvcHRpb25zLCBbJ3VybCcsICd0aWxlU2l6ZSddKSk7XG5cbiAgICBTb3VyY2UuX2xvYWRUaWxlSlNPTi5jYWxsKHRoaXMsIG9wdGlvbnMpO1xufVxuXG5SYXN0ZXJUaWxlU291cmNlLnByb3RvdHlwZSA9IHV0aWwuaW5oZXJpdChFdmVudGVkLCB7XG4gICAgbWluem9vbTogMCxcbiAgICBtYXh6b29tOiAyMixcbiAgICByb3VuZFpvb206IHRydWUsXG4gICAgdGlsZVNpemU6IDUxMixcbiAgICBfbG9hZGVkOiBmYWxzZSxcblxuICAgIG9uQWRkOiBmdW5jdGlvbihtYXApIHtcbiAgICAgICAgdGhpcy5tYXAgPSBtYXA7XG4gICAgfSxcblxuICAgIGxvYWRlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9weXJhbWlkICYmIHRoaXMuX3B5cmFtaWQubG9hZGVkKCk7XG4gICAgfSxcblxuICAgIHVwZGF0ZTogZnVuY3Rpb24odHJhbnNmb3JtKSB7XG4gICAgICAgIGlmICh0aGlzLl9weXJhbWlkKSB7XG4gICAgICAgICAgICB0aGlzLl9weXJhbWlkLnVwZGF0ZSh0aGlzLnVzZWQsIHRyYW5zZm9ybSwgdGhpcy5tYXAuc3R5bGUucmFzdGVyRmFkZUR1cmF0aW9uKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICByZWxvYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBub29wXG4gICAgfSxcblxuICAgIGdldFZpc2libGVDb29yZGluYXRlczogU291cmNlLl9nZXRWaXNpYmxlQ29vcmRpbmF0ZXMsXG4gICAgZ2V0VGlsZTogU291cmNlLl9nZXRUaWxlLFxuXG4gICAgX2xvYWRUaWxlOiBmdW5jdGlvbih0aWxlKSB7XG4gICAgICAgIHZhciB1cmwgPSBub3JtYWxpemVVUkwodGlsZS5jb29yZC51cmwodGhpcy50aWxlcyksIHRoaXMudXJsKTtcblxuICAgICAgICB0aWxlLnJlcXVlc3QgPSBhamF4LmdldEltYWdlKHVybCwgZG9uZS5iaW5kKHRoaXMpKTtcblxuICAgICAgICBmdW5jdGlvbiBkb25lKGVyciwgaW1nKSB7XG4gICAgICAgICAgICBkZWxldGUgdGlsZS5yZXF1ZXN0O1xuXG4gICAgICAgICAgICBpZiAodGlsZS5hYm9ydGVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHRpbGUuZXJyb3JlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlKCd0aWxlLmVycm9yJywge3RpbGU6IHRpbGUsIGVycm9yOiBlcnJ9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBnbCA9IHRoaXMubWFwLnBhaW50ZXIuZ2w7XG4gICAgICAgICAgICB0aWxlLnRleHR1cmUgPSB0aGlzLm1hcC5wYWludGVyLmdldFRleHR1cmUoaW1nLndpZHRoKTtcbiAgICAgICAgICAgIGlmICh0aWxlLnRleHR1cmUpIHtcbiAgICAgICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aWxlLnRleHR1cmUpO1xuICAgICAgICAgICAgICAgIGdsLnRleFN1YkltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgMCwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgaW1nKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGlsZS50ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgICAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRpbGUudGV4dHVyZSk7XG4gICAgICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLkxJTkVBUl9NSVBNQVBfTkVBUkVTVCk7XG4gICAgICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLkxJTkVBUik7XG4gICAgICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICAgICAgICAgICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIGltZyk7XG4gICAgICAgICAgICAgICAgdGlsZS50ZXh0dXJlLnNpemUgPSBpbWcud2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnbC5nZW5lcmF0ZU1pcG1hcChnbC5URVhUVVJFXzJEKTtcblxuICAgICAgICAgICAgdGlsZS50aW1lQWRkZWQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgICAgIHRoaXMubWFwLmFuaW1hdGlvbkxvb3Auc2V0KHRoaXMuc3R5bGUucmFzdGVyRmFkZUR1cmF0aW9uKTtcblxuICAgICAgICAgICAgdGlsZS5zb3VyY2UgPSB0aGlzO1xuICAgICAgICAgICAgdGlsZS5sb2FkZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICB0aGlzLmZpcmUoJ3RpbGUubG9hZCcsIHt0aWxlOiB0aWxlfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2Fib3J0VGlsZTogZnVuY3Rpb24odGlsZSkge1xuICAgICAgICB0aWxlLmFib3J0ZWQgPSB0cnVlO1xuXG4gICAgICAgIGlmICh0aWxlLnJlcXVlc3QpIHtcbiAgICAgICAgICAgIHRpbGUucmVxdWVzdC5hYm9ydCgpO1xuICAgICAgICAgICAgZGVsZXRlIHRpbGUucmVxdWVzdDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfYWRkVGlsZTogZnVuY3Rpb24odGlsZSkge1xuICAgICAgICB0aGlzLmZpcmUoJ3RpbGUuYWRkJywge3RpbGU6IHRpbGV9KTtcbiAgICB9LFxuXG4gICAgX3JlbW92ZVRpbGU6IGZ1bmN0aW9uKHRpbGUpIHtcbiAgICAgICAgdGhpcy5maXJlKCd0aWxlLnJlbW92ZScsIHt0aWxlOiB0aWxlfSk7XG4gICAgfSxcblxuICAgIF91bmxvYWRUaWxlOiBmdW5jdGlvbih0aWxlKSB7XG4gICAgICAgIGlmICh0aWxlLnRleHR1cmUpIHRoaXMubWFwLnBhaW50ZXIuc2F2ZVRleHR1cmUodGlsZS50ZXh0dXJlKTtcbiAgICB9LFxuXG4gICAgZmVhdHVyZXNBdDogZnVuY3Rpb24ocG9pbnQsIHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgW10pO1xuICAgIH0sXG5cbiAgICBmZWF0dXJlc0luOiBmdW5jdGlvbihiYm94LCBwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIFtdKTtcbiAgICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcbnZhciBhamF4ID0gcmVxdWlyZSgnLi4vdXRpbC9hamF4Jyk7XG52YXIgYnJvd3NlciA9IHJlcXVpcmUoJy4uL3V0aWwvYnJvd3NlcicpO1xudmFyIFRpbGVQeXJhbWlkID0gcmVxdWlyZSgnLi90aWxlX3B5cmFtaWQnKTtcbnZhciBub3JtYWxpemVVUkwgPSByZXF1aXJlKCcuLi91dGlsL21hcGJveCcpLm5vcm1hbGl6ZVNvdXJjZVVSTDtcbnZhciBUaWxlQ29vcmQgPSByZXF1aXJlKCcuL3RpbGVfY29vcmQnKTtcblxuZXhwb3J0cy5fbG9hZFRpbGVKU09OID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHZhciBsb2FkZWQgPSBmdW5jdGlvbihlcnIsIHRpbGVKU09OKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnZXJyb3InLCB7ZXJyb3I6IGVycn0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdXRpbC5leHRlbmQodGhpcywgdXRpbC5waWNrKHRpbGVKU09OLFxuICAgICAgICAgICAgWyd0aWxlcycsICdtaW56b29tJywgJ21heHpvb20nLCAnYXR0cmlidXRpb24nXSkpO1xuXG4gICAgICAgIGlmICh0aWxlSlNPTi52ZWN0b3JfbGF5ZXJzKSB7XG4gICAgICAgICAgICB0aGlzLnZlY3RvckxheWVycyA9IHRpbGVKU09OLnZlY3Rvcl9sYXllcnM7XG4gICAgICAgICAgICB0aGlzLnZlY3RvckxheWVySWRzID0gdGhpcy52ZWN0b3JMYXllcnMubWFwKGZ1bmN0aW9uKGxheWVyKSB7IHJldHVybiBsYXllci5pZDsgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9weXJhbWlkID0gbmV3IFRpbGVQeXJhbWlkKHtcbiAgICAgICAgICAgIHRpbGVTaXplOiB0aGlzLnRpbGVTaXplLFxuICAgICAgICAgICAgY2FjaGVTaXplOiAyMCxcbiAgICAgICAgICAgIG1pbnpvb206IHRoaXMubWluem9vbSxcbiAgICAgICAgICAgIG1heHpvb206IHRoaXMubWF4em9vbSxcbiAgICAgICAgICAgIHJvdW5kWm9vbTogdGhpcy5yb3VuZFpvb20sXG4gICAgICAgICAgICByZXBhcnNlT3ZlcnNjYWxlZDogdGhpcy5yZXBhcnNlT3ZlcnNjYWxlZCxcbiAgICAgICAgICAgIGxvYWQ6IHRoaXMuX2xvYWRUaWxlLmJpbmQodGhpcyksXG4gICAgICAgICAgICBhYm9ydDogdGhpcy5fYWJvcnRUaWxlLmJpbmQodGhpcyksXG4gICAgICAgICAgICB1bmxvYWQ6IHRoaXMuX3VubG9hZFRpbGUuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGFkZDogdGhpcy5fYWRkVGlsZS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgcmVtb3ZlOiB0aGlzLl9yZW1vdmVUaWxlLmJpbmQodGhpcyksXG4gICAgICAgICAgICByZWRvUGxhY2VtZW50OiB0aGlzLl9yZWRvVGlsZVBsYWNlbWVudCA/IHRoaXMuX3JlZG9UaWxlUGxhY2VtZW50LmJpbmQodGhpcykgOiB1bmRlZmluZWRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5maXJlKCdsb2FkJyk7XG4gICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgaWYgKG9wdGlvbnMudXJsKSB7XG4gICAgICAgIGFqYXguZ2V0SlNPTihub3JtYWxpemVVUkwob3B0aW9ucy51cmwpLCBsb2FkZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGJyb3dzZXIuZnJhbWUobG9hZGVkLmJpbmQodGhpcywgbnVsbCwgb3B0aW9ucykpO1xuICAgIH1cbn07XG5cbmV4cG9ydHMucmVkb1BsYWNlbWVudCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5fcHlyYW1pZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGlkcyA9IHRoaXMuX3B5cmFtaWQub3JkZXJlZElEcygpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0aWxlID0gdGhpcy5fcHlyYW1pZC5nZXRUaWxlKGlkc1tpXSk7XG4gICAgICAgIHRoaXMuX3JlZG9UaWxlUGxhY2VtZW50KHRpbGUpO1xuICAgIH1cbn07XG5cbmV4cG9ydHMuX2dldFRpbGUgPSBmdW5jdGlvbihjb29yZCkge1xuICAgIHJldHVybiB0aGlzLl9weXJhbWlkLmdldFRpbGUoY29vcmQuaWQpO1xufTtcblxuZXhwb3J0cy5fZ2V0VmlzaWJsZUNvb3JkaW5hdGVzID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLl9weXJhbWlkKSByZXR1cm4gW107XG4gICAgZWxzZSByZXR1cm4gdGhpcy5fcHlyYW1pZC5yZW5kZXJlZElEcygpLm1hcChUaWxlQ29vcmQuZnJvbUlEKTtcbn07XG5cbmV4cG9ydHMuX3ZlY3RvckZlYXR1cmVzQXQgPSBmdW5jdGlvbihjb29yZCwgcGFyYW1zLCBjYWxsYmFjaykge1xuICAgIGlmICghdGhpcy5fcHlyYW1pZClcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIFtdKTtcblxuICAgIHZhciByZXN1bHQgPSB0aGlzLl9weXJhbWlkLnRpbGVBdChjb29yZCk7XG4gICAgaWYgKCFyZXN1bHQpXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBbXSk7XG5cbiAgICB0aGlzLmRpc3BhdGNoZXIuc2VuZCgncXVlcnkgZmVhdHVyZXMnLCB7XG4gICAgICAgIHVpZDogcmVzdWx0LnRpbGUudWlkLFxuICAgICAgICB4OiByZXN1bHQueCxcbiAgICAgICAgeTogcmVzdWx0LnksXG4gICAgICAgIHRpbGVFeHRlbnQ6IHJlc3VsdC50aWxlLnRpbGVFeHRlbnQsXG4gICAgICAgIHNjYWxlOiByZXN1bHQuc2NhbGUsXG4gICAgICAgIHNvdXJjZTogdGhpcy5pZCxcbiAgICAgICAgcGFyYW1zOiBwYXJhbXNcbiAgICB9LCBjYWxsYmFjaywgcmVzdWx0LnRpbGUud29ya2VySUQpO1xufTtcblxuXG5leHBvcnRzLl92ZWN0b3JGZWF0dXJlc0luID0gZnVuY3Rpb24oYm91bmRzLCBwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCF0aGlzLl9weXJhbWlkKVxuICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgW10pO1xuXG4gICAgdmFyIHJlc3VsdHMgPSB0aGlzLl9weXJhbWlkLnRpbGVzSW4oYm91bmRzKTtcbiAgICBpZiAoIXJlc3VsdHMpXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBbXSk7XG5cbiAgICB1dGlsLmFzeW5jQWxsKHJlc3VsdHMsIGZ1bmN0aW9uIHF1ZXJ5VGlsZShyZXN1bHQsIGNiKSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hlci5zZW5kKCdxdWVyeSBmZWF0dXJlcycsIHtcbiAgICAgICAgICAgIHVpZDogcmVzdWx0LnRpbGUudWlkLFxuICAgICAgICAgICAgc291cmNlOiB0aGlzLmlkLFxuICAgICAgICAgICAgbWluWDogcmVzdWx0Lm1pblgsXG4gICAgICAgICAgICBtYXhYOiByZXN1bHQubWF4WCxcbiAgICAgICAgICAgIG1pblk6IHJlc3VsdC5taW5ZLFxuICAgICAgICAgICAgbWF4WTogcmVzdWx0Lm1heFksXG4gICAgICAgICAgICBwYXJhbXM6IHBhcmFtc1xuICAgICAgICB9LCBjYiwgcmVzdWx0LnRpbGUud29ya2VySUQpO1xuICAgIH0uYmluZCh0aGlzKSwgZnVuY3Rpb24gZG9uZShlcnIsIGZlYXR1cmVzKSB7XG4gICAgICAgIGNhbGxiYWNrKGVyciwgQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgZmVhdHVyZXMpKTtcbiAgICB9KTtcbn07XG5cbi8qXG4gKiBDcmVhdGUgYSB0aWxlZCBkYXRhIHNvdXJjZSBpbnN0YW5jZSBnaXZlbiBhbiBvcHRpb25zIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy50eXBlIEVpdGhlciBgcmFzdGVyYCBvciBgdmVjdG9yYC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnVybCBBIHRpbGUgc291cmNlIFVSTC4gVGhpcyBzaG91bGQgZWl0aGVyIGJlIGBtYXBib3g6Ly97bWFwaWR9YCBvciBhIGZ1bGwgYGh0dHBbc11gIHVybCB0aGF0IHBvaW50cyB0byBhIFRpbGVKU09OIGVuZHBvaW50LlxuICogQHBhcmFtIHtBcnJheX0gb3B0aW9ucy50aWxlcyBBbiBhcnJheSBvZiB0aWxlIHNvdXJjZXMuIElmIGB1cmxgIGlzIG5vdCBzcGVjaWZpZWQsIGB0aWxlc2AgY2FuIGJlIHVzZWQgaW5zdGVhZCB0byBzcGVjaWZ5IHRpbGUgc291cmNlcywgYXMgaW4gdGhlIFRpbGVKU09OIHNwZWMuIE90aGVyIFRpbGVKU09OIGtleXMgc3VjaCBhcyBgbWluem9vbWAgYW5kIGBtYXh6b29tYCBjYW4gYmUgc3BlY2lmaWVkIGluIGEgc291cmNlIG9iamVjdCBpZiBgdGlsZXNgIGlzIHVzZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5pZCBBbiBvcHRpb25hbCBgaWRgIHRvIGFzc2lnbiB0byB0aGUgc291cmNlXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMudGlsZVNpemU9NTEyXSBPcHRpb25hbCB0aWxlIHNpemUgKHdpZHRoIGFuZCBoZWlnaHQgaW4gcGl4ZWxzLCBhc3N1bWluZyB0aWxlcyBhcmUgc3F1YXJlKS4gVGhpcyBvcHRpb24gaXMgb25seSBjb25maWd1cmFibGUgZm9yIHJhc3RlciBzb3VyY2VzXG4gKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5jYWNoZVNpemUgT3B0aW9uYWwgbWF4IG51bWJlciBvZiB0aWxlcyB0byBjYWNoZSBhdCBhbnkgZ2l2ZW4gdGltZVxuICogQGV4YW1wbGVcbiAqIHZhciBzb3VyY2VPYmogPSBuZXcgbWFwYm94Z2wuU291cmNlLmNyZWF0ZSh7XG4gKiAgICB0eXBlOiAndmVjdG9yJyxcbiAqICAgIHVybDogJ21hcGJveDovL21hcGJveC5tYXBib3gtc3RyZWV0cy12NSdcbiAqIH0pO1xuICogbWFwLmFkZFNvdXJjZSgnc29tZSBpZCcsIHNvdXJjZU9iaik7IC8vIGFkZFxuICogbWFwLnJlbW92ZVNvdXJjZSgnc29tZSBpZCcpOyAgLy8gcmVtb3ZlXG4gKi9cbmV4cG9ydHMuY3JlYXRlID0gZnVuY3Rpb24oc291cmNlKSB7XG4gICAgLy8gVGhpcyBpcyBub3QgYXQgZmlsZSBzY29wZSBpbiBvcmRlciB0byBhdm9pZCBhIGNpcmN1bGFyIHJlcXVpcmUuXG4gICAgdmFyIHNvdXJjZXMgPSB7XG4gICAgICAgIHZlY3RvcjogcmVxdWlyZSgnLi92ZWN0b3JfdGlsZV9zb3VyY2UnKSxcbiAgICAgICAgcmFzdGVyOiByZXF1aXJlKCcuL3Jhc3Rlcl90aWxlX3NvdXJjZScpLFxuICAgICAgICBnZW9qc29uOiByZXF1aXJlKCcuL2dlb2pzb25fc291cmNlJyksXG4gICAgICAgIHZpZGVvOiByZXF1aXJlKCcuL3ZpZGVvX3NvdXJjZScpLFxuICAgICAgICBpbWFnZTogcmVxdWlyZSgnLi9pbWFnZV9zb3VyY2UnKVxuICAgIH07XG5cbiAgICBmb3IgKHZhciB0eXBlIGluIHNvdXJjZXMpIHtcbiAgICAgICAgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIHNvdXJjZXNbdHlwZV0pIHtcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IHNvdXJjZXNbc291cmNlLnR5cGVdKHNvdXJjZSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJy4uL2RhdGEvYnVmZmVyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gVGlsZTtcblxuLyoqXG4gKiBBIHRpbGUgb2JqZWN0IGlzIHRoZSBjb21iaW5hdGlvbiBvZiBhIENvb3JkaW5hdGUsIHdoaWNoIGRlZmluZXNcbiAqIGl0cyBwbGFjZSwgYXMgd2VsbCBhcyBhIHVuaXF1ZSBJRCBhbmQgZGF0YSB0cmFja2luZyBmb3IgaXRzIGNvbnRlbnRcbiAqXG4gKiBAcGFyYW0ge0Nvb3JkaW5hdGV9IGNvb3JkXG4gKiBAcGFyYW0ge251bWJlcn0gc2l6ZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gVGlsZShjb29yZCwgc2l6ZSwgc291cmNlTWF4Wm9vbSkge1xuICAgIHRoaXMuY29vcmQgPSBjb29yZDtcbiAgICB0aGlzLnVpZCA9IHV0aWwudW5pcXVlSWQoKTtcbiAgICB0aGlzLmxvYWRlZCA9IGZhbHNlO1xuICAgIHRoaXMudXNlcyA9IDA7XG4gICAgdGhpcy50aWxlU2l6ZSA9IHNpemU7XG4gICAgdGhpcy5zb3VyY2VNYXhab29tID0gc291cmNlTWF4Wm9vbTtcbn1cblxuVGlsZS5wcm90b3R5cGUgPSB7XG4gICAgLy8gdG9kbyB1bmhhcmRjb2RlXG4gICAgdGlsZUV4dGVudDogNDA5NixcblxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgY29vcmRpbmF0ZSBwb3NpdGlvbiwgem9vbSB0aGF0IGNvb3JkaW5hdGUgdG8gbXkgem9vbSBhbmRcbiAgICAgKiBzY2FsZSBhbmQgcmV0dXJuIGEgcG9zaXRpb24gaW4geCwgeSwgc2NhbGVcbiAgICAgKiBAcGFyYW0ge0Nvb3JkaW5hdGV9IGNvb3JkXG4gICAgICogQHJldHVybnMge09iamVjdH0gcG9zaXRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHBvc2l0aW9uQXQ6IGZ1bmN0aW9uKGNvb3JkKSB7XG4gICAgICAgIHZhciB6b29tZWRDb29yZCA9IGNvb3JkLnpvb21UbyhNYXRoLm1pbih0aGlzLmNvb3JkLnosIHRoaXMuc291cmNlTWF4Wm9vbSkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogKHpvb21lZENvb3JkLmNvbHVtbiAtIHRoaXMuY29vcmQueCkgKiB0aGlzLnRpbGVFeHRlbnQsXG4gICAgICAgICAgICB5OiAoem9vbWVkQ29vcmQucm93IC0gdGhpcy5jb29yZC55KSAqIHRoaXMudGlsZUV4dGVudFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIGRhdGEgb2JqZWN0IHdpdGggYSAnYnVmZmVycycgcHJvcGVydHksIGxvYWQgaXQgaW50b1xuICAgICAqIHRoaXMgdGlsZSdzIGVsZW1lbnRHcm91cHMgYW5kIGJ1ZmZlcnMgcHJvcGVydGllcyBhbmQgc2V0IGxvYWRlZFxuICAgICAqIHRvIHRydWUuIElmIHRoZSBkYXRhIGlzIG51bGwsIGxpa2UgaW4gdGhlIGNhc2Ugb2YgYW4gZW1wdHlcbiAgICAgKiBHZW9KU09OIHRpbGUsIG5vLW9wIGJ1dCBzdGlsbCBzZXQgbG9hZGVkIHRvIHRydWUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgbG9hZFZlY3RvckRhdGE6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgdGhpcy5sb2FkZWQgPSB0cnVlO1xuXG4gICAgICAgIC8vIGVtcHR5IEdlb0pTT04gdGlsZVxuICAgICAgICBpZiAoIWRhdGEpIHJldHVybjtcblxuICAgICAgICB0aGlzLmJ1ZmZlcnMgPSB1bnNlcmlhbGl6ZUJ1ZmZlcnMoZGF0YS5idWZmZXJzKTtcbiAgICAgICAgdGhpcy5lbGVtZW50R3JvdXBzID0gZGF0YS5lbGVtZW50R3JvdXBzO1xuICAgICAgICB0aGlzLnRpbGVFeHRlbnQgPSBkYXRhLmV4dGVudDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZ2l2ZW4gYSBkYXRhIG9iamVjdCBhbmQgYSBHTCBwYWludGVyLCBkZXN0cm95IGFuZCByZS1jcmVhdGVcbiAgICAgKiBhbGwgb2YgaXRzIGJ1ZmZlcnMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFpbnRlclxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICByZWxvYWRTeW1ib2xEYXRhOiBmdW5jdGlvbihkYXRhLCBwYWludGVyKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLmJ1ZmZlcnMpIHtcbiAgICAgICAgICAgIC8vIHRoZSB0aWxlIGhhcyBiZWVuIGRlc3Ryb3llZFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuYnVmZmVycy5nbHlwaFZlcnRleCkgdGhpcy5idWZmZXJzLmdseXBoVmVydGV4LmRlc3Ryb3kocGFpbnRlci5nbCk7XG4gICAgICAgIGlmICh0aGlzLmJ1ZmZlcnMuZ2x5cGhFbGVtZW50KSB0aGlzLmJ1ZmZlcnMuZ2x5cGhFbGVtZW50LmRlc3Ryb3kocGFpbnRlci5nbCk7XG4gICAgICAgIGlmICh0aGlzLmJ1ZmZlcnMuaWNvblZlcnRleCkgdGhpcy5idWZmZXJzLmljb25WZXJ0ZXguZGVzdHJveShwYWludGVyLmdsKTtcbiAgICAgICAgaWYgKHRoaXMuYnVmZmVycy5pY29uRWxlbWVudCkgdGhpcy5idWZmZXJzLmljb25FbGVtZW50LmRlc3Ryb3kocGFpbnRlci5nbCk7XG4gICAgICAgIGlmICh0aGlzLmJ1ZmZlcnMuY29sbGlzaW9uQm94VmVydGV4KSB0aGlzLmJ1ZmZlcnMuY29sbGlzaW9uQm94VmVydGV4LmRlc3Ryb3kocGFpbnRlci5nbCk7XG5cbiAgICAgICAgdmFyIGJ1ZmZlcnMgPSB1bnNlcmlhbGl6ZUJ1ZmZlcnMoZGF0YS5idWZmZXJzKTtcbiAgICAgICAgdGhpcy5idWZmZXJzLmdseXBoVmVydGV4ID0gYnVmZmVycy5nbHlwaFZlcnRleDtcbiAgICAgICAgdGhpcy5idWZmZXJzLmdseXBoRWxlbWVudCA9IGJ1ZmZlcnMuZ2x5cGhFbGVtZW50O1xuICAgICAgICB0aGlzLmJ1ZmZlcnMuaWNvblZlcnRleCA9IGJ1ZmZlcnMuaWNvblZlcnRleDtcbiAgICAgICAgdGhpcy5idWZmZXJzLmljb25FbGVtZW50ID0gYnVmZmVycy5pY29uRWxlbWVudDtcbiAgICAgICAgdGhpcy5idWZmZXJzLmNvbGxpc2lvbkJveFZlcnRleCA9IGJ1ZmZlcnMuY29sbGlzaW9uQm94VmVydGV4O1xuXG4gICAgICAgIGZvciAodmFyIGlkIGluIGRhdGEuZWxlbWVudEdyb3Vwcykge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50R3JvdXBzW2lkXSA9IGRhdGEuZWxlbWVudEdyb3Vwc1tpZF07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBzdXJlIHRoYXQgdGhpcyB0aWxlIGRvZXNuJ3Qgb3duIGFueSBkYXRhIHdpdGhpbiBhIGdpdmVuXG4gICAgICogcGFpbnRlciwgc28gdGhhdCBpdCBkb2Vzbid0IGNvbnN1bWUgYW55IG1lbW9yeSBvciBtYWludGFpblxuICAgICAqIGFueSByZWZlcmVuY2VzIHRvIHRoZSBwYWludGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYWludGVyIGdsIHBhaW50ZXIgb2JqZWN0XG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHVubG9hZFZlY3RvckRhdGE6IGZ1bmN0aW9uKHBhaW50ZXIpIHtcbiAgICAgICAgZm9yICh2YXIgYiBpbiB0aGlzLmJ1ZmZlcnMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmJ1ZmZlcnNbYl0pIHRoaXMuYnVmZmVyc1tiXS5kZXN0cm95KHBhaW50ZXIuZ2wpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYnVmZmVycyA9IG51bGw7XG4gICAgfSxcblxuICAgIHJlZG9QbGFjZW1lbnQ6IGZ1bmN0aW9uKHNvdXJjZSkge1xuICAgICAgICBpZiAoIXRoaXMubG9hZGVkIHx8IHRoaXMucmVkb2luZ1BsYWNlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5yZWRvV2hlbkRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZWRvaW5nUGxhY2VtZW50ID0gdHJ1ZTtcblxuICAgICAgICBzb3VyY2UuZGlzcGF0Y2hlci5zZW5kKCdyZWRvIHBsYWNlbWVudCcsIHtcbiAgICAgICAgICAgIHVpZDogdGhpcy51aWQsXG4gICAgICAgICAgICBzb3VyY2U6IHNvdXJjZS5pZCxcbiAgICAgICAgICAgIGFuZ2xlOiBzb3VyY2UubWFwLnRyYW5zZm9ybS5hbmdsZSxcbiAgICAgICAgICAgIHBpdGNoOiBzb3VyY2UubWFwLnRyYW5zZm9ybS5waXRjaCxcbiAgICAgICAgICAgIGNvbGxpc2lvbkRlYnVnOiBzb3VyY2UubWFwLmNvbGxpc2lvbkRlYnVnXG4gICAgICAgIH0sIGRvbmUuYmluZCh0aGlzKSwgdGhpcy53b3JrZXJJRCk7XG5cbiAgICAgICAgZnVuY3Rpb24gZG9uZShfLCBkYXRhKSB7XG4gICAgICAgICAgICB0aGlzLnJlbG9hZFN5bWJvbERhdGEoZGF0YSwgc291cmNlLm1hcC5wYWludGVyKTtcbiAgICAgICAgICAgIHNvdXJjZS5maXJlKCd0aWxlLmxvYWQnLCB7dGlsZTogdGhpc30pO1xuXG4gICAgICAgICAgICB0aGlzLnJlZG9pbmdQbGFjZW1lbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlZG9XaGVuRG9uZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVkb1BsYWNlbWVudChzb3VyY2UpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVkb1doZW5Eb25lID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0RWxlbWVudEdyb3VwczogZnVuY3Rpb24obGF5ZXIsIHNoYWRlck5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudEdyb3VwcyAmJiB0aGlzLmVsZW1lbnRHcm91cHNbbGF5ZXIucmVmIHx8IGxheWVyLmlkXSAmJiB0aGlzLmVsZW1lbnRHcm91cHNbbGF5ZXIucmVmIHx8IGxheWVyLmlkXVtzaGFkZXJOYW1lXTtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiB1bnNlcmlhbGl6ZUJ1ZmZlcnMoaW5wdXQpIHtcbiAgICB2YXIgb3V0cHV0ID0ge307XG4gICAgZm9yICh2YXIgayBpbiBpbnB1dCkge1xuICAgICAgICBvdXRwdXRba10gPSBuZXcgQnVmZmVyKGlucHV0W2tdKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xudmFyIENvb3JkaW5hdGUgPSByZXF1aXJlKCcuLi9nZW8vY29vcmRpbmF0ZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRpbGVDb29yZDtcblxuZnVuY3Rpb24gVGlsZUNvb3JkKHosIHgsIHksIHcpIHtcbiAgICBhc3NlcnQoIWlzTmFOKHopICYmIHogPj0gMCAmJiB6ICUgMSA9PT0gMCk7XG4gICAgYXNzZXJ0KCFpc05hTih4KSAmJiB4ID49IDAgJiYgeCAlIDEgPT09IDApO1xuICAgIGFzc2VydCghaXNOYU4oeSkgJiYgeSA+PSAwICYmIHkgJSAxID09PSAwKTtcblxuICAgIGlmIChpc05hTih3KSkgdyA9IDA7XG5cbiAgICB0aGlzLnogPSArejtcbiAgICB0aGlzLnggPSAreDtcbiAgICB0aGlzLnkgPSAreTtcbiAgICB0aGlzLncgPSArdztcblxuICAgIC8vIGNhbGN1bGF0ZSBpZFxuICAgIHcgKj0gMjtcbiAgICBpZiAodyA8IDApIHcgPSB3ICogLTEgLSAxO1xuICAgIHZhciBkaW0gPSAxIDw8IHRoaXMuejtcbiAgICB0aGlzLmlkID0gKChkaW0gKiBkaW0gKiB3ICsgZGltICogdGhpcy55ICsgdGhpcy54KSAqIDMyKSArIHRoaXMuejtcbn1cblxuVGlsZUNvb3JkLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnogKyBcIi9cIiArIHRoaXMueCArIFwiL1wiICsgdGhpcy55O1xufTtcblxuVGlsZUNvb3JkLnByb3RvdHlwZS50b0Nvb3JkaW5hdGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgem9vbSA9IHRoaXMuejtcbiAgICB2YXIgdGlsZVNjYWxlID0gTWF0aC5wb3coMiwgem9vbSk7XG4gICAgdmFyIHJvdyA9IHRoaXMueTtcbiAgICB2YXIgY29sdW1uID0gdGhpcy54ICsgdGlsZVNjYWxlICogdGhpcy53O1xuICAgIHJldHVybiBuZXcgQ29vcmRpbmF0ZShjb2x1bW4sIHJvdywgem9vbSk7XG59O1xuXG4vLyBQYXJzZSBhIHBhY2tlZCBpbnRlZ2VyIGlkIGludG8gYSBUaWxlQ29vcmQgb2JqZWN0XG5UaWxlQ29vcmQuZnJvbUlEID0gZnVuY3Rpb24oaWQpIHtcbiAgICB2YXIgeiA9IGlkICUgMzIsIGRpbSA9IDEgPDwgejtcbiAgICB2YXIgeHkgPSAoKGlkIC0geikgLyAzMik7XG4gICAgdmFyIHggPSB4eSAlIGRpbSwgeSA9ICgoeHkgLSB4KSAvIGRpbSkgJSBkaW07XG4gICAgdmFyIHcgPSBNYXRoLmZsb29yKHh5IC8gKGRpbSAqIGRpbSkpO1xuICAgIGlmICh3ICUgMiAhPT0gMCkgdyA9IHcgKiAtMSAtIDE7XG4gICAgdyAvPSAyO1xuICAgIHJldHVybiBuZXcgVGlsZUNvb3JkKHosIHgsIHksIHcpO1xufTtcblxuLy8gZ2l2ZW4gYSBsaXN0IG9mIHVybHMsIGNob29zZSBhIHVybCB0ZW1wbGF0ZSBhbmQgcmV0dXJuIGEgdGlsZSBVUkxcblRpbGVDb29yZC5wcm90b3R5cGUudXJsID0gZnVuY3Rpb24odXJscywgc291cmNlTWF4Wm9vbSkge1xuICAgIHJldHVybiB1cmxzWyh0aGlzLnggKyB0aGlzLnkpICUgdXJscy5sZW5ndGhdXG4gICAgICAgIC5yZXBsYWNlKCd7cHJlZml4fScsICh0aGlzLnggJSAxNikudG9TdHJpbmcoMTYpICsgKHRoaXMueSAlIDE2KS50b1N0cmluZygxNikpXG4gICAgICAgIC5yZXBsYWNlKCd7en0nLCBNYXRoLm1pbih0aGlzLnosIHNvdXJjZU1heFpvb20gfHwgdGhpcy56KSlcbiAgICAgICAgLnJlcGxhY2UoJ3t4fScsIHRoaXMueClcbiAgICAgICAgLnJlcGxhY2UoJ3t5fScsIHRoaXMueSk7XG59O1xuXG4vLyBSZXR1cm4gdGhlIGNvb3JkaW5hdGUgb2YgdGhlIHBhcmVudCB0aWxlXG5UaWxlQ29vcmQucHJvdG90eXBlLnBhcmVudCA9IGZ1bmN0aW9uKHNvdXJjZU1heFpvb20pIHtcbiAgICBpZiAodGhpcy56ID09PSAwKSByZXR1cm4gbnVsbDtcblxuICAgIC8vIHRoZSBpZCByZXByZXNlbnRzIGFuIG92ZXJzY2FsZWQgdGlsZSwgcmV0dXJuIHRoZSBzYW1lIGNvb3JkaW5hdGVzIHdpdGggYSBsb3dlciB6XG4gICAgaWYgKHRoaXMueiA+IHNvdXJjZU1heFpvb20pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUaWxlQ29vcmQodGhpcy56IC0gMSwgdGhpcy54LCB0aGlzLnksIHRoaXMudyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBUaWxlQ29vcmQodGhpcy56IC0gMSwgTWF0aC5mbG9vcih0aGlzLnggLyAyKSwgTWF0aC5mbG9vcih0aGlzLnkgLyAyKSwgdGhpcy53KTtcbn07XG5cblRpbGVDb29yZC5wcm90b3R5cGUud3JhcHBlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgVGlsZUNvb3JkKHRoaXMueiwgdGhpcy54LCB0aGlzLnksIDApO1xufTtcblxuLy8gUmV0dXJuIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgdGlsZSdzIGNoaWxkcmVuXG5UaWxlQ29vcmQucHJvdG90eXBlLmNoaWxkcmVuID0gZnVuY3Rpb24oc291cmNlTWF4Wm9vbSkge1xuXG4gICAgaWYgKHRoaXMueiA+PSBzb3VyY2VNYXhab29tKSB7XG4gICAgICAgIC8vIHJldHVybiBhIHNpbmdsZSB0aWxlIGNvb3JkIHJlcHJlc2VudGluZyBhIGFuIG92ZXJzY2FsZWQgdGlsZVxuICAgICAgICByZXR1cm4gW25ldyBUaWxlQ29vcmQodGhpcy56ICsgMSwgdGhpcy54LCB0aGlzLnksIHRoaXMudyldO1xuICAgIH1cblxuICAgIHZhciB6ID0gdGhpcy56ICsgMTtcbiAgICB2YXIgeCA9IHRoaXMueCAqIDI7XG4gICAgdmFyIHkgPSB0aGlzLnkgKiAyO1xuICAgIHJldHVybiBbXG4gICAgICAgIG5ldyBUaWxlQ29vcmQoeiwgeCwgeSwgdGhpcy53KSxcbiAgICAgICAgbmV3IFRpbGVDb29yZCh6LCB4ICsgMSwgeSwgdGhpcy53KSxcbiAgICAgICAgbmV3IFRpbGVDb29yZCh6LCB4LCB5ICsgMSwgdGhpcy53KSxcbiAgICAgICAgbmV3IFRpbGVDb29yZCh6LCB4ICsgMSwgeSArIDEsIHRoaXMudylcbiAgICBdO1xufTtcblxuLy8gVGFrZW4gZnJvbSBwb2x5bWFwcyBzcmMvTGF5ZXIuanNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW1wbGVnZW8vcG9seW1hcHMvYmxvYi9tYXN0ZXIvc3JjL0xheWVyLmpzI0wzMzMtTDM4M1xuXG5mdW5jdGlvbiBlZGdlKGEsIGIpIHtcbiAgICBpZiAoYS5yb3cgPiBiLnJvdykgeyB2YXIgdCA9IGE7IGEgPSBiOyBiID0gdDsgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHgwOiBhLmNvbHVtbixcbiAgICAgICAgeTA6IGEucm93LFxuICAgICAgICB4MTogYi5jb2x1bW4sXG4gICAgICAgIHkxOiBiLnJvdyxcbiAgICAgICAgZHg6IGIuY29sdW1uIC0gYS5jb2x1bW4sXG4gICAgICAgIGR5OiBiLnJvdyAtIGEucm93XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gc2NhblNwYW5zKGUwLCBlMSwgeW1pbiwgeW1heCwgc2NhbkxpbmUpIHtcbiAgICB2YXIgeTAgPSBNYXRoLm1heCh5bWluLCBNYXRoLmZsb29yKGUxLnkwKSk7XG4gICAgdmFyIHkxID0gTWF0aC5taW4oeW1heCwgTWF0aC5jZWlsKGUxLnkxKSk7XG5cbiAgICAvLyBzb3J0IGVkZ2VzIGJ5IHgtY29vcmRpbmF0ZVxuICAgIGlmICgoZTAueDAgPT09IGUxLngwICYmIGUwLnkwID09PSBlMS55MCkgP1xuICAgICAgICAgICAgKGUwLngwICsgZTEuZHkgLyBlMC5keSAqIGUwLmR4IDwgZTEueDEpIDpcbiAgICAgICAgICAgIChlMC54MSAtIGUxLmR5IC8gZTAuZHkgKiBlMC5keCA8IGUxLngwKSkge1xuICAgICAgICB2YXIgdCA9IGUwOyBlMCA9IGUxOyBlMSA9IHQ7XG4gICAgfVxuXG4gICAgLy8gc2NhbiBsaW5lcyFcbiAgICB2YXIgbTAgPSBlMC5keCAvIGUwLmR5O1xuICAgIHZhciBtMSA9IGUxLmR4IC8gZTEuZHk7XG4gICAgdmFyIGQwID0gZTAuZHggPiAwOyAvLyB1c2UgeSArIDEgdG8gY29tcHV0ZSB4MFxuICAgIHZhciBkMSA9IGUxLmR4IDwgMDsgLy8gdXNlIHkgKyAxIHRvIGNvbXB1dGUgeDFcbiAgICBmb3IgKHZhciB5ID0geTA7IHkgPCB5MTsgeSsrKSB7XG4gICAgICAgIHZhciB4MCA9IG0wICogTWF0aC5tYXgoMCwgTWF0aC5taW4oZTAuZHksIHkgKyBkMCAtIGUwLnkwKSkgKyBlMC54MDtcbiAgICAgICAgdmFyIHgxID0gbTEgKiBNYXRoLm1heCgwLCBNYXRoLm1pbihlMS5keSwgeSArIGQxIC0gZTEueTApKSArIGUxLngwO1xuICAgICAgICBzY2FuTGluZShNYXRoLmZsb29yKHgxKSwgTWF0aC5jZWlsKHgwKSwgeSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzY2FuVHJpYW5nbGUoYSwgYiwgYywgeW1pbiwgeW1heCwgc2NhbkxpbmUpIHtcbiAgICB2YXIgYWIgPSBlZGdlKGEsIGIpLFxuICAgICAgICBiYyA9IGVkZ2UoYiwgYyksXG4gICAgICAgIGNhID0gZWRnZShjLCBhKTtcblxuICAgIHZhciB0O1xuXG4gICAgLy8gc29ydCBlZGdlcyBieSB5LWxlbmd0aFxuICAgIGlmIChhYi5keSA+IGJjLmR5KSB7IHQgPSBhYjsgYWIgPSBiYzsgYmMgPSB0OyB9XG4gICAgaWYgKGFiLmR5ID4gY2EuZHkpIHsgdCA9IGFiOyBhYiA9IGNhOyBjYSA9IHQ7IH1cbiAgICBpZiAoYmMuZHkgPiBjYS5keSkgeyB0ID0gYmM7IGJjID0gY2E7IGNhID0gdDsgfVxuXG4gICAgLy8gc2NhbiBzcGFuISBzY2FuIHNwYW4hXG4gICAgaWYgKGFiLmR5KSBzY2FuU3BhbnMoY2EsIGFiLCB5bWluLCB5bWF4LCBzY2FuTGluZSk7XG4gICAgaWYgKGJjLmR5KSBzY2FuU3BhbnMoY2EsIGJjLCB5bWluLCB5bWF4LCBzY2FuTGluZSk7XG59XG5cblRpbGVDb29yZC5jb3ZlciA9IGZ1bmN0aW9uKHosIGJvdW5kcywgYWN0dWFsWikge1xuICAgIHZhciB0aWxlcyA9IDEgPDwgejtcbiAgICB2YXIgdCA9IHt9O1xuXG4gICAgZnVuY3Rpb24gc2NhbkxpbmUoeDAsIHgxLCB5KSB7XG4gICAgICAgIHZhciB4LCB3eCwgY29vcmQ7XG4gICAgICAgIGlmICh5ID49IDAgJiYgeSA8PSB0aWxlcykge1xuICAgICAgICAgICAgZm9yICh4ID0geDA7IHggPCB4MTsgeCsrKSB7XG4gICAgICAgICAgICAgICAgd3ggPSAoeCAlIHRpbGVzICsgdGlsZXMpICUgdGlsZXM7XG4gICAgICAgICAgICAgICAgY29vcmQgPSBuZXcgVGlsZUNvb3JkKGFjdHVhbFosIHd4LCB5LCBNYXRoLmZsb29yKHggLyB0aWxlcykpO1xuICAgICAgICAgICAgICAgIHRbY29vcmQuaWRdID0gY29vcmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEaXZpZGUgdGhlIHNjcmVlbiB1cCBpbiB0d28gdHJpYW5nbGVzIGFuZCBzY2FuIGVhY2ggb2YgdGhlbTpcbiAgICAvLyArLS0tL1xuICAgIC8vIHwgLyB8XG4gICAgLy8gLy0tLStcbiAgICBzY2FuVHJpYW5nbGUoYm91bmRzWzBdLCBib3VuZHNbMV0sIGJvdW5kc1syXSwgMCwgdGlsZXMsIHNjYW5MaW5lKTtcbiAgICBzY2FuVHJpYW5nbGUoYm91bmRzWzJdLCBib3VuZHNbM10sIGJvdW5kc1swXSwgMCwgdGlsZXMsIHNjYW5MaW5lKTtcblxuICAgIHJldHVybiBPYmplY3Qua2V5cyh0KS5tYXAoZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgcmV0dXJuIHRbaWRdO1xuICAgIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFRpbGUgPSByZXF1aXJlKCcuL3RpbGUnKTtcbnZhciBUaWxlQ29vcmQgPSByZXF1aXJlKCcuL3RpbGVfY29vcmQnKTtcbnZhciBQb2ludCA9IHJlcXVpcmUoJ3BvaW50LWdlb21ldHJ5Jyk7XG52YXIgQ2FjaGUgPSByZXF1aXJlKCcuLi91dGlsL21ydV9jYWNoZScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBUaWxlUHlyYW1pZDtcblxuLyoqXG4gKiBBIHRpbGUgcHlyYW1pZCBpcyBhIHNwZWNpYWxpemVkIGNhY2hlIGFuZCBkYXRhc3RydWN0dXJlXG4gKiB0aGF0IGNvbnRhaW5zIHRpbGVzLiBJdCdzIHVzZWQgYnkgc291cmNlcyB0byBtYW5hZ2UgdGhlaXJcbiAqIGRhdGEuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnRpbGVTaXplXG4gKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5taW56b29tXG4gKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5tYXh6b29tXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBUaWxlUHlyYW1pZChvcHRpb25zKSB7XG4gICAgdGhpcy50aWxlU2l6ZSA9IG9wdGlvbnMudGlsZVNpemU7XG4gICAgdGhpcy5taW56b29tID0gb3B0aW9ucy5taW56b29tO1xuICAgIHRoaXMubWF4em9vbSA9IG9wdGlvbnMubWF4em9vbTtcbiAgICB0aGlzLnJvdW5kWm9vbSA9IG9wdGlvbnMucm91bmRab29tO1xuICAgIHRoaXMucmVwYXJzZU92ZXJzY2FsZWQgPSBvcHRpb25zLnJlcGFyc2VPdmVyc2NhbGVkO1xuXG4gICAgdGhpcy5fbG9hZCA9IG9wdGlvbnMubG9hZDtcbiAgICB0aGlzLl9hYm9ydCA9IG9wdGlvbnMuYWJvcnQ7XG4gICAgdGhpcy5fdW5sb2FkID0gb3B0aW9ucy51bmxvYWQ7XG4gICAgdGhpcy5fYWRkID0gb3B0aW9ucy5hZGQ7XG4gICAgdGhpcy5fcmVtb3ZlID0gb3B0aW9ucy5yZW1vdmU7XG4gICAgdGhpcy5fcmVkb1BsYWNlbWVudCA9IG9wdGlvbnMucmVkb1BsYWNlbWVudDtcblxuICAgIHRoaXMuX3RpbGVzID0ge307XG4gICAgdGhpcy5fY2FjaGUgPSBuZXcgQ2FjaGUob3B0aW9ucy5jYWNoZVNpemUsIGZ1bmN0aW9uKHRpbGUpIHsgcmV0dXJuIHRoaXMuX3VubG9hZCh0aWxlKTsgfS5iaW5kKHRoaXMpKTtcblxuICAgIHRoaXMuX2ZpbHRlclJlbmRlcmVkID0gdGhpcy5fZmlsdGVyUmVuZGVyZWQuYmluZCh0aGlzKTtcbn1cblxuVGlsZVB5cmFtaWQucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIENvbmZpcm0gdGhhdCBldmVyeSB0cmFja2VkIHRpbGUgaXMgbG9hZGVkLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIGFsbCB0aWxlcyBhcmUgbG9hZGVkLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgbG9hZGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yICh2YXIgdCBpbiB0aGlzLl90aWxlcykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl90aWxlc1t0XS5sb2FkZWQgJiYgIXRoaXMuX3RpbGVzW3RdLmVycm9yZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYWxsIHRpbGUgaWRzIG9yZGVyZWQgd2l0aCB6LW9yZGVyLCBhbmQgY2FzdCB0byBudW1iZXJzXG4gICAgICogQHJldHVybnMge0FycmF5PG51bWJlcj59IGlkc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb3JkZXJlZElEczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl90aWxlcykubWFwKE51bWJlcikuc29ydChjb21wYXJlS2V5Wm9vbSk7XG4gICAgfSxcblxuICAgIHJlbmRlcmVkSURzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3JkZXJlZElEcygpLmZpbHRlcih0aGlzLl9maWx0ZXJSZW5kZXJlZCk7XG4gICAgfSxcblxuICAgIF9maWx0ZXJSZW5kZXJlZDogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RpbGVzW2lkXS5sb2FkZWQgJiYgIXRoaXMuX2NvdmVyZWRUaWxlc1tpZF07XG4gICAgfSxcblxuICAgIHJlbG9hZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX2NhY2hlLnJlc2V0KCk7XG4gICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5fdGlsZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvYWQodGhpcy5fdGlsZXNbaV0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBhIHNwZWNpZmljIHRpbGUgYnkgaWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IGlkIHRpbGUgaWRcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSB0aWxlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnZXRUaWxlOiBmdW5jdGlvbihpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGlsZXNbaWRdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBnZXQgdGhlIHpvb20gbGV2ZWwgYWRqdXN0ZWQgZm9yIHRoZSBkaWZmZXJlbmNlIGluIG1hcCBhbmQgc291cmNlIHRpbGVzaXplc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2Zvcm1cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSB6b29tIGxldmVsXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnZXRab29tOiBmdW5jdGlvbih0cmFuc2Zvcm0pIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybS56b29tICsgTWF0aC5sb2codHJhbnNmb3JtLnRpbGVTaXplIC8gdGhpcy50aWxlU2l6ZSkgLyBNYXRoLkxOMjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgem9vbSBsZXZlbCB0aGF0IHdpbGwgY292ZXIgYWxsIHRpbGVzIGluIGEgZ2l2ZW4gdHJhbnNmb3JtXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRyYW5zZm9ybVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHpvb20gbGV2ZWxcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvdmVyaW5nWm9vbUxldmVsOiBmdW5jdGlvbih0cmFuc2Zvcm0pIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnJvdW5kWm9vbSA/IE1hdGgucm91bmQgOiBNYXRoLmZsb29yKSh0aGlzLmdldFpvb20odHJhbnNmb3JtKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgdHJhbnNmb3JtLCByZXR1cm4gYWxsIGNvb3JkaW5hdGVzIHRoYXQgY291bGQgY292ZXIgdGhhdFxuICAgICAqIHRyYW5zZm9ybSBmb3IgYSBjb3ZlcmluZyB6b29tIGxldmVsLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2Zvcm1cbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8VGlsZT59IHRpbGVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb3ZlcmluZ1RpbGVzOiBmdW5jdGlvbih0cmFuc2Zvcm0pIHtcbiAgICAgICAgdmFyIHogPSB0aGlzLmNvdmVyaW5nWm9vbUxldmVsKHRyYW5zZm9ybSk7XG4gICAgICAgIHZhciBhY3R1YWxaID0gejtcblxuICAgICAgICBpZiAoeiA8IHRoaXMubWluem9vbSkgcmV0dXJuIFtdO1xuICAgICAgICBpZiAoeiA+IHRoaXMubWF4em9vbSkgeiA9IHRoaXMubWF4em9vbTtcblxuICAgICAgICB2YXIgdHIgPSB0cmFuc2Zvcm0sXG4gICAgICAgICAgICB0aWxlQ2VudGVyID0gdHIubG9jYXRpb25Db29yZGluYXRlKHRyLmNlbnRlcikuX3pvb21Ubyh6KSxcbiAgICAgICAgICAgIGNlbnRlclBvaW50ID0gbmV3IFBvaW50KHRpbGVDZW50ZXIuY29sdW1uIC0gMC41LCB0aWxlQ2VudGVyLnJvdyAtIDAuNSk7XG5cbiAgICAgICAgcmV0dXJuIFRpbGVDb29yZC5jb3Zlcih6LCBbXG4gICAgICAgICAgICB0ci5wb2ludENvb3JkaW5hdGUobmV3IFBvaW50KDAsIDApKS5fem9vbVRvKHopLFxuICAgICAgICAgICAgdHIucG9pbnRDb29yZGluYXRlKG5ldyBQb2ludCh0ci53aWR0aCwgMCkpLl96b29tVG8oeiksXG4gICAgICAgICAgICB0ci5wb2ludENvb3JkaW5hdGUobmV3IFBvaW50KHRyLndpZHRoLCB0ci5oZWlnaHQpKS5fem9vbVRvKHopLFxuICAgICAgICAgICAgdHIucG9pbnRDb29yZGluYXRlKG5ldyBQb2ludCgwLCB0ci5oZWlnaHQpKS5fem9vbVRvKHopXG4gICAgICAgIF0sIHRoaXMucmVwYXJzZU92ZXJzY2FsZWQgPyBhY3R1YWxaIDogeikuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gY2VudGVyUG9pbnQuZGlzdChhKSAtIGNlbnRlclBvaW50LmRpc3QoYik7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZWN1cnNpdmVseSBmaW5kIGNoaWxkcmVuIG9mIHRoZSBnaXZlbiB0aWxlICh1cCB0byBtYXhDb3ZlcmluZ1pvb20pIHRoYXQgYXJlIGFscmVhZHkgbG9hZGVkO1xuICAgICAqIGFkZHMgZm91bmQgdGlsZXMgdG8gcmV0YWluIG9iamVjdDsgcmV0dXJucyB0cnVlIGlmIGFueSBjaGlsZCBpcyBmb3VuZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q29vcmRpbmF0ZX0gY29vcmRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4Q292ZXJpbmdab29tXG4gICAgICogQHBhcmFtIHtib29sZWFufSByZXRhaW5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciB0aGUgb3BlcmF0aW9uIHdhcyBjb21wbGV0ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZmluZExvYWRlZENoaWxkcmVuOiBmdW5jdGlvbihjb29yZCwgbWF4Q292ZXJpbmdab29tLCByZXRhaW4pIHtcbiAgICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XG5cbiAgICAgICAgZm9yICh2YXIgaWQgaW4gdGhpcy5fdGlsZXMpIHtcbiAgICAgICAgICAgIHZhciB0aWxlID0gdGhpcy5fdGlsZXNbaWRdO1xuXG4gICAgICAgICAgICAvLyBvbmx5IGNvbnNpZGVyIGxvYWRlZCB0aWxlcyBvbiBoaWdoZXIgem9vbSBsZXZlbHMgKHVwIHRvIG1heENvdmVyaW5nWm9vbSlcbiAgICAgICAgICAgIGlmIChyZXRhaW5baWRdIHx8ICF0aWxlLmxvYWRlZCB8fCB0aWxlLmNvb3JkLnogPD0gY29vcmQueiB8fCB0aWxlLmNvb3JkLnogPiBtYXhDb3ZlcmluZ1pvb20pIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAvLyBkaXNyZWdhcmQgdGlsZXMgdGhhdCBhcmUgbm90IGRlc2NlbmRhbnRzIG9mIHRoZSBnaXZlbiB0aWxlIGNvb3JkaW5hdGVcbiAgICAgICAgICAgIHZhciB6MiA9IE1hdGgucG93KDIsIE1hdGgubWluKHRpbGUuY29vcmQueiwgdGhpcy5tYXh6b29tKSAtIE1hdGgubWluKGNvb3JkLnosIHRoaXMubWF4em9vbSkpO1xuICAgICAgICAgICAgaWYgKE1hdGguZmxvb3IodGlsZS5jb29yZC54IC8gejIpICE9PSBjb29yZC54IHx8XG4gICAgICAgICAgICAgICAgTWF0aC5mbG9vcih0aWxlLmNvb3JkLnkgLyB6MikgIT09IGNvb3JkLnkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgIC8vIGZvdW5kIGxvYWRlZCBjaGlsZFxuICAgICAgICAgICAgcmV0YWluW2lkXSA9IHRydWU7XG4gICAgICAgICAgICBmb3VuZCA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vIGxvb3AgdGhyb3VnaCBwYXJlbnRzOyByZXRhaW4gdGhlIHRvcG1vc3QgbG9hZGVkIG9uZSBpZiBmb3VuZFxuICAgICAgICAgICAgd2hpbGUgKHRpbGUgJiYgdGlsZS5jb29yZC56IC0gMSA+IGNvb3JkLnopIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50SWQgPSB0aWxlLmNvb3JkLnBhcmVudCh0aGlzLm1heHpvb20pLmlkO1xuICAgICAgICAgICAgICAgIHRpbGUgPSB0aGlzLl90aWxlc1twYXJlbnRJZF07XG5cbiAgICAgICAgICAgICAgICBpZiAodGlsZSAmJiB0aWxlLmxvYWRlZCkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcmV0YWluW2lkXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0YWluW3BhcmVudElkXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3VuZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZCBhIGxvYWRlZCBwYXJlbnQgb2YgdGhlIGdpdmVuIHRpbGUgKHVwIHRvIG1pbkNvdmVyaW5nWm9vbSk7XG4gICAgICogYWRkcyB0aGUgZm91bmQgdGlsZSB0byByZXRhaW4gb2JqZWN0IGFuZCByZXR1cm5zIHRoZSB0aWxlIGlmIGZvdW5kXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Nvb3JkaW5hdGV9IGNvb3JkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pbkNvdmVyaW5nWm9vbVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmV0YWluXG4gICAgICogQHJldHVybnMge1RpbGV9IHRpbGUgb2JqZWN0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmaW5kTG9hZGVkUGFyZW50OiBmdW5jdGlvbihjb29yZCwgbWluQ292ZXJpbmdab29tLCByZXRhaW4pIHtcbiAgICAgICAgZm9yICh2YXIgeiA9IGNvb3JkLnogLSAxOyB6ID49IG1pbkNvdmVyaW5nWm9vbTsgei0tKSB7XG4gICAgICAgICAgICBjb29yZCA9IGNvb3JkLnBhcmVudCh0aGlzLm1heHpvb20pO1xuICAgICAgICAgICAgdmFyIHRpbGUgPSB0aGlzLl90aWxlc1tjb29yZC5pZF07XG4gICAgICAgICAgICBpZiAodGlsZSAmJiB0aWxlLmxvYWRlZCkge1xuICAgICAgICAgICAgICAgIHJldGFpbltjb29yZC5pZF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGlsZXMgdGhhdCBhcmUgb3V0c2lkZSB0aGUgdmlld3BvcnQgYW5kIGFkZHMgbmV3IHRpbGVzIHRoYXRcbiAgICAgKiBhcmUgaW5zaWRlIHRoZSB2aWV3cG9ydC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHVwZGF0ZTogZnVuY3Rpb24odXNlZCwgdHJhbnNmb3JtLCBmYWRlRHVyYXRpb24pIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBjb29yZDtcbiAgICAgICAgdmFyIHRpbGU7XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBvdmVyem9vbWluZy91bmRlcnpvb21pbmcgYW1vdW50cy5cbiAgICAgICAgdmFyIHpvb20gPSAodGhpcy5yb3VuZFpvb20gPyBNYXRoLnJvdW5kIDogTWF0aC5mbG9vcikodGhpcy5nZXRab29tKHRyYW5zZm9ybSkpO1xuICAgICAgICB2YXIgbWluQ292ZXJpbmdab29tID0gTWF0aC5tYXgoem9vbSAtIDEwLCB0aGlzLm1pbnpvb20pO1xuICAgICAgICB2YXIgbWF4Q292ZXJpbmdab29tID0gTWF0aC5tYXgoem9vbSArIDMsICB0aGlzLm1pbnpvb20pO1xuXG4gICAgICAgIC8vIFJldGFpbiBpcyBhIGxpc3Qgb2YgdGlsZXMgdGhhdCB3ZSBzaG91bGRuJ3QgZGVsZXRlLCBldmVuIGlmIHRoZXkgYXJlIG5vdFxuICAgICAgICAvLyB0aGUgbW9zdCBpZGVhbCB0aWxlIGZvciB0aGUgY3VycmVudCB2aWV3cG9ydC4gVGhpcyBtYXkgaW5jbHVkZSB0aWxlcyBsaWtlXG4gICAgICAgIC8vIHBhcmVudCBvciBjaGlsZCB0aWxlcyB0aGF0IGFyZSAqYWxyZWFkeSogbG9hZGVkLlxuICAgICAgICB2YXIgcmV0YWluID0ge307XG4gICAgICAgIHZhciBub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuICAgICAgICAvLyBDb3ZlcmVkIGlzIGEgbGlzdCBvZiByZXRhaW5lZCB0aWxlcyB3aG8ncyBhcmVhcyBhcmUgZnVsbCBjb3ZlcmVkIGJ5IG90aGVyLFxuICAgICAgICAvLyBiZXR0ZXIsIHJldGFpbmVkIHRpbGVzLiBUaGV5IGFyZSBub3QgZHJhd24gc2VwYXJhdGVseS5cbiAgICAgICAgdGhpcy5fY292ZXJlZFRpbGVzID0ge307XG5cbiAgICAgICAgdmFyIHJlcXVpcmVkID0gdXNlZCA/IHRoaXMuY292ZXJpbmdUaWxlcyh0cmFuc2Zvcm0pIDogW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCByZXF1aXJlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29vcmQgPSByZXF1aXJlZFtpXTtcbiAgICAgICAgICAgIHRpbGUgPSB0aGlzLmFkZFRpbGUoY29vcmQpO1xuXG4gICAgICAgICAgICByZXRhaW5bY29vcmQuaWRdID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKHRpbGUubG9hZGVkKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAvLyBUaGUgdGlsZSB3ZSByZXF1aXJlIGlzIG5vdCB5ZXQgbG9hZGVkLlxuICAgICAgICAgICAgLy8gUmV0YWluIGNoaWxkIG9yIHBhcmVudCB0aWxlcyB0aGF0IGNvdmVyIHRoZSBzYW1lIGFyZWEuXG4gICAgICAgICAgICBpZiAoIXRoaXMuZmluZExvYWRlZENoaWxkcmVuKGNvb3JkLCBtYXhDb3ZlcmluZ1pvb20sIHJldGFpbikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbmRMb2FkZWRQYXJlbnQoY29vcmQsIG1pbkNvdmVyaW5nWm9vbSwgcmV0YWluKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXJlbnRzRm9yRmFkaW5nID0ge307XG5cbiAgICAgICAgdmFyIGlkcyA9IE9iamVjdC5rZXlzKHJldGFpbik7XG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgaWRzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICB2YXIgaWQgPSBpZHNba107XG4gICAgICAgICAgICBjb29yZCA9IFRpbGVDb29yZC5mcm9tSUQoaWQpO1xuICAgICAgICAgICAgdGlsZSA9IHRoaXMuX3RpbGVzW2lkXTtcbiAgICAgICAgICAgIGlmICh0aWxlICYmIHRpbGUudGltZUFkZGVkID4gbm93IC0gKGZhZGVEdXJhdGlvbiB8fCAwKSkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgdGlsZSBpcyBzdGlsbCBmYWRpbmcgaW4uIEZpbmQgdGlsZXMgdG8gY3Jvc3MtZmFkZSB3aXRoIGl0LlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpbmRMb2FkZWRDaGlsZHJlbihjb29yZCwgbWF4Q292ZXJpbmdab29tLCByZXRhaW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldGFpbltpZF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmZpbmRMb2FkZWRQYXJlbnQoY29vcmQsIG1pbkNvdmVyaW5nWm9vbSwgcGFyZW50c0ZvckZhZGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZmFkZWRQYXJlbnQ7XG4gICAgICAgIGZvciAoZmFkZWRQYXJlbnQgaW4gcGFyZW50c0ZvckZhZGluZykge1xuICAgICAgICAgICAgaWYgKCFyZXRhaW5bZmFkZWRQYXJlbnRdKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgYSB0aWxlIGlzIG9ubHkgbmVlZGVkIGZvciBmYWRpbmcsIG1hcmsgaXQgYXMgY292ZXJlZCBzbyB0aGF0IGl0IGlzbid0IHJlbmRlcmVkIG9uIGl0J3Mgb3duLlxuICAgICAgICAgICAgICAgIHRoaXMuX2NvdmVyZWRUaWxlc1tmYWRlZFBhcmVudF0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoZmFkZWRQYXJlbnQgaW4gcGFyZW50c0ZvckZhZGluZykge1xuICAgICAgICAgICAgcmV0YWluW2ZhZGVkUGFyZW50XSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZW1vdmUgdGhlIHRpbGVzIHdlIGRvbid0IG5lZWQgYW55bW9yZS5cbiAgICAgICAgdmFyIHJlbW92ZSA9IHV0aWwua2V5c0RpZmZlcmVuY2UodGhpcy5fdGlsZXMsIHJldGFpbik7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCByZW1vdmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlVGlsZSgrcmVtb3ZlW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgYSB0aWxlLCBnaXZlbiBpdHMgY29vcmRpbmF0ZSwgdG8gdGhlIHB5cmFtaWQuXG4gICAgICogQHBhcmFtIHtDb29yZGluYXRlfSBjb29yZFxuICAgICAqIEByZXR1cm5zIHtDb29yZGluYXRlfSB0aGUgY29vcmRpbmF0ZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGFkZFRpbGU6IGZ1bmN0aW9uKGNvb3JkKSB7XG4gICAgICAgIHZhciB0aWxlID0gdGhpcy5fdGlsZXNbY29vcmQuaWRdO1xuICAgICAgICBpZiAodGlsZSlcbiAgICAgICAgICAgIHJldHVybiB0aWxlO1xuXG4gICAgICAgIHZhciB3cmFwcGVkID0gY29vcmQud3JhcHBlZCgpO1xuICAgICAgICB0aWxlID0gdGhpcy5fdGlsZXNbd3JhcHBlZC5pZF07XG5cbiAgICAgICAgaWYgKCF0aWxlKSB7XG4gICAgICAgICAgICB0aWxlID0gdGhpcy5fY2FjaGUuZ2V0KHdyYXBwZWQuaWQpO1xuICAgICAgICAgICAgaWYgKHRpbGUgJiYgdGhpcy5fcmVkb1BsYWNlbWVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlZG9QbGFjZW1lbnQodGlsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRpbGUpIHtcbiAgICAgICAgICAgIHZhciB6b29tID0gY29vcmQuejtcbiAgICAgICAgICAgIHZhciBvdmVyc2NhbGluZyA9IHpvb20gPiB0aGlzLm1heHpvb20gPyBNYXRoLnBvdygyLCB6b29tIC0gdGhpcy5tYXh6b29tKSA6IDE7XG4gICAgICAgICAgICB0aWxlID0gbmV3IFRpbGUod3JhcHBlZCwgdGhpcy50aWxlU2l6ZSAqIG92ZXJzY2FsaW5nLCB0aGlzLm1heHpvb20pO1xuICAgICAgICAgICAgdGhpcy5fbG9hZCh0aWxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRpbGUudXNlcysrO1xuICAgICAgICB0aGlzLl90aWxlc1tjb29yZC5pZF0gPSB0aWxlO1xuICAgICAgICB0aGlzLl9hZGQodGlsZSwgY29vcmQpO1xuXG4gICAgICAgIHJldHVybiB0aWxlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSB0aWxlLCBnaXZlbiBpdHMgaWQsIGZyb20gdGhlIHB5cmFtaWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IGlkIHRpbGUgaWRcbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfSBub3RoaW5nXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICByZW1vdmVUaWxlOiBmdW5jdGlvbihpZCkge1xuICAgICAgICB2YXIgdGlsZSA9IHRoaXMuX3RpbGVzW2lkXTtcbiAgICAgICAgaWYgKCF0aWxlKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIHRpbGUudXNlcy0tO1xuICAgICAgICBkZWxldGUgdGhpcy5fdGlsZXNbaWRdO1xuICAgICAgICB0aGlzLl9yZW1vdmUodGlsZSk7XG5cbiAgICAgICAgaWYgKHRpbGUudXNlcyA+IDApXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgaWYgKHRpbGUubG9hZGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZS5hZGQodGlsZS5jb29yZC53cmFwcGVkKCkuaWQsIHRpbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fYWJvcnQodGlsZSk7XG4gICAgICAgICAgICB0aGlzLl91bmxvYWQodGlsZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFsbCB0aWxlcyBmcm9tIHRoaXMgcHlyYW1pZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY2xlYXJUaWxlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvciAodmFyIGlkIGluIHRoaXMuX3RpbGVzKVxuICAgICAgICAgICAgdGhpcy5yZW1vdmVUaWxlKGlkKTtcbiAgICAgICAgdGhpcy5fY2FjaGUucmVzZXQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRm9yIGEgZ2l2ZW4gY29vcmRpbmF0ZSwgc2VhcmNoIHRocm91Z2ggb3VyIGN1cnJlbnQgdGlsZXMgYW5kIGF0dGVtcHRcbiAgICAgKiB0byBmaW5kIGEgdGlsZSBhdCB0aGF0IHBvaW50XG4gICAgICogQHBhcmFtIHtDb29yZGluYXRlfSBjb29yZFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHRpbGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRpbGVBdDogZnVuY3Rpb24oY29vcmQpIHtcbiAgICAgICAgdmFyIGlkcyA9IHRoaXMub3JkZXJlZElEcygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHRpbGUgPSB0aGlzLl90aWxlc1tpZHNbaV1dO1xuICAgICAgICAgICAgdmFyIHBvcyA9IHRpbGUucG9zaXRpb25BdChjb29yZCk7XG4gICAgICAgICAgICBpZiAocG9zICYmIHBvcy54ID49IDAgJiYgcG9zLnggPCB0aWxlLnRpbGVFeHRlbnQgJiYgcG9zLnkgPj0gMCAmJiBwb3MueSA8IHRpbGUudGlsZUV4dGVudCkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBjbGljayBpcyB3aXRoaW4gdGhlIHZpZXdwb3J0LiBUaGVyZSBpcyBvbmx5IGV2ZXIgb25lIHRpbGUgaW5cbiAgICAgICAgICAgICAgICAvLyBhIGxheWVyIHRoYXQgaGFzIHRoaXMgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdGlsZTogdGlsZSxcbiAgICAgICAgICAgICAgICAgICAgeDogcG9zLngsXG4gICAgICAgICAgICAgICAgICAgIHk6IHBvcy55LFxuICAgICAgICAgICAgICAgICAgICBzY2FsZTogdGhpcy50cmFuc2Zvcm0ud29ybGRTaXplIC8gTWF0aC5wb3coMiwgdGlsZS5jb29yZC56KVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VhcmNoIHRocm91Z2ggb3VyIGN1cnJlbnQgdGlsZXMgYW5kIGF0dGVtcHQgdG8gZmluZCB0aGUgdGlsZXMgdGhhdFxuICAgICAqIGNvdmVyIHRoZSBnaXZlbiBib3VuZHMuXG4gICAgICogQHBhcmFtIHtBcnJheTxDb29yZGluYXRlPn0gYm91bmRzIFttaW54bWlueSwgbWF4eG1heHldIGNvb3JkaW5hdGVzIG9mIHRoZSBjb3JuZXJzIG9mIGJvdW5kaW5nIHJlY3RhbmdsZVxuICAgICAqIEByZXR1cm5zIHtBcnJheTxPYmplY3Q+fSByZXN1bHQgaXRlbXMgaGF2ZSB7dGlsZSwgbWluWCwgbWF4WCwgbWluWSwgbWF4WX0sIHdoZXJlIG1pbi9tYXggYm91bmRpbmcgdmFsdWVzIGFyZSB0aGUgZ2l2ZW4gYm91bmRzIHRyYW5zZm9ybWVkIGluIGludG8gdGhlIGNvb3JkaW5hdGUgc3BhY2Ugb2YgdGhpcyB0aWxlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGlsZXNJbjogZnVuY3Rpb24oYm91bmRzKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgdmFyIGlkcyA9IHRoaXMub3JkZXJlZElEcygpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdGlsZSA9IHRoaXMuX3RpbGVzW2lkc1tpXV07XG4gICAgICAgICAgICB2YXIgdGlsZVNwYWNlQm91bmRzID0gW1xuICAgICAgICAgICAgICAgIHRpbGUucG9zaXRpb25BdChib3VuZHNbMF0pLFxuICAgICAgICAgICAgICAgIHRpbGUucG9zaXRpb25BdChib3VuZHNbMV0pXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgaWYgKHRpbGVTcGFjZUJvdW5kc1swXS54IDwgdGlsZS50aWxlRXh0ZW50ICYmIHRpbGVTcGFjZUJvdW5kc1swXS55IDwgdGlsZS50aWxlRXh0ZW50ICYmXG4gICAgICAgICAgICAgICAgdGlsZVNwYWNlQm91bmRzWzFdLnggPj0gMCAmJiB0aWxlU3BhY2VCb3VuZHNbMV0ueSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0aWxlOiB0aWxlLFxuICAgICAgICAgICAgICAgICAgICBtaW5YOiB0aWxlU3BhY2VCb3VuZHNbMF0ueCxcbiAgICAgICAgICAgICAgICAgICAgbWF4WDogdGlsZVNwYWNlQm91bmRzWzFdLngsXG4gICAgICAgICAgICAgICAgICAgIG1pblk6IHRpbGVTcGFjZUJvdW5kc1swXS55LFxuICAgICAgICAgICAgICAgICAgICBtYXhZOiB0aWxlU3BhY2VCb3VuZHNbMV0ueVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBjb21wYXJlS2V5Wm9vbShhLCBiKSB7XG4gICAgcmV0dXJuIChiICUgMzIpIC0gKGEgJSAzMik7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJyk7XG52YXIgRXZlbnRlZCA9IHJlcXVpcmUoJy4uL3V0aWwvZXZlbnRlZCcpO1xudmFyIFNvdXJjZSA9IHJlcXVpcmUoJy4vc291cmNlJyk7XG52YXIgbm9ybWFsaXplVVJMID0gcmVxdWlyZSgnLi4vdXRpbC9tYXBib3gnKS5ub3JtYWxpemVUaWxlVVJMO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZlY3RvclRpbGVTb3VyY2U7XG5cbmZ1bmN0aW9uIFZlY3RvclRpbGVTb3VyY2Uob3B0aW9ucykge1xuICAgIHV0aWwuZXh0ZW5kKHRoaXMsIHV0aWwucGljayhvcHRpb25zLCBbJ3VybCcsICd0aWxlU2l6ZSddKSk7XG5cbiAgICBpZiAodGhpcy50aWxlU2l6ZSAhPT0gNTEyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndmVjdG9yIHRpbGUgc291cmNlcyBtdXN0IGhhdmUgYSB0aWxlU2l6ZSBvZiA1MTInKTtcbiAgICB9XG5cbiAgICBTb3VyY2UuX2xvYWRUaWxlSlNPTi5jYWxsKHRoaXMsIG9wdGlvbnMpO1xufVxuXG5WZWN0b3JUaWxlU291cmNlLnByb3RvdHlwZSA9IHV0aWwuaW5oZXJpdChFdmVudGVkLCB7XG4gICAgbWluem9vbTogMCxcbiAgICBtYXh6b29tOiAyMixcbiAgICB0aWxlU2l6ZTogNTEyLFxuICAgIHJlcGFyc2VPdmVyc2NhbGVkOiB0cnVlLFxuICAgIF9sb2FkZWQ6IGZhbHNlLFxuICAgIGlzVGlsZUNsaXBwZWQ6IHRydWUsXG5cbiAgICBvbkFkZDogZnVuY3Rpb24obWFwKSB7XG4gICAgICAgIHRoaXMubWFwID0gbWFwO1xuICAgIH0sXG5cbiAgICBsb2FkZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHlyYW1pZCAmJiB0aGlzLl9weXJhbWlkLmxvYWRlZCgpO1xuICAgIH0sXG5cbiAgICB1cGRhdGU6IGZ1bmN0aW9uKHRyYW5zZm9ybSkge1xuICAgICAgICBpZiAodGhpcy5fcHlyYW1pZCkge1xuICAgICAgICAgICAgdGhpcy5fcHlyYW1pZC51cGRhdGUodGhpcy51c2VkLCB0cmFuc2Zvcm0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHJlbG9hZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9weXJhbWlkKSB7XG4gICAgICAgICAgICB0aGlzLl9weXJhbWlkLnJlbG9hZCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldFZpc2libGVDb29yZGluYXRlczogU291cmNlLl9nZXRWaXNpYmxlQ29vcmRpbmF0ZXMsXG4gICAgZ2V0VGlsZTogU291cmNlLl9nZXRUaWxlLFxuXG4gICAgZmVhdHVyZXNBdDogU291cmNlLl92ZWN0b3JGZWF0dXJlc0F0LFxuICAgIGZlYXR1cmVzSW46IFNvdXJjZS5fdmVjdG9yRmVhdHVyZXNJbixcblxuICAgIF9sb2FkVGlsZTogZnVuY3Rpb24odGlsZSkge1xuICAgICAgICB2YXIgb3ZlcnNjYWxpbmcgPSB0aWxlLmNvb3JkLnogPiB0aGlzLm1heHpvb20gPyBNYXRoLnBvdygyLCB0aWxlLmNvb3JkLnogLSB0aGlzLm1heHpvb20pIDogMTtcbiAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICAgIHVybDogbm9ybWFsaXplVVJMKHRpbGUuY29vcmQudXJsKHRoaXMudGlsZXMsIHRoaXMubWF4em9vbSksIHRoaXMudXJsKSxcbiAgICAgICAgICAgIHVpZDogdGlsZS51aWQsXG4gICAgICAgICAgICBjb29yZDogdGlsZS5jb29yZCxcbiAgICAgICAgICAgIHpvb206IHRpbGUuY29vcmQueixcbiAgICAgICAgICAgIHRpbGVTaXplOiB0aGlzLnRpbGVTaXplICogb3ZlcnNjYWxpbmcsXG4gICAgICAgICAgICBzb3VyY2U6IHRoaXMuaWQsXG4gICAgICAgICAgICBvdmVyc2NhbGluZzogb3ZlcnNjYWxpbmcsXG4gICAgICAgICAgICBhbmdsZTogdGhpcy5tYXAudHJhbnNmb3JtLmFuZ2xlLFxuICAgICAgICAgICAgcGl0Y2g6IHRoaXMubWFwLnRyYW5zZm9ybS5waXRjaCxcbiAgICAgICAgICAgIGNvbGxpc2lvbkRlYnVnOiB0aGlzLm1hcC5jb2xsaXNpb25EZWJ1Z1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh0aWxlLndvcmtlcklEKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoZXIuc2VuZCgncmVsb2FkIHRpbGUnLCBwYXJhbXMsIHRoaXMuX3RpbGVMb2FkZWQuYmluZCh0aGlzLCB0aWxlKSwgdGlsZS53b3JrZXJJRCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aWxlLndvcmtlcklEID0gdGhpcy5kaXNwYXRjaGVyLnNlbmQoJ2xvYWQgdGlsZScsIHBhcmFtcywgdGhpcy5fdGlsZUxvYWRlZC5iaW5kKHRoaXMsIHRpbGUpKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfdGlsZUxvYWRlZDogZnVuY3Rpb24odGlsZSwgZXJyLCBkYXRhKSB7XG4gICAgICAgIGlmICh0aWxlLmFib3J0ZWQpXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgdGhpcy5maXJlKCd0aWxlLmVycm9yJywge3RpbGU6IHRpbGUsIGVycm9yOiBlcnJ9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRpbGUubG9hZFZlY3RvckRhdGEoZGF0YSk7XG5cbiAgICAgICAgaWYgKHRpbGUucmVkb1doZW5Eb25lKSB7XG4gICAgICAgICAgICB0aWxlLnJlZG9XaGVuRG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGlsZS5yZWRvUGxhY2VtZW50KHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5maXJlKCd0aWxlLmxvYWQnLCB7dGlsZTogdGlsZX0pO1xuICAgICAgICB0aGlzLmZpcmUoJ3RpbGUuc3RhdHMnLCBkYXRhLmJ1Y2tldFN0YXRzKTtcbiAgICB9LFxuXG4gICAgX2Fib3J0VGlsZTogZnVuY3Rpb24odGlsZSkge1xuICAgICAgICB0aWxlLmFib3J0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmRpc3BhdGNoZXIuc2VuZCgnYWJvcnQgdGlsZScsIHsgdWlkOiB0aWxlLnVpZCwgc291cmNlOiB0aGlzLmlkIH0sIG51bGwsIHRpbGUud29ya2VySUQpO1xuICAgIH0sXG5cbiAgICBfYWRkVGlsZTogZnVuY3Rpb24odGlsZSkge1xuICAgICAgICB0aGlzLmZpcmUoJ3RpbGUuYWRkJywge3RpbGU6IHRpbGV9KTtcbiAgICB9LFxuXG4gICAgX3JlbW92ZVRpbGU6IGZ1bmN0aW9uKHRpbGUpIHtcbiAgICAgICAgdGhpcy5maXJlKCd0aWxlLnJlbW92ZScsIHt0aWxlOiB0aWxlfSk7XG4gICAgfSxcblxuICAgIF91bmxvYWRUaWxlOiBmdW5jdGlvbih0aWxlKSB7XG4gICAgICAgIHRpbGUudW5sb2FkVmVjdG9yRGF0YSh0aGlzLm1hcC5wYWludGVyKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaGVyLnNlbmQoJ3JlbW92ZSB0aWxlJywgeyB1aWQ6IHRpbGUudWlkLCBzb3VyY2U6IHRoaXMuaWQgfSwgbnVsbCwgdGlsZS53b3JrZXJJRCk7XG4gICAgfSxcblxuICAgIHJlZG9QbGFjZW1lbnQ6IFNvdXJjZS5yZWRvUGxhY2VtZW50LFxuXG4gICAgX3JlZG9UaWxlUGxhY2VtZW50OiBmdW5jdGlvbih0aWxlKSB7XG4gICAgICAgIHRpbGUucmVkb1BsYWNlbWVudCh0aGlzKTtcbiAgICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcbnZhciBUaWxlID0gcmVxdWlyZSgnLi90aWxlJyk7XG52YXIgTG5nTGF0ID0gcmVxdWlyZSgnLi4vZ2VvL2xuZ19sYXQnKTtcbnZhciBQb2ludCA9IHJlcXVpcmUoJ3BvaW50LWdlb21ldHJ5Jyk7XG52YXIgRXZlbnRlZCA9IHJlcXVpcmUoJy4uL3V0aWwvZXZlbnRlZCcpO1xudmFyIGFqYXggPSByZXF1aXJlKCcuLi91dGlsL2FqYXgnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBWaWRlb1NvdXJjZTtcblxuLyoqXG4gKiBDcmVhdGUgYSBWaWRlbyBkYXRhIHNvdXJjZSBpbnN0YW5jZSBnaXZlbiBhbiBvcHRpb25zIG9iamVjdFxuICogQGNsYXNzIFZpZGVvU291cmNlXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IG9wdGlvbnMudXJscyBBbiBhcnJheSBvZiBVUkxzIHRvIHZpZGVvIGZpbGVzXG4gKiBAcGFyYW0ge0FycmF5fSBvcHRpb25zLmNvb3JkaW5hdGVzIGxuZywgbGF0IGNvb3JkaW5hdGVzIGluIG9yZGVyIGNsb2Nrd2lzZSBzdGFydGluZyBhdCB0aGUgdG9wIGxlZnQ6IHRsLCB0ciwgYnIsIGJsXG4gKiBAZXhhbXBsZVxuICogdmFyIHNvdXJjZU9iaiA9IG5ldyBtYXBib3hnbC5WaWRlb1NvdXJjZSh7XG4gKiAgICB1cmw6IFtcbiAqICAgICAgICAnaHR0cHM6Ly93d3cubWFwYm94LmNvbS92aWRlb3MvYmFsdGltb3JlLXNtb2tlLm1wNCcsXG4gKiAgICAgICAgJ2h0dHBzOi8vd3d3Lm1hcGJveC5jb20vdmlkZW9zL2JhbHRpbW9yZS1zbW9rZS53ZWJtJ1xuICogICAgXSxcbiAqICAgIGNvb3JkaW5hdGVzOiBbXG4gKiAgICAgICAgWy03Ni41NDMzNTczNzIyODM5NCwgMzkuMTg1Nzk5MDcyMjk3NDhdLFxuICogICAgICAgIFstNzYuNTI4MDM2NTk0MzkwODcsIDM5LjE4MzgzNjQ4NDc1ODddLFxuICogICAgICAgIFstNzYuNTI5NTM4NjMxNDM5MiwgMzkuMTc2ODMzOTI1MDc2MDZdLFxuICogICAgICAgIFstNzYuNTQ1MjAyNzMyMDg2MTgsIDM5LjE3ODc2MzQ0MTA2NjQyXVxuICogICAgXVxuICogfSk7XG4gKiBtYXAuYWRkU291cmNlKCdzb21lIGlkJywgc291cmNlT2JqKTsgLy8gYWRkXG4gKiBtYXAucmVtb3ZlU291cmNlKCdzb21lIGlkJyk7ICAvLyByZW1vdmVcbiAqL1xuZnVuY3Rpb24gVmlkZW9Tb3VyY2Uob3B0aW9ucykge1xuICAgIGFqYXguZ2V0VmlkZW8ob3B0aW9ucy51cmxzLCBmdW5jdGlvbihlcnIsIHZpZGVvKSB7XG4gICAgICAgIC8vIEBUT0RPIGhhbmRsZSBlcnJvcnMgdmlhIGV2ZW50LlxuICAgICAgICBpZiAoZXJyKSByZXR1cm47XG5cbiAgICAgICAgdGhpcy52aWRlbyA9IHZpZGVvO1xuICAgICAgICB0aGlzLnZpZGVvLmxvb3AgPSB0cnVlO1xuXG4gICAgICAgIHZhciBsb29wSUQ7XG5cbiAgICAgICAgLy8gc3RhcnQgcmVwYWludGluZyB3aGVuIHZpZGVvIHN0YXJ0cyBwbGF5aW5nXG4gICAgICAgIHRoaXMudmlkZW8uYWRkRXZlbnRMaXN0ZW5lcigncGxheWluZycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgbG9vcElEID0gdGhpcy5tYXAuc3R5bGUuYW5pbWF0aW9uTG9vcC5zZXQoSW5maW5pdHkpO1xuICAgICAgICAgICAgdGhpcy5tYXAuX3JlcmVuZGVyKCk7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgICAgLy8gc3RvcCByZXBhaW50aW5nIHdoZW4gdmlkZW8gc3RvcHNcbiAgICAgICAgdGhpcy52aWRlby5hZGRFdmVudExpc3RlbmVyKCdwYXVzZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5tYXAuc3R5bGUuYW5pbWF0aW9uTG9vcC5jYW5jZWwobG9vcElEKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcblxuICAgICAgICB0aGlzLl9sb2FkZWQgPSB0cnVlO1xuXG4gICAgICAgIGlmICh0aGlzLm1hcCkge1xuICAgICAgICAgICAgdGhpcy52aWRlby5wbGF5KCk7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZVRpbGUob3B0aW9ucy5jb29yZGluYXRlcyk7XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ2NoYW5nZScpO1xuICAgICAgICB9XG4gICAgfS5iaW5kKHRoaXMpKTtcbn1cblxuVmlkZW9Tb3VyY2UucHJvdG90eXBlID0gdXRpbC5pbmhlcml0KEV2ZW50ZWQsIC8qKiBAbGVuZHMgVmlkZW9Tb3VyY2UucHJvdG90eXBlICove1xuICAgIHJvdW5kWm9vbTogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgSFRNTCB2aWRlbyBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBnZXRWaWRlbzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZGVvO1xuICAgIH0sXG5cbiAgICBvbkFkZDogZnVuY3Rpb24obWFwKSB7XG4gICAgICAgIHRoaXMubWFwID0gbWFwO1xuICAgICAgICBpZiAodGhpcy52aWRlbykge1xuICAgICAgICAgICAgdGhpcy52aWRlby5wbGF5KCk7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZVRpbGUoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBjcmVhdGVUaWxlOiBmdW5jdGlvbihjb3JuZXJHZW9Db29yZHMpIHtcbiAgICAgICAgLypcbiAgICAgICAgICogQ2FsY3VsYXRlIHdoaWNoIG1lcmNhdG9yIHRpbGUgaXMgc3VpdGFibGUgZm9yIHJlbmRlcmluZyB0aGUgdmlkZW8gaW5cbiAgICAgICAgICogYW5kIGNyZWF0ZSBhIGJ1ZmZlciB3aXRoIHRoZSBjb3JuZXIgY29vcmRpbmF0ZXMuIFRoZXNlIGNvb3JkaW5hdGVzXG4gICAgICAgICAqIG1heSBiZSBvdXRzaWRlIHRoZSB0aWxlLCBiZWNhdXNlIHJhc3RlciB0aWxlcyBhcmVuJ3QgY2xpcHBlZCB3aGVuIHJlbmRlcmluZy5cbiAgICAgICAgICovXG4gICAgICAgIHZhciBtYXAgPSB0aGlzLm1hcDtcbiAgICAgICAgdmFyIGNvcm5lclowQ29vcmRzID0gY29ybmVyR2VvQ29vcmRzLm1hcChmdW5jdGlvbihjb29yZCkge1xuICAgICAgICAgICAgcmV0dXJuIG1hcC50cmFuc2Zvcm0ubG9jYXRpb25Db29yZGluYXRlKExuZ0xhdC5jb252ZXJ0KGNvb3JkKSkuem9vbVRvKDApO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgY2VudGVyQ29vcmQgPSB0aGlzLmNlbnRlckNvb3JkID0gdXRpbC5nZXRDb29yZGluYXRlc0NlbnRlcihjb3JuZXJaMENvb3Jkcyk7XG5cbiAgICAgICAgdmFyIHRpbGVFeHRlbnQgPSA0MDk2O1xuICAgICAgICB2YXIgdGlsZUNvb3JkcyA9IGNvcm5lclowQ29vcmRzLm1hcChmdW5jdGlvbihjb29yZCkge1xuICAgICAgICAgICAgdmFyIHpvb21lZENvb3JkID0gY29vcmQuem9vbVRvKGNlbnRlckNvb3JkLnpvb20pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChcbiAgICAgICAgICAgICAgICBNYXRoLnJvdW5kKCh6b29tZWRDb29yZC5jb2x1bW4gLSBjZW50ZXJDb29yZC5jb2x1bW4pICogdGlsZUV4dGVudCksXG4gICAgICAgICAgICAgICAgTWF0aC5yb3VuZCgoem9vbWVkQ29vcmQucm93IC0gY2VudGVyQ29vcmQucm93KSAqIHRpbGVFeHRlbnQpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGdsID0gbWFwLnBhaW50ZXIuZ2w7XG4gICAgICAgIHZhciBtYXhJbnQxNiA9IDMyNzY3O1xuICAgICAgICB2YXIgYXJyYXkgPSBuZXcgSW50MTZBcnJheShbXG4gICAgICAgICAgICB0aWxlQ29vcmRzWzBdLngsIHRpbGVDb29yZHNbMF0ueSwgMCwgMCxcbiAgICAgICAgICAgIHRpbGVDb29yZHNbMV0ueCwgdGlsZUNvb3Jkc1sxXS55LCBtYXhJbnQxNiwgMCxcbiAgICAgICAgICAgIHRpbGVDb29yZHNbM10ueCwgdGlsZUNvb3Jkc1szXS55LCAwLCBtYXhJbnQxNixcbiAgICAgICAgICAgIHRpbGVDb29yZHNbMl0ueCwgdGlsZUNvb3Jkc1syXS55LCBtYXhJbnQxNiwgbWF4SW50MTZcbiAgICAgICAgXSk7XG5cbiAgICAgICAgdGhpcy50aWxlID0gbmV3IFRpbGUoKTtcbiAgICAgICAgdGhpcy50aWxlLmJ1Y2tldHMgPSB7fTtcblxuICAgICAgICB0aGlzLnRpbGUuYm91bmRzQnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLnRpbGUuYm91bmRzQnVmZmVyKTtcbiAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIGFycmF5LCBnbC5TVEFUSUNfRFJBVyk7XG4gICAgfSxcblxuICAgIGxvYWRlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZGVvICYmIHRoaXMudmlkZW8ucmVhZHlTdGF0ZSA+PSAyO1xuICAgIH0sXG5cbiAgICB1cGRhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBub29wXG4gICAgfSxcblxuICAgIHJlbG9hZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIG5vb3BcbiAgICB9LFxuXG4gICAgcHJlcGFyZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5fbG9hZGVkKSByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLnZpZGVvLnJlYWR5U3RhdGUgPCAyKSByZXR1cm47IC8vIG5vdCBlbm91Z2ggZGF0YSBmb3IgY3VycmVudCBwb3NpdGlvblxuXG4gICAgICAgIHZhciBnbCA9IHRoaXMubWFwLnBhaW50ZXIuZ2w7XG4gICAgICAgIGlmICghdGhpcy50aWxlLnRleHR1cmUpIHtcbiAgICAgICAgICAgIHRoaXMudGlsZS50ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50aWxlLnRleHR1cmUpO1xuICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVIpO1xuICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLkxJTkVBUik7XG4gICAgICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHRoaXMudmlkZW8pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50aWxlLnRleHR1cmUpO1xuICAgICAgICAgICAgZ2wudGV4U3ViSW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCAwLCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCB0aGlzLnZpZGVvKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2N1cnJlbnRUaW1lID0gdGhpcy52aWRlby5jdXJyZW50VGltZTtcbiAgICB9LFxuXG4gICAgZ2V0VmlzaWJsZUNvb3JkaW5hdGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuY2VudGVyQ29vcmQpIHJldHVybiBbdGhpcy5jZW50ZXJDb29yZF07XG4gICAgICAgIGVsc2UgcmV0dXJuIFtdO1xuICAgIH0sXG5cbiAgICBnZXRUaWxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGlsZTtcbiAgICB9LFxuXG4gICAgZmVhdHVyZXNBdDogZnVuY3Rpb24ocG9pbnQsIHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIFtdKTtcbiAgICB9LFxuXG4gICAgZmVhdHVyZXNJbjogZnVuY3Rpb24oYmJveCwgcGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgW10pO1xuICAgIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQWN0b3IgPSByZXF1aXJlKCcuLi91dGlsL2FjdG9yJyk7XG52YXIgV29ya2VyVGlsZSA9IHJlcXVpcmUoJy4vd29ya2VyX3RpbGUnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJyk7XG52YXIgYWpheCA9IHJlcXVpcmUoJy4uL3V0aWwvYWpheCcpO1xudmFyIHZ0ID0gcmVxdWlyZSgndmVjdG9yLXRpbGUnKTtcbnZhciBQcm90b2J1ZiA9IHJlcXVpcmUoJ3BiZicpO1xuXG52YXIgZ2VvanNvbnZ0ID0gcmVxdWlyZSgnZ2VvanNvbi12dCcpO1xudmFyIEdlb0pTT05XcmFwcGVyID0gcmVxdWlyZSgnLi9nZW9qc29uX3dyYXBwZXInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihzZWxmKSB7XG4gICAgcmV0dXJuIG5ldyBXb3JrZXIoc2VsZik7XG59O1xuXG5mdW5jdGlvbiBXb3JrZXIoc2VsZikge1xuICAgIHRoaXMuc2VsZiA9IHNlbGY7XG4gICAgdGhpcy5hY3RvciA9IG5ldyBBY3RvcihzZWxmLCB0aGlzKTtcbiAgICB0aGlzLmxvYWRpbmcgPSB7fTtcblxuICAgIHRoaXMubG9hZGVkID0ge307XG4gICAgdGhpcy5sYXllcnMgPSBbXTtcbiAgICB0aGlzLmdlb0pTT05JbmRleGVzID0ge307XG59XG5cbnV0aWwuZXh0ZW5kKFdvcmtlci5wcm90b3R5cGUsIHtcbiAgICAnc2V0IGxheWVycyc6IGZ1bmN0aW9uKGxheWVycykge1xuICAgICAgICB0aGlzLmxheWVycyA9IGxheWVycztcbiAgICB9LFxuXG4gICAgJ2xvYWQgdGlsZSc6IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHBhcmFtcy5zb3VyY2UsXG4gICAgICAgICAgICB1aWQgPSBwYXJhbXMudWlkO1xuXG4gICAgICAgIGlmICghdGhpcy5sb2FkaW5nW3NvdXJjZV0pXG4gICAgICAgICAgICB0aGlzLmxvYWRpbmdbc291cmNlXSA9IHt9O1xuXG5cbiAgICAgICAgdmFyIHRpbGUgPSB0aGlzLmxvYWRpbmdbc291cmNlXVt1aWRdID0gbmV3IFdvcmtlclRpbGUocGFyYW1zKTtcblxuICAgICAgICB0aWxlLnhociA9IGFqYXguZ2V0QXJyYXlCdWZmZXIocGFyYW1zLnVybCwgZG9uZS5iaW5kKHRoaXMpKTtcblxuICAgICAgICBmdW5jdGlvbiBkb25lKGVyciwgZGF0YSkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMubG9hZGluZ1tzb3VyY2VdW3VpZF07XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSB0aWxlIHdhcyBub3QgZm91bmQsIGl0J3MgcHJvYmFibHkgbm90IGFjdXRhbGx5XG4gICAgICAgICAgICAvLyBhbiBlcnJvci4gVGhlcmUgc2hvdWxkIGJlIGEgYmV0dGVyIHdheSBvZiBoYW5kaW5nIHRoaXNcbiAgICAgICAgICAgIC8vIHRob3VnaC5cbiAgICAgICAgICAgIGlmIChlcnIgJiYgZXJyLm1lc3NhZ2UgPT09ICdOb3QgRm91bmQnKSByZXR1cm4gY2FsbGJhY2soKTtcblxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCB0cmVhdCBpdCBsaWtlIGFuIGVycm9yLlxuICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7XG5cbiAgICAgICAgICAgIHRpbGUuZGF0YSA9IG5ldyB2dC5WZWN0b3JUaWxlKG5ldyBQcm90b2J1ZihuZXcgVWludDhBcnJheShkYXRhKSkpO1xuICAgICAgICAgICAgdGlsZS5wYXJzZSh0aWxlLmRhdGEsIHRoaXMubGF5ZXJzLCB0aGlzLmFjdG9yLCBjYWxsYmFjayk7XG5cbiAgICAgICAgICAgIHRoaXMubG9hZGVkW3NvdXJjZV0gPSB0aGlzLmxvYWRlZFtzb3VyY2VdIHx8IHt9O1xuICAgICAgICAgICAgdGhpcy5sb2FkZWRbc291cmNlXVt1aWRdID0gdGlsZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAncmVsb2FkIHRpbGUnOiBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBsb2FkZWQgPSB0aGlzLmxvYWRlZFtwYXJhbXMuc291cmNlXSxcbiAgICAgICAgICAgIHVpZCA9IHBhcmFtcy51aWQ7XG4gICAgICAgIGlmIChsb2FkZWQgJiYgbG9hZGVkW3VpZF0pIHtcbiAgICAgICAgICAgIHZhciB0aWxlID0gbG9hZGVkW3VpZF07XG4gICAgICAgICAgICB0aWxlLnBhcnNlKHRpbGUuZGF0YSwgdGhpcy5sYXllcnMsIHRoaXMuYWN0b3IsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAnYWJvcnQgdGlsZSc6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICB2YXIgbG9hZGluZyA9IHRoaXMubG9hZGluZ1twYXJhbXMuc291cmNlXSxcbiAgICAgICAgICAgIHVpZCA9IHBhcmFtcy51aWQ7XG4gICAgICAgIGlmIChsb2FkaW5nICYmIGxvYWRpbmdbdWlkXSkge1xuICAgICAgICAgICAgbG9hZGluZ1t1aWRdLnhoci5hYm9ydCgpO1xuICAgICAgICAgICAgZGVsZXRlIGxvYWRpbmdbdWlkXTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAncmVtb3ZlIHRpbGUnOiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgdmFyIGxvYWRlZCA9IHRoaXMubG9hZGVkW3BhcmFtcy5zb3VyY2VdLFxuICAgICAgICAgICAgdWlkID0gcGFyYW1zLnVpZDtcbiAgICAgICAgaWYgKGxvYWRlZCAmJiBsb2FkZWRbdWlkXSkge1xuICAgICAgICAgICAgZGVsZXRlIGxvYWRlZFt1aWRdO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgICdyZWRvIHBsYWNlbWVudCc6IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGxvYWRlZCA9IHRoaXMubG9hZGVkW3BhcmFtcy5zb3VyY2VdLFxuICAgICAgICAgICAgbG9hZGluZyA9IHRoaXMubG9hZGluZ1twYXJhbXMuc291cmNlXSxcbiAgICAgICAgICAgIHVpZCA9IHBhcmFtcy51aWQ7XG5cbiAgICAgICAgaWYgKGxvYWRlZCAmJiBsb2FkZWRbdWlkXSkge1xuICAgICAgICAgICAgdmFyIHRpbGUgPSBsb2FkZWRbdWlkXTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aWxlLnJlZG9QbGFjZW1lbnQocGFyYW1zLmFuZ2xlLCBwYXJhbXMucGl0Y2gsIHBhcmFtcy5jb2xsaXNpb25EZWJ1Zyk7XG5cbiAgICAgICAgICAgIGlmIChyZXN1bHQucmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0LnJlc3VsdCwgcmVzdWx0LnRyYW5zZmVyYWJsZXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAobG9hZGluZyAmJiBsb2FkaW5nW3VpZF0pIHtcbiAgICAgICAgICAgIGxvYWRpbmdbdWlkXS5hbmdsZSA9IHBhcmFtcy5hbmdsZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAncGFyc2UgZ2VvanNvbic6IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGluZGV4RGF0YSA9IGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRhdGEgIT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKFwiSW5wdXQgZGF0YSBpcyBub3QgYSB2YWxpZCBHZW9KU09OIG9iamVjdC5cIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLmdlb0pTT05JbmRleGVzW3BhcmFtcy5zb3VyY2VdID0gZ2VvanNvbnZ0KGRhdGEsIHBhcmFtcy5nZW9qc29uVnRPcHRpb25zKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgICAgIH0uYmluZCh0aGlzKTtcblxuICAgICAgICAvLyBUT0RPIGFjY2VwdCBwYXJhbXMudXJsIGZvciB1cmxzIGluc3RlYWRcblxuICAgICAgICAvLyBOb3QsIGJlY2F1c2Ugb2Ygc2FtZSBvcmlnaW4gaXNzdWVzLCB1cmxzIG11c3QgZWl0aGVyIGluY2x1ZGUgYW5cbiAgICAgICAgLy8gZXhwbGljaXQgb3JpZ2luIG9yIGFic29sdXRlIHBhdGguXG4gICAgICAgIC8vIGllOiAvZm9vL2Jhci5qc29uIG9yIGh0dHA6Ly9leGFtcGxlLmNvbS9iYXIuanNvblxuICAgICAgICAvLyBidXQgbm90IC4uL2Zvby9iYXIuanNvblxuICAgICAgICBpZiAodHlwZW9mIHBhcmFtcy5kYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYWpheC5nZXRKU09OKHBhcmFtcy5kYXRhLCBpbmRleERhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaW5kZXhEYXRhKG51bGwsIHBhcmFtcy5kYXRhKTtcbiAgICB9LFxuXG4gICAgJ2xvYWQgZ2VvanNvbiB0aWxlJzogZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgc291cmNlID0gcGFyYW1zLnNvdXJjZSxcbiAgICAgICAgICAgIGNvb3JkID0gcGFyYW1zLmNvb3JkO1xuXG4gICAgICAgIGlmICghdGhpcy5nZW9KU09OSW5kZXhlc1tzb3VyY2VdKSByZXR1cm4gY2FsbGJhY2sobnVsbCwgbnVsbCk7IC8vIHdlIGNvdWxkbid0IGxvYWQgdGhlIGZpbGVcblxuICAgICAgICAvLyBjb25zb2xlLnRpbWUoJ3RpbGUgJyArIGNvb3JkLnogKyAnICcgKyBjb29yZC54ICsgJyAnICsgY29vcmQueSk7XG5cbiAgICAgICAgdmFyIGdlb0pTT05UaWxlID0gdGhpcy5nZW9KU09OSW5kZXhlc1tzb3VyY2VdLmdldFRpbGUoY29vcmQueiwgY29vcmQueCwgY29vcmQueSk7XG5cbiAgICAgICAgLy8gY29uc29sZS50aW1lRW5kKCd0aWxlICcgKyBjb29yZC56ICsgJyAnICsgY29vcmQueCArICcgJyArIGNvb3JkLnkpO1xuXG4gICAgICAgIC8vIGlmICghZ2VvSlNPTlRpbGUpIGNvbnNvbGUubG9nKCdub3QgZm91bmQnLCB0aGlzLmdlb0pTT05JbmRleGVzW3NvdXJjZV0sIGNvb3JkKTtcblxuICAgICAgICBpZiAoIWdlb0pTT05UaWxlKSByZXR1cm4gY2FsbGJhY2sobnVsbCwgbnVsbCk7IC8vIG5vdGhpbmcgaW4gdGhlIGdpdmVuIHRpbGVcblxuICAgICAgICB2YXIgdGlsZSA9IG5ldyBXb3JrZXJUaWxlKHBhcmFtcyk7XG4gICAgICAgIHRpbGUucGFyc2UobmV3IEdlb0pTT05XcmFwcGVyKGdlb0pTT05UaWxlLmZlYXR1cmVzKSwgdGhpcy5sYXllcnMsIHRoaXMuYWN0b3IsIGNhbGxiYWNrKTtcblxuICAgICAgICB0aGlzLmxvYWRlZFtzb3VyY2VdID0gdGhpcy5sb2FkZWRbc291cmNlXSB8fCB7fTtcbiAgICAgICAgdGhpcy5sb2FkZWRbc291cmNlXVtwYXJhbXMudWlkXSA9IHRpbGU7XG4gICAgfSxcblxuICAgICdxdWVyeSBmZWF0dXJlcyc6IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHRpbGUgPSB0aGlzLmxvYWRlZFtwYXJhbXMuc291cmNlXSAmJiB0aGlzLmxvYWRlZFtwYXJhbXMuc291cmNlXVtwYXJhbXMudWlkXTtcbiAgICAgICAgaWYgKHRpbGUpIHtcbiAgICAgICAgICAgIHRpbGUuZmVhdHVyZVRyZWUucXVlcnkocGFyYW1zLCBjYWxsYmFjayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCBbXSk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEZlYXR1cmVUcmVlID0gcmVxdWlyZSgnLi4vZGF0YS9mZWF0dXJlX3RyZWUnKTtcbnZhciBDb2xsaXNpb25UaWxlID0gcmVxdWlyZSgnLi4vc3ltYm9sL2NvbGxpc2lvbl90aWxlJyk7XG52YXIgQnVja2V0ID0gcmVxdWlyZSgnLi4vZGF0YS9idWNrZXQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBXb3JrZXJUaWxlO1xuXG5mdW5jdGlvbiBXb3JrZXJUaWxlKHBhcmFtcykge1xuICAgIHRoaXMuY29vcmQgPSBwYXJhbXMuY29vcmQ7XG4gICAgdGhpcy51aWQgPSBwYXJhbXMudWlkO1xuICAgIHRoaXMuem9vbSA9IHBhcmFtcy56b29tO1xuICAgIHRoaXMudGlsZVNpemUgPSBwYXJhbXMudGlsZVNpemU7XG4gICAgdGhpcy5zb3VyY2UgPSBwYXJhbXMuc291cmNlO1xuICAgIHRoaXMub3ZlcnNjYWxpbmcgPSBwYXJhbXMub3ZlcnNjYWxpbmc7XG4gICAgdGhpcy5hbmdsZSA9IHBhcmFtcy5hbmdsZTtcbiAgICB0aGlzLnBpdGNoID0gcGFyYW1zLnBpdGNoO1xuICAgIHRoaXMuY29sbGlzaW9uRGVidWcgPSBwYXJhbXMuY29sbGlzaW9uRGVidWc7XG59XG5cbldvcmtlclRpbGUucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24oZGF0YSwgbGF5ZXJzLCBhY3RvciwgY2FsbGJhY2spIHtcblxuICAgIHRoaXMuc3RhdHVzID0gJ3BhcnNpbmcnO1xuXG4gICAgdGhpcy5mZWF0dXJlVHJlZSA9IG5ldyBGZWF0dXJlVHJlZSh0aGlzLmNvb3JkLCB0aGlzLm92ZXJzY2FsaW5nKTtcblxuICAgIHZhciBzdGF0cyA9IHsgX3RvdGFsOiAwIH07XG5cbiAgICB2YXIgdGlsZSA9IHRoaXMsXG4gICAgICAgIGJ1ZmZlcnMgPSB7fSxcbiAgICAgICAgY29sbGlzaW9uVGlsZSA9IG5ldyBDb2xsaXNpb25UaWxlKHRoaXMuYW5nbGUsIHRoaXMucGl0Y2gpLFxuICAgICAgICBidWNrZXRzQnlJZCA9IHt9LFxuICAgICAgICBidWNrZXRzQnlTb3VyY2VMYXllciA9IHt9LFxuICAgICAgICBpLCBsYXllciwgc291cmNlTGF5ZXJJZCwgYnVja2V0O1xuXG4gICAgLy8gTWFwIG5vbi1yZWYgbGF5ZXJzIHRvIGJ1Y2tldHMuXG4gICAgZm9yIChpID0gMDsgaSA8IGxheWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsYXllciA9IGxheWVyc1tpXTtcblxuICAgICAgICBpZiAobGF5ZXIuc291cmNlICE9PSB0aGlzLnNvdXJjZSB8fFxuICAgICAgICAgICAgICAgIGxheWVyLnJlZiB8fFxuICAgICAgICAgICAgICAgIGxheWVyLm1pbnpvb20gJiYgdGhpcy56b29tIDwgbGF5ZXIubWluem9vbSB8fFxuICAgICAgICAgICAgICAgIGxheWVyLm1heHpvb20gJiYgdGhpcy56b29tID49IGxheWVyLm1heHpvb20gfHxcbiAgICAgICAgICAgICAgICBsYXllci5sYXlvdXQudmlzaWJpbGl0eSA9PT0gJ25vbmUnKVxuICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgYnVja2V0ID0gQnVja2V0LmNyZWF0ZSh7XG4gICAgICAgICAgICBsYXllcjogbGF5ZXIsXG4gICAgICAgICAgICBidWZmZXJzOiBidWZmZXJzLFxuICAgICAgICAgICAgem9vbTogdGhpcy56b29tLFxuICAgICAgICAgICAgb3ZlcnNjYWxpbmc6IHRoaXMub3ZlcnNjYWxpbmcsXG4gICAgICAgICAgICBjb2xsaXNpb25EZWJ1ZzogdGhpcy5jb2xsaXNpb25EZWJ1Z1xuICAgICAgICB9KTtcbiAgICAgICAgYnVja2V0LmxheWVycyA9IFtsYXllci5pZF07XG5cbiAgICAgICAgYnVja2V0c0J5SWRbbGF5ZXIuaWRdID0gYnVja2V0O1xuXG4gICAgICAgIGlmIChkYXRhLmxheWVycykgeyAvLyB2ZWN0b3J0aWxlXG4gICAgICAgICAgICBzb3VyY2VMYXllcklkID0gbGF5ZXJbJ3NvdXJjZS1sYXllciddO1xuICAgICAgICAgICAgYnVja2V0c0J5U291cmNlTGF5ZXJbc291cmNlTGF5ZXJJZF0gPSBidWNrZXRzQnlTb3VyY2VMYXllcltzb3VyY2VMYXllcklkXSB8fCB7fTtcbiAgICAgICAgICAgIGJ1Y2tldHNCeVNvdXJjZUxheWVyW3NvdXJjZUxheWVySWRdW2xheWVyLmlkXSA9IGJ1Y2tldDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEluZGV4IHJlZiBsYXllcnMuXG4gICAgZm9yIChpID0gMDsgaSA8IGxheWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsYXllciA9IGxheWVyc1tpXTtcbiAgICAgICAgaWYgKGxheWVyLnNvdXJjZSA9PT0gdGhpcy5zb3VyY2UgJiYgbGF5ZXIucmVmICYmIGJ1Y2tldHNCeUlkW2xheWVyLnJlZl0pIHtcbiAgICAgICAgICAgIGJ1Y2tldHNCeUlkW2xheWVyLnJlZl0ubGF5ZXJzLnB1c2gobGF5ZXIuaWQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGV4dGVudCA9IDQwOTY7XG5cbiAgICAvLyByZWFkIGVhY2ggbGF5ZXIsIGFuZCBzb3J0IGl0cyBmZWF0dXJlcyBpbnRvIGJ1Y2tldHNcbiAgICBpZiAoZGF0YS5sYXllcnMpIHsgLy8gdmVjdG9ydGlsZVxuICAgICAgICBmb3IgKHNvdXJjZUxheWVySWQgaW4gYnVja2V0c0J5U291cmNlTGF5ZXIpIHtcbiAgICAgICAgICAgIGxheWVyID0gZGF0YS5sYXllcnNbc291cmNlTGF5ZXJJZF07XG4gICAgICAgICAgICBpZiAoIWxheWVyKSBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChsYXllci5leHRlbnQpIGV4dGVudCA9IGxheWVyLmV4dGVudDtcbiAgICAgICAgICAgIHNvcnRMYXllckludG9CdWNrZXRzKGxheWVyLCBidWNrZXRzQnlTb3VyY2VMYXllcltzb3VyY2VMYXllcklkXSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgeyAvLyBnZW9qc29uXG4gICAgICAgIHNvcnRMYXllckludG9CdWNrZXRzKGRhdGEsIGJ1Y2tldHNCeUlkKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzb3J0TGF5ZXJJbnRvQnVja2V0cyhsYXllciwgYnVja2V0cykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxheWVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZmVhdHVyZSA9IGxheWVyLmZlYXR1cmUoaSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpZCBpbiBidWNrZXRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJ1Y2tldHNbaWRdLmZpbHRlcihmZWF0dXJlKSlcbiAgICAgICAgICAgICAgICAgICAgYnVja2V0c1tpZF0uZmVhdHVyZXMucHVzaChmZWF0dXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBidWNrZXRzID0gW10sXG4gICAgICAgIHN5bWJvbEJ1Y2tldHMgPSB0aGlzLnN5bWJvbEJ1Y2tldHMgPSBbXSxcbiAgICAgICAgb3RoZXJCdWNrZXRzID0gW107XG5cbiAgICBmb3IgKHZhciBpZCBpbiBidWNrZXRzQnlJZCkge1xuICAgICAgICBidWNrZXQgPSBidWNrZXRzQnlJZFtpZF07XG4gICAgICAgIGlmIChidWNrZXQuZmVhdHVyZXMubGVuZ3RoID09PSAwKSBjb250aW51ZTtcblxuICAgICAgICBidWNrZXRzLnB1c2goYnVja2V0KTtcblxuICAgICAgICBpZiAoYnVja2V0LnR5cGUgPT09ICdzeW1ib2wnKVxuICAgICAgICAgICAgc3ltYm9sQnVja2V0cy5wdXNoKGJ1Y2tldCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIG90aGVyQnVja2V0cy5wdXNoKGJ1Y2tldCk7XG4gICAgfVxuXG4gICAgdmFyIGljb25zID0ge30sXG4gICAgICAgIHN0YWNrcyA9IHt9O1xuXG4gICAgaWYgKHN5bWJvbEJ1Y2tldHMubGVuZ3RoID4gMCkge1xuXG4gICAgICAgIC8vIEdldCBkZXBlbmRlbmNpZXMgZm9yIHN5bWJvbCBidWNrZXRzXG4gICAgICAgIGZvciAoaSA9IHN5bWJvbEJ1Y2tldHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHN5bWJvbEJ1Y2tldHNbaV0udXBkYXRlSWNvbnMoaWNvbnMpO1xuICAgICAgICAgICAgc3ltYm9sQnVja2V0c1tpXS51cGRhdGVGb250KHN0YWNrcyk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBmb250TmFtZSBpbiBzdGFja3MpIHtcbiAgICAgICAgICAgIHN0YWNrc1tmb250TmFtZV0gPSBPYmplY3Qua2V5cyhzdGFja3NbZm9udE5hbWVdKS5tYXAoTnVtYmVyKTtcbiAgICAgICAgfVxuICAgICAgICBpY29ucyA9IE9iamVjdC5rZXlzKGljb25zKTtcblxuICAgICAgICB2YXIgZGVwcyA9IDA7XG5cbiAgICAgICAgYWN0b3Iuc2VuZCgnZ2V0IGdseXBocycsIHt1aWQ6IHRoaXMudWlkLCBzdGFja3M6IHN0YWNrc30sIGZ1bmN0aW9uKGVyciwgbmV3U3RhY2tzKSB7XG4gICAgICAgICAgICBzdGFja3MgPSBuZXdTdGFja3M7XG4gICAgICAgICAgICBnb3REZXBlbmRlbmN5KGVycik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChpY29ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGFjdG9yLnNlbmQoJ2dldCBpY29ucycsIHtpY29uczogaWNvbnN9LCBmdW5jdGlvbihlcnIsIG5ld0ljb25zKSB7XG4gICAgICAgICAgICAgICAgaWNvbnMgPSBuZXdJY29ucztcbiAgICAgICAgICAgICAgICBnb3REZXBlbmRlbmN5KGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdvdERlcGVuZGVuY3koKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGltbWVkaWF0ZWx5IHBhcnNlIG5vbi1zeW1ib2wgYnVja2V0cyAodGhleSBoYXZlIG5vIGRlcGVuZGVuY2llcylcbiAgICBmb3IgKGkgPSBvdGhlckJ1Y2tldHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgcGFyc2VCdWNrZXQodGhpcywgb3RoZXJCdWNrZXRzW2ldKTtcbiAgICB9XG5cbiAgICBpZiAoc3ltYm9sQnVja2V0cy5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiBkb25lKCk7XG5cbiAgICBmdW5jdGlvbiBnb3REZXBlbmRlbmN5KGVycikge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgZGVwcysrO1xuICAgICAgICBpZiAoZGVwcyA9PT0gMikge1xuICAgICAgICAgICAgLy8gYWxsIHN5bWJvbCBidWNrZXQgZGVwZW5kZW5jaWVzIGZldGNoZWQ7IHBhcnNlIHRoZW0gaW4gcHJvcGVyIG9yZGVyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gc3ltYm9sQnVja2V0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIHBhcnNlQnVja2V0KHRpbGUsIHN5bWJvbEJ1Y2tldHNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VCdWNrZXQodGlsZSwgYnVja2V0KSB7XG4gICAgICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBidWNrZXQuYWRkRmVhdHVyZXMoY29sbGlzaW9uVGlsZSwgc3RhY2tzLCBpY29ucyk7XG4gICAgICAgIHZhciB0aW1lID0gRGF0ZS5ub3coKSAtIG5vdztcblxuICAgICAgICBpZiAoYnVja2V0LmludGVyYWN0aXZlKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1Y2tldC5mZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBmZWF0dXJlID0gYnVja2V0LmZlYXR1cmVzW2ldO1xuICAgICAgICAgICAgICAgIHRpbGUuZmVhdHVyZVRyZWUuaW5zZXJ0KGZlYXR1cmUuYmJveCgpLCBidWNrZXQubGF5ZXJzLCBmZWF0dXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJ1Y2tldC5mZWF0dXJlcyA9IG51bGw7XG5cbiAgICAgICAgc3RhdHMuX3RvdGFsICs9IHRpbWU7XG4gICAgICAgIHN0YXRzW2J1Y2tldC5pZF0gPSAoc3RhdHNbYnVja2V0LmlkXSB8fCAwKSArIHRpbWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZG9uZSgpIHtcbiAgICAgICAgdGlsZS5zdGF0dXMgPSAnZG9uZSc7XG5cbiAgICAgICAgaWYgKHRpbGUucmVkb1BsYWNlbWVudEFmdGVyRG9uZSkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRpbGUucmVkb1BsYWNlbWVudCh0aWxlLmFuZ2xlLCB0aWxlLnBpdGNoKS5yZXN1bHQ7XG4gICAgICAgICAgICBidWZmZXJzLmdseXBoVmVydGV4ID0gcmVzdWx0LmJ1ZmZlcnMuZ2x5cGhWZXJ0ZXg7XG4gICAgICAgICAgICBidWZmZXJzLmljb25WZXJ0ZXggPSByZXN1bHQuYnVmZmVycy5pY29uVmVydGV4O1xuICAgICAgICAgICAgYnVmZmVycy5jb2xsaXNpb25Cb3hWZXJ0ZXggPSByZXN1bHQuYnVmZmVycy5jb2xsaXNpb25Cb3hWZXJ0ZXg7XG4gICAgICAgICAgICB0aWxlLnJlZG9QbGFjZW1lbnRBZnRlckRvbmUgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGxiYWNrKG51bGwsIHtcbiAgICAgICAgICAgIGVsZW1lbnRHcm91cHM6IGdldEVsZW1lbnRHcm91cHMoYnVja2V0cyksXG4gICAgICAgICAgICBidWZmZXJzOiBidWZmZXJzLFxuICAgICAgICAgICAgZXh0ZW50OiBleHRlbnQsXG4gICAgICAgICAgICBidWNrZXRTdGF0czogc3RhdHNcbiAgICAgICAgfSwgZ2V0VHJhbnNmZXJhYmxlcyhidWZmZXJzKSk7XG4gICAgfVxufTtcblxuV29ya2VyVGlsZS5wcm90b3R5cGUucmVkb1BsYWNlbWVudCA9IGZ1bmN0aW9uKGFuZ2xlLCBwaXRjaCwgY29sbGlzaW9uRGVidWcpIHtcblxuICAgIGlmICh0aGlzLnN0YXR1cyAhPT0gJ2RvbmUnKSB7XG4gICAgICAgIHRoaXMucmVkb1BsYWNlbWVudEFmdGVyRG9uZSA9IHRydWU7XG4gICAgICAgIHRoaXMuYW5nbGUgPSBhbmdsZTtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cblxuICAgIHZhciBidWZmZXJzID0ge30sXG4gICAgICAgIGNvbGxpc2lvblRpbGUgPSBuZXcgQ29sbGlzaW9uVGlsZShhbmdsZSwgcGl0Y2gpO1xuXG4gICAgZm9yICh2YXIgaSA9IHRoaXMuc3ltYm9sQnVja2V0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB0aGlzLnN5bWJvbEJ1Y2tldHNbaV0ucGxhY2VGZWF0dXJlcyhjb2xsaXNpb25UaWxlLCBidWZmZXJzLCBjb2xsaXNpb25EZWJ1Zyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdWx0OiB7XG4gICAgICAgICAgICBlbGVtZW50R3JvdXBzOiBnZXRFbGVtZW50R3JvdXBzKHRoaXMuc3ltYm9sQnVja2V0cyksXG4gICAgICAgICAgICBidWZmZXJzOiBidWZmZXJzXG4gICAgICAgIH0sXG4gICAgICAgIHRyYW5zZmVyYWJsZXM6IGdldFRyYW5zZmVyYWJsZXMoYnVmZmVycylcbiAgICB9O1xufTtcblxuZnVuY3Rpb24gZ2V0RWxlbWVudEdyb3VwcyhidWNrZXRzKSB7XG4gICAgdmFyIGVsZW1lbnRHcm91cHMgPSB7fTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVja2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBlbGVtZW50R3JvdXBzW2J1Y2tldHNbaV0uaWRdID0gYnVja2V0c1tpXS5lbGVtZW50R3JvdXBzO1xuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudEdyb3Vwcztcbn1cblxuZnVuY3Rpb24gZ2V0VHJhbnNmZXJhYmxlcyhidWZmZXJzKSB7XG4gICAgdmFyIHRyYW5zZmVyYWJsZXMgPSBbXTtcblxuICAgIGZvciAodmFyIGsgaW4gYnVmZmVycykge1xuICAgICAgICB0cmFuc2ZlcmFibGVzLnB1c2goYnVmZmVyc1trXS5hcnJheUJ1ZmZlcik7XG5cbiAgICAgICAgLy8gVGhlIEJ1ZmZlcjo6cHVzaCBtZXRob2QgaXMgZ2VuZXJhdGVkIHdpdGggXCJuZXcgRnVuY3Rpb24oLi4uKVwiIGFuZCBub3QgdHJhbnNmZXJyYWJsZS5cbiAgICAgICAgYnVmZmVyc1trXS5wdXNoID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRyYW5zZmVyYWJsZXM7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gQW5pbWF0aW9uTG9vcDtcblxuZnVuY3Rpb24gQW5pbWF0aW9uTG9vcCgpIHtcbiAgICB0aGlzLm4gPSAwO1xuICAgIHRoaXMudGltZXMgPSBbXTtcbn1cblxuLy8gQXJlIGFsbCBhbmltYXRpb25zIGRvbmU/XG5BbmltYXRpb25Mb29wLnByb3RvdHlwZS5zdG9wcGVkID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy50aW1lcyA9IHRoaXMudGltZXMuZmlsdGVyKGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIHQudGltZSA+PSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuICAgIH0pO1xuICAgIHJldHVybiAhdGhpcy50aW1lcy5sZW5ndGg7XG59O1xuXG4vLyBBZGQgYSBuZXcgYW5pbWF0aW9uIHRoYXQgd2lsbCBydW4gdCBtaWxsaXNlY29uZHNcbi8vIFJldHVybnMgYW4gaWQgdGhhdCBjYW4gYmUgdXNlZCB0byBjYW5jZWwgaXQgbGF5ZXJcbkFuaW1hdGlvbkxvb3AucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnRpbWVzLnB1c2goeyBpZDogdGhpcy5uLCB0aW1lOiB0ICsgKG5ldyBEYXRlKCkpLmdldFRpbWUoKSB9KTtcbiAgICByZXR1cm4gdGhpcy5uKys7XG59O1xuXG4vLyBDYW5jZWwgYW4gYW5pbWF0aW9uXG5BbmltYXRpb25Mb29wLnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbihuKSB7XG4gICAgdGhpcy50aW1lcyA9IHRoaXMudGltZXMuZmlsdGVyKGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIHQuaWQgIT09IG47XG4gICAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRlZCA9IHJlcXVpcmUoJy4uL3V0aWwvZXZlbnRlZCcpO1xudmFyIGFqYXggPSByZXF1aXJlKCcuLi91dGlsL2FqYXgnKTtcbnZhciBicm93c2VyID0gcmVxdWlyZSgnLi4vdXRpbC9icm93c2VyJyk7XG52YXIgbm9ybWFsaXplVVJMID0gcmVxdWlyZSgnLi4vdXRpbC9tYXBib3gnKS5ub3JtYWxpemVTcHJpdGVVUkw7XG5cbm1vZHVsZS5leHBvcnRzID0gSW1hZ2VTcHJpdGU7XG5cbmZ1bmN0aW9uIEltYWdlU3ByaXRlKGJhc2UpIHtcbiAgICB0aGlzLmJhc2UgPSBiYXNlO1xuICAgIHRoaXMucmV0aW5hID0gYnJvd3Nlci5kZXZpY2VQaXhlbFJhdGlvID4gMTtcblxuICAgIHZhciBmb3JtYXQgPSB0aGlzLnJldGluYSA/ICdAMngnIDogJyc7XG5cbiAgICBhamF4LmdldEpTT04obm9ybWFsaXplVVJMKGJhc2UsIGZvcm1hdCwgJy5qc29uJyksIGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ2Vycm9yJywge2Vycm9yOiBlcnJ9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIGlmICh0aGlzLmltZykgdGhpcy5maXJlKCdsb2FkJyk7XG4gICAgfS5iaW5kKHRoaXMpKTtcblxuICAgIGFqYXguZ2V0SW1hZ2Uobm9ybWFsaXplVVJMKGJhc2UsIGZvcm1hdCwgJy5wbmcnKSwgZnVuY3Rpb24oZXJyLCBpbWcpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgdGhpcy5maXJlKCdlcnJvcicsIHtlcnJvcjogZXJyfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwcmVtdWx0aXBseSB0aGUgc3ByaXRlXG4gICAgICAgIHZhciBkYXRhID0gaW1nLmdldERhdGEoKTtcbiAgICAgICAgdmFyIG5ld2RhdGEgPSBpbWcuZGF0YSA9IG5ldyBVaW50OEFycmF5KGRhdGEubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgICAgICAgICB2YXIgYWxwaGEgPSBkYXRhW2kgKyAzXSAvIDI1NTtcbiAgICAgICAgICAgIG5ld2RhdGFbaSArIDBdID0gZGF0YVtpICsgMF0gKiBhbHBoYTtcbiAgICAgICAgICAgIG5ld2RhdGFbaSArIDFdID0gZGF0YVtpICsgMV0gKiBhbHBoYTtcbiAgICAgICAgICAgIG5ld2RhdGFbaSArIDJdID0gZGF0YVtpICsgMl0gKiBhbHBoYTtcbiAgICAgICAgICAgIG5ld2RhdGFbaSArIDNdID0gZGF0YVtpICsgM107XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmltZyA9IGltZztcbiAgICAgICAgaWYgKHRoaXMuZGF0YSkgdGhpcy5maXJlKCdsb2FkJyk7XG4gICAgfS5iaW5kKHRoaXMpKTtcbn1cblxuSW1hZ2VTcHJpdGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFdmVudGVkKTtcblxuSW1hZ2VTcHJpdGUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmJhc2U7XG59O1xuXG5JbWFnZVNwcml0ZS5wcm90b3R5cGUubG9hZGVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICEhKHRoaXMuZGF0YSAmJiB0aGlzLmltZyk7XG59O1xuXG5JbWFnZVNwcml0ZS5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24oLypnbCovKSB7XG4gICAgaWYgKGJyb3dzZXIuZGV2aWNlUGl4ZWxSYXRpbyA+IDEgIT09IHRoaXMucmV0aW5hKSB7XG4gICAgICAgIHZhciBuZXdTcHJpdGUgPSBuZXcgSW1hZ2VTcHJpdGUodGhpcy5iYXNlKTtcbiAgICAgICAgbmV3U3ByaXRlLm9uKCdsb2FkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLmltZyA9IG5ld1Nwcml0ZS5pbWc7XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBuZXdTcHJpdGUuZGF0YTtcbiAgICAgICAgICAgIHRoaXMucmV0aW5hID0gbmV3U3ByaXRlLnJldGluYTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBTcHJpdGVQb3NpdGlvbigpIHt9XG5TcHJpdGVQb3NpdGlvbi5wcm90b3R5cGUgPSB7IHg6IDAsIHk6IDAsIHdpZHRoOiAwLCBoZWlnaHQ6IDAsIHBpeGVsUmF0aW86IDEsIHNkZjogZmFsc2UgfTtcblxuSW1hZ2VTcHJpdGUucHJvdG90eXBlLmdldFNwcml0ZVBvc2l0aW9uID0gZnVuY3Rpb24obmFtZSkge1xuICAgIGlmICghdGhpcy5sb2FkZWQoKSkgcmV0dXJuIG5ldyBTcHJpdGVQb3NpdGlvbigpO1xuXG4gICAgdmFyIHBvcyA9IHRoaXMuZGF0YSAmJiB0aGlzLmRhdGFbbmFtZV07XG4gICAgaWYgKHBvcyAmJiB0aGlzLmltZykgcmV0dXJuIHBvcztcblxuICAgIHJldHVybiBuZXcgU3ByaXRlUG9zaXRpb24oKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciByZWZlcmVuY2UgPSByZXF1aXJlKCcuL3JlZmVyZW5jZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5yZWZlcmVuY2UubGF5b3V0LmZvckVhY2goZnVuY3Rpb24oY2xhc3NOYW1lKSB7XG4gICAgdmFyIFByb3BlcnRpZXMgPSBmdW5jdGlvbihwcm9wcykge1xuICAgICAgICBmb3IgKHZhciBwIGluIHByb3BzKSB7XG4gICAgICAgICAgICB0aGlzW3BdID0gcHJvcHNbcF07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHByb3BlcnRpZXMgPSByZWZlcmVuY2VbY2xhc3NOYW1lXTtcbiAgICBmb3IgKHZhciBwcm9wIGluIHByb3BlcnRpZXMpIHtcbiAgICAgICAgaWYgKHByb3BlcnRpZXNbcHJvcF0uZGVmYXVsdCA9PT0gdW5kZWZpbmVkKSBjb250aW51ZTtcbiAgICAgICAgUHJvcGVydGllcy5wcm90b3R5cGVbcHJvcF0gPSBwcm9wZXJ0aWVzW3Byb3BdLmRlZmF1bHQ7XG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzW2NsYXNzTmFtZS5yZXBsYWNlKCdsYXlvdXRfJywgJycpXSA9IFByb3BlcnRpZXM7XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHJlZmVyZW5jZSA9IHJlcXVpcmUoJy4vcmVmZXJlbmNlJyk7XG52YXIgcGFyc2VDU1NDb2xvciA9IHJlcXVpcmUoJ2Nzc2NvbG9ycGFyc2VyJykucGFyc2VDU1NDb2xvcjtcblxubW9kdWxlLmV4cG9ydHMgPSB7fTtcblxucmVmZXJlbmNlLnBhaW50LmZvckVhY2goZnVuY3Rpb24oY2xhc3NOYW1lKSB7XG4gICAgdmFyIENhbGN1bGF0ZWQgPSBmdW5jdGlvbigpIHt9O1xuXG4gICAgdmFyIHByb3BlcnRpZXMgPSByZWZlcmVuY2VbY2xhc3NOYW1lXTtcbiAgICBmb3IgKHZhciBwIGluIHByb3BlcnRpZXMpIHtcbiAgICAgICAgdmFyIHByb3AgPSBwcm9wZXJ0aWVzW3BdLFxuICAgICAgICAgICAgdmFsdWUgPSBwcm9wLmRlZmF1bHQ7XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIGNvbnRpbnVlO1xuICAgICAgICBpZiAocHJvcC50eXBlID09PSAnY29sb3InKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHBhcnNlQ1NTQ29sb3IodmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgQ2FsY3VsYXRlZC5wcm90b3R5cGVbcF0gPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBDYWxjdWxhdGVkLnByb3RvdHlwZS5oaWRkZW4gPSBmYWxzZTtcbiAgICBtb2R1bGUuZXhwb3J0c1tjbGFzc05hbWUucmVwbGFjZSgncGFpbnRfJywgJycpXSA9IENhbGN1bGF0ZWQ7XG59KTtcbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnbWFwYm94LWdsLXN0eWxlLXNwZWMvcmVmZXJlbmNlL2xhdGVzdCcpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRlZCA9IHJlcXVpcmUoJy4uL3V0aWwvZXZlbnRlZCcpO1xudmFyIHN0eWxlQmF0Y2ggPSByZXF1aXJlKCcuL3N0eWxlX2JhdGNoJyk7XG52YXIgU3R5bGVMYXllciA9IHJlcXVpcmUoJy4vc3R5bGVfbGF5ZXInKTtcbnZhciBJbWFnZVNwcml0ZSA9IHJlcXVpcmUoJy4vaW1hZ2Vfc3ByaXRlJyk7XG52YXIgR2x5cGhTb3VyY2UgPSByZXF1aXJlKCcuLi9zeW1ib2wvZ2x5cGhfc291cmNlJyk7XG52YXIgU3ByaXRlQXRsYXMgPSByZXF1aXJlKCcuLi9zeW1ib2wvc3ByaXRlX2F0bGFzJyk7XG52YXIgTGluZUF0bGFzID0gcmVxdWlyZSgnLi4vcmVuZGVyL2xpbmVfYXRsYXMnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJyk7XG52YXIgYWpheCA9IHJlcXVpcmUoJy4uL3V0aWwvYWpheCcpO1xudmFyIG5vcm1hbGl6ZVVSTCA9IHJlcXVpcmUoJy4uL3V0aWwvbWFwYm94Jykubm9ybWFsaXplU3R5bGVVUkw7XG52YXIgYnJvd3NlciA9IHJlcXVpcmUoJy4uL3V0aWwvYnJvd3NlcicpO1xudmFyIERpc3BhdGNoZXIgPSByZXF1aXJlKCcuLi91dGlsL2Rpc3BhdGNoZXInKTtcbnZhciBBbmltYXRpb25Mb29wID0gcmVxdWlyZSgnLi9hbmltYXRpb25fbG9vcCcpO1xudmFyIHZhbGlkYXRlID0gcmVxdWlyZSgnbWFwYm94LWdsLXN0eWxlLXNwZWMvbGliL3ZhbGlkYXRlL2xhdGVzdCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0eWxlO1xuXG5mdW5jdGlvbiBTdHlsZShzdHlsZXNoZWV0LCBhbmltYXRpb25Mb29wKSB7XG4gICAgdGhpcy5hbmltYXRpb25Mb29wID0gYW5pbWF0aW9uTG9vcCB8fCBuZXcgQW5pbWF0aW9uTG9vcCgpO1xuICAgIHRoaXMuZGlzcGF0Y2hlciA9IG5ldyBEaXNwYXRjaGVyKE1hdGgubWF4KGJyb3dzZXIuaGFyZHdhcmVDb25jdXJyZW5jeSAtIDEsIDEpLCB0aGlzKTtcbiAgICB0aGlzLnNwcml0ZUF0bGFzID0gbmV3IFNwcml0ZUF0bGFzKDUxMiwgNTEyKTtcbiAgICB0aGlzLmxpbmVBdGxhcyA9IG5ldyBMaW5lQXRsYXMoMjU2LCA1MTIpO1xuXG4gICAgdGhpcy5fbGF5ZXJzID0ge307XG4gICAgdGhpcy5fb3JkZXIgID0gW107XG4gICAgdGhpcy5fZ3JvdXBzID0gW107XG4gICAgdGhpcy5zb3VyY2VzID0ge307XG5cbiAgICB0aGlzLnpvb21IaXN0b3J5ID0ge307XG5cbiAgICB1dGlsLmJpbmRBbGwoW1xuICAgICAgICAnX2ZvcndhcmRTb3VyY2VFdmVudCcsXG4gICAgICAgICdfZm9yd2FyZFRpbGVFdmVudCcsXG4gICAgICAgICdfcmVkb1BsYWNlbWVudCdcbiAgICBdLCB0aGlzKTtcblxuICAgIHZhciBsb2FkZWQgPSBmdW5jdGlvbihlcnIsIHN0eWxlc2hlZXQpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgdGhpcy5maXJlKCdlcnJvcicsIHtlcnJvcjogZXJyfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdmFsaWQgPSB2YWxpZGF0ZShzdHlsZXNoZWV0KTtcbiAgICAgICAgaWYgKHZhbGlkLmxlbmd0aCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWxpZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyZSgnZXJyb3InLCB7IGVycm9yOiBuZXcgRXJyb3IodmFsaWRbaV0ubWVzc2FnZSkgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9sb2FkZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnN0eWxlc2hlZXQgPSBzdHlsZXNoZWV0O1xuXG4gICAgICAgIHZhciBzb3VyY2VzID0gc3R5bGVzaGVldC5zb3VyY2VzO1xuICAgICAgICBmb3IgKHZhciBpZCBpbiBzb3VyY2VzKSB7XG4gICAgICAgICAgICB0aGlzLmFkZFNvdXJjZShpZCwgc291cmNlc1tpZF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0eWxlc2hlZXQuc3ByaXRlKSB7XG4gICAgICAgICAgICB0aGlzLnNwcml0ZSA9IG5ldyBJbWFnZVNwcml0ZShzdHlsZXNoZWV0LnNwcml0ZSk7XG4gICAgICAgICAgICB0aGlzLnNwcml0ZS5vbignbG9hZCcsIHRoaXMuZmlyZS5iaW5kKHRoaXMsICdjaGFuZ2UnKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmdseXBoU291cmNlID0gbmV3IEdseXBoU291cmNlKHN0eWxlc2hlZXQuZ2x5cGhzKTtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZSgpO1xuICAgICAgICB0aGlzLmZpcmUoJ2xvYWQnKTtcbiAgICB9LmJpbmQodGhpcyk7XG5cbiAgICBpZiAodHlwZW9mIHN0eWxlc2hlZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGFqYXguZ2V0SlNPTihub3JtYWxpemVVUkwoc3R5bGVzaGVldCksIGxvYWRlZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYnJvd3Nlci5mcmFtZShsb2FkZWQuYmluZCh0aGlzLCBudWxsLCBzdHlsZXNoZWV0KSk7XG4gICAgfVxuXG4gICAgdGhpcy5vbignc291cmNlLmxvYWQnLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICB2YXIgc291cmNlID0gZXZlbnQuc291cmNlO1xuICAgICAgICBpZiAoc291cmNlICYmIHNvdXJjZS52ZWN0b3JMYXllcklkcykge1xuICAgICAgICAgICAgZm9yICh2YXIgbGF5ZXJJZCBpbiB0aGlzLl9sYXllcnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLl9sYXllcnNbbGF5ZXJJZF07XG4gICAgICAgICAgICAgICAgaWYgKGxheWVyLnNvdXJjZSA9PT0gc291cmNlLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbGlkYXRlTGF5ZXIobGF5ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5TdHlsZS5wcm90b3R5cGUgPSB1dGlsLmluaGVyaXQoRXZlbnRlZCwge1xuICAgIF9sb2FkZWQ6IGZhbHNlLFxuXG4gICAgX3ZhbGlkYXRlTGF5ZXI6IGZ1bmN0aW9uKGxheWVyKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSB0aGlzLnNvdXJjZXNbbGF5ZXIuc291cmNlXTtcblxuICAgICAgICBpZiAoIWxheWVyWydzb3VyY2UtbGF5ZXInXSkgcmV0dXJuO1xuICAgICAgICBpZiAoIXNvdXJjZSkgcmV0dXJuO1xuICAgICAgICBpZiAoIXNvdXJjZS52ZWN0b3JMYXllcklkcykgcmV0dXJuO1xuXG4gICAgICAgIGlmIChzb3VyY2UudmVjdG9yTGF5ZXJJZHMuaW5kZXhPZihsYXllclsnc291cmNlLWxheWVyJ10pID09PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5maXJlKCdlcnJvcicsIHtcbiAgICAgICAgICAgICAgICBlcnJvcjogbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAnU291cmNlIGxheWVyIFwiJyArIGxheWVyWydzb3VyY2UtbGF5ZXInXSArICdcIiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2RvZXMgbm90IGV4aXN0IG9uIHNvdXJjZSBcIicgKyBzb3VyY2UuaWQgKyAnXCIgJyArXG4gICAgICAgICAgICAgICAgICAgICdhcyBzcGVjaWZpZWQgYnkgc3R5bGUgbGF5ZXIgXCInICsgbGF5ZXIuaWQgKyAnXCInXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbG9hZGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9sb2FkZWQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgZm9yICh2YXIgaWQgaW4gdGhpcy5zb3VyY2VzKVxuICAgICAgICAgICAgaWYgKCF0aGlzLnNvdXJjZXNbaWRdLmxvYWRlZCgpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICBpZiAodGhpcy5zcHJpdGUgJiYgIXRoaXMuc3ByaXRlLmxvYWRlZCgpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICBfcmVzb2x2ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpZCwgbGF5ZXI7XG5cbiAgICAgICAgdGhpcy5fbGF5ZXJzID0ge307XG4gICAgICAgIHRoaXMuX29yZGVyICA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zdHlsZXNoZWV0LmxheWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGF5ZXIgPSBuZXcgU3R5bGVMYXllcih0aGlzLnN0eWxlc2hlZXQubGF5ZXJzW2ldKTtcbiAgICAgICAgICAgIHRoaXMuX2xheWVyc1tsYXllci5pZF0gPSBsYXllcjtcbiAgICAgICAgICAgIHRoaXMuX29yZGVyLnB1c2gobGF5ZXIuaWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVzb2x2ZSBsYXlvdXQgcHJvcGVydGllcy5cbiAgICAgICAgZm9yIChpZCBpbiB0aGlzLl9sYXllcnMpIHtcbiAgICAgICAgICAgIHRoaXMuX2xheWVyc1tpZF0ucmVzb2x2ZUxheW91dCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVzb2x2ZSByZWZlcmVuY2UgYW5kIHBhaW50IHByb3BlcnRpZXMuXG4gICAgICAgIGZvciAoaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XG4gICAgICAgICAgICB0aGlzLl9sYXllcnNbaWRdLnJlc29sdmVSZWZlcmVuY2UodGhpcy5fbGF5ZXJzKTtcbiAgICAgICAgICAgIHRoaXMuX2xheWVyc1tpZF0ucmVzb2x2ZVBhaW50KCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9ncm91cExheWVycygpO1xuICAgICAgICB0aGlzLl9icm9hZGNhc3RMYXllcnMoKTtcbiAgICB9LFxuXG4gICAgX2dyb3VwTGF5ZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGdyb3VwO1xuXG4gICAgICAgIHRoaXMuX2dyb3VwcyA9IFtdO1xuXG4gICAgICAgIC8vIFNwbGl0IGludG8gZ3JvdXBzIG9mIGNvbnNlY3V0aXZlIHRvcC1sZXZlbCBsYXllcnMgd2l0aCB0aGUgc2FtZSBzb3VyY2UuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fb3JkZXIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBsYXllciA9IHRoaXMuX2xheWVyc1t0aGlzLl9vcmRlcltpXV07XG5cbiAgICAgICAgICAgIGlmICghZ3JvdXAgfHwgbGF5ZXIuc291cmNlICE9PSBncm91cC5zb3VyY2UpIHtcbiAgICAgICAgICAgICAgICBncm91cCA9IFtdO1xuICAgICAgICAgICAgICAgIGdyb3VwLnNvdXJjZSA9IGxheWVyLnNvdXJjZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9ncm91cHMucHVzaChncm91cCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdyb3VwLnB1c2gobGF5ZXIpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9icm9hZGNhc3RMYXllcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoZXIuYnJvYWRjYXN0KCdzZXQgbGF5ZXJzJywgdGhpcy5fb3JkZXIubWFwKGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGF5ZXJzW2lkXS5qc29uKCk7XG4gICAgICAgIH0sIHRoaXMpKTtcbiAgICB9LFxuXG4gICAgX2Nhc2NhZGU6IGZ1bmN0aW9uKGNsYXNzZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9sb2FkZWQpIHJldHVybjtcblxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7XG4gICAgICAgICAgICB0cmFuc2l0aW9uOiB0cnVlXG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XG4gICAgICAgICAgICB0aGlzLl9sYXllcnNbaWRdLmNhc2NhZGUoY2xhc3Nlcywgb3B0aW9ucyxcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlc2hlZXQudHJhbnNpdGlvbiB8fCB7fSxcbiAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGlvbkxvb3ApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5maXJlKCdjaGFuZ2UnKTtcbiAgICB9LFxuXG4gICAgX3JlY2FsY3VsYXRlOiBmdW5jdGlvbih6KSB7XG4gICAgICAgIGZvciAodmFyIGlkIGluIHRoaXMuc291cmNlcylcbiAgICAgICAgICAgIHRoaXMuc291cmNlc1tpZF0udXNlZCA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuX3VwZGF0ZVpvb21IaXN0b3J5KHopO1xuXG4gICAgICAgIHRoaXMucmFzdGVyRmFkZUR1cmF0aW9uID0gMzAwO1xuICAgICAgICBmb3IgKGlkIGluIHRoaXMuX2xheWVycykge1xuICAgICAgICAgICAgdmFyIGxheWVyID0gdGhpcy5fbGF5ZXJzW2lkXTtcblxuICAgICAgICAgICAgaWYgKGxheWVyLnJlY2FsY3VsYXRlKHosIHRoaXMuem9vbUhpc3RvcnkpICYmIGxheWVyLnNvdXJjZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc291cmNlc1tsYXllci5zb3VyY2VdLnVzZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1heFpvb21UcmFuc2l0aW9uRHVyYXRpb24gPSAzMDA7XG4gICAgICAgIGlmIChNYXRoLmZsb29yKHRoaXMueikgIT09IE1hdGguZmxvb3IoeikpIHtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uTG9vcC5zZXQobWF4Wm9vbVRyYW5zaXRpb25EdXJhdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnogPSB6O1xuICAgICAgICB0aGlzLmZpcmUoJ3pvb20nKTtcbiAgICB9LFxuXG4gICAgX3VwZGF0ZVpvb21IaXN0b3J5OiBmdW5jdGlvbih6KSB7XG5cbiAgICAgICAgdmFyIHpoID0gdGhpcy56b29tSGlzdG9yeTtcblxuICAgICAgICBpZiAoemgubGFzdEludGVnZXJab29tID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIGZpcnN0IHRpbWVcbiAgICAgICAgICAgIHpoLmxhc3RJbnRlZ2VyWm9vbSA9IE1hdGguZmxvb3Ioeik7XG4gICAgICAgICAgICB6aC5sYXN0SW50ZWdlclpvb21UaW1lID0gMDtcbiAgICAgICAgICAgIHpoLmxhc3Rab29tID0gejtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNoZWNrIHdoZXRoZXIgYW4gaW50ZWdlciB6b29tIGxldmVsIGFzIHBhc3NlZCBzaW5jZSB0aGUgbGFzdCBmcmFtZVxuICAgICAgICAvLyBhbmQgaWYgeWVzLCByZWNvcmQgaXQgd2l0aCB0aGUgdGltZS4gVXNlZCBmb3IgdHJhbnNpdGlvbmluZyBwYXR0ZXJucy5cbiAgICAgICAgaWYgKE1hdGguZmxvb3IoemgubGFzdFpvb20pIDwgTWF0aC5mbG9vcih6KSkge1xuICAgICAgICAgICAgemgubGFzdEludGVnZXJab29tID0gTWF0aC5mbG9vcih6KTtcbiAgICAgICAgICAgIHpoLmxhc3RJbnRlZ2VyWm9vbVRpbWUgPSBEYXRlLm5vdygpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoTWF0aC5mbG9vcih6aC5sYXN0Wm9vbSkgPiBNYXRoLmZsb29yKHopKSB7XG4gICAgICAgICAgICB6aC5sYXN0SW50ZWdlclpvb20gPSBNYXRoLmZsb29yKHogKyAxKTtcbiAgICAgICAgICAgIHpoLmxhc3RJbnRlZ2VyWm9vbVRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICB9XG5cbiAgICAgICAgemgubGFzdFpvb20gPSB6O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBseSBtdWx0aXBsZSBzdHlsZSBtdXRhdGlvbnMgaW4gYSBiYXRjaFxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IHdvcmsgRnVuY3Rpb24gd2hpY2ggYWNjZXB0cyB0aGUgU3R5bGVCYXRjaCBpbnRlcmZhY2VcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGJhdGNoOiBmdW5jdGlvbih3b3JrKSB7XG4gICAgICAgIHN0eWxlQmF0Y2godGhpcywgd29yayk7XG4gICAgfSxcblxuICAgIGFkZFNvdXJjZTogZnVuY3Rpb24oaWQsIHNvdXJjZSkge1xuICAgICAgICB0aGlzLmJhdGNoKGZ1bmN0aW9uKGJhdGNoKSB7XG4gICAgICAgICAgICBiYXRjaC5hZGRTb3VyY2UoaWQsIHNvdXJjZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBzb3VyY2UgZnJvbSB0aGlzIHN0eWxlc2hlZXQsIGdpdmVuIGl0cyBpZC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgaWQgb2YgdGhlIHNvdXJjZSB0byByZW1vdmVcbiAgICAgKiBAcmV0dXJucyB7U3R5bGV9IHRoaXMgc3R5bGVcbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gaWYgbm8gc291cmNlIGlzIGZvdW5kIHdpdGggdGhlIGdpdmVuIElEXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICByZW1vdmVTb3VyY2U6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIHRoaXMuYmF0Y2goZnVuY3Rpb24oYmF0Y2gpIHtcbiAgICAgICAgICAgIGJhdGNoLnJlbW92ZVNvdXJjZShpZCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSBzb3VyY2UgYnkgaWQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIGlkIG9mIHRoZSBkZXNpcmVkIHNvdXJjZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHNvdXJjZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZ2V0U291cmNlOiBmdW5jdGlvbihpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VzW2lkXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGEgbGF5ZXIgdG8gdGhlIG1hcCBzdHlsZS4gVGhlIGxheWVyIHdpbGwgYmUgaW5zZXJ0ZWQgYmVmb3JlIHRoZSBsYXllciB3aXRoXG4gICAgICogSUQgYGJlZm9yZWAsIG9yIGFwcGVuZGVkIGlmIGBiZWZvcmVgIGlzIG9taXR0ZWQuXG4gICAgICogQHBhcmFtIHtTdHlsZUxheWVyfE9iamVjdH0gbGF5ZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IGJlZm9yZSAgSUQgb2YgYW4gZXhpc3RpbmcgbGF5ZXIgdG8gaW5zZXJ0IGJlZm9yZVxuICAgICAqIEBmaXJlcyBsYXllci5hZGRcbiAgICAgKiBAcmV0dXJucyB7U3R5bGV9IGB0aGlzYFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYWRkTGF5ZXI6IGZ1bmN0aW9uKGxheWVyLCBiZWZvcmUpIHtcbiAgICAgICAgdGhpcy5iYXRjaChmdW5jdGlvbihiYXRjaCkge1xuICAgICAgICAgICAgYmF0Y2guYWRkTGF5ZXIobGF5ZXIsIGJlZm9yZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBsYXllciBmcm9tIHRoaXMgc3R5bGVzaGVldCwgZ2l2ZW4gaXRzIGlkLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBpZCBvZiB0aGUgbGF5ZXIgdG8gcmVtb3ZlXG4gICAgICogQHJldHVybnMge1N0eWxlfSB0aGlzIHN0eWxlXG4gICAgICogQHRocm93cyB7RXJyb3J9IGlmIG5vIGxheWVyIGlzIGZvdW5kIHdpdGggdGhlIGdpdmVuIElEXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICByZW1vdmVMYXllcjogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgdGhpcy5iYXRjaChmdW5jdGlvbihiYXRjaCkge1xuICAgICAgICAgICAgYmF0Y2gucmVtb3ZlTGF5ZXIoaWQpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBzdHlsZSBsYXllciBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gYGlkYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCAtIGlkIG9mIHRoZSBkZXNpcmVkIGxheWVyXG4gICAgICogQHJldHVybnMgez9PYmplY3R9IGEgbGF5ZXIsIGlmIG9uZSB3aXRoIHRoZSBnaXZlbiBgaWRgIGV4aXN0c1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZ2V0TGF5ZXI6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sYXllcnNbaWRdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJZiBhIGxheWVyIGhhcyBhIGByZWZgIHByb3BlcnR5IHRoYXQgbWFrZXMgaXQgZGVyaXZlIHNvbWUgdmFsdWVzXG4gICAgICogZnJvbSBhbm90aGVyIGxheWVyLCByZXR1cm4gdGhhdCByZWZlcmVudCBsYXllci4gT3RoZXJ3aXNlLFxuICAgICAqIHJldHVybnMgdGhlIGxheWVyIGl0c2VsZi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgdGhlIGxheWVyJ3MgaWRcbiAgICAgKiBAcmV0dXJucyB7TGF5ZXJ9IHRoZSByZWZlcmVudCBsYXllciBvciB0aGUgbGF5ZXIgaXRzZWxmXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnZXRSZWZlcmVudExheWVyOiBmdW5jdGlvbihpZCkge1xuICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLmdldExheWVyKGlkKTtcbiAgICAgICAgaWYgKGxheWVyLnJlZikge1xuICAgICAgICAgICAgbGF5ZXIgPSB0aGlzLmdldExheWVyKGxheWVyLnJlZik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxheWVyO1xuICAgIH0sXG5cbiAgICBzZXRGaWx0ZXI6IGZ1bmN0aW9uKGxheWVyLCBmaWx0ZXIpIHtcbiAgICAgICAgdGhpcy5iYXRjaChmdW5jdGlvbihiYXRjaCkge1xuICAgICAgICAgICAgYmF0Y2guc2V0RmlsdGVyKGxheWVyLCBmaWx0ZXIpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc2V0TGF5ZXJab29tUmFuZ2U6IGZ1bmN0aW9uKGxheWVySWQsIG1pbnpvb20sIG1heHpvb20pIHtcbiAgICAgICAgdGhpcy5iYXRjaChmdW5jdGlvbihiYXRjaCkge1xuICAgICAgICAgICAgYmF0Y2guc2V0TGF5ZXJab29tUmFuZ2UobGF5ZXJJZCwgbWluem9vbSwgbWF4em9vbSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSBsYXllcidzIGZpbHRlciBvYmplY3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXIgdGhlIGxheWVyIHRvIGluc3BlY3RcbiAgICAgKiBAcmV0dXJucyB7Kn0gdGhlIGxheWVyJ3MgZmlsdGVyLCBpZiBhbnlcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGdldEZpbHRlcjogZnVuY3Rpb24obGF5ZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UmVmZXJlbnRMYXllcihsYXllcikuZmlsdGVyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSBsYXlvdXQgcHJvcGVydHkncyB2YWx1ZSBmcm9tIGEgZ2l2ZW4gbGF5ZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXIgdGhlIGxheWVyIHRvIGluc3BlY3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgbGF5b3V0IHByb3BlcnR5XG4gICAgICogQHJldHVybnMgeyp9IHRoZSBwcm9wZXJ0eSB2YWx1ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZ2V0TGF5b3V0UHJvcGVydHk6IGZ1bmN0aW9uKGxheWVyLCBuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFJlZmVyZW50TGF5ZXIobGF5ZXIpLmdldExheW91dFByb3BlcnR5KG5hbWUpO1xuICAgIH0sXG5cbiAgICBnZXRQYWludFByb3BlcnR5OiBmdW5jdGlvbihsYXllciwgbmFtZSwga2xhc3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TGF5ZXIobGF5ZXIpLmdldFBhaW50UHJvcGVydHkobmFtZSwga2xhc3MpO1xuICAgIH0sXG5cbiAgICBmZWF0dXJlc0F0OiBmdW5jdGlvbihjb29yZCwgcGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLl9xdWVyeUZlYXR1cmVzKCdmZWF0dXJlc0F0JywgY29vcmQsIHBhcmFtcywgY2FsbGJhY2spO1xuICAgIH0sXG5cbiAgICBmZWF0dXJlc0luOiBmdW5jdGlvbihiYm94LCBwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX3F1ZXJ5RmVhdHVyZXMoJ2ZlYXR1cmVzSW4nLCBiYm94LCBwYXJhbXMsIGNhbGxiYWNrKTtcbiAgICB9LFxuXG4gICAgX3F1ZXJ5RmVhdHVyZXM6IGZ1bmN0aW9uKHF1ZXJ5VHlwZSwgYmJveE9yQ29vcmRzLCBwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBmZWF0dXJlcyA9IFtdO1xuICAgICAgICB2YXIgZXJyb3IgPSBudWxsO1xuXG4gICAgICAgIGlmIChwYXJhbXMubGF5ZXIpIHtcbiAgICAgICAgICAgIHBhcmFtcy5sYXllcklkcyA9IEFycmF5LmlzQXJyYXkocGFyYW1zLmxheWVyKSA/IHBhcmFtcy5sYXllciA6IFtwYXJhbXMubGF5ZXJdO1xuICAgICAgICB9XG5cbiAgICAgICAgdXRpbC5hc3luY0FsbChPYmplY3Qua2V5cyh0aGlzLnNvdXJjZXMpLCBmdW5jdGlvbihpZCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSB0aGlzLnNvdXJjZXNbaWRdO1xuICAgICAgICAgICAgc291cmNlW3F1ZXJ5VHlwZV0oYmJveE9yQ29vcmRzLCBwYXJhbXMsIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkgZmVhdHVyZXMgPSBmZWF0dXJlcy5jb25jYXQocmVzdWx0KTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSBlcnJvciA9IGVycjtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0uYmluZCh0aGlzKSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHJldHVybiBjYWxsYmFjayhlcnJvcik7XG5cbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGZlYXR1cmVzXG4gICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihmZWF0dXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9sYXllcnNbZmVhdHVyZS5sYXllcl0gIT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbihmZWF0dXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmUubGF5ZXIgPSB0aGlzLl9sYXllcnNbZmVhdHVyZS5sYXllcl0uanNvbigpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmVhdHVyZTtcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9LFxuXG4gICAgX3JlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hlci5yZW1vdmUoKTtcbiAgICB9LFxuXG4gICAgX3JlbG9hZFNvdXJjZTogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgdGhpcy5zb3VyY2VzW2lkXS5yZWxvYWQoKTtcbiAgICB9LFxuXG4gICAgX3VwZGF0ZVNvdXJjZXM6IGZ1bmN0aW9uKHRyYW5zZm9ybSkge1xuICAgICAgICBmb3IgKHZhciBpZCBpbiB0aGlzLnNvdXJjZXMpIHtcbiAgICAgICAgICAgIHRoaXMuc291cmNlc1tpZF0udXBkYXRlKHRyYW5zZm9ybSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX3JlZG9QbGFjZW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IgKHZhciBpZCBpbiB0aGlzLnNvdXJjZXMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNvdXJjZXNbaWRdLnJlZG9QbGFjZW1lbnQpIHRoaXMuc291cmNlc1tpZF0ucmVkb1BsYWNlbWVudCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9mb3J3YXJkU291cmNlRXZlbnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdGhpcy5maXJlKCdzb3VyY2UuJyArIGUudHlwZSwgdXRpbC5leHRlbmQoe3NvdXJjZTogZS50YXJnZXR9LCBlKSk7XG4gICAgfSxcblxuICAgIF9mb3J3YXJkVGlsZUV2ZW50OiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHRoaXMuZmlyZShlLnR5cGUsIHV0aWwuZXh0ZW5kKHtzb3VyY2U6IGUudGFyZ2V0fSwgZSkpO1xuICAgIH0sXG5cbiAgICAvLyBDYWxsYmFja3MgZnJvbSB3ZWIgd29ya2Vyc1xuXG4gICAgJ2dldCBzcHJpdGUganNvbic6IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHNwcml0ZSA9IHRoaXMuc3ByaXRlO1xuICAgICAgICBpZiAoc3ByaXRlLmxvYWRlZCgpKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCB7IHNwcml0ZTogc3ByaXRlLmRhdGEsIHJldGluYTogc3ByaXRlLnJldGluYSB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNwcml0ZS5vbignbG9hZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHsgc3ByaXRlOiBzcHJpdGUuZGF0YSwgcmV0aW5hOiBzcHJpdGUucmV0aW5hIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgJ2dldCBpY29ucyc6IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHNwcml0ZSA9IHRoaXMuc3ByaXRlO1xuICAgICAgICB2YXIgc3ByaXRlQXRsYXMgPSB0aGlzLnNwcml0ZUF0bGFzO1xuICAgICAgICBpZiAoc3ByaXRlLmxvYWRlZCgpKSB7XG4gICAgICAgICAgICBzcHJpdGVBdGxhcy5zZXRTcHJpdGUoc3ByaXRlKTtcbiAgICAgICAgICAgIHNwcml0ZUF0bGFzLmFkZEljb25zKHBhcmFtcy5pY29ucywgY2FsbGJhY2spO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3ByaXRlLm9uKCdsb2FkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc3ByaXRlQXRsYXMuc2V0U3ByaXRlKHNwcml0ZSk7XG4gICAgICAgICAgICAgICAgc3ByaXRlQXRsYXMuYWRkSWNvbnMocGFyYW1zLmljb25zLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAnZ2V0IGdseXBocyc6IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHN0YWNrcyA9IHBhcmFtcy5zdGFja3MsXG4gICAgICAgICAgICByZW1haW5pbmcgPSBPYmplY3Qua2V5cyhzdGFja3MpLmxlbmd0aCxcbiAgICAgICAgICAgIGFsbEdseXBocyA9IHt9O1xuXG4gICAgICAgIGZvciAodmFyIGZvbnROYW1lIGluIHN0YWNrcykge1xuICAgICAgICAgICAgdGhpcy5nbHlwaFNvdXJjZS5nZXRTaW1wbGVHbHlwaHMoZm9udE5hbWUsIHN0YWNrc1tmb250TmFtZV0sIHBhcmFtcy51aWQsIGRvbmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZG9uZShlcnIsIGdseXBocywgZm9udE5hbWUpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIGNvbnNvbGUuZXJyb3IoZXJyKTtcblxuICAgICAgICAgICAgYWxsR2x5cGhzW2ZvbnROYW1lXSA9IGdseXBocztcbiAgICAgICAgICAgIHJlbWFpbmluZy0tO1xuXG4gICAgICAgICAgICBpZiAocmVtYWluaW5nID09PSAwKVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGFsbEdseXBocyk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFNvdXJjZSA9IHJlcXVpcmUoJy4uL3NvdXJjZS9zb3VyY2UnKTtcbnZhciBTdHlsZUxheWVyID0gcmVxdWlyZSgnLi9zdHlsZV9sYXllcicpO1xuXG5mdW5jdGlvbiBzdHlsZUJhdGNoKHN0eWxlLCB3b3JrKSB7XG4gICAgaWYgKCFzdHlsZS5fbG9hZGVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU3R5bGUgaXMgbm90IGRvbmUgbG9hZGluZycpO1xuICAgIH1cblxuICAgIHZhciBiYXRjaCA9IE9iamVjdC5jcmVhdGUoc3R5bGVCYXRjaC5wcm90b3R5cGUpO1xuXG4gICAgYmF0Y2guX3N0eWxlID0gc3R5bGU7XG4gICAgYmF0Y2guX2dyb3VwTGF5ZXJzID0gZmFsc2U7XG4gICAgYmF0Y2guX2Jyb2FkY2FzdExheWVycyA9IGZhbHNlO1xuICAgIGJhdGNoLl9yZWxvYWRTb3VyY2VzID0ge307XG4gICAgYmF0Y2guX2V2ZW50cyA9IFtdO1xuICAgIGJhdGNoLl9jaGFuZ2UgPSBmYWxzZTtcblxuICAgIHdvcmsoYmF0Y2gpO1xuXG4gICAgaWYgKGJhdGNoLl9ncm91cExheWVycykge1xuICAgICAgICBiYXRjaC5fc3R5bGUuX2dyb3VwTGF5ZXJzKCk7XG4gICAgfVxuXG4gICAgaWYgKGJhdGNoLl9icm9hZGNhc3RMYXllcnMpIHtcbiAgICAgICAgYmF0Y2guX3N0eWxlLl9icm9hZGNhc3RMYXllcnMoKTtcbiAgICB9XG5cbiAgICBPYmplY3Qua2V5cyhiYXRjaC5fcmVsb2FkU291cmNlcykuZm9yRWFjaChmdW5jdGlvbihzb3VyY2VJZCkge1xuICAgICAgICBiYXRjaC5fc3R5bGUuX3JlbG9hZFNvdXJjZShzb3VyY2VJZCk7XG4gICAgfSk7XG5cbiAgICBiYXRjaC5fZXZlbnRzLmZvckVhY2goZnVuY3Rpb24oYXJncykge1xuICAgICAgICBiYXRjaC5fc3R5bGUuZmlyZS5hcHBseShiYXRjaC5fc3R5bGUsIGFyZ3MpO1xuICAgIH0pO1xuXG4gICAgaWYgKGJhdGNoLl9jaGFuZ2UpIHtcbiAgICAgICAgYmF0Y2guX3N0eWxlLmZpcmUoJ2NoYW5nZScpO1xuICAgIH1cbn1cblxuc3R5bGVCYXRjaC5wcm90b3R5cGUgPSB7XG5cbiAgICBhZGRMYXllcjogZnVuY3Rpb24obGF5ZXIsIGJlZm9yZSkge1xuICAgICAgICBpZiAodGhpcy5fc3R5bGUuX2xheWVyc1tsYXllci5pZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGVyZSBpcyBhbHJlYWR5IGEgbGF5ZXIgd2l0aCB0aGlzIElEJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEobGF5ZXIgaW5zdGFuY2VvZiBTdHlsZUxheWVyKSkge1xuICAgICAgICAgICAgbGF5ZXIgPSBuZXcgU3R5bGVMYXllcihsYXllcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3R5bGUuX3ZhbGlkYXRlTGF5ZXIobGF5ZXIpO1xuICAgICAgICB0aGlzLl9zdHlsZS5fbGF5ZXJzW2xheWVyLmlkXSA9IGxheWVyO1xuICAgICAgICB0aGlzLl9zdHlsZS5fb3JkZXIuc3BsaWNlKGJlZm9yZSA/IHRoaXMuX3N0eWxlLl9vcmRlci5pbmRleE9mKGJlZm9yZSkgOiBJbmZpbml0eSwgMCwgbGF5ZXIuaWQpO1xuICAgICAgICBsYXllci5yZXNvbHZlTGF5b3V0KCk7XG4gICAgICAgIGxheWVyLnJlc29sdmVSZWZlcmVuY2UodGhpcy5fc3R5bGUuX2xheWVycyk7XG4gICAgICAgIGxheWVyLnJlc29sdmVQYWludCgpO1xuXG4gICAgICAgIHRoaXMuX2dyb3VwTGF5ZXJzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fYnJvYWRjYXN0TGF5ZXJzID0gdHJ1ZTtcbiAgICAgICAgaWYgKGxheWVyLnNvdXJjZSkge1xuICAgICAgICAgICAgdGhpcy5fcmVsb2FkU291cmNlc1tsYXllci5zb3VyY2VdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9ldmVudHMucHVzaChbJ2xheWVyLmFkZCcsIHtsYXllcjogbGF5ZXJ9XSk7XG4gICAgICAgIHRoaXMuX2NoYW5nZSA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHJlbW92ZUxheWVyOiBmdW5jdGlvbihpZCkge1xuICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLl9zdHlsZS5fbGF5ZXJzW2lkXTtcbiAgICAgICAgaWYgKGxheWVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlcmUgaXMgbm8gbGF5ZXIgd2l0aCB0aGlzIElEJyk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLl9zdHlsZS5fbGF5ZXJzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc3R5bGUuX2xheWVyc1tpXS5yZWYgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVMYXllcihpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgdGhpcy5fc3R5bGUuX2xheWVyc1tpZF07XG4gICAgICAgIHRoaXMuX3N0eWxlLl9vcmRlci5zcGxpY2UodGhpcy5fc3R5bGUuX29yZGVyLmluZGV4T2YoaWQpLCAxKTtcblxuICAgICAgICB0aGlzLl9ncm91cExheWVycyA9IHRydWU7XG4gICAgICAgIHRoaXMuX2Jyb2FkY2FzdExheWVycyA9IHRydWU7XG4gICAgICAgIHRoaXMuX2V2ZW50cy5wdXNoKFsnbGF5ZXIucmVtb3ZlJywge2xheWVyOiBsYXllcn1dKTtcbiAgICAgICAgdGhpcy5fY2hhbmdlID0gdHJ1ZTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc2V0UGFpbnRQcm9wZXJ0eTogZnVuY3Rpb24obGF5ZXIsIG5hbWUsIHZhbHVlLCBrbGFzcykge1xuICAgICAgICB0aGlzLl9zdHlsZS5nZXRMYXllcihsYXllcikuc2V0UGFpbnRQcm9wZXJ0eShuYW1lLCB2YWx1ZSwga2xhc3MpO1xuICAgICAgICB0aGlzLl9jaGFuZ2UgPSB0cnVlO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzZXRMYXlvdXRQcm9wZXJ0eTogZnVuY3Rpb24obGF5ZXIsIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGxheWVyID0gdGhpcy5fc3R5bGUuZ2V0UmVmZXJlbnRMYXllcihsYXllcik7XG4gICAgICAgIGxheWVyLnNldExheW91dFByb3BlcnR5KG5hbWUsIHZhbHVlKTtcblxuICAgICAgICB0aGlzLl9icm9hZGNhc3RMYXllcnMgPSB0cnVlO1xuICAgICAgICBpZiAobGF5ZXIuc291cmNlKSB7XG4gICAgICAgICAgICB0aGlzLl9yZWxvYWRTb3VyY2VzW2xheWVyLnNvdXJjZV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NoYW5nZSA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNldEZpbHRlcjogZnVuY3Rpb24obGF5ZXIsIGZpbHRlcikge1xuICAgICAgICBsYXllciA9IHRoaXMuX3N0eWxlLmdldFJlZmVyZW50TGF5ZXIobGF5ZXIpO1xuICAgICAgICBsYXllci5maWx0ZXIgPSBmaWx0ZXI7XG5cbiAgICAgICAgdGhpcy5fYnJvYWRjYXN0TGF5ZXJzID0gdHJ1ZTtcbiAgICAgICAgaWYgKGxheWVyLnNvdXJjZSkge1xuICAgICAgICAgICAgdGhpcy5fcmVsb2FkU291cmNlc1tsYXllci5zb3VyY2VdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jaGFuZ2UgPSB0cnVlO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzZXRMYXllclpvb21SYW5nZTogZnVuY3Rpb24obGF5ZXJJZCwgbWluem9vbSwgbWF4em9vbSkge1xuICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLl9zdHlsZS5nZXRSZWZlcmVudExheWVyKGxheWVySWQpO1xuICAgICAgICBpZiAobWluem9vbSAhPSBudWxsKSB7XG4gICAgICAgICAgICBsYXllci5taW56b29tID0gbWluem9vbTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF4em9vbSAhPSBudWxsKSB7XG4gICAgICAgICAgICBsYXllci5tYXh6b29tID0gbWF4em9vbTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2Jyb2FkY2FzdExheWVycyA9IHRydWU7XG4gICAgICAgIGlmIChsYXllci5zb3VyY2UpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbG9hZFNvdXJjZXNbbGF5ZXIuc291cmNlXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2hhbmdlID0gdHJ1ZTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgYWRkU291cmNlOiBmdW5jdGlvbihpZCwgc291cmNlKSB7XG4gICAgICAgIGlmICghdGhpcy5fc3R5bGUuX2xvYWRlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdHlsZSBpcyBub3QgZG9uZSBsb2FkaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3N0eWxlLnNvdXJjZXNbaWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlcmUgaXMgYWxyZWFkeSBhIHNvdXJjZSB3aXRoIHRoaXMgSUQnKTtcbiAgICAgICAgfVxuICAgICAgICBzb3VyY2UgPSBTb3VyY2UuY3JlYXRlKHNvdXJjZSk7XG4gICAgICAgIHRoaXMuX3N0eWxlLnNvdXJjZXNbaWRdID0gc291cmNlO1xuICAgICAgICBzb3VyY2UuaWQgPSBpZDtcbiAgICAgICAgc291cmNlLnN0eWxlID0gdGhpcy5fc3R5bGU7XG4gICAgICAgIHNvdXJjZS5kaXNwYXRjaGVyID0gdGhpcy5fc3R5bGUuZGlzcGF0Y2hlcjtcbiAgICAgICAgc291cmNlXG4gICAgICAgICAgICAub24oJ2xvYWQnLCB0aGlzLl9zdHlsZS5fZm9yd2FyZFNvdXJjZUV2ZW50KVxuICAgICAgICAgICAgLm9uKCdlcnJvcicsIHRoaXMuX3N0eWxlLl9mb3J3YXJkU291cmNlRXZlbnQpXG4gICAgICAgICAgICAub24oJ2NoYW5nZScsIHRoaXMuX3N0eWxlLl9mb3J3YXJkU291cmNlRXZlbnQpXG4gICAgICAgICAgICAub24oJ3RpbGUuYWRkJywgdGhpcy5fc3R5bGUuX2ZvcndhcmRUaWxlRXZlbnQpXG4gICAgICAgICAgICAub24oJ3RpbGUubG9hZCcsIHRoaXMuX3N0eWxlLl9mb3J3YXJkVGlsZUV2ZW50KVxuICAgICAgICAgICAgLm9uKCd0aWxlLmVycm9yJywgdGhpcy5fc3R5bGUuX2ZvcndhcmRUaWxlRXZlbnQpXG4gICAgICAgICAgICAub24oJ3RpbGUucmVtb3ZlJywgdGhpcy5fc3R5bGUuX2ZvcndhcmRUaWxlRXZlbnQpXG4gICAgICAgICAgICAub24oJ3RpbGUuc3RhdHMnLCB0aGlzLl9zdHlsZS5fZm9yd2FyZFRpbGVFdmVudCk7XG5cbiAgICAgICAgdGhpcy5fZXZlbnRzLnB1c2goWydzb3VyY2UuYWRkJywge3NvdXJjZTogc291cmNlfV0pO1xuICAgICAgICB0aGlzLl9jaGFuZ2UgPSB0cnVlO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICByZW1vdmVTb3VyY2U6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdHlsZS5zb3VyY2VzW2lkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZXJlIGlzIG5vIHNvdXJjZSB3aXRoIHRoaXMgSUQnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc291cmNlID0gdGhpcy5fc3R5bGUuc291cmNlc1tpZF07XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9zdHlsZS5zb3VyY2VzW2lkXTtcbiAgICAgICAgc291cmNlXG4gICAgICAgICAgICAub2ZmKCdsb2FkJywgdGhpcy5fc3R5bGUuX2ZvcndhcmRTb3VyY2VFdmVudClcbiAgICAgICAgICAgIC5vZmYoJ2Vycm9yJywgdGhpcy5fc3R5bGUuX2ZvcndhcmRTb3VyY2VFdmVudClcbiAgICAgICAgICAgIC5vZmYoJ2NoYW5nZScsIHRoaXMuX3N0eWxlLl9mb3J3YXJkU291cmNlRXZlbnQpXG4gICAgICAgICAgICAub2ZmKCd0aWxlLmFkZCcsIHRoaXMuX3N0eWxlLl9mb3J3YXJkVGlsZUV2ZW50KVxuICAgICAgICAgICAgLm9mZigndGlsZS5sb2FkJywgdGhpcy5fc3R5bGUuX2ZvcndhcmRUaWxlRXZlbnQpXG4gICAgICAgICAgICAub2ZmKCd0aWxlLmVycm9yJywgdGhpcy5fc3R5bGUuX2ZvcndhcmRUaWxlRXZlbnQpXG4gICAgICAgICAgICAub2ZmKCd0aWxlLnJlbW92ZScsIHRoaXMuX3N0eWxlLl9mb3J3YXJkVGlsZUV2ZW50KVxuICAgICAgICAgICAgLm9mZigndGlsZS5zdGF0cycsIHRoaXMuX3N0eWxlLl9mb3J3YXJkVGlsZUV2ZW50KTtcblxuICAgICAgICB0aGlzLl9ldmVudHMucHVzaChbJ3NvdXJjZS5yZW1vdmUnLCB7c291cmNlOiBzb3VyY2V9XSk7XG4gICAgICAgIHRoaXMuX2NoYW5nZSA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdHlsZUJhdGNoO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcGFyc2VDU1NDb2xvciA9IHJlcXVpcmUoJ2Nzc2NvbG9ycGFyc2VyJykucGFyc2VDU1NDb2xvcjtcbnZhciBNYXBib3hHTEZ1bmN0aW9uID0gcmVxdWlyZSgnbWFwYm94LWdsLWZ1bmN0aW9uJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0eWxlRGVjbGFyYXRpb247XG5cbmZ1bmN0aW9uIFN0eWxlRGVjbGFyYXRpb24ocmVmZXJlbmNlLCB2YWx1ZSkge1xuICAgIHRoaXMudHlwZSA9IHJlZmVyZW5jZS50eXBlO1xuICAgIHRoaXMudHJhbnNpdGlvbmFibGUgPSByZWZlcmVuY2UudHJhbnNpdGlvbjtcblxuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHZhbHVlID0gcmVmZXJlbmNlLmRlZmF1bHQ7XG4gICAgfVxuXG4gICAgLy8gaW1tdXRhYmxlIHJlcHJlc2VudGF0aW9uIG9mIHZhbHVlLiB1c2VkIGZvciBjb21wYXJpc29uXG4gICAgdGhpcy5qc29uID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuXG4gICAgaWYgKHRoaXMudHlwZSA9PT0gJ2NvbG9yJykge1xuICAgICAgICB0aGlzLnZhbHVlID0gcGFyc2VDb2xvcih2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIGlmIChyZWZlcmVuY2UuZnVuY3Rpb24gPT09ICdpbnRlcnBvbGF0ZWQnKSB7XG4gICAgICAgIHRoaXMuY2FsY3VsYXRlID0gTWFwYm94R0xGdW5jdGlvbi5pbnRlcnBvbGF0ZWQodGhpcy52YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jYWxjdWxhdGUgPSBNYXBib3hHTEZ1bmN0aW9uWydwaWVjZXdpc2UtY29uc3RhbnQnXSh0aGlzLnZhbHVlKTtcbiAgICAgICAgaWYgKHJlZmVyZW5jZS50cmFuc2l0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmNhbGN1bGF0ZSA9IHRyYW5zaXRpb25lZCh0aGlzLmNhbGN1bGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIHRyYW5zaXRpb25lZChjYWxjdWxhdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oeiwgemgsIGR1cmF0aW9uKSB7XG4gICAgICAgIHZhciBmcmFjdGlvbiA9IHogJSAxO1xuICAgICAgICB2YXIgdCA9IE1hdGgubWluKChEYXRlLm5vdygpIC0gemgubGFzdEludGVnZXJab29tVGltZSkgLyBkdXJhdGlvbiwgMSk7XG4gICAgICAgIHZhciBmcm9tU2NhbGUgPSAxO1xuICAgICAgICB2YXIgdG9TY2FsZSA9IDE7XG4gICAgICAgIHZhciBtaXgsIGZyb20sIHRvO1xuXG4gICAgICAgIGlmICh6ID4gemgubGFzdEludGVnZXJab29tKSB7XG4gICAgICAgICAgICBtaXggPSBmcmFjdGlvbiArICgxIC0gZnJhY3Rpb24pICogdDtcbiAgICAgICAgICAgIGZyb21TY2FsZSAqPSAyO1xuICAgICAgICAgICAgZnJvbSA9IGNhbGN1bGF0ZSh6IC0gMSk7XG4gICAgICAgICAgICB0byA9IGNhbGN1bGF0ZSh6KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1peCA9IDEgLSAoMSAtIHQpICogZnJhY3Rpb247XG4gICAgICAgICAgICB0byA9IGNhbGN1bGF0ZSh6KTtcbiAgICAgICAgICAgIGZyb20gPSBjYWxjdWxhdGUoeiArIDEpO1xuICAgICAgICAgICAgZnJvbVNjYWxlIC89IDI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZnJvbTogZnJvbSxcbiAgICAgICAgICAgIGZyb21TY2FsZTogZnJvbVNjYWxlLFxuICAgICAgICAgICAgdG86IHRvLFxuICAgICAgICAgICAgdG9TY2FsZTogdG9TY2FsZSxcbiAgICAgICAgICAgIHQ6IG1peFxuICAgICAgICB9O1xuICAgIH07XG59XG5cbnZhciBjb2xvckNhY2hlID0ge307XG5cbmZ1bmN0aW9uIHBhcnNlQ29sb3IoaW5wdXQpIHtcblxuICAgIGlmIChjb2xvckNhY2hlW2lucHV0XSkge1xuICAgICAgICByZXR1cm4gY29sb3JDYWNoZVtpbnB1dF07XG5cbiAgICAvLyBSR0JBIGFycmF5XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgICByZXR1cm4gaW5wdXQ7XG5cbiAgICAvLyBHTCBmdW5jdGlvblxuICAgIH0gZWxzZSBpZiAoaW5wdXQgJiYgaW5wdXQuc3RvcHMpIHtcbiAgICAgICAgcmV0dXJuIHV0aWwuZXh0ZW5kKHt9LCBpbnB1dCwge1xuICAgICAgICAgICAgc3RvcHM6IGlucHV0LnN0b3BzLm1hcChmdW5jdGlvbihzdGVwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtzdGVwWzBdLCBwYXJzZUNvbG9yKHN0ZXBbMV0pXTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuXG4gICAgLy8gQ29sb3Igc3RyaW5nXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSBjb2xvckRvd25ncmFkZShwYXJzZUNTU0NvbG9yKGlucHV0KSk7XG4gICAgICAgIGNvbG9yQ2FjaGVbaW5wdXRdID0gb3V0cHV0O1xuICAgICAgICByZXR1cm4gb3V0cHV0O1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvbG9yICcgKyBpbnB1dCk7XG4gICAgfVxuXG59XG5cbmZ1bmN0aW9uIGNvbG9yRG93bmdyYWRlKGNvbG9yKSB7XG4gICAgcmV0dXJuIFtjb2xvclswXSAvIDI1NSwgY29sb3JbMV0gLyAyNTUsIGNvbG9yWzJdIC8gMjU1LCBjb2xvclszXSAvIDFdO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xudmFyIHJlZmVyZW5jZSA9IHJlcXVpcmUoJy4vcmVmZXJlbmNlJyk7XG52YXIgU3R5bGVEZWNsYXJhdGlvbiA9IHJlcXVpcmUoJy4vc3R5bGVfZGVjbGFyYXRpb24nKTtcblxudmFyIGxvb2t1cCA9IHtcbiAgICBwYWludDoge30sXG4gICAgbGF5b3V0OiB7fVxufTtcblxucmVmZXJlbmNlLmxheWVyLnR5cGUudmFsdWVzLmZvckVhY2goZnVuY3Rpb24odHlwZSkge1xuICAgIGxvb2t1cC5wYWludFt0eXBlXSA9IG1ha2VDb25zdHJ1Y3RvcihyZWZlcmVuY2VbJ3BhaW50XycgKyB0eXBlXSk7XG4gICAgbG9va3VwLmxheW91dFt0eXBlXSA9IG1ha2VDb25zdHJ1Y3RvcihyZWZlcmVuY2VbJ2xheW91dF8nICsgdHlwZV0pO1xufSk7XG5cbmZ1bmN0aW9uIG1ha2VDb25zdHJ1Y3RvcihyZWZlcmVuY2UpIHtcbiAgICBmdW5jdGlvbiBTdHlsZURlY2xhcmF0aW9uU2V0KHByb3BlcnRpZXMpIHtcbiAgICAgICAgdGhpcy5fdmFsdWVzID0ge307XG4gICAgICAgIHRoaXMuX3RyYW5zaXRpb25zID0ge307XG5cbiAgICAgICAgZm9yICh2YXIgayBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICB0aGlzW2tdID0gcHJvcGVydGllc1trXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIE9iamVjdC5rZXlzKHJlZmVyZW5jZSkuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgICAgIHZhciBwcm9wZXJ0eSA9IHJlZmVyZW5jZVtrXTtcblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3R5bGVEZWNsYXJhdGlvblNldC5wcm90b3R5cGUsIGssIHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlc1trXSA9IG5ldyBTdHlsZURlY2xhcmF0aW9uKHByb3BlcnR5LCB2KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl92YWx1ZXNba10udmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChwcm9wZXJ0eS50cmFuc2l0aW9uKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3R5bGVEZWNsYXJhdGlvblNldC5wcm90b3R5cGUsIGsgKyAnLXRyYW5zaXRpb24nLCB7XG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zaXRpb25zW2tdID0gdjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl90cmFuc2l0aW9uc1trXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgU3R5bGVEZWNsYXJhdGlvblNldC5wcm90b3R5cGUudmFsdWVzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZXM7XG4gICAgfTtcblxuICAgIFN0eWxlRGVjbGFyYXRpb25TZXQucHJvdG90eXBlLnRyYW5zaXRpb24gPSBmdW5jdGlvbihrLCBnbG9iYWwpIHtcbiAgICAgICAgdmFyIHQgPSB0aGlzLl90cmFuc2l0aW9uc1trXSB8fCB7fTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGR1cmF0aW9uOiB1dGlsLmNvYWxlc2NlKHQuZHVyYXRpb24sIGdsb2JhbC5kdXJhdGlvbiwgMzAwKSxcbiAgICAgICAgICAgIGRlbGF5OiB1dGlsLmNvYWxlc2NlKHQuZGVsYXksIGdsb2JhbC5kZWxheSwgMClcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgU3R5bGVEZWNsYXJhdGlvblNldC5wcm90b3R5cGUuanNvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG5cbiAgICAgICAgZm9yICh2YXIgdiBpbiB0aGlzLl92YWx1ZXMpIHtcbiAgICAgICAgICAgIHJlc3VsdFt2XSA9IHRoaXMuX3ZhbHVlc1t2XS52YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIHQgaW4gdGhpcy5fdHJhbnNpdGlvbnMpIHtcbiAgICAgICAgICAgIHJlc3VsdFt0ICsgJy10cmFuc2l0aW9uJ10gPSB0aGlzLl90cmFuc2l0aW9uc1t2XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIHJldHVybiBTdHlsZURlY2xhcmF0aW9uU2V0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHJlbmRlclR5cGUsIGxheWVyVHlwZSwgcHJvcGVydGllcykge1xuICAgIHJldHVybiBuZXcgbG9va3VwW3JlbmRlclR5cGVdW2xheWVyVHlwZV0ocHJvcGVydGllcyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xudmFyIFN0eWxlVHJhbnNpdGlvbiA9IHJlcXVpcmUoJy4vc3R5bGVfdHJhbnNpdGlvbicpO1xudmFyIFN0eWxlRGVjbGFyYXRpb25TZXQgPSByZXF1aXJlKCcuL3N0eWxlX2RlY2xhcmF0aW9uX3NldCcpO1xudmFyIExheW91dFByb3BlcnRpZXMgPSByZXF1aXJlKCcuL2xheW91dF9wcm9wZXJ0aWVzJyk7XG52YXIgUGFpbnRQcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi9wYWludF9wcm9wZXJ0aWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3R5bGVMYXllcjtcblxuZnVuY3Rpb24gU3R5bGVMYXllcihsYXllcikge1xuICAgIHRoaXMuX2xheWVyID0gbGF5ZXI7XG5cbiAgICB0aGlzLmlkID0gbGF5ZXIuaWQ7XG4gICAgdGhpcy5yZWYgPSBsYXllci5yZWY7XG5cbiAgICAvLyBSZXNvbHZlZCBhbmQgY2FzY2FkZWQgcGFpbnQgcHJvcGVydGllcy5cbiAgICB0aGlzLl9yZXNvbHZlZCA9IHt9OyAvLyBjbGFzcyBuYW1lIC0+IFN0eWxlRGVjbGFyYXRpb25TZXRcbiAgICB0aGlzLl9jYXNjYWRlZCA9IHt9OyAvLyBwcm9wZXJ0eSBuYW1lIC0+IFN0eWxlVHJhbnNpdGlvblxuXG4gICAgdGhpcy5hc3NpZ24obGF5ZXIpO1xufVxuXG5TdHlsZUxheWVyLnByb3RvdHlwZSA9IHtcbiAgICByZXNvbHZlTGF5b3V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJlZikge1xuICAgICAgICAgICAgdGhpcy5sYXlvdXQgPSBuZXcgTGF5b3V0UHJvcGVydGllc1t0aGlzLnR5cGVdKHRoaXMuX2xheWVyLmxheW91dCk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmxheW91dFsnc3ltYm9sLXBsYWNlbWVudCddID09PSAnbGluZScpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMubGF5b3V0Lmhhc093blByb3BlcnR5KCd0ZXh0LXJvdGF0aW9uLWFsaWdubWVudCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGF5b3V0Wyd0ZXh0LXJvdGF0aW9uLWFsaWdubWVudCddID0gJ21hcCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5sYXlvdXQuaGFzT3duUHJvcGVydHkoJ2ljb24tcm90YXRpb24tYWxpZ25tZW50JykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXlvdXRbJ2ljb24tcm90YXRpb24tYWxpZ25tZW50J10gPSAnbWFwJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5sYXlvdXRbJ3N5bWJvbC1hdm9pZC1lZGdlcyddID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBzZXRMYXlvdXRQcm9wZXJ0eTogZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmxheW91dFtuYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubGF5b3V0W25hbWVdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0TGF5b3V0UHJvcGVydHk6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGF5b3V0W25hbWVdO1xuICAgIH0sXG5cbiAgICByZXNvbHZlUmVmZXJlbmNlOiBmdW5jdGlvbihsYXllcnMpIHtcbiAgICAgICAgaWYgKHRoaXMucmVmKSB7XG4gICAgICAgICAgICB0aGlzLmFzc2lnbihsYXllcnNbdGhpcy5yZWZdKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICByZXNvbHZlUGFpbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IgKHZhciBwIGluIHRoaXMuX2xheWVyKSB7XG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSBwLm1hdGNoKC9ecGFpbnQoPzpcXC4oLiopKT8kLyk7XG4gICAgICAgICAgICBpZiAoIW1hdGNoKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZWRbbWF0Y2hbMV0gfHwgJyddID1cbiAgICAgICAgICAgICAgICBuZXcgU3R5bGVEZWNsYXJhdGlvblNldCgncGFpbnQnLCB0aGlzLnR5cGUsIHRoaXMuX2xheWVyW3BdKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBzZXRQYWludFByb3BlcnR5OiBmdW5jdGlvbihuYW1lLCB2YWx1ZSwga2xhc3MpIHtcbiAgICAgICAgdmFyIGRlY2xhcmF0aW9ucyA9IHRoaXMuX3Jlc29sdmVkW2tsYXNzIHx8ICcnXTtcbiAgICAgICAgaWYgKCFkZWNsYXJhdGlvbnMpIHtcbiAgICAgICAgICAgIGRlY2xhcmF0aW9ucyA9IHRoaXMuX3Jlc29sdmVkW2tsYXNzIHx8ICcnXSA9XG4gICAgICAgICAgICAgICAgbmV3IFN0eWxlRGVjbGFyYXRpb25TZXQoJ3BhaW50JywgdGhpcy50eXBlLCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVjbGFyYXRpb25zW25hbWVdID0gdmFsdWU7XG4gICAgfSxcblxuICAgIGdldFBhaW50UHJvcGVydHk6IGZ1bmN0aW9uKG5hbWUsIGtsYXNzKSB7XG4gICAgICAgIHZhciBkZWNsYXJhdGlvbnMgPSB0aGlzLl9yZXNvbHZlZFtrbGFzcyB8fCAnJ107XG4gICAgICAgIGlmICghZGVjbGFyYXRpb25zKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIGRlY2xhcmF0aW9uc1tuYW1lXTtcbiAgICB9LFxuXG4gICAgY2FzY2FkZTogZnVuY3Rpb24oY2xhc3Nlcywgb3B0aW9ucywgZ2xvYmFsVHJhbnMsIGFuaW1hdGlvbkxvb3ApIHtcbiAgICAgICAgZm9yICh2YXIga2xhc3MgaW4gdGhpcy5fcmVzb2x2ZWQpIHtcbiAgICAgICAgICAgIGlmIChrbGFzcyAhPT0gXCJcIiAmJiAhY2xhc3Nlc1trbGFzc10pXG4gICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgIHZhciBkZWNsYXJhdGlvbnMgPSB0aGlzLl9yZXNvbHZlZFtrbGFzc10sXG4gICAgICAgICAgICAgICAgdmFsdWVzID0gZGVjbGFyYXRpb25zLnZhbHVlcygpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBrIGluIHZhbHVlcykge1xuICAgICAgICAgICAgICAgIHZhciBuZXdEZWNsYXJhdGlvbiA9IHZhbHVlc1trXTtcbiAgICAgICAgICAgICAgICB2YXIgb2xkVHJhbnNpdGlvbiA9IG9wdGlvbnMudHJhbnNpdGlvbiA/IHRoaXMuX2Nhc2NhZGVkW2tdIDogdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAgICAgLy8gT25seSBjcmVhdGUgYSBuZXcgdHJhbnNpdGlvbiBpZiB0aGUgZGVjbGFyYXRpb24gY2hhbmdlZFxuICAgICAgICAgICAgICAgIGlmICghb2xkVHJhbnNpdGlvbiB8fCBvbGRUcmFuc2l0aW9uLmRlY2xhcmF0aW9uLmpzb24gIT09IG5ld0RlY2xhcmF0aW9uLmpzb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1N0eWxlVHJhbnMgPSBkZWNsYXJhdGlvbnMudHJhbnNpdGlvbihrLCBnbG9iYWxUcmFucyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdUcmFuc2l0aW9uID0gdGhpcy5fY2FzY2FkZWRba10gPVxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFN0eWxlVHJhbnNpdGlvbihuZXdEZWNsYXJhdGlvbiwgb2xkVHJhbnNpdGlvbiwgbmV3U3R5bGVUcmFucyk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUnVuIHRoZSBhbmltYXRpb24gbG9vcCB1bnRpbCB0aGUgZW5kIG9mIHRoZSB0cmFuc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgIGlmICghbmV3VHJhbnNpdGlvbi5pbnN0YW50KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1RyYW5zaXRpb24ubG9vcElEID0gYW5pbWF0aW9uTG9vcC5zZXQobmV3VHJhbnNpdGlvbi5lbmRUaW1lIC0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAob2xkVHJhbnNpdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uTG9vcC5jYW5jZWwob2xkVHJhbnNpdGlvbi5sb29wSUQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGhlIC1zaXplIHByb3BlcnRpZXMgYXJlIHVzZWQgYm90aCBhcyBsYXlvdXQgYW5kIHBhaW50LlxuICAgICAgICAvLyBJbiB0aGUgc3BlYyB0aGV5IGFyZSBsYXlvdXQgcHJvcGVydGllcy4gVGhpcyBhZGRzIHRoZW1cbiAgICAgICAgLy8gYXMgaW50ZXJuYWwgcGFpbnQgcHJvcGVydGllcy5cbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgICAgIHZhciByZXNvbHZlZExheW91dCA9IG5ldyBTdHlsZURlY2xhcmF0aW9uU2V0KCdsYXlvdXQnLCB0aGlzLnR5cGUsIHRoaXMubGF5b3V0KTtcbiAgICAgICAgICAgIHRoaXMuX2Nhc2NhZGVkWyd0ZXh0LXNpemUnXSA9IG5ldyBTdHlsZVRyYW5zaXRpb24ocmVzb2x2ZWRMYXlvdXQudmFsdWVzKClbJ3RleHQtc2l6ZSddLCB1bmRlZmluZWQsIGdsb2JhbFRyYW5zKTtcbiAgICAgICAgICAgIHRoaXMuX2Nhc2NhZGVkWydpY29uLXNpemUnXSA9IG5ldyBTdHlsZVRyYW5zaXRpb24ocmVzb2x2ZWRMYXlvdXQudmFsdWVzKClbJ2ljb24tc2l6ZSddLCB1bmRlZmluZWQsIGdsb2JhbFRyYW5zKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICByZWNhbGN1bGF0ZTogZnVuY3Rpb24oeiwgem9vbUhpc3RvcnkpIHtcbiAgICAgICAgdmFyIHR5cGUgPSB0aGlzLnR5cGUsXG4gICAgICAgICAgICBjYWxjdWxhdGVkID0gdGhpcy5wYWludCA9IG5ldyBQYWludFByb3BlcnRpZXNbdHlwZV0oKTtcblxuICAgICAgICBmb3IgKHZhciBrIGluIHRoaXMuX2Nhc2NhZGVkKSB7XG4gICAgICAgICAgICBjYWxjdWxhdGVkW2tdID0gdGhpcy5fY2FzY2FkZWRba10uYXQoeiwgem9vbUhpc3RvcnkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5oaWRkZW4gPSAodGhpcy5taW56b29tICYmIHogPCB0aGlzLm1pbnpvb20pIHx8XG4gICAgICAgICAgICAgICAgICAgICAgKHRoaXMubWF4em9vbSAmJiB6ID49IHRoaXMubWF4em9vbSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAvLyBpbmNsdWRlIHZpc2liaWxpdHkgY2hlY2sgZm9yIG5vbi1idWNrZXRlZCBiYWNrZ3JvdW5kIGxheWVyc1xuICAgICAgICAgICAgICAgICAgICAgICh0aGlzLmxheW91dC52aXNpYmlsaXR5ID09PSAnbm9uZScpO1xuXG4gICAgICAgIGlmICh0eXBlID09PSAnc3ltYm9sJykge1xuICAgICAgICAgICAgaWYgKChjYWxjdWxhdGVkWyd0ZXh0LW9wYWNpdHknXSA9PT0gMCB8fCAhdGhpcy5sYXlvdXRbJ3RleHQtZmllbGQnXSkgJiZcbiAgICAgICAgICAgICAgICAoY2FsY3VsYXRlZFsnaWNvbi1vcGFjaXR5J10gPT09IDAgfHwgIXRoaXMubGF5b3V0WydpY29uLWltYWdlJ10pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oaWRkZW4gPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcmVtdWx0aXBseUxheWVyKGNhbGN1bGF0ZWQsICd0ZXh0Jyk7XG4gICAgICAgICAgICAgICAgcHJlbXVsdGlwbHlMYXllcihjYWxjdWxhdGVkLCAnaWNvbicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAoY2FsY3VsYXRlZFt0eXBlICsgJy1vcGFjaXR5J10gPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByZW11bHRpcGx5TGF5ZXIoY2FsY3VsYXRlZCwgdHlwZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fY2FzY2FkZWRbJ2xpbmUtZGFzaGFycmF5J10pIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBsaW5lIGlzIGRhc2hlZCwgc2NhbGUgdGhlIGRhc2ggbGVuZ3RocyBieSB0aGUgbGluZVxuICAgICAgICAgICAgLy8gd2lkdGggYXQgdGhlIHByZXZpb3VzIHJvdW5kIHpvb20gbGV2ZWwuXG4gICAgICAgICAgICB2YXIgZGFzaEFycmF5ID0gY2FsY3VsYXRlZFsnbGluZS1kYXNoYXJyYXknXTtcbiAgICAgICAgICAgIHZhciBsaW5lV2lkdGggPSB0aGlzLl9jYXNjYWRlZFsnbGluZS13aWR0aCddID9cbiAgICAgICAgICAgICAgICB0aGlzLl9jYXNjYWRlZFsnbGluZS13aWR0aCddLmF0KE1hdGguZmxvb3IoeiksIEluZmluaXR5KSA6XG4gICAgICAgICAgICAgICAgY2FsY3VsYXRlZFsnbGluZS13aWR0aCddO1xuXG4gICAgICAgICAgICBkYXNoQXJyYXkuZnJvbVNjYWxlICo9IGxpbmVXaWR0aDtcbiAgICAgICAgICAgIGRhc2hBcnJheS50b1NjYWxlICo9IGxpbmVXaWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhdGhpcy5oaWRkZW47XG4gICAgfSxcblxuICAgIGFzc2lnbjogZnVuY3Rpb24obGF5ZXIpIHtcbiAgICAgICAgdXRpbC5leHRlbmQodGhpcywgdXRpbC5waWNrKGxheWVyLFxuICAgICAgICAgICAgWyd0eXBlJywgJ3NvdXJjZScsICdzb3VyY2UtbGF5ZXInLFxuICAgICAgICAgICAgJ21pbnpvb20nLCAnbWF4em9vbScsICdmaWx0ZXInLFxuICAgICAgICAgICAgJ2xheW91dCddKSk7XG4gICAgfSxcblxuICAgIGpzb246IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdXRpbC5leHRlbmQoe30sXG4gICAgICAgICAgICB0aGlzLl9sYXllcixcbiAgICAgICAgICAgIHV0aWwucGljayh0aGlzLFxuICAgICAgICAgICAgICAgIFsndHlwZScsICdzb3VyY2UnLCAnc291cmNlLWxheWVyJyxcbiAgICAgICAgICAgICAgICAnbWluem9vbScsICdtYXh6b29tJywgJ2ZpbHRlcicsXG4gICAgICAgICAgICAgICAgJ2xheW91dCcsICdwYWludCddKSk7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gcHJlbXVsdGlwbHlMYXllcihsYXllciwgdHlwZSkge1xuICAgIHZhciBjb2xvclByb3AgPSB0eXBlICsgJy1jb2xvcicsXG4gICAgICAgIGhhbG9Qcm9wID0gdHlwZSArICctaGFsby1jb2xvcicsXG4gICAgICAgIG91dGxpbmVQcm9wID0gdHlwZSArICctb3V0bGluZS1jb2xvcicsXG4gICAgICAgIGNvbG9yID0gbGF5ZXJbY29sb3JQcm9wXSxcbiAgICAgICAgaGFsb0NvbG9yID0gbGF5ZXJbaGFsb1Byb3BdLFxuICAgICAgICBvdXRsaW5lQ29sb3IgPSBsYXllcltvdXRsaW5lUHJvcF0sXG4gICAgICAgIG9wYWNpdHkgPSBsYXllclt0eXBlICsgJy1vcGFjaXR5J107XG5cbiAgICB2YXIgY29sb3JPcGFjaXR5ID0gY29sb3IgJiYgKG9wYWNpdHkgKiBjb2xvclszXSk7XG4gICAgdmFyIGhhbG9PcGFjaXR5ID0gaGFsb0NvbG9yICYmIChvcGFjaXR5ICogaGFsb0NvbG9yWzNdKTtcbiAgICB2YXIgb3V0bGluZU9wYWNpdHkgPSBvdXRsaW5lQ29sb3IgJiYgKG9wYWNpdHkgKiBvdXRsaW5lQ29sb3JbM10pO1xuXG4gICAgaWYgKGNvbG9yT3BhY2l0eSAhPT0gdW5kZWZpbmVkICYmIGNvbG9yT3BhY2l0eSA8IDEpIHtcbiAgICAgICAgbGF5ZXJbY29sb3JQcm9wXSA9IHV0aWwucHJlbXVsdGlwbHkoW2NvbG9yWzBdLCBjb2xvclsxXSwgY29sb3JbMl0sIGNvbG9yT3BhY2l0eV0pO1xuICAgIH1cbiAgICBpZiAoaGFsb09wYWNpdHkgIT09IHVuZGVmaW5lZCAmJiBoYWxvT3BhY2l0eSA8IDEpIHtcbiAgICAgICAgbGF5ZXJbaGFsb1Byb3BdID0gdXRpbC5wcmVtdWx0aXBseShbaGFsb0NvbG9yWzBdLCBoYWxvQ29sb3JbMV0sIGhhbG9Db2xvclsyXSwgaGFsb09wYWNpdHldKTtcbiAgICB9XG4gICAgaWYgKG91dGxpbmVPcGFjaXR5ICE9PSB1bmRlZmluZWQgJiYgb3V0bGluZU9wYWNpdHkgPCAxKSB7XG4gICAgICAgIGxheWVyW291dGxpbmVQcm9wXSA9IHV0aWwucHJlbXVsdGlwbHkoW291dGxpbmVDb2xvclswXSwgb3V0bGluZUNvbG9yWzFdLCBvdXRsaW5lQ29sb3JbMl0sIG91dGxpbmVPcGFjaXR5XSk7XG4gICAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xudmFyIGludGVycG9sYXRlID0gcmVxdWlyZSgnLi4vdXRpbC9pbnRlcnBvbGF0ZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0eWxlVHJhbnNpdGlvbjtcblxuLypcbiAqIFJlcHJlc2VudHMgYSB0cmFuc2l0aW9uIGJldHdlZW4gdHdvIGRlY2xhcmF0aW9uc1xuICovXG5mdW5jdGlvbiBTdHlsZVRyYW5zaXRpb24oZGVjbGFyYXRpb24sIG9sZFRyYW5zaXRpb24sIHZhbHVlKSB7XG5cbiAgICB0aGlzLmRlY2xhcmF0aW9uID0gZGVjbGFyYXRpb247XG4gICAgdGhpcy5zdGFydFRpbWUgPSB0aGlzLmVuZFRpbWUgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuXG4gICAgdmFyIHR5cGUgPSBkZWNsYXJhdGlvbi50eXBlO1xuICAgIGlmICgodHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZSA9PT0gJ2FycmF5JykgJiYgZGVjbGFyYXRpb24udHJhbnNpdGlvbmFibGUpIHtcbiAgICAgICAgdGhpcy5pbnRlcnAgPSBpbnRlcnBab29tVHJhbnNpdGlvbmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaW50ZXJwID0gaW50ZXJwb2xhdGVbdHlwZV07XG4gICAgfVxuXG4gICAgdGhpcy5vbGRUcmFuc2l0aW9uID0gb2xkVHJhbnNpdGlvbjtcbiAgICB0aGlzLmR1cmF0aW9uID0gdmFsdWUuZHVyYXRpb24gfHwgMDtcbiAgICB0aGlzLmRlbGF5ID0gdmFsdWUuZGVsYXkgfHwgMDtcblxuICAgIGlmICghdGhpcy5pbnN0YW50KCkpIHtcbiAgICAgICAgdGhpcy5lbmRUaW1lID0gdGhpcy5zdGFydFRpbWUgKyB0aGlzLmR1cmF0aW9uICsgdGhpcy5kZWxheTtcbiAgICAgICAgdGhpcy5lYXNlID0gdXRpbC5lYXNlQ3ViaWNJbk91dDtcbiAgICB9XG5cbiAgICBpZiAob2xkVHJhbnNpdGlvbiAmJiBvbGRUcmFuc2l0aW9uLmVuZFRpbWUgPD0gdGhpcy5zdGFydFRpbWUpIHtcbiAgICAgICAgLy8gT2xkIHRyYW5zaXRpb24gaXMgZG9uZSBydW5uaW5nLCBzbyB3ZSBjYW5cbiAgICAgICAgLy8gZGVsZXRlIGl0cyByZWZlcmVuY2UgdG8gaXRzIG9sZCB0cmFuc2l0aW9uLlxuXG4gICAgICAgIGRlbGV0ZSBvbGRUcmFuc2l0aW9uLm9sZFRyYW5zaXRpb247XG4gICAgfVxufVxuXG5TdHlsZVRyYW5zaXRpb24ucHJvdG90eXBlLmluc3RhbnQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gIXRoaXMub2xkVHJhbnNpdGlvbiB8fCAhdGhpcy5pbnRlcnAgfHwgKHRoaXMuZHVyYXRpb24gPT09IDAgJiYgdGhpcy5kZWxheSA9PT0gMCk7XG59O1xuXG4vKlxuICogUmV0dXJuIHRoZSB2YWx1ZSBvZiB0aGUgdHJhbnNpdGlvbmluZyBwcm9wZXJ0eSBhdCB6b29tIGxldmVsIGB6YCBhbmQgb3B0aW9uYWwgdGltZSBgdGBcbiAqL1xuU3R5bGVUcmFuc2l0aW9uLnByb3RvdHlwZS5hdCA9IGZ1bmN0aW9uKHosIHpvb21IaXN0b3J5LCB0KSB7XG5cbiAgICB2YXIgdmFsdWUgPSB0aGlzLmRlY2xhcmF0aW9uLmNhbGN1bGF0ZSh6LCB6b29tSGlzdG9yeSwgdGhpcy5kdXJhdGlvbik7XG5cbiAgICBpZiAodGhpcy5pbnN0YW50KCkpIHJldHVybiB2YWx1ZTtcblxuICAgIHQgPSB0IHx8IERhdGUubm93KCk7XG5cbiAgICBpZiAodCA8IHRoaXMuZW5kVGltZSkge1xuICAgICAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLm9sZFRyYW5zaXRpb24uYXQoeiwgem9vbUhpc3RvcnksIHRoaXMuc3RhcnRUaW1lKTtcbiAgICAgICAgdmFyIGVhc2VkID0gdGhpcy5lYXNlKCh0IC0gdGhpcy5zdGFydFRpbWUgLSB0aGlzLmRlbGF5KSAvIHRoaXMuZHVyYXRpb24pO1xuICAgICAgICB2YWx1ZSA9IHRoaXMuaW50ZXJwKG9sZFZhbHVlLCB2YWx1ZSwgZWFzZWQpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcblxufTtcblxuZnVuY3Rpb24gaW50ZXJwWm9vbVRyYW5zaXRpb25lZChmcm9tLCB0bywgdCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGZyb206IGZyb20udG8sXG4gICAgICAgIGZyb21TY2FsZTogZnJvbS50b1NjYWxlLFxuICAgICAgICB0bzogdG8udG8sXG4gICAgICAgIHRvU2NhbGU6IHRvLnRvU2NhbGUsXG4gICAgICAgIHQ6IHRcbiAgICB9O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgUG9pbnQgPSByZXF1aXJlKCdwb2ludC1nZW9tZXRyeScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFuY2hvcjtcblxuZnVuY3Rpb24gQW5jaG9yKHgsIHksIGFuZ2xlLCBzZWdtZW50KSB7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICAgIHRoaXMuYW5nbGUgPSBhbmdsZTtcblxuICAgIGlmIChzZWdtZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5zZWdtZW50ID0gc2VnbWVudDtcbiAgICB9XG59XG5cbkFuY2hvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFBvaW50LnByb3RvdHlwZSk7XG5cbkFuY2hvci5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IEFuY2hvcih0aGlzLngsIHRoaXMueSwgdGhpcy5hbmdsZSwgdGhpcy5zZWdtZW50KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gQmluUGFjaztcblxuLyoqXG4gKiBTaW1wbGUgQmluIFBhY2tpbmdcbiAqIFVzZXMgdGhlIFNoZWxmIEJlc3QgSGVpZ2h0IEZpdCBhbGdvcml0aG0gZnJvbVxuICogaHR0cDovL2NsYi5kZW1vbi5maS9maWxlcy9SZWN0YW5nbGVCaW5QYWNrLnBkZlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gQmluUGFjayh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMuc2hlbHZlcyA9IFtdO1xuICAgIHRoaXMuc3RhdHMgPSB7fTtcbiAgICB0aGlzLmNvdW50ID0gZnVuY3Rpb24oaCkge1xuICAgICAgICB0aGlzLnN0YXRzW2hdID0gKHRoaXMuc3RhdHNbaF0gfCAwKSArIDE7XG4gICAgfTtcbn1cblxuQmluUGFjay5wcm90b3R5cGUuYWxsb2NhdGUgPSBmdW5jdGlvbihyZXFXaWR0aCwgcmVxSGVpZ2h0KSB7XG4gICAgdmFyIHkgPSAwLFxuICAgICAgICBiZXN0ID0geyBzaGVsZjogLTEsIHdhc3RlOiBJbmZpbml0eSB9LFxuICAgICAgICBzaGVsZiwgd2FzdGU7XG5cbiAgICAvLyBmaW5kIHNoZWxmXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnNoZWx2ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc2hlbGYgPSB0aGlzLnNoZWx2ZXNbaV07XG4gICAgICAgIHkgKz0gc2hlbGYuaGVpZ2h0O1xuXG4gICAgICAgIC8vIGV4YWN0bHkgdGhlIHJpZ2h0IGhlaWdodCB3aXRoIHdpZHRoIHRvIHNwYXJlLCBwYWNrIGl0Li5cbiAgICAgICAgaWYgKHJlcUhlaWdodCA9PT0gc2hlbGYuaGVpZ2h0ICYmIHJlcVdpZHRoIDw9IHNoZWxmLmZyZWUpIHtcbiAgICAgICAgICAgIHRoaXMuY291bnQocmVxSGVpZ2h0KTtcbiAgICAgICAgICAgIHJldHVybiBzaGVsZi5hbGxvYyhyZXFXaWR0aCwgcmVxSGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBub3QgZW5vdWdoIGhlaWdodCBvciB3aWR0aCwgc2tpcCBpdC4uXG4gICAgICAgIGlmIChyZXFIZWlnaHQgPiBzaGVsZi5oZWlnaHQgfHwgcmVxV2lkdGggPiBzaGVsZi5mcmVlKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBtYXliZSBlbm91Z2ggaGVpZ2h0IG9yIHdpZHRoLCBtaW5pbWl6ZSB3YXN0ZS4uXG4gICAgICAgIGlmIChyZXFIZWlnaHQgPCBzaGVsZi5oZWlnaHQgJiYgcmVxV2lkdGggPD0gc2hlbGYuZnJlZSkge1xuICAgICAgICAgICAgd2FzdGUgPSBzaGVsZi5oZWlnaHQgLSByZXFIZWlnaHQ7XG4gICAgICAgICAgICBpZiAod2FzdGUgPCBiZXN0Lndhc3RlKSB7XG4gICAgICAgICAgICAgICAgYmVzdC53YXN0ZSA9IHdhc3RlO1xuICAgICAgICAgICAgICAgIGJlc3Quc2hlbGYgPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGJlc3Quc2hlbGYgIT09IC0xKSB7XG4gICAgICAgIHNoZWxmID0gdGhpcy5zaGVsdmVzW2Jlc3Quc2hlbGZdO1xuICAgICAgICB0aGlzLmNvdW50KHJlcUhlaWdodCk7XG4gICAgICAgIHJldHVybiBzaGVsZi5hbGxvYyhyZXFXaWR0aCwgcmVxSGVpZ2h0KTtcbiAgICB9XG5cbiAgICAvLyBhZGQgc2hlbGZcbiAgICBpZiAocmVxSGVpZ2h0IDw9ICh0aGlzLmhlaWdodCAtIHkpICYmIHJlcVdpZHRoIDw9IHRoaXMud2lkdGgpIHtcbiAgICAgICAgc2hlbGYgPSBuZXcgU2hlbGYoeSwgdGhpcy53aWR0aCwgcmVxSGVpZ2h0KTtcbiAgICAgICAgdGhpcy5zaGVsdmVzLnB1c2goc2hlbGYpO1xuICAgICAgICB0aGlzLmNvdW50KHJlcUhlaWdodCk7XG4gICAgICAgIHJldHVybiBzaGVsZi5hbGxvYyhyZXFXaWR0aCwgcmVxSGVpZ2h0KTtcbiAgICB9XG5cbiAgICAvLyBubyBtb3JlIHNwYWNlXG4gICAgcmV0dXJuIHt4OiAtMSwgeTogLTF9O1xufTtcblxuXG5CaW5QYWNrLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbihyZXFXaWR0aCwgcmVxSGVpZ2h0KSB7XG4gICAgaWYgKHJlcVdpZHRoIDwgdGhpcy53aWR0aCB8fCByZXFIZWlnaHQgPCB0aGlzLmhlaWdodCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICB0aGlzLmhlaWdodCA9IHJlcUhlaWdodDtcbiAgICB0aGlzLndpZHRoID0gcmVxV2lkdGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnNoZWx2ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5zaGVsdmVzW2ldLnJlc2l6ZShyZXFXaWR0aCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcblxuXG5mdW5jdGlvbiBTaGVsZih5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdGhpcy55ID0geTtcbiAgICB0aGlzLnggPSAwO1xuICAgIHRoaXMud2lkdGggPSB0aGlzLmZyZWUgPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbn1cblxuU2hlbGYucHJvdG90eXBlID0ge1xuICAgIGFsbG9jOiBmdW5jdGlvbihyZXFXaWR0aCwgcmVxSGVpZ2h0KSB7XG4gICAgICAgIGlmIChyZXFXaWR0aCA+IHRoaXMuZnJlZSB8fCByZXFIZWlnaHQgPiB0aGlzLmhlaWdodCkge1xuICAgICAgICAgICAgcmV0dXJuIHt4OiAtMSwgeTogLTF9O1xuICAgICAgICB9XG4gICAgICAgIHZhciB4ID0gdGhpcy54O1xuICAgICAgICB0aGlzLnggKz0gcmVxV2lkdGg7XG4gICAgICAgIHRoaXMuZnJlZSAtPSByZXFXaWR0aDtcbiAgICAgICAgcmV0dXJuIHt4OiB4LCB5OiB0aGlzLnksIHc6IHJlcVdpZHRoLCBoOiByZXFIZWlnaHR9O1xuICAgIH0sXG5cbiAgICByZXNpemU6IGZ1bmN0aW9uKHJlcVdpZHRoKSB7XG4gICAgICAgIGlmIChyZXFXaWR0aCA8IHRoaXMud2lkdGgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICAgIHRoaXMuZnJlZSArPSAocmVxV2lkdGggLSB0aGlzLndpZHRoKTtcbiAgICAgICAgdGhpcy53aWR0aCA9IHJlcVdpZHRoO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59O1xuXG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gY2hlY2tNYXhBbmdsZTtcblxuLyoqXG4gKiBMYWJlbHMgcGxhY2VkIGFyb3VuZCByZWFsbHkgc2hhcnAgYW5nbGVzIGFyZW4ndCByZWFkYWJsZS4gQ2hlY2sgaWYgYW55XG4gKiBwYXJ0IG9mIHRoZSBwb3RlbnRpYWwgbGFiZWwgaGFzIGEgY29tYmluZWQgYW5nbGUgdGhhdCBpcyB0b28gYmlnLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8UG9pbnQ+fSBsaW5lXG4gKiBAcGFyYW0ge0FuY2hvcn0gYW5jaG9yIFRoZSBwb2ludCBvbiB0aGUgbGluZSBhcm91bmQgd2hpY2ggdGhlIGxhYmVsIGlzIGFuY2hvcmVkLlxuICogQHBhcmFtIHtudW1iZXJ9IGxhYmVsTGVuZ3RoIFRoZSBsZW5ndGggb2YgdGhlIGxhYmVsIGluIGdlb21ldHJ5IHVuaXRzLlxuICogQHBhcmFtIHtudW1iZXJ9IHdpbmRvd1NpemUgVGhlIGNoZWNrIGZhaWxzIGlmIHRoZSBjb21iaW5lZCBhbmdsZXMgd2l0aGluIGEgcGFydCBvZiB0aGUgbGluZSB0aGF0IGlzIGB3aW5kb3dTaXplYCBsb25nIGlzIHRvbyBiaWcuXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4QW5nbGUgVGhlIG1heGltdW0gY29tYmluZWQgYW5nbGUgdGhhdCBhbnkgd2luZG93IGFsb25nIHRoZSBsYWJlbCBpcyBhbGxvd2VkIHRvIGhhdmUuXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IHdoZXRoZXIgdGhlIGxhYmVsIHNob3VsZCBiZSBwbGFjZWRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNoZWNrTWF4QW5nbGUobGluZSwgYW5jaG9yLCBsYWJlbExlbmd0aCwgd2luZG93U2l6ZSwgbWF4QW5nbGUpIHtcblxuICAgIC8vIGhvcml6b250YWwgbGFiZWxzIGFsd2F5cyBwYXNzXG4gICAgaWYgKGFuY2hvci5zZWdtZW50ID09PSB1bmRlZmluZWQpIHJldHVybiB0cnVlO1xuXG4gICAgdmFyIHAgPSBhbmNob3I7XG4gICAgdmFyIGluZGV4ID0gYW5jaG9yLnNlZ21lbnQgKyAxO1xuICAgIHZhciBhbmNob3JEaXN0YW5jZSA9IDA7XG5cbiAgICAvLyBtb3ZlIGJhY2t3YXJkcyBhbG9uZyB0aGUgbGluZSB0byB0aGUgZmlyc3Qgc2VnbWVudCB0aGUgbGFiZWwgYXBwZWFycyBvblxuICAgIHdoaWxlIChhbmNob3JEaXN0YW5jZSA+IC1sYWJlbExlbmd0aCAvIDIpIHtcbiAgICAgICAgaW5kZXgtLTtcblxuICAgICAgICAvLyB0aGVyZSBpc24ndCBlbm91Z2ggcm9vbSBmb3IgdGhlIGxhYmVsIGFmdGVyIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGxpbmVcbiAgICAgICAgaWYgKGluZGV4IDwgMCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIGFuY2hvckRpc3RhbmNlIC09IGxpbmVbaW5kZXhdLmRpc3QocCk7XG4gICAgICAgIHAgPSBsaW5lW2luZGV4XTtcbiAgICB9XG5cbiAgICBhbmNob3JEaXN0YW5jZSArPSBsaW5lW2luZGV4XS5kaXN0KGxpbmVbaW5kZXggKyAxXSk7XG4gICAgaW5kZXgrKztcblxuICAgIC8vIHN0b3JlIHJlY2VudCBjb3JuZXJzIGFuZCB0aGVpciB0b3RhbCBhbmdsZSBkaWZmZXJlbmNlXG4gICAgdmFyIHJlY2VudENvcm5lcnMgPSBbXTtcbiAgICB2YXIgcmVjZW50QW5nbGVEZWx0YSA9IDA7XG5cbiAgICAvLyBtb3ZlIGZvcndhcmRzIGJ5IHRoZSBsZW5ndGggb2YgdGhlIGxhYmVsIGFuZCBjaGVjayBhbmdsZXMgYWxvbmcgdGhlIHdheVxuICAgIHdoaWxlIChhbmNob3JEaXN0YW5jZSA8IGxhYmVsTGVuZ3RoIC8gMikge1xuICAgICAgICB2YXIgcHJldiA9IGxpbmVbaW5kZXggLSAxXTtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSBsaW5lW2luZGV4XTtcbiAgICAgICAgdmFyIG5leHQgPSBsaW5lW2luZGV4ICsgMV07XG5cbiAgICAgICAgLy8gdGhlcmUgaXNuJ3QgZW5vdWdoIHJvb20gZm9yIHRoZSBsYWJlbCBiZWZvcmUgdGhlIGVuZCBvZiB0aGUgbGluZVxuICAgICAgICBpZiAoIW5leHQpIHJldHVybiBmYWxzZTtcblxuICAgICAgICB2YXIgYW5nbGVEZWx0YSA9IHByZXYuYW5nbGVUbyhjdXJyZW50KSAtIGN1cnJlbnQuYW5nbGVUbyhuZXh0KTtcbiAgICAgICAgLy8gcmVzdHJpY3QgYW5nbGUgdG8gLXBpLi5waSByYW5nZVxuICAgICAgICBhbmdsZURlbHRhID0gKChhbmdsZURlbHRhICsgMyAqIE1hdGguUEkpICUgKE1hdGguUEkgKiAyKSkgLSBNYXRoLlBJO1xuXG4gICAgICAgIHJlY2VudENvcm5lcnMucHVzaCh7XG4gICAgICAgICAgICBkaXN0YW5jZTogYW5jaG9yRGlzdGFuY2UsXG4gICAgICAgICAgICBhbmdsZURlbHRhOiBhbmdsZURlbHRhXG4gICAgICAgIH0pO1xuICAgICAgICByZWNlbnRBbmdsZURlbHRhICs9IGFuZ2xlRGVsdGE7XG5cbiAgICAgICAgLy8gcmVtb3ZlIGNvcm5lcnMgdGhhdCBhcmUgZmFyIGVub3VnaCBhd2F5IGZyb20gdGhlIGxpc3Qgb2YgcmVjZW50IGFuY2hvcnNcbiAgICAgICAgd2hpbGUgKGFuY2hvckRpc3RhbmNlIC0gcmVjZW50Q29ybmVyc1swXS5kaXN0YW5jZSA+IHdpbmRvd1NpemUpIHtcbiAgICAgICAgICAgIHJlY2VudEFuZ2xlRGVsdGEgLT0gcmVjZW50Q29ybmVycy5zaGlmdCgpLmFuZ2xlRGVsdGE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aGUgc3VtIG9mIGFuZ2xlcyB3aXRoaW4gdGhlIHdpbmRvdyBhcmVhIGV4Y2VlZHMgdGhlIG1heGltdW0gYWxsb3dlZCB2YWx1ZS4gY2hlY2sgZmFpbHMuXG4gICAgICAgIGlmIChNYXRoLmFicyhyZWNlbnRBbmdsZURlbHRhKSA+IG1heEFuZ2xlKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgaW5kZXgrKztcbiAgICAgICAgYW5jaG9yRGlzdGFuY2UgKz0gY3VycmVudC5kaXN0KG5leHQpO1xuICAgIH1cblxuICAgIC8vIG5vIHBhcnQgb2YgdGhlIGxpbmUgaGFkIGFuIGFuZ2xlIGdyZWF0ZXIgdGhhbiB0aGUgbWF4aW11bSBhbGxvd2VkLiBjaGVjayBwYXNzZXMuXG4gICAgcmV0dXJuIHRydWU7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBQb2ludCA9IHJlcXVpcmUoJ3BvaW50LWdlb21ldHJ5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gY2xpcExpbmU7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcGFydCBvZiBhIG11bHRpbGluZSB0aGF0IGludGVyc2VjdHMgd2l0aCB0aGUgcHJvdmlkZWQgcmVjdGFuZ3VsYXIgYm94LlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8UG9pbnQ+Pn0gbGluZXNcbiAqIEBwYXJhbSB7bnVtYmVyfSB4MSB0aGUgbGVmdCBlZGdlIG9mIHRoZSBib3hcbiAqIEBwYXJhbSB7bnVtYmVyfSB5MSB0aGUgdG9wIGVkZ2Ugb2YgdGhlIGJveFxuICogQHBhcmFtIHtudW1iZXJ9IHgyIHRoZSByaWdodCBlZGdlIG9mIHRoZSBib3hcbiAqIEBwYXJhbSB7bnVtYmVyfSB5MiB0aGUgYm90dG9tIGVkZ2Ugb2YgdGhlIGJveFxuICogQHJldHVybnMge0FycmF5PEFycmF5PFBvaW50Pj59IGxpbmVzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjbGlwTGluZShsaW5lcywgeDEsIHkxLCB4MiwgeTIpIHtcbiAgICB2YXIgY2xpcHBlZExpbmVzID0gW107XG5cbiAgICBmb3IgKHZhciBsID0gMDsgbCA8IGxpbmVzLmxlbmd0aDsgbCsrKSB7XG4gICAgICAgIHZhciBsaW5lID0gbGluZXNbbF07XG4gICAgICAgIHZhciBjbGlwcGVkTGluZTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmUubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcDAgPSBsaW5lW2ldO1xuICAgICAgICAgICAgdmFyIHAxID0gbGluZVtpICsgMV07XG5cblxuICAgICAgICAgICAgaWYgKHAwLnggPCB4MSAmJiBwMS54IDwgeDEpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocDAueCA8IHgxKSB7XG4gICAgICAgICAgICAgICAgcDAgPSBuZXcgUG9pbnQoeDEsIHAwLnkgKyAocDEueSAtIHAwLnkpICogKCh4MSAtIHAwLngpIC8gKHAxLnggLSBwMC54KSkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwMS54IDwgeDEpIHtcbiAgICAgICAgICAgICAgICBwMSA9IG5ldyBQb2ludCh4MSwgcDAueSArIChwMS55IC0gcDAueSkgKiAoKHgxIC0gcDAueCkgLyAocDEueCAtIHAwLngpKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwMC55IDwgeTEgJiYgcDEueSA8IHkxKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHAwLnkgPCB5MSkge1xuICAgICAgICAgICAgICAgIHAwID0gbmV3IFBvaW50KHAwLnggKyAocDEueCAtIHAwLngpICogKCh5MSAtIHAwLnkpIC8gKHAxLnkgLSBwMC55KSksIHkxKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocDEueSA8IHkxKSB7XG4gICAgICAgICAgICAgICAgcDEgPSBuZXcgUG9pbnQocDAueCArIChwMS54IC0gcDAueCkgKiAoKHkxIC0gcDAueSkgLyAocDEueSAtIHAwLnkpKSwgeTEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocDAueCA+PSB4MiAmJiBwMS54ID49IHgyKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHAwLnggPj0geDIpIHtcbiAgICAgICAgICAgICAgICBwMCA9IG5ldyBQb2ludCh4MiwgcDAueSArIChwMS55IC0gcDAueSkgKiAoKHgyIC0gcDAueCkgLyAocDEueCAtIHAwLngpKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHAxLnggPj0geDIpIHtcbiAgICAgICAgICAgICAgICBwMSA9IG5ldyBQb2ludCh4MiwgcDAueSArIChwMS55IC0gcDAueSkgKiAoKHgyIC0gcDAueCkgLyAocDEueCAtIHAwLngpKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwMC55ID49IHkyICYmIHAxLnkgPj0geTIpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocDAueSA+PSB5Mikge1xuICAgICAgICAgICAgICAgIHAwID0gbmV3IFBvaW50KHAwLnggKyAocDEueCAtIHAwLngpICogKCh5MiAtIHAwLnkpIC8gKHAxLnkgLSBwMC55KSksIHkyKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocDEueSA+PSB5Mikge1xuICAgICAgICAgICAgICAgIHAxID0gbmV3IFBvaW50KHAwLnggKyAocDEueCAtIHAwLngpICogKCh5MiAtIHAwLnkpIC8gKHAxLnkgLSBwMC55KSksIHkyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFjbGlwcGVkTGluZSB8fCAhcDAuZXF1YWxzKGNsaXBwZWRMaW5lW2NsaXBwZWRMaW5lLmxlbmd0aCAtIDFdKSkge1xuICAgICAgICAgICAgICAgIGNsaXBwZWRMaW5lID0gW3AwXTtcbiAgICAgICAgICAgICAgICBjbGlwcGVkTGluZXMucHVzaChjbGlwcGVkTGluZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNsaXBwZWRMaW5lLnB1c2gocDEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsaXBwZWRMaW5lcztcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBDb2xsaXNpb25Cb3g7XG5cbi8qKlxuICogQSBjb2xsaXNpb24gYm94IHJlcHJlc2VudHMgYW4gYXJlYSBvZiB0aGUgbWFwIHRoYXQgdGhhdCBpcyBjb3ZlcmVkIGJ5IGFcbiAqIGxhYmVsLiBDb2xsaXNpb25GZWF0dXJlIHVzZXMgb25lIG9yIG1vcmUgb2YgdGhlc2UgY29sbGlzaW9uIGJveGVzIHRvXG4gKiByZXByZXNlbnQgYWxsIHRoZSBhcmVhIGNvdmVyZWQgYnkgYSBzaW5nbGUgbGFiZWwuIFRoZXkgYXJlIHVzZWQgdG9cbiAqIHByZXZlbnQgY29sbGlzaW9ucyBiZXR3ZWVuIGxhYmVscy5cbiAqXG4gKiBBIGNvbGxpc2lvbiBib3ggYWN0dWFsbHkgcmVwcmVzZW50cyBhIDNkIHZvbHVtZS4gVGhlIGZpcnN0IHR3byBkaW1lbnNpb25zLFxuICogeCBhbmQgeSwgYXJlIHNwZWNpZmllZCB3aXRoIGBhbmNob3JgIGFsb25nIHdpdGggYHgxYCwgYHkxYCwgYHgyYCwgYHkyYC5cbiAqIFRoZSB0aGlyZCBkaW1lbnNpb24sIHpvb20sIGlzIGxpbWl0ZWQgYnkgYG1heFNjYWxlYCB3aGljaCBkZXRlcm1pbmVzXG4gKiBob3cgZmFyIGluIHRoZSB6IGRpbWVuc2lvbnMgdGhlIGJveCBleHRlbmRzLlxuICpcbiAqIEFzIHlvdSB6b29tIGluIG9uIGEgbWFwLCBhbGwgcG9pbnRzIG9uIHRoZSBtYXAgZ2V0IGZ1cnRoZXIgYW5kIGZ1cnRoZXIgYXBhcnRcbiAqIGJ1dCBsYWJlbHMgc3RheSByb3VnaGx5IHRoZSBzYW1lIHNpemUuIExhYmVscyBjb3ZlciBsZXNzIHJlYWwgd29ybGQgYXJlYSBvblxuICogdGhlIG1hcCBhdCBoaWdoZXIgem9vbSBsZXZlbHMgdGhhbiB0aGV5IGRvIGF0IGxvd2VyIHpvb20gbGV2ZWxzLiBUaGlzIGlzIHdoeVxuICogYXJlYXMgYXJlIGFyZSByZXByZXNlbnRlZCB3aXRoIGFuIGFuY2hvciBwb2ludCBhbmQgb2Zmc2V0cyBmcm9tIHRoYXQgcG9pbnRcbiAqIGluc3RlYWQgb2YganVzdCB1c2luZyBmb3VyIGFic29sdXRlIHBvaW50cy5cbiAqXG4gKiBMaW5lIGxhYmVscyBhcmUgcmVwcmVzZW50ZWQgYnkgYSBzZXQgb2YgdGhlc2UgYm94ZXMgc3BhY2VkIG91dCBhbG9uZyBhIGxpbmUuXG4gKiBXaGVuIHlvdSB6b29tIGluLCBsaW5lIGxhYmVscyBjb3ZlciBsZXNzIHJlYWwgd29ybGQgZGlzdGFuY2UgYWxvbmcgdGhlIGxpbmVcbiAqIHRoYW4gdGhleSB1c2VkIHRvLiBDb2xsaXNpb24gYm94ZXMgbmVhciB0aGUgZWRnZXMgdGhhdCB1c2VkIHRvIGNvdmVyIGxhYmVsXG4gKiBubyBsb25nZXIgZG8uIElmIGEgYm94IGRvZXNuJ3QgY292ZXIgdGhlIGxhYmVsIGFueW1vcmUgaXQgc2hvdWxkIGJlIGlnbm9yZWRcbiAqIHdoZW4gZG9pbmcgY29sbGlzaW9uIGNoZWNrcy4gYG1heFNjYWxlYCBpcyBob3cgbXVjaCB5b3UgY2FuIHNjYWxlIHRoZSBtYXBcbiAqIGJlZm9yZSB0aGUgbGFiZWwgaXNuJ3Qgd2l0aGluIHRoZSBib3ggYW55bW9yZS5cbiAqIEZvciBleGFtcGxlXG4gKiBsb3dlciB6b29tOlxuICogaHR0cHM6Ly9jbG91ZC5naXRodWJ1c2VyY29udGVudC5jb20vYXNzZXRzLzE0MjE2NTIvODA2MDA5NC80ZDk3NWY3Ni0wZTkxLTExZTUtODRiMS00ZWRlYjMwYTU4NzUucG5nXG4gKiBzbGlnaHRseSBoaWdoZXIgem9vbTpcbiAqIGh0dHBzOi8vY2xvdWQuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2Fzc2V0cy8xNDIxNjUyLzgwNjAwNjEvMjZhZTFjMzgtMGU5MS0xMWU1LThjNWEtOWYzODBiZjI5ZjBhLnBuZ1xuICogSW4gdGhlIHpvb21lZCBpbiBpbWFnZSB0aGUgdHdvIGdyZXkgYm94ZXMgb24gZWl0aGVyIHNpZGUgZG9uJ3QgY292ZXIgdGhlXG4gKiBsYWJlbCBhbnltb3JlLiBUaGVpciBtYXhTY2FsZSBpcyBzbWFsbGVyIHRoYW4gdGhlIGN1cnJlbnQgc2NhbGUuXG4gKlxuICpcbiAqIEBjbGFzcyBDb2xsaXNpb25Cb3hcbiAqIEBwYXJhbSB7UG9pbnR9IGFuY2hvclBvaW50IFRoZSBhbmNob3IgcG9pbnQgdGhlIGJveCBpcyBjZW50ZXJlZCBhcm91bmQuXG4gKiBAcGFyYW0ge251bWJlcn0geDEgVGhlIGRpc3RhbmNlIGZyb20gdGhlIGFuY2hvciB0byB0aGUgbGVmdCBlZGdlLlxuICogQHBhcmFtIHtudW1iZXJ9IHkxIFRoZSBkaXN0YW5jZSBmcm9tIHRoZSBhbmNob3IgdG8gdGhlIHRvcCBlZGdlLlxuICogQHBhcmFtIHtudW1iZXJ9IHgyIFRoZSBkaXN0YW5jZSBmcm9tIHRoZSBhbmNob3IgdG8gdGhlIHJpZ2h0IGVkZ2UuXG4gKiBAcGFyYW0ge251bWJlcn0geTIgVGhlIGRpc3RhbmNlIGZyb20gdGhlIGFuY2hvciB0byB0aGUgYm90dG9tIGVkZ2UuXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4U2NhbGUgVGhlIG1heGltdW0gc2NhbGUgdGhpcyBib3ggY2FuIGJsb2NrIG90aGVyIGJveGVzIGF0LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gQ29sbGlzaW9uQm94KGFuY2hvclBvaW50LCB4MSwgeTEsIHgyLCB5MiwgbWF4U2NhbGUpIHtcbiAgICAvLyB0aGUgYm94IGlzIGNlbnRlcmVkIGFyb3VuZCB0aGUgYW5jaG9yIHBvaW50XG4gICAgdGhpcy5hbmNob3JQb2ludCA9IGFuY2hvclBvaW50O1xuXG4gICAgLy8gZGlzdGFuY2VzIHRvIHRoZSBlZGdlcyBmcm9tIHRoZSBhbmNob3JcbiAgICB0aGlzLngxID0geDE7XG4gICAgdGhpcy55MSA9IHkxO1xuICAgIHRoaXMueDIgPSB4MjtcbiAgICB0aGlzLnkyID0geTI7XG5cbiAgICAvLyB0aGUgYm94IGlzIG9ubHkgdmFsaWQgZm9yIHNjYWxlcyA8IG1heFNjYWxlLlxuICAgIC8vIFRoZSBib3ggZG9lcyBub3QgYmxvY2sgb3RoZXIgYm94ZXMgYXQgc2NhbGVzID49IG1heFNjYWxlO1xuICAgIHRoaXMubWF4U2NhbGUgPSBtYXhTY2FsZTtcblxuICAgIC8vIHRoZSBzY2FsZSBhdCB3aGljaCB0aGUgbGFiZWwgY2FuIGZpcnN0IGJlIHNob3duXG4gICAgdGhpcy5wbGFjZW1lbnRTY2FsZSA9IDA7XG5cbiAgICAvLyByb3RhdGVkIGFuZCBzY2FsZWQgYmJveCB1c2VkIGZvciBpbmRleGluZ1xuICAgIHRoaXNbMF0gPSB0aGlzWzFdID0gdGhpc1syXSA9IHRoaXNbM10gPSAwO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ29sbGlzaW9uQm94ID0gcmVxdWlyZSgnLi9jb2xsaXNpb25fYm94Jyk7XG52YXIgUG9pbnQgPSByZXF1aXJlKCdwb2ludC1nZW9tZXRyeScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbGxpc2lvbkZlYXR1cmU7XG5cbi8qKlxuICogQSBDb2xsaXNpb25GZWF0dXJlIHJlcHJlc2VudHMgdGhlIGFyZWEgb2YgdGhlIHRpbGUgY292ZXJlZCBieSBhIHNpbmdsZSBsYWJlbC5cbiAqIEl0IGlzIHVzZWQgd2l0aCBDb2xsaXNpb25UaWxlIHRvIGNoZWNrIGlmIHRoZSBsYWJlbCBvdmVybGFwcyB3aXRoIGFueVxuICogcHJldmlvdXMgbGFiZWxzLiBBIENvbGxpc2lvbkZlYXR1cmUgaXMgbW9zdGx5IGp1c3QgYSBzZXQgb2YgQ29sbGlzaW9uQm94XG4gKiBvYmplY3RzLlxuICpcbiAqIEBjbGFzcyBDb2xsaXNpb25GZWF0dXJlXG4gKiBAcGFyYW0ge0FycmF5PFBvaW50Pn0gbGluZSBUaGUgZ2VvbWV0cnkgdGhlIGxhYmVsIGlzIHBsYWNlZCBvbi5cbiAqIEBwYXJhbSB7QW5jaG9yfSBhbmNob3IgVGhlIHBvaW50IGFsb25nIHRoZSBsaW5lIGFyb3VuZCB3aGljaCB0aGUgbGFiZWwgaXMgYW5jaG9yZWQuXG4gKiBAcGFyYW0ge09iamVjdH0gc2hhcGVkIFRoZSB0ZXh0IG9yIGljb24gc2hhcGluZyByZXN1bHRzLlxuICogQHBhcmFtIHtudW1iZXJ9IGJveFNjYWxlIEEgbWFnaWMgbnVtYmVyIHVzZWQgdG8gY29udmVydCBmcm9tIGdseXBoIG1ldHJpY3MgdW5pdHMgdG8gZ2VvbWV0cnkgdW5pdHMuXG4gKiBAcGFyYW0ge251bWJlcn0gcGFkZGluZyBUaGUgYW1vdW50IG9mIHBhZGRpbmcgdG8gYWRkIGFyb3VuZCB0aGUgbGFiZWwgZWRnZXMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGFsaWduTGluZSBXaGV0aGVyIHRoZSBsYWJlbCBpcyBhbGlnbmVkIHdpdGggdGhlIGxpbmUgb3IgdGhlIHZpZXdwb3J0LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIENvbGxpc2lvbkZlYXR1cmUobGluZSwgYW5jaG9yLCBzaGFwZWQsIGJveFNjYWxlLCBwYWRkaW5nLCBhbGlnbkxpbmUpIHtcblxuICAgIHZhciB5MSA9IHNoYXBlZC50b3AgKiBib3hTY2FsZSAtIHBhZGRpbmc7XG4gICAgdmFyIHkyID0gc2hhcGVkLmJvdHRvbSAqIGJveFNjYWxlICsgcGFkZGluZztcbiAgICB2YXIgeDEgPSBzaGFwZWQubGVmdCAqIGJveFNjYWxlIC0gcGFkZGluZztcbiAgICB2YXIgeDIgPSBzaGFwZWQucmlnaHQgKiBib3hTY2FsZSArIHBhZGRpbmc7XG5cbiAgICB0aGlzLmJveGVzID0gW107XG5cbiAgICBpZiAoYWxpZ25MaW5lKSB7XG5cbiAgICAgICAgdmFyIGhlaWdodCA9IHkyIC0geTE7XG4gICAgICAgIHZhciBsZW5ndGggPSB4MiAtIHgxO1xuXG4gICAgICAgIGlmIChoZWlnaHQgPD0gMCkgcmV0dXJuO1xuXG4gICAgICAgIC8vIHNldCBtaW5pbXVtIGJveCBoZWlnaHQgdG8gYXZvaWQgdmVyeSBtYW55IHNtYWxsIGxhYmVsc1xuICAgICAgICBoZWlnaHQgPSBNYXRoLm1heCgxMCAqIGJveFNjYWxlLCBoZWlnaHQpO1xuXG4gICAgICAgIHRoaXMuX2FkZExpbmVDb2xsaXNpb25Cb3hlcyhsaW5lLCBhbmNob3IsIGxlbmd0aCwgaGVpZ2h0KTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYm94ZXMucHVzaChuZXcgQ29sbGlzaW9uQm94KG5ldyBQb2ludChhbmNob3IueCwgYW5jaG9yLnkpLCB4MSwgeTEsIHgyLCB5MiwgSW5maW5pdHkpKTtcbiAgICB9XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgc2V0IG9mIENvbGxpc2lvbkJveCBvYmplY3RzIGZvciBhIGxpbmUuXG4gKlxuICogQHBhcmFtIHtBcnJheTxQb2ludD59IGxpbmVcbiAqIEBwYXJhbSB7QW5jaG9yfSBhbmNob3JcbiAqIEBwYXJhbSB7bnVtYmVyfSBsYWJlbExlbmd0aCBUaGUgbGVuZ3RoIG9mIHRoZSBsYWJlbCBpbiBnZW9tZXRyeSB1bml0cy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBib3hTaXplIFRoZSBzaXplIG9mIHRoZSBjb2xsaXNpb24gYm94ZXMgdGhhdCB3aWxsIGJlIGNyZWF0ZWQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuQ29sbGlzaW9uRmVhdHVyZS5wcm90b3R5cGUuX2FkZExpbmVDb2xsaXNpb25Cb3hlcyA9IGZ1bmN0aW9uKGxpbmUsIGFuY2hvciwgbGFiZWxMZW5ndGgsIGJveFNpemUpIHtcbiAgICB2YXIgc3RlcCA9IGJveFNpemUgLyAyO1xuICAgIHZhciBuQm94ZXMgPSBNYXRoLmZsb29yKGxhYmVsTGVuZ3RoIC8gc3RlcCk7XG5cbiAgICAvLyBvZmZzZXQgdGhlIGNlbnRlciBvZiB0aGUgZmlyc3QgYm94IGJ5IGhhbGYgYSBib3ggc28gdGhhdCB0aGUgZWRnZSBvZiB0aGVcbiAgICAvLyBib3ggaXMgYXQgdGhlIGVkZ2Ugb2YgdGhlIGxhYmVsLlxuICAgIHZhciBmaXJzdEJveE9mZnNldCA9IC1ib3hTaXplIC8gMjtcblxuICAgIHZhciBiYm94ZXMgPSB0aGlzLmJveGVzO1xuXG4gICAgdmFyIHAgPSBhbmNob3I7XG4gICAgdmFyIGluZGV4ID0gYW5jaG9yLnNlZ21lbnQgKyAxO1xuICAgIHZhciBhbmNob3JEaXN0YW5jZSA9IGZpcnN0Qm94T2Zmc2V0O1xuXG4gICAgLy8gbW92ZSBiYWNrd2FyZHMgYWxvbmcgdGhlIGxpbmUgdG8gdGhlIGZpcnN0IHNlZ21lbnQgdGhlIGxhYmVsIGFwcGVhcnMgb25cbiAgICBkbyB7XG4gICAgICAgIGluZGV4LS07XG5cbiAgICAgICAgLy8gdGhlcmUgaXNuJ3QgZW5vdWdoIHJvb20gZm9yIHRoZSBsYWJlbCBhZnRlciB0aGUgYmVnaW5uaW5nIG9mIHRoZSBsaW5lXG4gICAgICAgIC8vIGNoZWNrTWF4QW5nbGUgc2hvdWxkIGhhdmUgYWxyZWFkeSBjYXVnaHQgdGhpc1xuICAgICAgICBpZiAoaW5kZXggPCAwKSByZXR1cm4gYmJveGVzO1xuXG4gICAgICAgIGFuY2hvckRpc3RhbmNlIC09IGxpbmVbaW5kZXhdLmRpc3QocCk7XG4gICAgICAgIHAgPSBsaW5lW2luZGV4XTtcbiAgICB9IHdoaWxlIChhbmNob3JEaXN0YW5jZSA+IC1sYWJlbExlbmd0aCAvIDIpO1xuXG4gICAgdmFyIHNlZ21lbnRMZW5ndGggPSBsaW5lW2luZGV4XS5kaXN0KGxpbmVbaW5kZXggKyAxXSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5Cb3hlczsgaSsrKSB7XG4gICAgICAgIC8vIHRoZSBkaXN0YW5jZSB0aGUgYm94IHdpbGwgYmUgZnJvbSB0aGUgYW5jaG9yXG4gICAgICAgIHZhciBib3hEaXN0YW5jZVRvQW5jaG9yID0gLWxhYmVsTGVuZ3RoIC8gMiArIGkgKiBzdGVwO1xuXG4gICAgICAgIC8vIHRoZSBib3ggaXMgbm90IG9uIHRoZSBjdXJyZW50IHNlZ21lbnQuIE1vdmUgdG8gdGhlIG5leHQgc2VnbWVudC5cbiAgICAgICAgd2hpbGUgKGFuY2hvckRpc3RhbmNlICsgc2VnbWVudExlbmd0aCA8IGJveERpc3RhbmNlVG9BbmNob3IpIHtcbiAgICAgICAgICAgIGFuY2hvckRpc3RhbmNlICs9IHNlZ21lbnRMZW5ndGg7XG4gICAgICAgICAgICBpbmRleCsrO1xuXG4gICAgICAgICAgICAvLyBUaGVyZSBpc24ndCBlbm91Z2ggcm9vbSBiZWZvcmUgdGhlIGVuZCBvZiB0aGUgbGluZS5cbiAgICAgICAgICAgIGlmIChpbmRleCArIDEgPj0gbGluZS5sZW5ndGgpIHJldHVybiBiYm94ZXM7XG5cbiAgICAgICAgICAgIHNlZ21lbnRMZW5ndGggPSBsaW5lW2luZGV4XS5kaXN0KGxpbmVbaW5kZXggKyAxXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aGUgZGlzdGFuY2UgdGhlIGJveCB3aWxsIGJlIGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgc2VnbWVudFxuICAgICAgICB2YXIgc2VnbWVudEJveERpc3RhbmNlID0gYm94RGlzdGFuY2VUb0FuY2hvciAtIGFuY2hvckRpc3RhbmNlO1xuXG4gICAgICAgIHZhciBwMCA9IGxpbmVbaW5kZXhdO1xuICAgICAgICB2YXIgcDEgPSBsaW5lW2luZGV4ICsgMV07XG4gICAgICAgIHZhciBib3hBbmNob3JQb2ludCA9IHAxLnN1YihwMCkuX3VuaXQoKS5fbXVsdChzZWdtZW50Qm94RGlzdGFuY2UpLl9hZGQocDApO1xuXG4gICAgICAgIHZhciBkaXN0YW5jZVRvSW5uZXJFZGdlID0gTWF0aC5tYXgoTWF0aC5hYnMoYm94RGlzdGFuY2VUb0FuY2hvciAtIGZpcnN0Qm94T2Zmc2V0KSAtIHN0ZXAgLyAyLCAwKTtcbiAgICAgICAgdmFyIG1heFNjYWxlID0gbGFiZWxMZW5ndGggLyAyIC8gZGlzdGFuY2VUb0lubmVyRWRnZTtcblxuICAgICAgICBiYm94ZXMucHVzaChuZXcgQ29sbGlzaW9uQm94KGJveEFuY2hvclBvaW50LCAtYm94U2l6ZSAvIDIsIC1ib3hTaXplIC8gMiwgYm94U2l6ZSAvIDIsIGJveFNpemUgLyAyLCBtYXhTY2FsZSkpO1xuICAgIH1cblxuICAgIHJldHVybiBiYm94ZXM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmJ1c2ggPSByZXF1aXJlKCdyYnVzaCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbGxpc2lvblRpbGU7XG5cbi8qKlxuICogQSBjb2xsaXNpb24gdGlsZSB1c2VkIHRvIHByZXZlbnQgc3ltYm9scyBmcm9tIG92ZXJsYXBwaW5nLiBJdCBrZWVwIHRyYWNrcyBvZlxuICogd2hlcmUgcHJldmlvdXMgc3ltYm9scyBoYXZlIGJlZW4gcGxhY2VkIGFuZCBpcyB1c2VkIHRvIGNoZWNrIGlmIGEgbmV3XG4gKiBzeW1ib2wgb3ZlcmxhcHMgd2l0aCBhbnkgcHJldmlvdXNseSBhZGRlZCBzeW1ib2xzLlxuICpcbiAqIEBjbGFzcyBDb2xsaXNpb25UaWxlXG4gKiBAcGFyYW0ge251bWJlcn0gYW5nbGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBwaXRjaFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gQ29sbGlzaW9uVGlsZShhbmdsZSwgcGl0Y2gpIHtcbiAgICB0aGlzLnRyZWUgPSByYnVzaCgpO1xuICAgIHRoaXMuYW5nbGUgPSBhbmdsZTtcblxuICAgIHZhciBzaW4gPSBNYXRoLnNpbihhbmdsZSksXG4gICAgICAgIGNvcyA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICB0aGlzLnJvdGF0aW9uTWF0cml4ID0gW2NvcywgLXNpbiwgc2luLCBjb3NdO1xuXG4gICAgLy8gU3RyZXRjaCBib3hlcyBpbiB5IGRpcmVjdGlvbiB0byBhY2NvdW50IGZvciB0aGUgbWFwIHRpbHQuXG4gICAgdGhpcy55U3RyZXRjaCA9IDEgLyBNYXRoLmNvcyhwaXRjaCAvIDE4MCAqIE1hdGguUEkpO1xuXG4gICAgLy8gVGhlIGFtb3VudCB0aGUgbWFwIGlzIHNxdWlzaGVkIGRlcGVuZHMgb24gdGhlIHkgcG9zaXRpb24uXG4gICAgLy8gU29ydCBvZiBhY2NvdW50IGZvciB0aGlzIGJ5IG1ha2luZyBhbGwgYm94ZXMgYSBiaXQgYmlnZ2VyLlxuICAgIHRoaXMueVN0cmV0Y2ggPSBNYXRoLnBvdyh0aGlzLnlTdHJldGNoLCAxLjMpO1xufVxuXG5Db2xsaXNpb25UaWxlLnByb3RvdHlwZS5taW5TY2FsZSA9IDAuMjU7XG5Db2xsaXNpb25UaWxlLnByb3RvdHlwZS5tYXhTY2FsZSA9IDI7XG5cblxuLyoqXG4gKiBGaW5kIHRoZSBzY2FsZSBhdCB3aGljaCB0aGUgY29sbGlzaW9uRmVhdHVyZSBjYW4gYmUgc2hvd24gd2l0aG91dFxuICogb3ZlcmxhcHBpbmcgd2l0aCBvdGhlciBmZWF0dXJlcy5cbiAqXG4gKiBAcGFyYW0ge0NvbGxpc2lvbkZlYXR1cmV9IGNvbGxpc2lvbkZlYXR1cmVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHBsYWNlbWVudFNjYWxlXG4gKiBAcHJpdmF0ZVxuICovXG5Db2xsaXNpb25UaWxlLnByb3RvdHlwZS5wbGFjZUNvbGxpc2lvbkZlYXR1cmUgPSBmdW5jdGlvbihjb2xsaXNpb25GZWF0dXJlKSB7XG5cbiAgICB2YXIgbWluUGxhY2VtZW50U2NhbGUgPSB0aGlzLm1pblNjYWxlO1xuICAgIHZhciByb3RhdGlvbk1hdHJpeCA9IHRoaXMucm90YXRpb25NYXRyaXg7XG4gICAgdmFyIHlTdHJldGNoID0gdGhpcy55U3RyZXRjaDtcblxuICAgIGZvciAodmFyIGIgPSAwOyBiIDwgY29sbGlzaW9uRmVhdHVyZS5ib3hlcy5sZW5ndGg7IGIrKykge1xuXG4gICAgICAgIHZhciBib3ggPSBjb2xsaXNpb25GZWF0dXJlLmJveGVzW2JdO1xuXG4gICAgICAgIHZhciBhbmNob3JQb2ludCA9IGJveC5hbmNob3JQb2ludC5tYXRNdWx0KHJvdGF0aW9uTWF0cml4KTtcbiAgICAgICAgdmFyIHggPSBhbmNob3JQb2ludC54O1xuICAgICAgICB2YXIgeSA9IGFuY2hvclBvaW50Lnk7XG5cbiAgICAgICAgYm94WzBdID0geCArIGJveC54MTtcbiAgICAgICAgYm94WzFdID0geSArIGJveC55MSAqIHlTdHJldGNoO1xuICAgICAgICBib3hbMl0gPSB4ICsgYm94LngyO1xuICAgICAgICBib3hbM10gPSB5ICsgYm94LnkyICogeVN0cmV0Y2g7XG5cbiAgICAgICAgdmFyIGJsb2NraW5nQm94ZXMgPSB0aGlzLnRyZWUuc2VhcmNoKGJveCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBibG9ja2luZ0JveGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYmxvY2tpbmcgPSBibG9ja2luZ0JveGVzW2ldO1xuICAgICAgICAgICAgdmFyIGJsb2NraW5nQW5jaG9yUG9pbnQgPSBibG9ja2luZy5hbmNob3JQb2ludC5tYXRNdWx0KHJvdGF0aW9uTWF0cml4KTtcblxuICAgICAgICAgICAgLy8gRmluZCB0aGUgbG93ZXN0IHNjYWxlIGF0IHdoaWNoIHRoZSB0d28gYm94ZXMgY2FuIGZpdCBzaWRlIGJ5IHNpZGUgd2l0aG91dCBvdmVybGFwcGluZy5cbiAgICAgICAgICAgIC8vIE9yaWdpbmFsIGFsZ29yaXRobTpcbiAgICAgICAgICAgIHZhciBzMSA9IChibG9ja2luZy54MSAtIGJveC54MikgLyAoeCAtIGJsb2NraW5nQW5jaG9yUG9pbnQueCk7IC8vIHNjYWxlIGF0IHdoaWNoIG5ldyBib3ggaXMgdG8gdGhlIGxlZnQgb2Ygb2xkIGJveFxuICAgICAgICAgICAgdmFyIHMyID0gKGJsb2NraW5nLngyIC0gYm94LngxKSAvICh4IC0gYmxvY2tpbmdBbmNob3JQb2ludC54KTsgLy8gc2NhbGUgYXQgd2hpY2ggbmV3IGJveCBpcyB0byB0aGUgcmlnaHQgb2Ygb2xkIGJveFxuICAgICAgICAgICAgdmFyIHMzID0gKGJsb2NraW5nLnkxIC0gYm94LnkyKSAqIHlTdHJldGNoIC8gKHkgLSBibG9ja2luZ0FuY2hvclBvaW50LnkpOyAvLyBzY2FsZSBhdCB3aGljaCBuZXcgYm94IGlzIHRvIHRoZSB0b3Agb2Ygb2xkIGJveFxuICAgICAgICAgICAgdmFyIHM0ID0gKGJsb2NraW5nLnkyIC0gYm94LnkxKSAqIHlTdHJldGNoIC8gKHkgLSBibG9ja2luZ0FuY2hvclBvaW50LnkpOyAvLyBzY2FsZSBhdCB3aGljaCBuZXcgYm94IGlzIHRvIHRoZSBib3R0b20gb2Ygb2xkIGJveFxuXG4gICAgICAgICAgICBpZiAoaXNOYU4oczEpIHx8IGlzTmFOKHMyKSkgczEgPSBzMiA9IDE7XG4gICAgICAgICAgICBpZiAoaXNOYU4oczMpIHx8IGlzTmFOKHM0KSkgczMgPSBzNCA9IDE7XG5cbiAgICAgICAgICAgIHZhciBjb2xsaXNpb25GcmVlU2NhbGUgPSBNYXRoLm1pbihNYXRoLm1heChzMSwgczIpLCBNYXRoLm1heChzMywgczQpKTtcblxuICAgICAgICAgICAgaWYgKGNvbGxpc2lvbkZyZWVTY2FsZSA+IGJsb2NraW5nLm1heFNjYWxlKSB7XG4gICAgICAgICAgICAgICAgLy8gQWZ0ZXIgYSBib3gncyBtYXhTY2FsZSB0aGUgbGFiZWwgaGFzIHNocnVuayBlbm91Z2ggdGhhdCB0aGUgYm94IGlzIG5vIGxvbmdlciBuZWVkZWQgdG8gY292ZXIgaXQsXG4gICAgICAgICAgICAgICAgLy8gc28gdW5ibG9jayB0aGUgbmV3IGJveCBhdCB0aGUgc2NhbGUgdGhhdCB0aGUgb2xkIGJveCBkaXNhcHBlYXJzLlxuICAgICAgICAgICAgICAgIGNvbGxpc2lvbkZyZWVTY2FsZSA9IGJsb2NraW5nLm1heFNjYWxlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY29sbGlzaW9uRnJlZVNjYWxlID4gYm94Lm1heFNjYWxlKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGJveCBjYW4gb25seSBiZSBzaG93biBhZnRlciBpdCBpcyB2aXNpYmxlLCB0aGVuIHRoZSBib3ggY2FuIG5ldmVyIGJlIHNob3duLlxuICAgICAgICAgICAgICAgIC8vIEJ1dCB0aGUgbGFiZWwgY2FuIGJlIHNob3duIGFmdGVyIHRoaXMgYm94IGlzIG5vdCB2aXNpYmxlLlxuICAgICAgICAgICAgICAgIGNvbGxpc2lvbkZyZWVTY2FsZSA9IGJveC5tYXhTY2FsZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNvbGxpc2lvbkZyZWVTY2FsZSA+IG1pblBsYWNlbWVudFNjYWxlICYmXG4gICAgICAgICAgICAgICAgICAgIGNvbGxpc2lvbkZyZWVTY2FsZSA+PSBibG9ja2luZy5wbGFjZW1lbnRTY2FsZSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgY29sbGlzaW9uIG9jY3VycyBhdCBhIGxvd2VyIHNjYWxlIHRoYW4gcHJldmlvdXNseSBmb3VuZCBjb2xsaXNpb25zXG4gICAgICAgICAgICAgICAgLy8gYW5kIHRoZSBjb2xsaXNpb24gb2NjdXJzIHdoaWxlIHRoZSBvdGhlciBsYWJlbCBpcyB2aXNpYmxlXG5cbiAgICAgICAgICAgICAgICAvLyB0aGlzIHRoaXMgaXMgdGhlIGxvd2VzdCBzY2FsZSBhdCB3aGljaCB0aGUgbGFiZWwgd29uJ3QgY29sbGlkZSB3aXRoIGFueXRoaW5nXG4gICAgICAgICAgICAgICAgbWluUGxhY2VtZW50U2NhbGUgPSBjb2xsaXNpb25GcmVlU2NhbGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtaW5QbGFjZW1lbnRTY2FsZSA+PSB0aGlzLm1heFNjYWxlKSByZXR1cm4gbWluUGxhY2VtZW50U2NhbGU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWluUGxhY2VtZW50U2NhbGU7XG59O1xuXG4vKipcbiAqIFJlbWVtYmVyIHRoaXMgY29sbGlzaW9uRmVhdHVyZSBhbmQgd2hhdCBzY2FsZSBpdCB3YXMgcGxhY2VkIGF0IHRvIGJsb2NrXG4gKiBsYXRlciBmZWF0dXJlcyBmcm9tIG92ZXJsYXBwaW5nIHdpdGggaXQuXG4gKlxuICogQHBhcmFtIHtDb2xsaXNpb25GZWF0dXJlfSBjb2xsaXNpb25GZWF0dXJlXG4gKiBAcGFyYW0ge251bWJlcn0gbWluUGxhY2VtZW50U2NhbGVcbiAqIEBwcml2YXRlXG4gKi9cbkNvbGxpc2lvblRpbGUucHJvdG90eXBlLmluc2VydENvbGxpc2lvbkZlYXR1cmUgPSBmdW5jdGlvbihjb2xsaXNpb25GZWF0dXJlLCBtaW5QbGFjZW1lbnRTY2FsZSkge1xuXG4gICAgdmFyIGJveGVzID0gY29sbGlzaW9uRmVhdHVyZS5ib3hlcztcbiAgICBmb3IgKHZhciBrID0gMDsgayA8IGJveGVzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIGJveGVzW2tdLnBsYWNlbWVudFNjYWxlID0gbWluUGxhY2VtZW50U2NhbGU7XG4gICAgfVxuXG4gICAgaWYgKG1pblBsYWNlbWVudFNjYWxlIDwgdGhpcy5tYXhTY2FsZSkge1xuICAgICAgICB0aGlzLnRyZWUubG9hZChib3hlcyk7XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGludGVycG9sYXRlID0gcmVxdWlyZSgnLi4vdXRpbC9pbnRlcnBvbGF0ZScpO1xudmFyIEFuY2hvciA9IHJlcXVpcmUoJy4uL3N5bWJvbC9hbmNob3InKTtcbnZhciBjaGVja01heEFuZ2xlID0gcmVxdWlyZSgnLi9jaGVja19tYXhfYW5nbGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRBbmNob3JzO1xuXG5mdW5jdGlvbiBnZXRBbmNob3JzKGxpbmUsIHNwYWNpbmcsIG1heEFuZ2xlLCBzaGFwZWRUZXh0LCBzaGFwZWRJY29uLCBnbHlwaFNpemUsIGJveFNjYWxlLCBvdmVyc2NhbGluZykge1xuXG4gICAgLy8gUmVzYW1wbGUgYSBsaW5lIHRvIGdldCBhbmNob3IgcG9pbnRzIGZvciBsYWJlbHMgYW5kIGNoZWNrIHRoYXQgZWFjaFxuICAgIC8vIHBvdGVudGlhbCBsYWJlbCBwYXNzZXMgdGV4dC1tYXgtYW5nbGUgY2hlY2sgYW5kIGhhcyBlbm91Z2ggZnJvb20gdG8gZml0XG4gICAgLy8gb24gdGhlIGxpbmUuXG5cbiAgICB2YXIgYW5nbGVXaW5kb3dTaXplID0gc2hhcGVkVGV4dCA/XG4gICAgICAgIDMgLyA1ICogZ2x5cGhTaXplICogYm94U2NhbGUgOlxuICAgICAgICAwO1xuXG4gICAgdmFyIGxhYmVsTGVuZ3RoID0gTWF0aC5tYXgoXG4gICAgICAgIHNoYXBlZFRleHQgPyBzaGFwZWRUZXh0LnJpZ2h0IC0gc2hhcGVkVGV4dC5sZWZ0IDogMCxcbiAgICAgICAgc2hhcGVkSWNvbiA/IHNoYXBlZEljb24ucmlnaHQgLSBzaGFwZWRJY29uLmxlZnQgOiAwKTtcblxuICAgIC8vIElzIHRoZSBsaW5lIGNvbnRpbnVlZCBmcm9tIG91dHNpZGUgdGhlIHRpbGUgYm91bmRhcnk/XG4gICAgaWYgKGxpbmVbMF0ueCA9PT0gMCB8fCBsaW5lWzBdLnggPT09IDQwOTYgfHwgbGluZVswXS55ID09PSAwIHx8IGxpbmVbMF0ueSA9PT0gNDA5Nikge1xuICAgICAgICB2YXIgY29udGludWVkTGluZSA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gSXMgdGhlIGxhYmVsIGxvbmcsIHJlbGF0aXZlIHRvIHRoZSBzcGFjaW5nP1xuICAgIC8vIElmIHNvLCBhZGp1c3QgdGhlIHNwYWNpbmcgc28gdGhlcmUgaXMgYWx3YXlzIGEgbWluaW11bSBzcGFjZSBvZiBgc3BhY2luZyAvIDRgIGJldHdlZW4gbGFiZWwgZWRnZXMuXG4gICAgaWYgKHNwYWNpbmcgLSBsYWJlbExlbmd0aCAqIGJveFNjYWxlICA8IHNwYWNpbmcgLyA0KSB7XG4gICAgICAgIHNwYWNpbmcgPSBsYWJlbExlbmd0aCAqIGJveFNjYWxlICsgc3BhY2luZyAvIDQ7XG4gICAgfVxuXG4gICAgLy8gT2Zmc2V0IHRoZSBmaXJzdCBhbmNob3IgYnk6XG4gICAgLy8gRWl0aGVyIGhhbGYgdGhlIGxhYmVsIGxlbmd0aCBwbHVzIGEgZml4ZWQgZXh0cmEgb2Zmc2V0IGlmIHRoZSBsaW5lIGlzIG5vdCBjb250aW51ZWRcbiAgICAvLyBPciBoYWxmIHRoZSBzcGFjaW5nIGlmIHRoZSBsaW5lIGlzIGNvbnRpbnVlZC5cblxuICAgIC8vIEZvciBub24tY29udGludWVkIGxpbmVzLCBhZGQgYSBiaXQgb2YgZml4ZWQgZXh0cmEgb2Zmc2V0IHRvIGF2b2lkIGNvbGxpc2lvbnMgYXQgVCBpbnRlcnNlY3Rpb25zLlxuICAgIHZhciBmaXhlZEV4dHJhT2Zmc2V0ID0gZ2x5cGhTaXplICogMjtcblxuICAgIHZhciBvZmZzZXQgPSAhY29udGludWVkTGluZSA/XG4gICAgICAgICgobGFiZWxMZW5ndGggLyAyICsgZml4ZWRFeHRyYU9mZnNldCkgKiBib3hTY2FsZSAqIG92ZXJzY2FsaW5nKSAlIHNwYWNpbmcgOlxuICAgICAgICAoc3BhY2luZyAvIDIgKiBvdmVyc2NhbGluZykgJSBzcGFjaW5nO1xuXG4gICAgcmV0dXJuIHJlc2FtcGxlKGxpbmUsIG9mZnNldCwgc3BhY2luZywgYW5nbGVXaW5kb3dTaXplLCBtYXhBbmdsZSwgbGFiZWxMZW5ndGggKiBib3hTY2FsZSwgY29udGludWVkTGluZSwgZmFsc2UpO1xufVxuXG5cbmZ1bmN0aW9uIHJlc2FtcGxlKGxpbmUsIG9mZnNldCwgc3BhY2luZywgYW5nbGVXaW5kb3dTaXplLCBtYXhBbmdsZSwgbGFiZWxMZW5ndGgsIGNvbnRpbnVlZExpbmUsIHBsYWNlQXRNaWRkbGUpIHtcblxuICAgIHZhciBkaXN0YW5jZSA9IDAsXG4gICAgICAgIG1hcmtlZERpc3RhbmNlID0gb2Zmc2V0IC0gc3BhY2luZztcblxuICAgIHZhciBhbmNob3JzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmUubGVuZ3RoIC0gMTsgaSsrKSB7XG5cbiAgICAgICAgdmFyIGEgPSBsaW5lW2ldLFxuICAgICAgICAgICAgYiA9IGxpbmVbaSArIDFdO1xuXG4gICAgICAgIHZhciBzZWdtZW50RGlzdCA9IGEuZGlzdChiKSxcbiAgICAgICAgICAgIGFuZ2xlID0gYi5hbmdsZVRvKGEpO1xuXG4gICAgICAgIHdoaWxlIChtYXJrZWREaXN0YW5jZSArIHNwYWNpbmcgPCBkaXN0YW5jZSArIHNlZ21lbnREaXN0KSB7XG4gICAgICAgICAgICBtYXJrZWREaXN0YW5jZSArPSBzcGFjaW5nO1xuXG4gICAgICAgICAgICB2YXIgdCA9IChtYXJrZWREaXN0YW5jZSAtIGRpc3RhbmNlKSAvIHNlZ21lbnREaXN0LFxuICAgICAgICAgICAgICAgIHggPSBpbnRlcnBvbGF0ZShhLngsIGIueCwgdCksXG4gICAgICAgICAgICAgICAgeSA9IGludGVycG9sYXRlKGEueSwgYi55LCB0KTtcblxuICAgICAgICAgICAgaWYgKHggPj0gMCAmJiB4IDwgNDA5NiAmJiB5ID49IDAgJiYgeSA8IDQwOTYpIHtcbiAgICAgICAgICAgICAgICB4ID0gTWF0aC5yb3VuZCh4KTtcbiAgICAgICAgICAgICAgICB5ID0gTWF0aC5yb3VuZCh5KTtcbiAgICAgICAgICAgICAgICB2YXIgYW5jaG9yID0gbmV3IEFuY2hvcih4LCB5LCBhbmdsZSwgaSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWFuZ2xlV2luZG93U2l6ZSB8fCBjaGVja01heEFuZ2xlKGxpbmUsIGFuY2hvciwgbGFiZWxMZW5ndGgsIGFuZ2xlV2luZG93U2l6ZSwgbWF4QW5nbGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFuY2hvcnMucHVzaChhbmNob3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGRpc3RhbmNlICs9IHNlZ21lbnREaXN0O1xuICAgIH1cblxuICAgIGlmICghcGxhY2VBdE1pZGRsZSAmJiAhYW5jaG9ycy5sZW5ndGggJiYgIWNvbnRpbnVlZExpbmUpIHtcbiAgICAgICAgLy8gVGhlIGZpcnN0IGF0dGVtcHQgYXQgZmluZGluZyBhbmNob3JzIGF0IHdoaWNoIGxhYmVscyBjYW4gYmUgcGxhY2VkIGZhaWxlZC5cbiAgICAgICAgLy8gVHJ5IGFnYWluLCBidXQgdGhpcyB0aW1lIGp1c3QgdHJ5IHBsYWNpbmcgb25lIGFuY2hvciBhdCB0aGUgbWlkZGxlIG9mIHRoZSBsaW5lLlxuICAgICAgICAvLyBUaGlzIGhhcyB0aGUgbW9zdCBlZmZlY3QgZm9yIHNob3J0IGxpbmVzIGluIG92ZXJzY2FsZWQgdGlsZXMsIHNpbmNlIHRoZVxuICAgICAgICAvLyBpbml0aWFsIG9mZnNldCB1c2VkIGluIG92ZXJzY2FsZWQgdGlsZXMgaXMgY2FsY3VsYXRlZCB0byBhbGlnbiBsYWJlbHMgd2l0aCBwb3NpdGlvbnMgaW5cbiAgICAgICAgLy8gcGFyZW50IHRpbGVzIGluc3RlYWQgb2YgcGxhY2luZyB0aGUgbGFiZWwgYXMgY2xvc2UgdG8gdGhlIGJlZ2lubmluZyBhcyBwb3NzaWJsZS5cbiAgICAgICAgYW5jaG9ycyA9IHJlc2FtcGxlKGxpbmUsIGRpc3RhbmNlIC8gMiwgc3BhY2luZywgYW5nbGVXaW5kb3dTaXplLCBtYXhBbmdsZSwgbGFiZWxMZW5ndGgsIGNvbnRpbnVlZExpbmUsIHRydWUpO1xuICAgIH1cblxuICAgIHJldHVybiBhbmNob3JzO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQmluUGFjayA9IHJlcXVpcmUoJy4vYmluX3BhY2snKTtcblxubW9kdWxlLmV4cG9ydHMgPSBHbHlwaEF0bGFzO1xuZnVuY3Rpb24gR2x5cGhBdGxhcyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgdGhpcy5iaW4gPSBuZXcgQmluUGFjayh3aWR0aCwgaGVpZ2h0KTtcbiAgICB0aGlzLmluZGV4ID0ge307XG4gICAgdGhpcy5pZHMgPSB7fTtcbiAgICB0aGlzLmRhdGEgPSBuZXcgVWludDhBcnJheSh3aWR0aCAqIGhlaWdodCk7XG59XG5cbkdseXBoQXRsYXMucHJvdG90eXBlID0ge1xuICAgIGdldCBkZWJ1ZygpIHtcbiAgICAgICAgcmV0dXJuICdjYW52YXMnIGluIHRoaXM7XG4gICAgfSxcbiAgICBzZXQgZGVidWcodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICYmICF0aGlzLmNhbnZhcykge1xuICAgICAgICAgICAgdGhpcy5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLndpZHRoID0gdGhpcy53aWR0aDtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmNhbnZhcyk7XG4gICAgICAgICAgICB0aGlzLmN0eCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXZhbHVlICYmIHRoaXMuY2FudmFzKSB7XG4gICAgICAgICAgICB0aGlzLmNhbnZhcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuY2FudmFzKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmN0eDtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmNhbnZhcztcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbkdseXBoQXRsYXMucHJvdG90eXBlLmdldEdseXBocyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBnbHlwaHMgPSB7fSxcbiAgICAgICAgc3BsaXQsXG4gICAgICAgIG5hbWUsXG4gICAgICAgIGlkO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMuaWRzKSB7XG4gICAgICAgIHNwbGl0ID0ga2V5LnNwbGl0KCcjJyk7XG4gICAgICAgIG5hbWUgPSBzcGxpdFswXTtcbiAgICAgICAgaWQgPSBzcGxpdFsxXTtcblxuICAgICAgICBpZiAoIWdseXBoc1tuYW1lXSkgZ2x5cGhzW25hbWVdID0gW107XG4gICAgICAgIGdseXBoc1tuYW1lXS5wdXNoKGlkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2x5cGhzO1xufTtcblxuR2x5cGhBdGxhcy5wcm90b3R5cGUuZ2V0UmVjdHMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVjdHMgPSB7fSxcbiAgICAgICAgc3BsaXQsXG4gICAgICAgIG5hbWUsXG4gICAgICAgIGlkO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMuaWRzKSB7XG4gICAgICAgIHNwbGl0ID0ga2V5LnNwbGl0KCcjJyk7XG4gICAgICAgIG5hbWUgPSBzcGxpdFswXTtcbiAgICAgICAgaWQgPSBzcGxpdFsxXTtcblxuICAgICAgICBpZiAoIXJlY3RzW25hbWVdKSByZWN0c1tuYW1lXSA9IHt9O1xuICAgICAgICByZWN0c1tuYW1lXVtpZF0gPSB0aGlzLmluZGV4W2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlY3RzO1xufTtcblxuXG5HbHlwaEF0bGFzLnByb3RvdHlwZS5hZGRHbHlwaCA9IGZ1bmN0aW9uKGlkLCBuYW1lLCBnbHlwaCwgYnVmZmVyKSB7XG4gICAgaWYgKCFnbHlwaCkge1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJ21pc3NpbmcgZ2x5cGgnLCBjb2RlLCBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBrZXkgPSBuYW1lICsgXCIjXCIgKyBnbHlwaC5pZDtcblxuICAgIC8vIFRoZSBnbHlwaCBpcyBhbHJlYWR5IGluIHRoaXMgdGV4dHVyZS5cbiAgICBpZiAodGhpcy5pbmRleFtrZXldKSB7XG4gICAgICAgIGlmICh0aGlzLmlkc1trZXldLmluZGV4T2YoaWQpIDwgMCkge1xuICAgICAgICAgICAgdGhpcy5pZHNba2V5XS5wdXNoKGlkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pbmRleFtrZXldO1xuICAgIH1cblxuICAgIC8vIFRoZSBnbHlwaCBiaXRtYXAgaGFzIHplcm8gd2lkdGguXG4gICAgaWYgKCFnbHlwaC5iaXRtYXApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGJ1ZmZlcmVkV2lkdGggPSBnbHlwaC53aWR0aCArIGJ1ZmZlciAqIDI7XG4gICAgdmFyIGJ1ZmZlcmVkSGVpZ2h0ID0gZ2x5cGguaGVpZ2h0ICsgYnVmZmVyICogMjtcblxuICAgIC8vIEFkZCBhIDFweCBib3JkZXIgYXJvdW5kIGV2ZXJ5IGltYWdlLlxuICAgIHZhciBwYWRkaW5nID0gMTtcbiAgICB2YXIgcGFja1dpZHRoID0gYnVmZmVyZWRXaWR0aCArIDIgKiBwYWRkaW5nO1xuICAgIHZhciBwYWNrSGVpZ2h0ID0gYnVmZmVyZWRIZWlnaHQgKyAyICogcGFkZGluZztcblxuICAgIC8vIEluY3JlYXNlIHRvIG5leHQgbnVtYmVyIGRpdmlzaWJsZSBieSA0LCBidXQgYXQgbGVhc3QgMS5cbiAgICAvLyBUaGlzIGlzIHNvIHdlIGNhbiBzY2FsZSBkb3duIHRoZSB0ZXh0dXJlIGNvb3JkaW5hdGVzIGFuZCBwYWNrIHRoZW1cbiAgICAvLyBpbnRvIDIgYnl0ZXMgcmF0aGVyIHRoYW4gNCBieXRlcy5cbiAgICBwYWNrV2lkdGggKz0gKDQgLSBwYWNrV2lkdGggJSA0KTtcbiAgICBwYWNrSGVpZ2h0ICs9ICg0IC0gcGFja0hlaWdodCAlIDQpO1xuXG4gICAgdmFyIHJlY3QgPSB0aGlzLmJpbi5hbGxvY2F0ZShwYWNrV2lkdGgsIHBhY2tIZWlnaHQpO1xuICAgIGlmIChyZWN0LnggPCAwKSB7XG4gICAgICAgIHRoaXMucmVzaXplKCk7XG4gICAgICAgIHJlY3QgPSB0aGlzLmJpbi5hbGxvY2F0ZShwYWNrV2lkdGgsIHBhY2tIZWlnaHQpO1xuICAgIH1cbiAgICBpZiAocmVjdC54IDwgMCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ2dseXBoIGJpdG1hcCBvdmVyZmxvdycpO1xuICAgICAgICByZXR1cm4geyBnbHlwaDogZ2x5cGgsIHJlY3Q6IG51bGwgfTtcbiAgICB9XG5cbiAgICB0aGlzLmluZGV4W2tleV0gPSByZWN0O1xuICAgIHRoaXMuaWRzW2tleV0gPSBbaWRdO1xuXG4gICAgdmFyIHRhcmdldCA9IHRoaXMuZGF0YTtcbiAgICB2YXIgc291cmNlID0gZ2x5cGguYml0bWFwO1xuICAgIGZvciAodmFyIHkgPSAwOyB5IDwgYnVmZmVyZWRIZWlnaHQ7IHkrKykge1xuICAgICAgICB2YXIgeTEgPSB0aGlzLndpZHRoICogKHJlY3QueSArIHkgKyBwYWRkaW5nKSArIHJlY3QueCArIHBhZGRpbmc7XG4gICAgICAgIHZhciB5MiA9IGJ1ZmZlcmVkV2lkdGggKiB5O1xuICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IGJ1ZmZlcmVkV2lkdGg7IHgrKykge1xuICAgICAgICAgICAgdGFyZ2V0W3kxICsgeF0gPSBzb3VyY2VbeTIgKyB4XTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuXG4gICAgcmV0dXJuIHJlY3Q7XG59O1xuXG5HbHlwaEF0bGFzLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3JpZ3cgPSB0aGlzLndpZHRoLFxuICAgICAgICBvcmlnaCA9IHRoaXMuaGVpZ2h0O1xuXG4gICAgLy8gRm9yIG5vdywgZG9uJ3QgZ3JvdyB0aGUgYXRsYXMgYmV5b25kIDEwMjR4MTAyNCBiZWNhdXNlIG9mIGhvd1xuICAgIC8vIHRleHR1cmUgY29vcmRzIHBhY2sgaW50byB1bnNpZ25lZCBieXRlIGluIHN5bWJvbCBidWNrZXQuXG4gICAgaWYgKG9yaWd3ID4gNTEyIHx8IG9yaWdoID4gNTEyKSByZXR1cm47XG5cbiAgICBpZiAodGhpcy50ZXh0dXJlKSB7XG4gICAgICAgIGlmICh0aGlzLmdsKSB7XG4gICAgICAgICAgICB0aGlzLmdsLmRlbGV0ZVRleHR1cmUodGhpcy50ZXh0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRleHR1cmUgPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMud2lkdGggKj0gMjtcbiAgICB0aGlzLmhlaWdodCAqPSAyO1xuICAgIHRoaXMuYmluLnJlc2l6ZSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG5cbiAgICB2YXIgYnVmID0gbmV3IEFycmF5QnVmZmVyKHRoaXMud2lkdGggKiB0aGlzLmhlaWdodCksXG4gICAgICAgIHNyYywgZHN0O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3JpZ2g7IGkrKykge1xuICAgICAgICBzcmMgPSBuZXcgVWludDhBcnJheSh0aGlzLmRhdGEuYnVmZmVyLCBvcmlnaCAqIGksIG9yaWd3KTtcbiAgICAgICAgZHN0ID0gbmV3IFVpbnQ4QXJyYXkoYnVmLCBvcmlnaCAqIGkgKiAyLCBvcmlndyk7XG4gICAgICAgIGRzdC5zZXQoc3JjKTtcbiAgICB9XG4gICAgdGhpcy5kYXRhID0gbmV3IFVpbnQ4QXJyYXkoYnVmKTtcbn07XG5cbkdseXBoQXRsYXMucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbihnbCkge1xuICAgIHRoaXMuZ2wgPSBnbDtcbiAgICBpZiAoIXRoaXMudGV4dHVyZSkge1xuICAgICAgICB0aGlzLnRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZSk7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5MSU5FQVIpO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTElORUFSKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLkFMUEhBLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgMCwgZ2wuQUxQSEEsIGdsLlVOU0lHTkVEX0JZVEUsIG51bGwpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKTtcbiAgICB9XG59O1xuXG5HbHlwaEF0bGFzLnByb3RvdHlwZS51cGRhdGVUZXh0dXJlID0gZnVuY3Rpb24oZ2wpIHtcbiAgICB0aGlzLmJpbmQoZ2wpO1xuICAgIGlmICh0aGlzLmRpcnR5KSB7XG5cbiAgICAgICAgZ2wudGV4U3ViSW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCAwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgZ2wuQUxQSEEsIGdsLlVOU0lHTkVEX0JZVEUsIHRoaXMuZGF0YSk7XG5cbiAgICAgICAgLy8gREVCVUdcbiAgICAgICAgaWYgKHRoaXMuY3R4KSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuY3R4LmdldEltYWdlRGF0YSgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaiA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpKyssIGogKz0gNCkge1xuICAgICAgICAgICAgICAgIGRhdGEuZGF0YVtqXSA9IHRoaXMuZGF0YVtpXTtcbiAgICAgICAgICAgICAgICBkYXRhLmRhdGFbaiArIDFdID0gdGhpcy5kYXRhW2ldO1xuICAgICAgICAgICAgICAgIGRhdGEuZGF0YVtqICsgMl0gPSB0aGlzLmRhdGFbaV07XG4gICAgICAgICAgICAgICAgZGF0YS5kYXRhW2ogKyAzXSA9IDI1NTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY3R4LnB1dEltYWdlRGF0YShkYXRhLCAwLCAwKTtcblxuICAgICAgICAgICAgdGhpcy5jdHguc3Ryb2tlU3R5bGUgPSAncmVkJztcbiAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdGhpcy5iaW4uZnJlZS5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgIHZhciBmcmVlID0gdGhpcy5iaW4uZnJlZVtrXTtcbiAgICAgICAgICAgICAgICB0aGlzLmN0eC5zdHJva2VSZWN0KGZyZWUueCwgZnJlZS55LCBmcmVlLncsIGZyZWUuaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRU5EIERFQlVHXG5cbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBub3JtYWxpemVVUkwgPSByZXF1aXJlKCcuLi91dGlsL21hcGJveCcpLm5vcm1hbGl6ZUdseXBoc1VSTDtcbnZhciBnZXRBcnJheUJ1ZmZlciA9IHJlcXVpcmUoJy4uL3V0aWwvYWpheCcpLmdldEFycmF5QnVmZmVyO1xudmFyIEdseXBocyA9IHJlcXVpcmUoJy4uL3V0aWwvZ2x5cGhzJyk7XG52YXIgR2x5cGhBdGxhcyA9IHJlcXVpcmUoJy4uL3N5bWJvbC9nbHlwaF9hdGxhcycpO1xudmFyIFByb3RvYnVmID0gcmVxdWlyZSgncGJmJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gR2x5cGhTb3VyY2U7XG5cbi8qKlxuICogQSBnbHlwaCBzb3VyY2UgaGFzIGEgVVJMIGZyb20gd2hpY2ggdG8gbG9hZCBuZXcgZ2x5cGhzIGFuZCBtYW5hZ2VzXG4gKiBHbHlwaEF0bGFzZXMgaW4gd2hpY2ggdG8gc3RvcmUgZ2x5cGhzIHVzZWQgYnkgdGhlIHJlcXVlc3RlZCBmb250c3RhY2tzXG4gKiBhbmQgcmFuZ2VzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgZ2x5cGggdGVtcGxhdGUgdXJsXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBHbHlwaFNvdXJjZSh1cmwpIHtcbiAgICB0aGlzLnVybCA9IHVybCAmJiBub3JtYWxpemVVUkwodXJsKTtcbiAgICB0aGlzLmF0bGFzZXMgPSB7fTtcbiAgICB0aGlzLnN0YWNrcyA9IHt9O1xuICAgIHRoaXMubG9hZGluZyA9IHt9O1xufVxuXG5HbHlwaFNvdXJjZS5wcm90b3R5cGUuZ2V0U2ltcGxlR2x5cGhzID0gZnVuY3Rpb24oZm9udHN0YWNrLCBnbHlwaElEcywgdWlkLCBjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLnN0YWNrc1tmb250c3RhY2tdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5zdGFja3NbZm9udHN0YWNrXSA9IHt9O1xuICAgIH1cbiAgICBpZiAodGhpcy5hdGxhc2VzW2ZvbnRzdGFja10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmF0bGFzZXNbZm9udHN0YWNrXSA9IG5ldyBHbHlwaEF0bGFzKDEyOCwgMTI4KTtcbiAgICB9XG5cbiAgICB2YXIgZ2x5cGhzID0ge307XG4gICAgdmFyIHN0YWNrID0gdGhpcy5zdGFja3NbZm9udHN0YWNrXTtcbiAgICB2YXIgYXRsYXMgPSB0aGlzLmF0bGFzZXNbZm9udHN0YWNrXTtcblxuICAgIC8vIHRoZSBudW1iZXIgb2YgcGl4ZWxzIHRoZSBzZGYgYml0bWFwcyBhcmUgcGFkZGVkIGJ5XG4gICAgdmFyIGJ1ZmZlciA9IDM7XG5cbiAgICB2YXIgbWlzc2luZyA9IHt9O1xuICAgIHZhciByZW1haW5pbmcgPSAwO1xuICAgIHZhciByYW5nZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2x5cGhJRHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGdseXBoSUQgPSBnbHlwaElEc1tpXTtcbiAgICAgICAgcmFuZ2UgPSBNYXRoLmZsb29yKGdseXBoSUQgLyAyNTYpO1xuXG4gICAgICAgIGlmIChzdGFja1tyYW5nZV0pIHtcbiAgICAgICAgICAgIHZhciBnbHlwaCA9IHN0YWNrW3JhbmdlXS5nbHlwaHNbZ2x5cGhJRF07XG4gICAgICAgICAgICB2YXIgcmVjdCAgPSBhdGxhcy5hZGRHbHlwaCh1aWQsIGZvbnRzdGFjaywgZ2x5cGgsIGJ1ZmZlcik7XG4gICAgICAgICAgICBpZiAoZ2x5cGgpIGdseXBoc1tnbHlwaElEXSA9IG5ldyBTaW1wbGVHbHlwaChnbHlwaCwgcmVjdCwgYnVmZmVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChtaXNzaW5nW3JhbmdlXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbWlzc2luZ1tyYW5nZV0gPSBbXTtcbiAgICAgICAgICAgICAgICByZW1haW5pbmcrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1pc3NpbmdbcmFuZ2VdLnB1c2goZ2x5cGhJRCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXJlbWFpbmluZykgY2FsbGJhY2sodW5kZWZpbmVkLCBnbHlwaHMsIGZvbnRzdGFjayk7XG5cbiAgICB2YXIgb25SYW5nZUxvYWRlZCA9IGZ1bmN0aW9uKGVyciwgcmFuZ2UsIGRhdGEpIHtcbiAgICAgICAgLy8gVE9ETyBub3QgYmUgc2lsZW50IGFib3V0IGVycm9yc1xuICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgICAgdmFyIHN0YWNrID0gdGhpcy5zdGFja3NbZm9udHN0YWNrXVtyYW5nZV0gPSBkYXRhLnN0YWNrc1swXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWlzc2luZ1tyYW5nZV0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZ2x5cGhJRCA9IG1pc3NpbmdbcmFuZ2VdW2ldO1xuICAgICAgICAgICAgICAgIHZhciBnbHlwaCA9IHN0YWNrLmdseXBoc1tnbHlwaElEXTtcbiAgICAgICAgICAgICAgICB2YXIgcmVjdCAgPSBhdGxhcy5hZGRHbHlwaCh1aWQsIGZvbnRzdGFjaywgZ2x5cGgsIGJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgaWYgKGdseXBoKSBnbHlwaHNbZ2x5cGhJRF0gPSBuZXcgU2ltcGxlR2x5cGgoZ2x5cGgsIHJlY3QsIGJ1ZmZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVtYWluaW5nLS07XG4gICAgICAgIGlmICghcmVtYWluaW5nKSBjYWxsYmFjayh1bmRlZmluZWQsIGdseXBocywgZm9udHN0YWNrKTtcbiAgICB9LmJpbmQodGhpcyk7XG5cbiAgICBmb3IgKHZhciByIGluIG1pc3NpbmcpIHtcbiAgICAgICAgdGhpcy5sb2FkUmFuZ2UoZm9udHN0YWNrLCByLCBvblJhbmdlTG9hZGVkKTtcbiAgICB9XG59O1xuXG4vLyBBIHNpbXBsaWZpZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdseXBoIGNvbnRhaW5pbmcgb25seSB0aGUgcHJvcGVydGllcyBuZWVkZWQgZm9yIHNoYXBpbmcuXG5mdW5jdGlvbiBTaW1wbGVHbHlwaChnbHlwaCwgcmVjdCwgYnVmZmVyKSB7XG4gICAgdmFyIHBhZGRpbmcgPSAxO1xuICAgIHRoaXMuYWR2YW5jZSA9IGdseXBoLmFkdmFuY2U7XG4gICAgdGhpcy5sZWZ0ID0gZ2x5cGgubGVmdCAtIGJ1ZmZlciAtIHBhZGRpbmc7XG4gICAgdGhpcy50b3AgPSBnbHlwaC50b3AgKyBidWZmZXIgKyBwYWRkaW5nO1xuICAgIHRoaXMucmVjdCA9IHJlY3Q7XG59XG5cbkdseXBoU291cmNlLnByb3RvdHlwZS5sb2FkUmFuZ2UgPSBmdW5jdGlvbihmb250c3RhY2ssIHJhbmdlLCBjYWxsYmFjaykge1xuICAgIGlmIChyYW5nZSAqIDI1NiA+IDY1NTM1KSByZXR1cm4gY2FsbGJhY2soJ2dseXBocyA+IDY1NTM1IG5vdCBzdXBwb3J0ZWQnKTtcblxuICAgIGlmICh0aGlzLmxvYWRpbmdbZm9udHN0YWNrXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMubG9hZGluZ1tmb250c3RhY2tdID0ge307XG4gICAgfVxuICAgIHZhciBsb2FkaW5nID0gdGhpcy5sb2FkaW5nW2ZvbnRzdGFja107XG5cbiAgICBpZiAobG9hZGluZ1tyYW5nZV0pIHtcbiAgICAgICAgbG9hZGluZ1tyYW5nZV0ucHVzaChjYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbG9hZGluZ1tyYW5nZV0gPSBbY2FsbGJhY2tdO1xuXG4gICAgICAgIHZhciByYW5nZU5hbWUgPSAocmFuZ2UgKiAyNTYpICsgJy0nICsgKHJhbmdlICogMjU2ICsgMjU1KTtcbiAgICAgICAgdmFyIHVybCA9IGdseXBoVXJsKGZvbnRzdGFjaywgcmFuZ2VOYW1lLCB0aGlzLnVybCk7XG5cbiAgICAgICAgZ2V0QXJyYXlCdWZmZXIodXJsLCBmdW5jdGlvbihlcnIsIGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBnbHlwaHMgPSAhZXJyICYmIG5ldyBHbHlwaHMobmV3IFByb3RvYnVmKG5ldyBVaW50OEFycmF5KGRhdGEpKSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvYWRpbmdbcmFuZ2VdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbG9hZGluZ1tyYW5nZV1baV0oZXJyLCByYW5nZSwgZ2x5cGhzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbGV0ZSBsb2FkaW5nW3JhbmdlXTtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxuR2x5cGhTb3VyY2UucHJvdG90eXBlLmdldEdseXBoQXRsYXMgPSBmdW5jdGlvbihmb250c3RhY2spIHtcbiAgICByZXR1cm4gdGhpcy5hdGxhc2VzW2ZvbnRzdGFja107XG59O1xuXG4vKipcbiAqIFVzZSBDTkFNRSBzaGFyZGluZyB0byBsb2FkIGEgc3BlY2lmaWMgZ2x5cGggcmFuZ2Ugb3ZlciBhIHJhbmRvbWl6ZWRcbiAqIGJ1dCBjb25zaXN0ZW50IHN1YmRvbWFpbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBmb250c3RhY2sgY29tbWEtam9pbmVkIGZvbnRzXG4gKiBAcGFyYW0ge3N0cmluZ30gcmFuZ2UgY29tbWEtam9pbmVkIHJhbmdlXG4gKiBAcGFyYW0ge3VybH0gdXJsIHRlbXBsYXRlZCB1cmxcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3ViZG9tYWlucz1hYmNdIHN1YmRvbWFpbnMgYXMgYSBzdHJpbmcgd2hlcmUgZWFjaCBsZXR0ZXIgaXMgb25lLlxuICogQHJldHVybnMge3N0cmluZ30gYSB1cmwgdG8gbG9hZCB0aGF0IHNlY3Rpb24gb2YgZ2x5cGhzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnbHlwaFVybChmb250c3RhY2ssIHJhbmdlLCB1cmwsIHN1YmRvbWFpbnMpIHtcbiAgICBzdWJkb21haW5zID0gc3ViZG9tYWlucyB8fCAnYWJjJztcblxuICAgIHJldHVybiB1cmxcbiAgICAgICAgLnJlcGxhY2UoJ3tzfScsIHN1YmRvbWFpbnNbZm9udHN0YWNrLmxlbmd0aCAlIHN1YmRvbWFpbnMubGVuZ3RoXSlcbiAgICAgICAgLnJlcGxhY2UoJ3tmb250c3RhY2t9JywgZm9udHN0YWNrKVxuICAgICAgICAucmVwbGFjZSgne3JhbmdlfScsIHJhbmdlKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZmVhdHVyZXMsIHRleHRGZWF0dXJlcywgZ2VvbWV0cmllcykge1xuXG4gICAgdmFyIGxlZnRJbmRleCA9IHt9LFxuICAgICAgICByaWdodEluZGV4ID0ge30sXG4gICAgICAgIG1lcmdlZEZlYXR1cmVzID0gW10sXG4gICAgICAgIG1lcmdlZEdlb20gPSBbXSxcbiAgICAgICAgbWVyZ2VkVGV4dHMgPSBbXSxcbiAgICAgICAgbWVyZ2VkSW5kZXggPSAwLFxuICAgICAgICBrO1xuXG4gICAgZnVuY3Rpb24gYWRkKGspIHtcbiAgICAgICAgbWVyZ2VkRmVhdHVyZXMucHVzaChmZWF0dXJlc1trXSk7XG4gICAgICAgIG1lcmdlZEdlb20ucHVzaChnZW9tZXRyaWVzW2tdKTtcbiAgICAgICAgbWVyZ2VkVGV4dHMucHVzaCh0ZXh0RmVhdHVyZXNba10pO1xuICAgICAgICBtZXJnZWRJbmRleCsrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1lcmdlRnJvbVJpZ2h0KGxlZnRLZXksIHJpZ2h0S2V5LCBnZW9tKSB7XG4gICAgICAgIHZhciBpID0gcmlnaHRJbmRleFtsZWZ0S2V5XTtcbiAgICAgICAgZGVsZXRlIHJpZ2h0SW5kZXhbbGVmdEtleV07XG4gICAgICAgIHJpZ2h0SW5kZXhbcmlnaHRLZXldID0gaTtcblxuICAgICAgICBtZXJnZWRHZW9tW2ldWzBdLnBvcCgpO1xuICAgICAgICBtZXJnZWRHZW9tW2ldWzBdID0gbWVyZ2VkR2VvbVtpXVswXS5jb25jYXQoZ2VvbVswXSk7XG4gICAgICAgIHJldHVybiBpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1lcmdlRnJvbUxlZnQobGVmdEtleSwgcmlnaHRLZXksIGdlb20pIHtcbiAgICAgICAgdmFyIGkgPSBsZWZ0SW5kZXhbcmlnaHRLZXldO1xuICAgICAgICBkZWxldGUgbGVmdEluZGV4W3JpZ2h0S2V5XTtcbiAgICAgICAgbGVmdEluZGV4W2xlZnRLZXldID0gaTtcblxuICAgICAgICBtZXJnZWRHZW9tW2ldWzBdLnNoaWZ0KCk7XG4gICAgICAgIG1lcmdlZEdlb21baV1bMF0gPSBnZW9tWzBdLmNvbmNhdChtZXJnZWRHZW9tW2ldWzBdKTtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0S2V5KHRleHQsIGdlb20sIG9uUmlnaHQpIHtcbiAgICAgICAgdmFyIHBvaW50ID0gb25SaWdodCA/IGdlb21bMF1bZ2VvbVswXS5sZW5ndGggLSAxXSA6IGdlb21bMF1bMF07XG4gICAgICAgIHJldHVybiB0ZXh0ICsgJzonICsgcG9pbnQueCArICc6JyArIHBvaW50Lnk7XG4gICAgfVxuXG4gICAgZm9yIChrID0gMDsgayA8IGZlYXR1cmVzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIHZhciBnZW9tID0gZ2VvbWV0cmllc1trXSxcbiAgICAgICAgICAgIHRleHQgPSB0ZXh0RmVhdHVyZXNba107XG5cbiAgICAgICAgaWYgKCF0ZXh0KSB7XG4gICAgICAgICAgICBhZGQoayk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsZWZ0S2V5ID0gZ2V0S2V5KHRleHQsIGdlb20pLFxuICAgICAgICAgICAgcmlnaHRLZXkgPSBnZXRLZXkodGV4dCwgZ2VvbSwgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKChsZWZ0S2V5IGluIHJpZ2h0SW5kZXgpICYmIChyaWdodEtleSBpbiBsZWZ0SW5kZXgpICYmIChyaWdodEluZGV4W2xlZnRLZXldICE9PSBsZWZ0SW5kZXhbcmlnaHRLZXldKSkge1xuICAgICAgICAgICAgLy8gZm91bmQgbGluZXMgd2l0aCB0aGUgc2FtZSB0ZXh0IGFkamFjZW50IHRvIGJvdGggZW5kcyBvZiB0aGUgY3VycmVudCBsaW5lLCBtZXJnZSBhbGwgdGhyZWVcbiAgICAgICAgICAgIHZhciBqID0gbWVyZ2VGcm9tTGVmdChsZWZ0S2V5LCByaWdodEtleSwgZ2VvbSk7XG4gICAgICAgICAgICB2YXIgaSA9IG1lcmdlRnJvbVJpZ2h0KGxlZnRLZXksIHJpZ2h0S2V5LCBtZXJnZWRHZW9tW2pdKTtcblxuICAgICAgICAgICAgZGVsZXRlIGxlZnRJbmRleFtsZWZ0S2V5XTtcbiAgICAgICAgICAgIGRlbGV0ZSByaWdodEluZGV4W3JpZ2h0S2V5XTtcblxuICAgICAgICAgICAgcmlnaHRJbmRleFtnZXRLZXkodGV4dCwgbWVyZ2VkR2VvbVtpXSwgdHJ1ZSldID0gaTtcbiAgICAgICAgICAgIG1lcmdlZEdlb21bal0gPSBudWxsO1xuXG4gICAgICAgIH0gZWxzZSBpZiAobGVmdEtleSBpbiByaWdodEluZGV4KSB7XG4gICAgICAgICAgICAvLyBmb3VuZCBtZXJnZWFibGUgbGluZSBhZGphY2VudCB0byB0aGUgc3RhcnQgb2YgdGhlIGN1cnJlbnQgbGluZSwgbWVyZ2VcbiAgICAgICAgICAgIG1lcmdlRnJvbVJpZ2h0KGxlZnRLZXksIHJpZ2h0S2V5LCBnZW9tKTtcblxuICAgICAgICB9IGVsc2UgaWYgKHJpZ2h0S2V5IGluIGxlZnRJbmRleCkge1xuICAgICAgICAgICAgLy8gZm91bmQgbWVyZ2VhYmxlIGxpbmUgYWRqYWNlbnQgdG8gdGhlIGVuZCBvZiB0aGUgY3VycmVudCBsaW5lLCBtZXJnZVxuICAgICAgICAgICAgbWVyZ2VGcm9tTGVmdChsZWZ0S2V5LCByaWdodEtleSwgZ2VvbSk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIG5vIGFkamFjZW50IGxpbmVzLCBhZGQgYXMgYSBuZXcgaXRlbVxuICAgICAgICAgICAgYWRkKGspO1xuICAgICAgICAgICAgbGVmdEluZGV4W2xlZnRLZXldID0gbWVyZ2VkSW5kZXggLSAxO1xuICAgICAgICAgICAgcmlnaHRJbmRleFtyaWdodEtleV0gPSBtZXJnZWRJbmRleCAtIDE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBmZWF0dXJlczogbWVyZ2VkRmVhdHVyZXMsXG4gICAgICAgIHRleHRGZWF0dXJlczogbWVyZ2VkVGV4dHMsXG4gICAgICAgIGdlb21ldHJpZXM6IG1lcmdlZEdlb21cbiAgICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFBvaW50ID0gcmVxdWlyZSgncG9pbnQtZ2VvbWV0cnknKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZ2V0SWNvblF1YWRzOiBnZXRJY29uUXVhZHMsXG4gICAgZ2V0R2x5cGhRdWFkczogZ2V0R2x5cGhRdWFkc1xufTtcblxudmFyIG1pblNjYWxlID0gMC41OyAvLyB1bmRlcnNjYWxlIGJ5IDEgem9vbSBsZXZlbFxuXG4vKipcbiAqIEEgdGV4dHVyZWQgcXVhZCBmb3IgcmVuZGVyaW5nIGEgc2luZ2xlIGljb24gb3IgZ2x5cGguXG4gKlxuICogVGhlIHpvb20gcmFuZ2UgdGhlIGdseXBoIGNhbiBiZSBzaG93biBpcyBkZWZpbmVkIGJ5IG1pblNjYWxlIGFuZCBtYXhTY2FsZS5cbiAqXG4gKiBAcGFyYW0ge1BvaW50fSBhbmNob3JQb2ludCB0aGUgcG9pbnQgdGhlIHN5bWJvbCBpcyBhbmNob3JlZCBhcm91bmRcbiAqIEBwYXJhbSB7UG9pbnR9IHRsIFRoZSBvZmZzZXQgb2YgdGhlIHRvcCBsZWZ0IGNvcm5lciBmcm9tIHRoZSBhbmNob3IuXG4gKiBAcGFyYW0ge1BvaW50fSB0ciBUaGUgb2Zmc2V0IG9mIHRoZSB0b3AgcmlnaHQgY29ybmVyIGZyb20gdGhlIGFuY2hvci5cbiAqIEBwYXJhbSB7UG9pbnR9IGJsIFRoZSBvZmZzZXQgb2YgdGhlIGJvdHRvbSBsZWZ0IGNvcm5lciBmcm9tIHRoZSBhbmNob3IuXG4gKiBAcGFyYW0ge1BvaW50fSBiciBUaGUgb2Zmc2V0IG9mIHRoZSBib3R0b20gcmlnaHQgY29ybmVyIGZyb20gdGhlIGFuY2hvci5cbiAqIEBwYXJhbSB7T2JqZWN0fSB0ZXggVGhlIHRleHR1cmUgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gYW5nbGUgVGhlIGFuZ2xlIG9mIHRoZSBsYWJlbCBhdCBpdCdzIGNlbnRlciwgbm90IHRoZSBhbmdsZSBvZiB0aGlzIHF1YWQuXG4gKiBAcGFyYW0ge251bWJlcn0gbWluU2NhbGUgVGhlIG1pbmltdW0gc2NhbGUsIHJlbGF0aXZlIHRvIHRoZSB0aWxlJ3MgaW50ZW5kZWQgc2NhbGUsIHRoYXQgdGhlIGdseXBoIGNhbiBiZSBzaG93biBhdC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhTY2FsZSBUaGUgbWF4aW11bSBzY2FsZSwgcmVsYXRpdmUgdG8gdGhlIHRpbGUncyBpbnRlbmRlZCBzY2FsZSwgdGhhdCB0aGUgZ2x5cGggY2FuIGJlIHNob3duIGF0LlxuICpcbiAqIEBjbGFzcyBTeW1ib2xRdWFkXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBTeW1ib2xRdWFkKGFuY2hvclBvaW50LCB0bCwgdHIsIGJsLCBiciwgdGV4LCBhbmdsZSwgbWluU2NhbGUsIG1heFNjYWxlKSB7XG4gICAgdGhpcy5hbmNob3JQb2ludCA9IGFuY2hvclBvaW50O1xuICAgIHRoaXMudGwgPSB0bDtcbiAgICB0aGlzLnRyID0gdHI7XG4gICAgdGhpcy5ibCA9IGJsO1xuICAgIHRoaXMuYnIgPSBicjtcbiAgICB0aGlzLnRleCA9IHRleDtcbiAgICB0aGlzLmFuZ2xlID0gYW5nbGU7XG4gICAgdGhpcy5taW5TY2FsZSA9IG1pblNjYWxlO1xuICAgIHRoaXMubWF4U2NhbGUgPSBtYXhTY2FsZTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgdGhlIHF1YWRzIHVzZWQgZm9yIHJlbmRlcmluZyBhbiBpY29uLlxuICpcbiAqIEBwYXJhbSB7QW5jaG9yfSBhbmNob3JcbiAqIEBwYXJhbSB7UG9zaXRpb25lZEljb259IHNoYXBlZEljb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBib3hTY2FsZSBBIG1hZ2ljIG51bWJlciBmb3IgY29udmVydGluZyBnbHlwaCBtZXRyaWMgdW5pdHMgdG8gZ2VvbWV0cnkgdW5pdHMuXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PFBvaW50Pj59IGxpbmVcbiAqIEBwYXJhbSB7TGF5b3V0UHJvcGVydGllc30gbGF5b3V0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGFsb25nTGluZSBXaGV0aGVyIHRoZSBpY29uIHNob3VsZCBiZSBwbGFjZWQgYWxvbmcgdGhlIGxpbmUuXG4gKiBAcmV0dXJucyB7QXJyYXk8U3ltYm9sUXVhZD59XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnZXRJY29uUXVhZHMoYW5jaG9yLCBzaGFwZWRJY29uLCBib3hTY2FsZSwgbGluZSwgbGF5b3V0LCBhbG9uZ0xpbmUpIHtcblxuICAgIHZhciByZWN0ID0gc2hhcGVkSWNvbi5pbWFnZS5yZWN0O1xuXG4gICAgdmFyIGJvcmRlciA9IDE7XG4gICAgdmFyIGxlZnQgPSBzaGFwZWRJY29uLmxlZnQgLSBib3JkZXI7XG4gICAgdmFyIHJpZ2h0ID0gbGVmdCArIHJlY3QudyAvIHNoYXBlZEljb24uaW1hZ2UucGl4ZWxSYXRpbztcbiAgICB2YXIgdG9wID0gc2hhcGVkSWNvbi50b3AgLSBib3JkZXI7XG4gICAgdmFyIGJvdHRvbSA9IHRvcCArIHJlY3QuaCAvIHNoYXBlZEljb24uaW1hZ2UucGl4ZWxSYXRpbztcbiAgICB2YXIgdGwgPSBuZXcgUG9pbnQobGVmdCwgdG9wKTtcbiAgICB2YXIgdHIgPSBuZXcgUG9pbnQocmlnaHQsIHRvcCk7XG4gICAgdmFyIGJyID0gbmV3IFBvaW50KHJpZ2h0LCBib3R0b20pO1xuICAgIHZhciBibCA9IG5ldyBQb2ludChsZWZ0LCBib3R0b20pO1xuXG4gICAgdmFyIGFuZ2xlID0gbGF5b3V0WydpY29uLXJvdGF0ZSddICogTWF0aC5QSSAvIDE4MDtcbiAgICBpZiAoYWxvbmdMaW5lKSB7XG4gICAgICAgIHZhciBwcmV2ID0gbGluZVthbmNob3Iuc2VnbWVudF07XG4gICAgICAgIGlmIChhbmNob3IueSA9PT0gcHJldi55ICYmIGFuY2hvci54ID09PSBwcmV2LnggJiYgYW5jaG9yLnNlZ21lbnQgKyAxIDwgbGluZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBuZXh0ID0gbGluZVthbmNob3Iuc2VnbWVudCArIDFdO1xuICAgICAgICAgICAgYW5nbGUgKz0gTWF0aC5hdGFuMihhbmNob3IueSAtIG5leHQueSwgYW5jaG9yLnggLSBuZXh0LngpICsgTWF0aC5QSTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFuZ2xlICs9IE1hdGguYXRhbjIoYW5jaG9yLnkgLSBwcmV2LnksIGFuY2hvci54IC0gcHJldi54KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChhbmdsZSkge1xuICAgICAgICB2YXIgc2luID0gTWF0aC5zaW4oYW5nbGUpLFxuICAgICAgICAgICAgY29zID0gTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICAgICAgbWF0cml4ID0gW2NvcywgLXNpbiwgc2luLCBjb3NdO1xuXG4gICAgICAgIHRsID0gdGwubWF0TXVsdChtYXRyaXgpO1xuICAgICAgICB0ciA9IHRyLm1hdE11bHQobWF0cml4KTtcbiAgICAgICAgYmwgPSBibC5tYXRNdWx0KG1hdHJpeCk7XG4gICAgICAgIGJyID0gYnIubWF0TXVsdChtYXRyaXgpO1xuICAgIH1cblxuICAgIHJldHVybiBbbmV3IFN5bWJvbFF1YWQobmV3IFBvaW50KGFuY2hvci54LCBhbmNob3IueSksIHRsLCB0ciwgYmwsIGJyLCBzaGFwZWRJY29uLmltYWdlLnJlY3QsIDAsIG1pblNjYWxlLCBJbmZpbml0eSldO1xufVxuXG4vKipcbiAqIENyZWF0ZSB0aGUgcXVhZHMgdXNlZCBmb3IgcmVuZGVyaW5nIGEgdGV4dCBsYWJlbC5cbiAqXG4gKiBAcGFyYW0ge0FuY2hvcn0gYW5jaG9yXG4gKiBAcGFyYW0ge1NoYXBpbmd9IHNoYXBpbmdcbiAqIEBwYXJhbSB7bnVtYmVyfSBib3hTY2FsZSBBIG1hZ2ljIG51bWJlciBmb3IgY29udmVydGluZyBmcm9tIGdseXBoIG1ldHJpYyB1bml0cyB0byBnZW9tZXRyeSB1bml0cy5cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8UG9pbnQ+Pn0gbGluZVxuICogQHBhcmFtIHtMYXlvdXRQcm9wZXJ0aWVzfSBsYXlvdXRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYWxvbmdMaW5lIFdoZXRoZXIgdGhlIGxhYmVsIHNob3VsZCBiZSBwbGFjZWQgYWxvbmcgdGhlIGxpbmUuXG4gKiBAcmV0dXJucyB7QXJyYXk8U3ltYm9sUXVhZD59XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnZXRHbHlwaFF1YWRzKGFuY2hvciwgc2hhcGluZywgYm94U2NhbGUsIGxpbmUsIGxheW91dCwgYWxvbmdMaW5lKSB7XG5cbiAgICB2YXIgdGV4dFJvdGF0ZSA9IGxheW91dFsndGV4dC1yb3RhdGUnXSAqIE1hdGguUEkgLyAxODA7XG4gICAgdmFyIGtlZXBVcHJpZ2h0ID0gbGF5b3V0Wyd0ZXh0LWtlZXAtdXByaWdodCddO1xuXG4gICAgdmFyIHBvc2l0aW9uZWRHbHlwaHMgPSBzaGFwaW5nLnBvc2l0aW9uZWRHbHlwaHM7XG4gICAgdmFyIHF1YWRzID0gW107XG5cbiAgICBmb3IgKHZhciBrID0gMDsgayA8IHBvc2l0aW9uZWRHbHlwaHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdmFyIHBvc2l0aW9uZWRHbHlwaCA9IHBvc2l0aW9uZWRHbHlwaHNba107XG4gICAgICAgIHZhciBnbHlwaCA9IHBvc2l0aW9uZWRHbHlwaC5nbHlwaDtcbiAgICAgICAgdmFyIHJlY3QgPSBnbHlwaC5yZWN0O1xuXG4gICAgICAgIGlmICghcmVjdCkgY29udGludWU7XG5cbiAgICAgICAgdmFyIGNlbnRlclggPSAocG9zaXRpb25lZEdseXBoLnggKyBnbHlwaC5hZHZhbmNlIC8gMikgKiBib3hTY2FsZTtcblxuICAgICAgICB2YXIgZ2x5cGhJbnN0YW5jZXM7XG4gICAgICAgIHZhciBsYWJlbE1pblNjYWxlID0gbWluU2NhbGU7XG4gICAgICAgIGlmIChhbG9uZ0xpbmUpIHtcbiAgICAgICAgICAgIGdseXBoSW5zdGFuY2VzID0gW107XG4gICAgICAgICAgICBsYWJlbE1pblNjYWxlID0gZ2V0U2VnbWVudEdseXBocyhnbHlwaEluc3RhbmNlcywgYW5jaG9yLCBjZW50ZXJYLCBsaW5lLCBhbmNob3Iuc2VnbWVudCwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoa2VlcFVwcmlnaHQpIHtcbiAgICAgICAgICAgICAgICBsYWJlbE1pblNjYWxlID0gTWF0aC5taW4obGFiZWxNaW5TY2FsZSwgZ2V0U2VnbWVudEdseXBocyhnbHlwaEluc3RhbmNlcywgYW5jaG9yLCBjZW50ZXJYLCBsaW5lLCBhbmNob3Iuc2VnbWVudCwgZmFsc2UpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2x5cGhJbnN0YW5jZXMgPSBbe1xuICAgICAgICAgICAgICAgIGFuY2hvclBvaW50OiBuZXcgUG9pbnQoYW5jaG9yLngsIGFuY2hvci55KSxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IDAsXG4gICAgICAgICAgICAgICAgYW5nbGU6IDAsXG4gICAgICAgICAgICAgICAgbWF4U2NhbGU6IEluZmluaXR5LFxuICAgICAgICAgICAgICAgIG1pblNjYWxlOiBtaW5TY2FsZVxuICAgICAgICAgICAgfV07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgeDEgPSBwb3NpdGlvbmVkR2x5cGgueCArIGdseXBoLmxlZnQsXG4gICAgICAgICAgICB5MSA9IHBvc2l0aW9uZWRHbHlwaC55IC0gZ2x5cGgudG9wLFxuICAgICAgICAgICAgeDIgPSB4MSArIHJlY3QudyxcbiAgICAgICAgICAgIHkyID0geTEgKyByZWN0LmgsXG5cbiAgICAgICAgICAgIG90bCA9IG5ldyBQb2ludCh4MSwgeTEpLFxuICAgICAgICAgICAgb3RyID0gbmV3IFBvaW50KHgyLCB5MSksXG4gICAgICAgICAgICBvYmwgPSBuZXcgUG9pbnQoeDEsIHkyKSxcbiAgICAgICAgICAgIG9iciA9IG5ldyBQb2ludCh4MiwgeTIpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2x5cGhJbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcblxuICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gZ2x5cGhJbnN0YW5jZXNbaV0sXG4gICAgICAgICAgICAgICAgdGwgPSBvdGwsXG4gICAgICAgICAgICAgICAgdHIgPSBvdHIsXG4gICAgICAgICAgICAgICAgYmwgPSBvYmwsXG4gICAgICAgICAgICAgICAgYnIgPSBvYnIsXG4gICAgICAgICAgICAgICAgYW5nbGUgPSBpbnN0YW5jZS5hbmdsZSArIHRleHRSb3RhdGU7XG5cbiAgICAgICAgICAgIGlmIChhbmdsZSkge1xuICAgICAgICAgICAgICAgIHZhciBzaW4gPSBNYXRoLnNpbihhbmdsZSksXG4gICAgICAgICAgICAgICAgICAgIGNvcyA9IE1hdGguY29zKGFuZ2xlKSxcbiAgICAgICAgICAgICAgICAgICAgbWF0cml4ID0gW2NvcywgLXNpbiwgc2luLCBjb3NdO1xuXG4gICAgICAgICAgICAgICAgdGwgPSB0bC5tYXRNdWx0KG1hdHJpeCk7XG4gICAgICAgICAgICAgICAgdHIgPSB0ci5tYXRNdWx0KG1hdHJpeCk7XG4gICAgICAgICAgICAgICAgYmwgPSBibC5tYXRNdWx0KG1hdHJpeCk7XG4gICAgICAgICAgICAgICAgYnIgPSBici5tYXRNdWx0KG1hdHJpeCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFByZXZlbnQgbGFiZWwgZnJvbSBleHRlbmRpbmcgcGFzdCB0aGUgZW5kIG9mIHRoZSBsaW5lXG4gICAgICAgICAgICB2YXIgZ2x5cGhNaW5TY2FsZSA9IE1hdGgubWF4KGluc3RhbmNlLm1pblNjYWxlLCBsYWJlbE1pblNjYWxlKTtcblxuICAgICAgICAgICAgdmFyIGdseXBoQW5nbGUgPSAoYW5jaG9yLmFuZ2xlICsgdGV4dFJvdGF0ZSArIGluc3RhbmNlLm9mZnNldCArIDIgKiBNYXRoLlBJKSAlICgyICogTWF0aC5QSSk7XG4gICAgICAgICAgICBxdWFkcy5wdXNoKG5ldyBTeW1ib2xRdWFkKGluc3RhbmNlLmFuY2hvclBvaW50LCB0bCwgdHIsIGJsLCBiciwgcmVjdCwgZ2x5cGhBbmdsZSwgZ2x5cGhNaW5TY2FsZSwgaW5zdGFuY2UubWF4U2NhbGUpKTtcblxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHF1YWRzO1xufVxuXG4vKipcbiAqIFdlIGNhbiBvbmx5IHJlbmRlciBnbHlwaCBxdWFkcyB0aGF0IHNsaWRlIGFsb25nIGEgc3RyYWlnaHQgbGluZS4gVG8gZHJhd1xuICogY3VydmVkIGxpbmVzIHdlIG5lZWQgYW4gaW5zdGFuY2Ugb2YgYSBnbHlwaCBmb3IgZWFjaCBzZWdtZW50IGl0IGFwcGVhcnMgb24uXG4gKiBUaGlzIGNyZWF0ZXMgYWxsIHRoZSBpbnN0YW5jZXMgb2YgYSBnbHlwaCB0aGF0IGFyZSBuZWNlc3NhcnkgdG8gcmVuZGVyIGEgbGFiZWwuXG4gKlxuICogV2UgbmVlZCBhXG4gKiBAcGFyYW0ge0FycmF5PE9iamVjdD59IGdseXBoSW5zdGFuY2VzIEFuIGVtcHR5IGFycmF5IHRoYXQgZ2x5cGhJbnN0YW5jZXMgYXJlIGFkZGVkIHRvLlxuICogQHBhcmFtIHtBbmNob3J9IGFuY2hvclxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBUaGUgZ2x5cGgncyBvZmZzZXQgZnJvbSB0aGUgY2VudGVyIG9mIHRoZSBsYWJlbC5cbiAqIEBwYXJhbSB7QXJyYXk8UG9pbnQ+fSBsaW5lXG4gKiBAcGFyYW0ge251bWJlcn0gc2VnbWVudCBUaGUgaW5kZXggb2YgdGhlIHNlZ21lbnQgb2YgdGhlIGxpbmUgb24gd2hpY2ggdGhlIGFuY2hvciBleGlzdHMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGZvcndhcmQgSWYgdHJ1ZSBnZXQgdGhlIGdseXBocyB0aGF0IGNvbWUgbGF0ZXIgb24gdGhlIGxpbmUsIG90aGVyd2lzZSBnZXQgdGhlIGdseXBocyB0aGF0IGNvbWUgZWFybGllci5cbiAqXG4gKiBAcmV0dXJucyB7QXJyYXk8T2JqZWN0Pn0gZ2x5cGhJbnN0YW5jZXNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGdldFNlZ21lbnRHbHlwaHMoZ2x5cGhzLCBhbmNob3IsIG9mZnNldCwgbGluZSwgc2VnbWVudCwgZm9yd2FyZCkge1xuICAgIHZhciB1cHNpZGVEb3duID0gIWZvcndhcmQ7XG5cbiAgICBpZiAob2Zmc2V0IDwgMCkgZm9yd2FyZCA9ICFmb3J3YXJkO1xuXG4gICAgaWYgKGZvcndhcmQpIHNlZ21lbnQrKztcblxuICAgIHZhciBuZXdBbmNob3JQb2ludCA9IG5ldyBQb2ludChhbmNob3IueCwgYW5jaG9yLnkpO1xuICAgIHZhciBlbmQgPSBsaW5lW3NlZ21lbnRdO1xuICAgIHZhciBwcmV2U2NhbGUgPSBJbmZpbml0eTtcblxuICAgIG9mZnNldCA9IE1hdGguYWJzKG9mZnNldCk7XG5cbiAgICB2YXIgcGxhY2VtZW50U2NhbGUgPSBtaW5TY2FsZTtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBkaXN0YW5jZSA9IG5ld0FuY2hvclBvaW50LmRpc3QoZW5kKTtcbiAgICAgICAgdmFyIHNjYWxlID0gb2Zmc2V0IC8gZGlzdGFuY2U7XG5cbiAgICAgICAgLy8gR2V0IHRoZSBhbmdsZSBvZiB0aGUgbGluZSBzZWdtZW50XG4gICAgICAgIHZhciBhbmdsZSA9IE1hdGguYXRhbjIoZW5kLnkgLSBuZXdBbmNob3JQb2ludC55LCBlbmQueCAtIG5ld0FuY2hvclBvaW50LngpO1xuICAgICAgICBpZiAoIWZvcndhcmQpIGFuZ2xlICs9IE1hdGguUEk7XG4gICAgICAgIGlmICh1cHNpZGVEb3duKSBhbmdsZSArPSBNYXRoLlBJO1xuXG4gICAgICAgIGdseXBocy5wdXNoKHtcbiAgICAgICAgICAgIGFuY2hvclBvaW50OiBuZXdBbmNob3JQb2ludCxcbiAgICAgICAgICAgIG9mZnNldDogdXBzaWRlRG93biA/IE1hdGguUEkgOiAwLFxuICAgICAgICAgICAgbWluU2NhbGU6IHNjYWxlLFxuICAgICAgICAgICAgbWF4U2NhbGU6IHByZXZTY2FsZSxcbiAgICAgICAgICAgIGFuZ2xlOiAoYW5nbGUgKyAyICogTWF0aC5QSSkgJSAoMiAqIE1hdGguUEkpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChzY2FsZSA8PSBwbGFjZW1lbnRTY2FsZSkgYnJlYWs7XG5cbiAgICAgICAgbmV3QW5jaG9yUG9pbnQgPSBlbmQ7XG5cbiAgICAgICAgLy8gc2tpcCBkdXBsaWNhdGUgbm9kZXNcbiAgICAgICAgd2hpbGUgKG5ld0FuY2hvclBvaW50LmVxdWFscyhlbmQpKSB7XG4gICAgICAgICAgICBzZWdtZW50ICs9IGZvcndhcmQgPyAxIDogLTE7XG4gICAgICAgICAgICBlbmQgPSBsaW5lW3NlZ21lbnRdO1xuICAgICAgICAgICAgaWYgKCFlbmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2NhbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdW5pdCA9IGVuZC5zdWIobmV3QW5jaG9yUG9pbnQpLl91bml0KCk7XG4gICAgICAgIG5ld0FuY2hvclBvaW50ID0gbmV3QW5jaG9yUG9pbnQuc3ViKHVuaXQuX211bHQoZGlzdGFuY2UpKTtcblxuICAgICAgICBwcmV2U2NhbGUgPSBzY2FsZTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGxhY2VtZW50U2NhbGU7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciByZXNvbHZlVG9rZW5zID0gcmVxdWlyZSgnLi4vdXRpbC90b2tlbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlc29sdmVUZXh0O1xuXG4vKipcbiAqIEZvciBhbiBhcnJheSBvZiBmZWF0dXJlcyBkZXRlcm1pbmUgd2hhdCBnbHlwaHMgbmVlZCB0byBiZSBsb2FkZWRcbiAqIGFuZCBhcHBseSBhbnkgdGV4dCBwcmVwcm9jZXNzaW5nLiBUaGUgcmVtYWluaW5nIHVzZXJzIG9mIHRleHQgc2hvdWxkXG4gKiB1c2UgdGhlIGB0ZXh0RmVhdHVyZXNgIGtleSByZXR1cm5lZCBieSB0aGlzIGZ1bmN0aW9uIHJhdGhlciB0aGFuIGFjY2Vzc2luZ1xuICogZmVhdHVyZSB0ZXh0IGRpcmVjdGx5LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZVRleHQoZmVhdHVyZXMsIGxheW91dFByb3BlcnRpZXMsIGNvZGVwb2ludHMpIHtcbiAgICB2YXIgdGV4dEZlYXR1cmVzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMCwgZmwgPSBmZWF0dXJlcy5sZW5ndGg7IGkgPCBmbDsgaSsrKSB7XG4gICAgICAgIHZhciB0ZXh0ID0gcmVzb2x2ZVRva2VucyhmZWF0dXJlc1tpXS5wcm9wZXJ0aWVzLCBsYXlvdXRQcm9wZXJ0aWVzWyd0ZXh0LWZpZWxkJ10pO1xuICAgICAgICBpZiAoIXRleHQpIHtcbiAgICAgICAgICAgIHRleHRGZWF0dXJlc1tpXSA9IG51bGw7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0ZXh0ID0gdGV4dC50b1N0cmluZygpO1xuXG4gICAgICAgIHZhciB0cmFuc2Zvcm0gPSBsYXlvdXRQcm9wZXJ0aWVzWyd0ZXh0LXRyYW5zZm9ybSddO1xuICAgICAgICBpZiAodHJhbnNmb3JtID09PSAndXBwZXJjYXNlJykge1xuICAgICAgICAgICAgdGV4dCA9IHRleHQudG9Mb2NhbGVVcHBlckNhc2UoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0cmFuc2Zvcm0gPT09ICdsb3dlcmNhc2UnKSB7XG4gICAgICAgICAgICB0ZXh0ID0gdGV4dC50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0ZXh0Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBjb2RlcG9pbnRzW3RleHQuY2hhckNvZGVBdChqKV0gPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVHJhY2sgaW5kZXhlcyBvZiBmZWF0dXJlcyB3aXRoIHRleHQuXG4gICAgICAgIHRleHRGZWF0dXJlc1tpXSA9IHRleHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRleHRGZWF0dXJlcztcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgc2hhcGVUZXh0OiBzaGFwZVRleHQsXG4gICAgc2hhcGVJY29uOiBzaGFwZUljb25cbn07XG5cblxuLy8gVGhlIHBvc2l0aW9uIG9mIGEgZ2x5cGggcmVsYXRpdmUgdG8gdGhlIHRleHQncyBhbmNob3IgcG9pbnQuXG5mdW5jdGlvbiBQb3NpdGlvbmVkR2x5cGgoY29kZVBvaW50LCB4LCB5LCBnbHlwaCkge1xuICAgIHRoaXMuY29kZVBvaW50ID0gY29kZVBvaW50O1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICB0aGlzLmdseXBoID0gZ2x5cGg7XG59XG5cbi8vIEEgY29sbGVjdGlvbiBvZiBwb3NpdGlvbmVkIGdseXBocyBhbmQgc29tZSBtZXRhZGF0YVxuZnVuY3Rpb24gU2hhcGluZyhwb3NpdGlvbmVkR2x5cGhzLCB0ZXh0LCB0b3AsIGJvdHRvbSwgbGVmdCwgcmlnaHQpIHtcbiAgICB0aGlzLnBvc2l0aW9uZWRHbHlwaHMgPSBwb3NpdGlvbmVkR2x5cGhzO1xuICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgdGhpcy50b3AgPSB0b3A7XG4gICAgdGhpcy5ib3R0b20gPSBib3R0b207XG4gICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG59XG5cbmZ1bmN0aW9uIHNoYXBlVGV4dCh0ZXh0LCBnbHlwaHMsIG1heFdpZHRoLCBsaW5lSGVpZ2h0LCBob3Jpem9udGFsQWxpZ24sIHZlcnRpY2FsQWxpZ24sIGp1c3RpZnksIHNwYWNpbmcsIHRyYW5zbGF0ZSkge1xuXG4gICAgdmFyIHBvc2l0aW9uZWRHbHlwaHMgPSBbXTtcbiAgICB2YXIgc2hhcGluZyA9IG5ldyBTaGFwaW5nKHBvc2l0aW9uZWRHbHlwaHMsIHRleHQsIHRyYW5zbGF0ZVsxXSwgdHJhbnNsYXRlWzFdLCB0cmFuc2xhdGVbMF0sIHRyYW5zbGF0ZVswXSk7XG5cbiAgICAvLyB0aGUgeSBvZmZzZXQgKnNob3VsZCogYmUgcGFydCBvZiB0aGUgZm9udCBtZXRhZGF0YVxuICAgIHZhciB5T2Zmc2V0ID0gLTE3O1xuXG4gICAgdmFyIHggPSAwO1xuICAgIHZhciB5ID0geU9mZnNldDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY29kZVBvaW50ID0gdGV4dC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB2YXIgZ2x5cGggPSBnbHlwaHNbY29kZVBvaW50XTtcblxuICAgICAgICBpZiAoIWdseXBoKSBjb250aW51ZTtcblxuICAgICAgICBwb3NpdGlvbmVkR2x5cGhzLnB1c2gobmV3IFBvc2l0aW9uZWRHbHlwaChjb2RlUG9pbnQsIHgsIHksIGdseXBoKSk7XG4gICAgICAgIHggKz0gZ2x5cGguYWR2YW5jZSArIHNwYWNpbmc7XG4gICAgfVxuXG4gICAgaWYgKCFwb3NpdGlvbmVkR2x5cGhzLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgbGluZXdyYXAoc2hhcGluZywgZ2x5cGhzLCBsaW5lSGVpZ2h0LCBtYXhXaWR0aCwgaG9yaXpvbnRhbEFsaWduLCB2ZXJ0aWNhbEFsaWduLCBqdXN0aWZ5LCB0cmFuc2xhdGUpO1xuXG4gICAgcmV0dXJuIHNoYXBpbmc7XG59XG5cbnZhciBpbnZpc2libGUgPSB7XG4gICAgMHgyMDogICB0cnVlLCAvLyBzcGFjZVxuICAgIDB4MjAwYjogdHJ1ZSAgLy8gemVyby13aWR0aCBzcGFjZVxufTtcblxudmFyIGJyZWFrYWJsZSA9IHtcbiAgICAweDIwOiAgIHRydWUsIC8vIHNwYWNlXG4gICAgMHgyNjogICB0cnVlLCAvLyBhbXBlcnNhbmRcbiAgICAweDJiOiAgIHRydWUsIC8vIHBsdXMgc2lnblxuICAgIDB4MmQ6ICAgdHJ1ZSwgLy8gaHlwaGVuLW1pbnVzXG4gICAgMHgyZjogICB0cnVlLCAvLyBzb2xpZHVzXG4gICAgMHhhZDogICB0cnVlLCAvLyBzb2Z0IGh5cGhlblxuICAgIDB4Yjc6ICAgdHJ1ZSwgLy8gbWlkZGxlIGRvdFxuICAgIDB4MjAwYjogdHJ1ZSwgLy8gemVyby13aWR0aCBzcGFjZVxuICAgIDB4MjAxMDogdHJ1ZSwgLy8gaHlwaGVuXG4gICAgMHgyMDEzOiB0cnVlICAvLyBlbiBkYXNoXG59O1xuXG5mdW5jdGlvbiBsaW5ld3JhcChzaGFwaW5nLCBnbHlwaHMsIGxpbmVIZWlnaHQsIG1heFdpZHRoLCBob3Jpem9udGFsQWxpZ24sIHZlcnRpY2FsQWxpZ24sIGp1c3RpZnksIHRyYW5zbGF0ZSkge1xuICAgIHZhciBsYXN0U2FmZUJyZWFrID0gbnVsbDtcblxuICAgIHZhciBsZW5ndGhCZWZvcmVDdXJyZW50TGluZSA9IDA7XG4gICAgdmFyIGxpbmVTdGFydEluZGV4ID0gMDtcbiAgICB2YXIgbGluZSA9IDA7XG5cbiAgICB2YXIgbWF4TGluZUxlbmd0aCA9IDA7XG5cbiAgICB2YXIgcG9zaXRpb25lZEdseXBocyA9IHNoYXBpbmcucG9zaXRpb25lZEdseXBocztcblxuICAgIGlmIChtYXhXaWR0aCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvc2l0aW9uZWRHbHlwaHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbmVkR2x5cGggPSBwb3NpdGlvbmVkR2x5cGhzW2ldO1xuXG4gICAgICAgICAgICBwb3NpdGlvbmVkR2x5cGgueCAtPSBsZW5ndGhCZWZvcmVDdXJyZW50TGluZTtcbiAgICAgICAgICAgIHBvc2l0aW9uZWRHbHlwaC55ICs9IGxpbmVIZWlnaHQgKiBsaW5lO1xuXG4gICAgICAgICAgICBpZiAocG9zaXRpb25lZEdseXBoLnggPiBtYXhXaWR0aCAmJiBsYXN0U2FmZUJyZWFrICE9PSBudWxsKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgbGluZUxlbmd0aCA9IHBvc2l0aW9uZWRHbHlwaHNbbGFzdFNhZmVCcmVhayArIDFdLng7XG4gICAgICAgICAgICAgICAgbWF4TGluZUxlbmd0aCA9IE1hdGgubWF4KGxpbmVMZW5ndGgsIG1heExpbmVMZW5ndGgpO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IGxhc3RTYWZlQnJlYWsgKyAxOyBrIDw9IGk7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbmVkR2x5cGhzW2tdLnkgKz0gbGluZUhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25lZEdseXBoc1trXS54IC09IGxpbmVMZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGp1c3RpZnkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29sbGFwc2UgaW52aXNpYmxlIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICAgICAgICAgIHZhciBsaW5lRW5kID0gbGFzdFNhZmVCcmVhaztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGludmlzaWJsZVtwb3NpdGlvbmVkR2x5cGhzW2xhc3RTYWZlQnJlYWtdLmNvZGVQb2ludF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVFbmQtLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGp1c3RpZnlMaW5lKHBvc2l0aW9uZWRHbHlwaHMsIGdseXBocywgbGluZVN0YXJ0SW5kZXgsIGxpbmVFbmQsIGp1c3RpZnkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxpbmVTdGFydEluZGV4ID0gbGFzdFNhZmVCcmVhayArIDE7XG4gICAgICAgICAgICAgICAgbGFzdFNhZmVCcmVhayA9IG51bGw7XG4gICAgICAgICAgICAgICAgbGVuZ3RoQmVmb3JlQ3VycmVudExpbmUgKz0gbGluZUxlbmd0aDtcbiAgICAgICAgICAgICAgICBsaW5lKys7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChicmVha2FibGVbcG9zaXRpb25lZEdseXBoLmNvZGVQb2ludF0pIHtcbiAgICAgICAgICAgICAgICBsYXN0U2FmZUJyZWFrID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBsYXN0UG9zaXRpb25lZEdseXBoID0gcG9zaXRpb25lZEdseXBoc1twb3NpdGlvbmVkR2x5cGhzLmxlbmd0aCAtIDFdO1xuICAgIHZhciBsYXN0TGluZUxlbmd0aCA9IGxhc3RQb3NpdGlvbmVkR2x5cGgueCArIGdseXBoc1tsYXN0UG9zaXRpb25lZEdseXBoLmNvZGVQb2ludF0uYWR2YW5jZTtcbiAgICBtYXhMaW5lTGVuZ3RoID0gTWF0aC5tYXgobWF4TGluZUxlbmd0aCwgbGFzdExpbmVMZW5ndGgpO1xuXG4gICAgdmFyIGhlaWdodCA9IChsaW5lICsgMSkgKiBsaW5lSGVpZ2h0O1xuXG4gICAganVzdGlmeUxpbmUocG9zaXRpb25lZEdseXBocywgZ2x5cGhzLCBsaW5lU3RhcnRJbmRleCwgcG9zaXRpb25lZEdseXBocy5sZW5ndGggLSAxLCBqdXN0aWZ5KTtcbiAgICBhbGlnbihwb3NpdGlvbmVkR2x5cGhzLCBqdXN0aWZ5LCBob3Jpem9udGFsQWxpZ24sIHZlcnRpY2FsQWxpZ24sIG1heExpbmVMZW5ndGgsIGxpbmVIZWlnaHQsIGxpbmUsIHRyYW5zbGF0ZSk7XG5cbiAgICAvLyBDYWxjdWxhdGUgdGhlIGJvdW5kaW5nIGJveFxuICAgIHNoYXBpbmcudG9wICs9IC12ZXJ0aWNhbEFsaWduICogaGVpZ2h0O1xuICAgIHNoYXBpbmcuYm90dG9tID0gc2hhcGluZy50b3AgKyBoZWlnaHQ7XG4gICAgc2hhcGluZy5sZWZ0ICs9IC1ob3Jpem9udGFsQWxpZ24gKiBtYXhMaW5lTGVuZ3RoO1xuICAgIHNoYXBpbmcucmlnaHQgPSBzaGFwaW5nLmxlZnQgKyBtYXhMaW5lTGVuZ3RoO1xufVxuXG5mdW5jdGlvbiBqdXN0aWZ5TGluZShwb3NpdGlvbmVkR2x5cGhzLCBnbHlwaHMsIHN0YXJ0LCBlbmQsIGp1c3RpZnkpIHtcbiAgICB2YXIgbGFzdEFkdmFuY2UgPSBnbHlwaHNbcG9zaXRpb25lZEdseXBoc1tlbmRdLmNvZGVQb2ludF0uYWR2YW5jZTtcbiAgICB2YXIgbGluZUluZGVudCA9IChwb3NpdGlvbmVkR2x5cGhzW2VuZF0ueCArIGxhc3RBZHZhbmNlKSAqIGp1c3RpZnk7XG5cbiAgICBmb3IgKHZhciBqID0gc3RhcnQ7IGogPD0gZW5kOyBqKyspIHtcbiAgICAgICAgcG9zaXRpb25lZEdseXBoc1tqXS54IC09IGxpbmVJbmRlbnQ7XG4gICAgfVxuXG59XG5cbmZ1bmN0aW9uIGFsaWduKHBvc2l0aW9uZWRHbHlwaHMsIGp1c3RpZnksIGhvcml6b250YWxBbGlnbiwgdmVydGljYWxBbGlnbiwgbWF4TGluZUxlbmd0aCwgbGluZUhlaWdodCwgbGluZSwgdHJhbnNsYXRlKSB7XG4gICAgdmFyIHNoaWZ0WCA9IChqdXN0aWZ5IC0gaG9yaXpvbnRhbEFsaWduKSAqIG1heExpbmVMZW5ndGggKyB0cmFuc2xhdGVbMF07XG4gICAgdmFyIHNoaWZ0WSA9ICgtdmVydGljYWxBbGlnbiAqIChsaW5lICsgMSkgKyAwLjUpICogbGluZUhlaWdodCArIHRyYW5zbGF0ZVsxXTtcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgcG9zaXRpb25lZEdseXBocy5sZW5ndGg7IGorKykge1xuICAgICAgICBwb3NpdGlvbmVkR2x5cGhzW2pdLnggKz0gc2hpZnRYO1xuICAgICAgICBwb3NpdGlvbmVkR2x5cGhzW2pdLnkgKz0gc2hpZnRZO1xuICAgIH1cbn1cblxuXG5mdW5jdGlvbiBzaGFwZUljb24oaW1hZ2UsIGxheW91dCkge1xuICAgIGlmICghaW1hZ2UgfHwgIWltYWdlLnJlY3QpIHJldHVybiBudWxsO1xuXG4gICAgdmFyIGR4ID0gbGF5b3V0WydpY29uLW9mZnNldCddWzBdO1xuICAgIHZhciBkeSA9IGxheW91dFsnaWNvbi1vZmZzZXQnXVsxXTtcbiAgICB2YXIgeDEgPSBkeCAtIGltYWdlLndpZHRoIC8gMjtcbiAgICB2YXIgeDIgPSB4MSArIGltYWdlLndpZHRoO1xuICAgIHZhciB5MSA9IGR5IC0gaW1hZ2UuaGVpZ2h0IC8gMjtcbiAgICB2YXIgeTIgPSB5MSArIGltYWdlLmhlaWdodDtcblxuICAgIHJldHVybiBuZXcgUG9zaXRpb25lZEljb24oaW1hZ2UsIHkxLCB5MiwgeDEsIHgyKTtcbn1cblxuZnVuY3Rpb24gUG9zaXRpb25lZEljb24oaW1hZ2UsIHRvcCwgYm90dG9tLCBsZWZ0LCByaWdodCkge1xuICAgIHRoaXMuaW1hZ2UgPSBpbWFnZTtcbiAgICB0aGlzLnRvcCA9IHRvcDtcbiAgICB0aGlzLmJvdHRvbSA9IGJvdHRvbTtcbiAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgIHRoaXMucmlnaHQgPSByaWdodDtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEJpblBhY2sgPSByZXF1aXJlKCcuL2Jpbl9wYWNrJyk7XG52YXIgYnJvd3NlciA9IHJlcXVpcmUoJy4uL3V0aWwvYnJvd3NlcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNwcml0ZUF0bGFzO1xuZnVuY3Rpb24gU3ByaXRlQXRsYXMod2lkdGgsIGhlaWdodCkge1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcblxuICAgIHRoaXMuYmluID0gbmV3IEJpblBhY2sod2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy5pbWFnZXMgPSB7fTtcbiAgICB0aGlzLmRhdGEgPSBmYWxzZTtcbiAgICB0aGlzLnRleHR1cmUgPSAwOyAvLyBXZWJHTCBJRFxuICAgIHRoaXMuZmlsdGVyID0gMDsgLy8gV2ViR0wgSURcbiAgICB0aGlzLnBpeGVsUmF0aW8gPSAxO1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xufVxuXG5TcHJpdGVBdGxhcy5wcm90b3R5cGUgPSB7XG4gICAgZ2V0IGRlYnVnKCkge1xuICAgICAgICByZXR1cm4gJ2NhbnZhcycgaW4gdGhpcztcbiAgICB9LFxuICAgIHNldCBkZWJ1Zyh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgJiYgIXRoaXMuY2FudmFzKSB7XG4gICAgICAgICAgICB0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgdGhpcy5jYW52YXMud2lkdGggPSB0aGlzLndpZHRoICogdGhpcy5waXhlbFJhdGlvO1xuICAgICAgICAgICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gdGhpcy5oZWlnaHQgKiB0aGlzLnBpeGVsUmF0aW87XG4gICAgICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS53aWR0aCA9IHRoaXMud2lkdGggKyAncHgnO1xuICAgICAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUud2lkdGggPSB0aGlzLndpZHRoICsgJ3B4JztcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5jYW52YXMpO1xuICAgICAgICAgICAgdGhpcy5jdHggPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICB9IGVsc2UgaWYgKCF2YWx1ZSAmJiB0aGlzLmNhbnZhcykge1xuICAgICAgICAgICAgdGhpcy5jYW52YXMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmNhbnZhcyk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5jdHg7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5jYW52YXM7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5mdW5jdGlvbiBjb3B5Qml0bWFwKHNyYywgc3JjU3RyaWRlLCBzcmNYLCBzcmNZLCBkc3QsIGRzdFN0cmlkZSwgZHN0WCwgZHN0WSwgd2lkdGgsIGhlaWdodCwgd3JhcCkge1xuICAgIHZhciBzcmNJID0gc3JjWSAqIHNyY1N0cmlkZSArIHNyY1g7XG4gICAgdmFyIGRzdEkgPSBkc3RZICogZHN0U3RyaWRlICsgZHN0WDtcbiAgICB2YXIgeCwgeTtcblxuICAgIGlmICh3cmFwKSB7XG4gICAgICAgIC8vIGFkZCAxIHBpeGVsIHdyYXBwZWQgcGFkZGluZyBvbiBlYWNoIHNpZGUgb2YgdGhlIGltYWdlXG4gICAgICAgIGRzdEkgLT0gZHN0U3RyaWRlO1xuICAgICAgICBmb3IgKHkgPSAtMTsgeSA8PSBoZWlnaHQ7IHkrKywgc3JjSSA9ICgoeSArIGhlaWdodCkgJSBoZWlnaHQgKyBzcmNZKSAqIHNyY1N0cmlkZSArIHNyY1gsIGRzdEkgKz0gZHN0U3RyaWRlKSB7XG4gICAgICAgICAgICBmb3IgKHggPSAtMTsgeCA8PSB3aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgZHN0W2RzdEkgKyB4XSA9IHNyY1tzcmNJICsgKCh4ICsgd2lkdGgpICUgd2lkdGgpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh5ID0gMDsgeSA8IGhlaWdodDsgeSsrLCBzcmNJICs9IHNyY1N0cmlkZSwgZHN0SSArPSBkc3RTdHJpZGUpIHtcbiAgICAgICAgICAgIGZvciAoeCA9IDA7IHggPCB3aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgZHN0W2RzdEkgKyB4XSA9IHNyY1tzcmNJICsgeF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cblNwcml0ZUF0bGFzLnByb3RvdHlwZS5hbGxvY2F0ZUltYWdlID0gZnVuY3Rpb24ocGl4ZWxXaWR0aCwgcGl4ZWxIZWlnaHQpIHtcblxuICAgIHBpeGVsV2lkdGggPSBwaXhlbFdpZHRoIC8gdGhpcy5waXhlbFJhdGlvO1xuICAgIHBpeGVsSGVpZ2h0ID0gcGl4ZWxIZWlnaHQgLyB0aGlzLnBpeGVsUmF0aW87XG5cbiAgICAvLyBJbmNyZWFzZSB0byBuZXh0IG51bWJlciBkaXZpc2libGUgYnkgNCwgYnV0IGF0IGxlYXN0IDEuXG4gICAgLy8gVGhpcyBpcyBzbyB3ZSBjYW4gc2NhbGUgZG93biB0aGUgdGV4dHVyZSBjb29yZGluYXRlcyBhbmQgcGFjayB0aGVtXG4gICAgLy8gaW50byAyIGJ5dGVzIHJhdGhlciB0aGFuIDQgYnl0ZXMuXG4gICAgLy8gUGFkIGljb25zIHRvIHByZXZlbnQgdGhlbSBmcm9tIHBvbGx1dGluZyBuZWlnaGJvdXJzIGR1cmluZyBsaW5lYXIgaW50ZXJwb2xhdGlvblxuICAgIHZhciBwYWRkaW5nID0gMjtcbiAgICB2YXIgcGFja1dpZHRoID0gcGl4ZWxXaWR0aCArIHBhZGRpbmcgKyAoNCAtIChwaXhlbFdpZHRoICsgcGFkZGluZykgJSA0KTtcbiAgICB2YXIgcGFja0hlaWdodCA9IHBpeGVsSGVpZ2h0ICsgcGFkZGluZyArICg0IC0gKHBpeGVsSGVpZ2h0ICsgcGFkZGluZykgJSA0KTsvLyArIDQ7XG5cbiAgICAvLyBXZSBoYXZlIHRvIGFsbG9jYXRlIGEgbmV3IGFyZWEgaW4gdGhlIGJpbiwgYW5kIHN0b3JlIGFuIGVtcHR5IGltYWdlIGluIGl0LlxuICAgIC8vIEFkZCBhIDFweCBib3JkZXIgYXJvdW5kIGV2ZXJ5IGltYWdlLlxuICAgIHZhciByZWN0ID0gdGhpcy5iaW4uYWxsb2NhdGUocGFja1dpZHRoLCBwYWNrSGVpZ2h0KTtcbiAgICBpZiAocmVjdC54IDwgMCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1Nwcml0ZUF0bGFzIG91dCBvZiBzcGFjZS4nKTtcbiAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlY3Q7XG59O1xuXG5TcHJpdGVBdGxhcy5wcm90b3R5cGUuZ2V0SW1hZ2UgPSBmdW5jdGlvbihuYW1lLCB3cmFwKSB7XG4gICAgaWYgKHRoaXMuaW1hZ2VzW25hbWVdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmltYWdlc1tuYW1lXTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuc3ByaXRlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBwb3MgPSB0aGlzLnNwcml0ZS5nZXRTcHJpdGVQb3NpdGlvbihuYW1lKTtcbiAgICBpZiAoIXBvcy53aWR0aCB8fCAhcG9zLmhlaWdodCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgcmVjdCA9IHRoaXMuYWxsb2NhdGVJbWFnZShwb3Mud2lkdGgsIHBvcy5oZWlnaHQpO1xuICAgIGlmIChyZWN0LnggPCAwKSB7XG4gICAgICAgIHJldHVybiByZWN0O1xuICAgIH1cblxuICAgIHZhciBpbWFnZSA9IG5ldyBBdGxhc0ltYWdlKHJlY3QsIHBvcy53aWR0aCAvIHBvcy5waXhlbFJhdGlvLCBwb3MuaGVpZ2h0IC8gcG9zLnBpeGVsUmF0aW8sIHBvcy5zZGYsIHBvcy5waXhlbFJhdGlvIC8gdGhpcy5waXhlbFJhdGlvKTtcbiAgICB0aGlzLmltYWdlc1tuYW1lXSA9IGltYWdlO1xuXG4gICAgdGhpcy5jb3B5KHJlY3QsIHBvcywgd3JhcCk7XG5cbiAgICByZXR1cm4gaW1hZ2U7XG59O1xuXG5cbi8vIFJldHVybiBwb3NpdGlvbiBvZiBhIHJlcGVhdGluZyBmaWxsIHBhdHRlcm4uXG5TcHJpdGVBdGxhcy5wcm90b3R5cGUuZ2V0UG9zaXRpb24gPSBmdW5jdGlvbihuYW1lLCByZXBlYXRpbmcpIHtcbiAgICB2YXIgaW1hZ2UgPSB0aGlzLmdldEltYWdlKG5hbWUsIHJlcGVhdGluZyk7XG4gICAgdmFyIHJlY3QgPSBpbWFnZSAmJiBpbWFnZS5yZWN0O1xuXG4gICAgaWYgKCFyZWN0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciB3aWR0aCA9IGltYWdlLndpZHRoICogaW1hZ2UucGl4ZWxSYXRpbztcbiAgICB2YXIgaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0ICogaW1hZ2UucGl4ZWxSYXRpbztcbiAgICB2YXIgcGFkZGluZyA9IDE7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBzaXplOiBbaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodF0sXG4gICAgICAgIHRsOiBbKHJlY3QueCArIHBhZGRpbmcpICAgICAgICAgLyB0aGlzLndpZHRoLCAocmVjdC55ICsgcGFkZGluZykgICAgICAgICAgLyB0aGlzLmhlaWdodF0sXG4gICAgICAgIGJyOiBbKHJlY3QueCArIHBhZGRpbmcgKyB3aWR0aCkgLyB0aGlzLndpZHRoLCAocmVjdC55ICsgcGFkZGluZyArIGhlaWdodCkgLyB0aGlzLmhlaWdodF1cbiAgICB9O1xufTtcblxuXG5TcHJpdGVBdGxhcy5wcm90b3R5cGUuYWxsb2NhdGUgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuZGF0YSkge1xuICAgICAgICB2YXIgdyA9IE1hdGguZmxvb3IodGhpcy53aWR0aCAqIHRoaXMucGl4ZWxSYXRpbyk7XG4gICAgICAgIHZhciBoID0gTWF0aC5mbG9vcih0aGlzLmhlaWdodCAqIHRoaXMucGl4ZWxSYXRpbyk7XG4gICAgICAgIHRoaXMuZGF0YSA9IG5ldyBVaW50MzJBcnJheSh3ICogaCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFbaV0gPSAwO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuXG5TcHJpdGVBdGxhcy5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKGRzdCwgc3JjLCB3cmFwKSB7XG4gICAgaWYgKCF0aGlzLnNwcml0ZS5pbWcuZGF0YSkgcmV0dXJuO1xuICAgIHZhciBzcmNJbWcgPSBuZXcgVWludDMyQXJyYXkodGhpcy5zcHJpdGUuaW1nLmRhdGEuYnVmZmVyKTtcblxuICAgIHRoaXMuYWxsb2NhdGUoKTtcbiAgICB2YXIgZHN0SW1nID0gdGhpcy5kYXRhO1xuXG4gICAgdmFyIHBhZGRpbmcgPSAxO1xuXG4gICAgY29weUJpdG1hcChcbiAgICAgICAgLyogc291cmNlIGJ1ZmZlciAqLyAgc3JjSW1nLFxuICAgICAgICAvKiBzb3VyY2Ugc3RyaWRlICovICB0aGlzLnNwcml0ZS5pbWcud2lkdGgsXG4gICAgICAgIC8qIHNvdXJjZSB4ICovICAgICAgIHNyYy54LFxuICAgICAgICAvKiBzb3VyY2UgeSAqLyAgICAgICBzcmMueSxcbiAgICAgICAgLyogZGVzdCBidWZmZXIgKi8gICAgZHN0SW1nLFxuICAgICAgICAvKiBkZXN0IHN0cmlkZSAqLyAgICB0aGlzLndpZHRoICogdGhpcy5waXhlbFJhdGlvLFxuICAgICAgICAvKiBkZXN0IHggKi8gICAgICAgICAoZHN0LnggKyBwYWRkaW5nKSAqIHRoaXMucGl4ZWxSYXRpbyxcbiAgICAgICAgLyogZGVzdCB5ICovICAgICAgICAgKGRzdC55ICsgcGFkZGluZykgKiB0aGlzLnBpeGVsUmF0aW8sXG4gICAgICAgIC8qIGljb24gZGltZW5zaW9uICovIHNyYy53aWR0aCxcbiAgICAgICAgLyogaWNvbiBkaW1lbnNpb24gKi8gc3JjLmhlaWdodCxcbiAgICAgICAgLyogd3JhcCAqLyB3cmFwXG4gICAgKTtcblxuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xufTtcblxuU3ByaXRlQXRsYXMucHJvdG90eXBlLnNldFNwcml0ZSA9IGZ1bmN0aW9uKHNwcml0ZSkge1xuICAgIGlmIChzcHJpdGUpIHtcbiAgICAgICAgdGhpcy5waXhlbFJhdGlvID0gYnJvd3Nlci5kZXZpY2VQaXhlbFJhdGlvID4gMSA/IDIgOiAxO1xuXG4gICAgICAgIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgICAgICAgdGhpcy5jYW52YXMud2lkdGggPSB0aGlzLndpZHRoICogdGhpcy5waXhlbFJhdGlvO1xuICAgICAgICAgICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gdGhpcy5oZWlnaHQgKiB0aGlzLnBpeGVsUmF0aW87XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5zcHJpdGUgPSBzcHJpdGU7XG59O1xuXG5TcHJpdGVBdGxhcy5wcm90b3R5cGUuYWRkSWNvbnMgPSBmdW5jdGlvbihpY29ucywgY2FsbGJhY2spIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGljb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuZ2V0SW1hZ2UoaWNvbnNbaV0pO1xuICAgIH1cblxuICAgIGNhbGxiYWNrKG51bGwsIHRoaXMuaW1hZ2VzKTtcbn07XG5cblNwcml0ZUF0bGFzLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24oZ2wsIGxpbmVhcikge1xuICAgIHZhciBmaXJzdCA9IGZhbHNlO1xuICAgIGlmICghdGhpcy50ZXh0dXJlKSB7XG4gICAgICAgIHRoaXMudGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgICBmaXJzdCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKTtcbiAgICB9XG5cbiAgICB2YXIgZmlsdGVyVmFsID0gbGluZWFyID8gZ2wuTElORUFSIDogZ2wuTkVBUkVTVDtcbiAgICBpZiAoZmlsdGVyVmFsICE9PSB0aGlzLmZpbHRlcikge1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZmlsdGVyVmFsKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGZpbHRlclZhbCk7XG4gICAgICAgIHRoaXMuZmlsdGVyID0gZmlsdGVyVmFsO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmRpcnR5KSB7XG4gICAgICAgIHRoaXMuYWxsb2NhdGUoKTtcblxuICAgICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgICAgIGdsLnRleEltYWdlMkQoXG4gICAgICAgICAgICAgICAgZ2wuVEVYVFVSRV8yRCwgLy8gZW51bSB0YXJnZXRcbiAgICAgICAgICAgICAgICAwLCAvLyBpbmQgbGV2ZWxcbiAgICAgICAgICAgICAgICBnbC5SR0JBLCAvLyBpbmQgaW50ZXJuYWxmb3JtYXRcbiAgICAgICAgICAgICAgICB0aGlzLndpZHRoICogdGhpcy5waXhlbFJhdGlvLCAvLyBHTHNpemVpIHdpZHRoXG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHQgKiB0aGlzLnBpeGVsUmF0aW8sIC8vIEdMc2l6ZWkgaGVpZ2h0XG4gICAgICAgICAgICAgICAgMCwgLy8gaW5kIGJvcmRlclxuICAgICAgICAgICAgICAgIGdsLlJHQkEsIC8vIGVudW0gZm9ybWF0XG4gICAgICAgICAgICAgICAgZ2wuVU5TSUdORURfQllURSwgLy8gZW51bSB0eXBlXG4gICAgICAgICAgICAgICAgbmV3IFVpbnQ4QXJyYXkodGhpcy5kYXRhLmJ1ZmZlcikgLy8gT2JqZWN0IGRhdGFcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbC50ZXhTdWJJbWFnZTJEKFxuICAgICAgICAgICAgICAgIGdsLlRFWFRVUkVfMkQsIC8vIGVudW0gdGFyZ2V0XG4gICAgICAgICAgICAgICAgMCwgLy8gaW50IGxldmVsXG4gICAgICAgICAgICAgICAgMCwgLy8gaW50IHhvZmZzZXRcbiAgICAgICAgICAgICAgICAwLCAvLyBpbnQgeW9mZnNldFxuICAgICAgICAgICAgICAgIHRoaXMud2lkdGggKiB0aGlzLnBpeGVsUmF0aW8sIC8vIGxvbmcgd2lkdGhcbiAgICAgICAgICAgICAgICB0aGlzLmhlaWdodCAqIHRoaXMucGl4ZWxSYXRpbywgLy8gbG9uZyBoZWlnaHRcbiAgICAgICAgICAgICAgICBnbC5SR0JBLCAvLyBlbnVtIGZvcm1hdFxuICAgICAgICAgICAgICAgIGdsLlVOU0lHTkVEX0JZVEUsIC8vIGVudW0gdHlwZVxuICAgICAgICAgICAgICAgIG5ldyBVaW50OEFycmF5KHRoaXMuZGF0YS5idWZmZXIpIC8vIE9iamVjdCBwaXhlbHNcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG5cbiAgICAgICAgLy8gREVCVUdcbiAgICAgICAgaWYgKHRoaXMuY3R4KSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuY3R4LmdldEltYWdlRGF0YSgwLCAwLCB0aGlzLndpZHRoICogdGhpcy5waXhlbFJhdGlvLCB0aGlzLmhlaWdodCAqIHRoaXMucGl4ZWxSYXRpbyk7XG4gICAgICAgICAgICBkYXRhLmRhdGEuc2V0KG5ldyBVaW50OENsYW1wZWRBcnJheSh0aGlzLmRhdGEuYnVmZmVyKSk7XG4gICAgICAgICAgICB0aGlzLmN0eC5wdXRJbWFnZURhdGEoZGF0YSwgMCwgMCk7XG5cbiAgICAgICAgICAgIHRoaXMuY3R4LnN0cm9rZVN0eWxlID0gJ3JlZCc7XG4gICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRoaXMuYmluLmZyZWUubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZnJlZSA9IHRoaXMuYmluLmZyZWVba107XG4gICAgICAgICAgICAgICAgdGhpcy5jdHguc3Ryb2tlUmVjdChmcmVlLnggKiB0aGlzLnBpeGVsUmF0aW8sIGZyZWUueSAqIHRoaXMucGl4ZWxSYXRpbywgZnJlZS53ICogdGhpcy5waXhlbFJhdGlvLCBmcmVlLmggKiB0aGlzLnBpeGVsUmF0aW8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEVORCBERUJVR1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIEF0bGFzSW1hZ2UocmVjdCwgd2lkdGgsIGhlaWdodCwgc2RmLCBwaXhlbFJhdGlvKSB7XG4gICAgdGhpcy5yZWN0ID0gcmVjdDtcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGhpcy5zZGYgPSBzZGY7XG4gICAgdGhpcy5waXhlbFJhdGlvID0gcGl4ZWxSYXRpbztcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcbnZhciBpbnRlcnBvbGF0ZSA9IHJlcXVpcmUoJy4uL3V0aWwvaW50ZXJwb2xhdGUnKTtcbnZhciBicm93c2VyID0gcmVxdWlyZSgnLi4vdXRpbC9icm93c2VyJyk7XG52YXIgTG5nTGF0ID0gcmVxdWlyZSgnLi4vZ2VvL2xuZ19sYXQnKTtcbnZhciBMbmdMYXRCb3VuZHMgPSByZXF1aXJlKCcuLi9nZW8vbG5nX2xhdF9ib3VuZHMnKTtcbnZhciBQb2ludCA9IHJlcXVpcmUoJ3BvaW50LWdlb21ldHJ5Jyk7XG5cbi8qKlxuICogT3B0aW9ucyBjb21tb24gdG8gTWFwI2p1bXBUbywgTWFwI2Vhc2VUbywgYW5kIE1hcCNmbHlUbywgY29udHJvbGxpbmcgdGhlIGRlc3RpbmF0aW9uXG4gKiBsb2NhdGlvbiwgem9vbSBsZXZlbCwgYmVhcmluZyBhbmQgcGl0Y2guIEFsbCBwcm9wZXJ0aWVzIGFyZSBvcHRpb25zOyB1bnNwZWNpZmllZFxuICogb3B0aW9ucyB3aWxsIGRlZmF1bHQgdG8gdGhlIGN1cnJlbnQgdmFsdWUgZm9yIHRoYXQgcHJvcGVydHkuXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gQ2FtZXJhT3B0aW9uc1xuICogQHByb3BlcnR5IHtMbmdMYXR9IGNlbnRlciBNYXAgY2VudGVyXG4gKiBAcHJvcGVydHkge251bWJlcn0gem9vbSBNYXAgem9vbSBsZXZlbFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGJlYXJpbmcgTWFwIHJvdGF0aW9uIGJlYXJpbmcgaW4gZGVncmVlcyBjb3VudGVyLWNsb2Nrd2lzZSBmcm9tIG5vcnRoXG4gKiBAcHJvcGVydHkge251bWJlcn0gcGl0Y2ggTWFwIGFuZ2xlIGluIGRlZ3JlZXMgYXQgd2hpY2ggdGhlIGNhbWVyYSBpcyBsb29raW5nIGF0IHRoZSBncm91bmRcbiAqIEBwcm9wZXJ0eSB7TG5nTGF0fSBhcm91bmQgSWYgem9vbWluZywgdGhlIHpvb20gY2VudGVyIChkZWZhdWx0cyB0byBtYXAgY2VudGVyKVxuICovXG5cbi8qKlxuICogT3B0aW9ucyBjb21tb24gdG8gbWFwIG1vdmVtZW50IG1ldGhvZHMgdGhhdCBpbnZvbHZlIGFuaW1hdGlvbiwgc3VjaCBhcyBNYXAjcGFuQnkgYW5kXG4gKiBNYXAjZWFzZVRvLCBjb250cm9sbGluZyB0aGUgZHVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbiBhbmQgZWFzaW5nIGZ1bmN0aW9uLiBBbGwgcHJvcGVydGllc1xuICogYXJlIG9wdGlvbmFsLlxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEFuaW1hdGlvbk9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkdXJhdGlvbiBOdW1iZXIgaW4gbWlsbGlzZWNvbmRzXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBlYXNpbmdcbiAqIEBwcm9wZXJ0eSB7QXJyYXl9IG9mZnNldCBwb2ludCwgb3JpZ2luIG9mIG1vdmVtZW50IHJlbGF0aXZlIHRvIG1hcCBjZW50ZXJcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gYW5pbWF0ZSBXaGVuIHNldCB0byBmYWxzZSwgbm8gYW5pbWF0aW9uIGhhcHBlbnNcbiAqL1xuXG52YXIgQ2FtZXJhID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHt9O1xuXG51dGlsLmV4dGVuZChDYW1lcmEucHJvdG90eXBlLCAvKiogQGxlbmRzIE1hcC5wcm90b3R5cGUgKi97XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IHZpZXcgZ2VvZ3JhcGhpY2FsIHBvaW50LlxuICAgICAqIEByZXR1cm5zIHtMbmdMYXR9XG4gICAgICovXG4gICAgZ2V0Q2VudGVyOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMudHJhbnNmb3JtLmNlbnRlcjsgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgYSBtYXAgbG9jYXRpb24uIEVxdWl2YWxlbnQgdG8gYGp1bXBUbyh7Y2VudGVyOiBjZW50ZXJ9KWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0xuZ0xhdH0gY2VudGVyIE1hcCBjZW50ZXIgdG8ganVtcCB0b1xuICAgICAqIEBmaXJlcyBtb3Zlc3RhcnRcbiAgICAgKiBAZmlyZXMgbW92ZWVuZFxuICAgICAqIEByZXR1cm5zIHtNYXB9IGB0aGlzYFxuICAgICAqIEBleGFtcGxlXG4gICAgICogbWFwLnNldENlbnRlcihbLTc0LCAzOF0pO1xuICAgICAqL1xuICAgIHNldENlbnRlcjogZnVuY3Rpb24oY2VudGVyKSB7XG4gICAgICAgIHRoaXMuanVtcFRvKHtjZW50ZXI6IGNlbnRlcn0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUGFuIGJ5IGEgY2VydGFpbiBudW1iZXIgb2YgcGl4ZWxzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IG9mZnNldCBbeCwgeV1cbiAgICAgKiBAcGFyYW0ge0FuaW1hdGlvbk9wdGlvbnN9IFtvcHRpb25zXVxuICAgICAqIEBmaXJlcyBtb3Zlc3RhcnRcbiAgICAgKiBAZmlyZXMgbW92ZWVuZFxuICAgICAqIEByZXR1cm5zIHtNYXB9IGB0aGlzYFxuICAgICAqL1xuICAgIHBhbkJ5OiBmdW5jdGlvbihvZmZzZXQsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5wYW5Ubyh0aGlzLnRyYW5zZm9ybS5jZW50ZXIsIHV0aWwuZXh0ZW5kKHtvZmZzZXQ6IFBvaW50LmNvbnZlcnQob2Zmc2V0KS5tdWx0KC0xKX0sIG9wdGlvbnMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBhbiB0byBhIGNlcnRhaW4gbG9jYXRpb24gd2l0aCBlYXNpbmdcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TG5nTGF0fSBsbmdsYXQgTG9jYXRpb24gdG8gcGFuIHRvXG4gICAgICogQHBhcmFtIHtBbmltYXRpb25PcHRpb25zfSBbb3B0aW9uc11cbiAgICAgKiBAZmlyZXMgbW92ZXN0YXJ0XG4gICAgICogQGZpcmVzIG1vdmVlbmRcbiAgICAgKiBAcmV0dXJucyB7TWFwfSBgdGhpc2BcbiAgICAgKi9cbiAgICBwYW5UbzogZnVuY3Rpb24obG5nbGF0LCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuc3RvcCgpO1xuXG4gICAgICAgIGxuZ2xhdCA9IExuZ0xhdC5jb252ZXJ0KGxuZ2xhdCk7XG5cbiAgICAgICAgb3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHtcbiAgICAgICAgICAgIGR1cmF0aW9uOiA1MDAsXG4gICAgICAgICAgICBlYXNpbmc6IHV0aWwuZWFzZSxcbiAgICAgICAgICAgIG9mZnNldDogWzAsIDBdXG4gICAgICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgICAgIHZhciB0ciA9IHRoaXMudHJhbnNmb3JtLFxuICAgICAgICAgICAgb2Zmc2V0ID0gUG9pbnQuY29udmVydChvcHRpb25zLm9mZnNldCkucm90YXRlKC10ci5hbmdsZSksXG4gICAgICAgICAgICBmcm9tID0gdHIucG9pbnQsXG4gICAgICAgICAgICB0byA9IHRyLnByb2plY3QobG5nbGF0KS5zdWIob2Zmc2V0KTtcblxuICAgICAgICBpZiAoIW9wdGlvbnMubm9Nb3ZlU3RhcnQpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnbW92ZXN0YXJ0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9lYXNlKGZ1bmN0aW9uKGspIHtcbiAgICAgICAgICAgIHRyLmNlbnRlciA9IHRyLnVucHJvamVjdChmcm9tLmFkZCh0by5zdWIoZnJvbSkubXVsdChrKSkpO1xuICAgICAgICAgICAgdGhpcy5maXJlKCdtb3ZlJyk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5maXJlKCdtb3ZlZW5kJyk7XG4gICAgICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudCB6b29tXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXRab29tOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMudHJhbnNmb3JtLnpvb207IH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgbWFwIHpvb20uIEVxdWl2YWxlbnQgdG8gYGp1bXBUbyh7em9vbTogem9vbX0pYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB6b29tIE1hcCB6b29tIGxldmVsXG4gICAgICogQGZpcmVzIG1vdmVzdGFydFxuICAgICAqIEBmaXJlcyBtb3ZlZW5kXG4gICAgICogQHJldHVybnMge01hcH0gYHRoaXNgXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyB6b29tIHRoZSBtYXAgdG8gNVxuICAgICAqIG1hcC5zZXRab29tKDUpO1xuICAgICAqL1xuICAgIHNldFpvb206IGZ1bmN0aW9uKHpvb20pIHtcbiAgICAgICAgdGhpcy5qdW1wVG8oe3pvb206IHpvb219KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFpvb21zIHRvIGEgY2VydGFpbiB6b29tIGxldmVsIHdpdGggZWFzaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHpvb21cbiAgICAgKiBAcGFyYW0ge0FuaW1hdGlvbk9wdGlvbnN9IFtvcHRpb25zXVxuICAgICAqIEBmaXJlcyBtb3Zlc3RhcnRcbiAgICAgKiBAZmlyZXMgbW92ZWVuZFxuICAgICAqIEByZXR1cm5zIHtNYXB9IGB0aGlzYFxuICAgICAqL1xuICAgIHpvb21UbzogZnVuY3Rpb24oem9vbSwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnN0b3AoKTtcblxuICAgICAgICBvcHRpb25zID0gdXRpbC5leHRlbmQoe1xuICAgICAgICAgICAgZHVyYXRpb246IDUwMFxuICAgICAgICB9LCBvcHRpb25zKTtcblxuICAgICAgICBvcHRpb25zLmVhc2luZyA9IHRoaXMuX3VwZGF0ZUVhc2luZyhvcHRpb25zLmR1cmF0aW9uLCB6b29tLCBvcHRpb25zLmVhc2luZyk7XG5cbiAgICAgICAgdmFyIHRyID0gdGhpcy50cmFuc2Zvcm0sXG4gICAgICAgICAgICBhcm91bmQgPSB0ci5jZW50ZXIsXG4gICAgICAgICAgICBzdGFydFpvb20gPSB0ci56b29tO1xuXG4gICAgICAgIGlmIChvcHRpb25zLmFyb3VuZCkge1xuICAgICAgICAgICAgYXJvdW5kID0gTG5nTGF0LmNvbnZlcnQob3B0aW9ucy5hcm91bmQpO1xuICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMub2Zmc2V0KSB7XG4gICAgICAgICAgICBhcm91bmQgPSB0ci5wb2ludExvY2F0aW9uKHRyLmNlbnRlclBvaW50LmFkZChQb2ludC5jb252ZXJ0KG9wdGlvbnMub2Zmc2V0KSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuYW5pbWF0ZSA9PT0gZmFsc2UpIG9wdGlvbnMuZHVyYXRpb24gPSAwO1xuXG4gICAgICAgIGlmICghdGhpcy56b29taW5nKSB7XG4gICAgICAgICAgICB0aGlzLnpvb21pbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5maXJlKCdtb3Zlc3RhcnQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2Vhc2UoZnVuY3Rpb24oaykge1xuICAgICAgICAgICAgdHIuc2V0Wm9vbUFyb3VuZChpbnRlcnBvbGF0ZShzdGFydFpvb20sIHpvb20sIGspLCBhcm91bmQpO1xuICAgICAgICAgICAgdGhpcy5maXJlKCdtb3ZlJykuZmlyZSgnem9vbScpO1xuICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuZWFzZSA9IG51bGw7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5kdXJhdGlvbiA+PSAyMDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnpvb21pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmUoJ21vdmVlbmQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgb3B0aW9ucyk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuZHVyYXRpb24gPCAyMDApIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9vblpvb21FbmQpO1xuICAgICAgICAgICAgdGhpcy5fb25ab29tRW5kID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnpvb21pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmUoJ21vdmVlbmQnKTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSwgMjAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBab29tIGluIGJ5IDEgbGV2ZWxcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QW5pbWF0aW9uT3B0aW9uc30gW29wdGlvbnNdXG4gICAgICogQGZpcmVzIG1vdmVzdGFydFxuICAgICAqIEBmaXJlcyBtb3ZlZW5kXG4gICAgICogQHJldHVybnMge01hcH0gYHRoaXNgXG4gICAgICovXG4gICAgem9vbUluOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuem9vbVRvKHRoaXMuZ2V0Wm9vbSgpICsgMSwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBab29tIG91dCBieSAxIGxldmVsXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FuaW1hdGlvbk9wdGlvbnN9IFtvcHRpb25zXVxuICAgICAqIEBmaXJlcyBtb3Zlc3RhcnRcbiAgICAgKiBAZmlyZXMgbW92ZWVuZFxuICAgICAqIEByZXR1cm5zIHtNYXB9IGB0aGlzYFxuICAgICAqL1xuICAgIHpvb21PdXQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy56b29tVG8odGhpcy5nZXRab29tKCkgLSAxLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IGJlYXJpbmcgaW4gZGVncmVlc1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0QmVhcmluZzogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnRyYW5zZm9ybS5iZWFyaW5nOyB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBhIG1hcCByb3RhdGlvbi4gRXF1aXZhbGVudCB0byBganVtcFRvKHtiZWFyaW5nOiBiZWFyaW5nfSlgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJlYXJpbmcgTWFwIHJvdGF0aW9uIGJlYXJpbmcgaW4gZGVncmVlcyBjb3VudGVyLWNsb2Nrd2lzZSBmcm9tIG5vcnRoXG4gICAgICogQGZpcmVzIG1vdmVzdGFydFxuICAgICAqIEBmaXJlcyBtb3ZlZW5kXG4gICAgICogQHJldHVybnMge01hcH0gYHRoaXNgXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyByb3RhdGUgdGhlIG1hcCB0byA5MCBkZWdyZWVzXG4gICAgICogbWFwLnNldEJlYXJpbmcoOTApO1xuICAgICAqL1xuICAgIHNldEJlYXJpbmc6IGZ1bmN0aW9uKGJlYXJpbmcpIHtcbiAgICAgICAgdGhpcy5qdW1wVG8oe2JlYXJpbmc6IGJlYXJpbmd9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJvdGF0ZSBiZWFyaW5nIGJ5IGEgY2VydGFpbiBudW1iZXIgb2YgZGVncmVlcyB3aXRoIGVhc2luZ1xuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJlYXJpbmdcbiAgICAgKiBAcGFyYW0ge0FuaW1hdGlvbk9wdGlvbnN9IFtvcHRpb25zXVxuICAgICAqIEBmaXJlcyBtb3Zlc3RhcnRcbiAgICAgKiBAZmlyZXMgbW92ZWVuZFxuICAgICAqIEByZXR1cm5zIHtNYXB9IGB0aGlzYFxuICAgICAqL1xuICAgIHJvdGF0ZVRvOiBmdW5jdGlvbihiZWFyaW5nLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuc3RvcCgpO1xuXG4gICAgICAgIG9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7XG4gICAgICAgICAgICBkdXJhdGlvbjogNTAwLFxuICAgICAgICAgICAgZWFzaW5nOiB1dGlsLmVhc2VcbiAgICAgICAgfSwgb3B0aW9ucyk7XG5cbiAgICAgICAgdmFyIHRyID0gdGhpcy50cmFuc2Zvcm0sXG4gICAgICAgICAgICBzdGFydCA9IHRoaXMuZ2V0QmVhcmluZygpLFxuICAgICAgICAgICAgYXJvdW5kID0gdHIuY2VudGVyO1xuXG4gICAgICAgIGlmIChvcHRpb25zLmFyb3VuZCkge1xuICAgICAgICAgICAgYXJvdW5kID0gTG5nTGF0LmNvbnZlcnQob3B0aW9ucy5hcm91bmQpO1xuICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMub2Zmc2V0KSB7XG4gICAgICAgICAgICBhcm91bmQgPSB0ci5wb2ludExvY2F0aW9uKHRyLmNlbnRlclBvaW50LmFkZChQb2ludC5jb252ZXJ0KG9wdGlvbnMub2Zmc2V0KSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgYmVhcmluZyA9IHRoaXMuX25vcm1hbGl6ZUJlYXJpbmcoYmVhcmluZywgc3RhcnQpO1xuXG4gICAgICAgIHRoaXMucm90YXRpbmcgPSB0cnVlO1xuICAgICAgICBpZiAoIW9wdGlvbnMubm9Nb3ZlU3RhcnQpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnbW92ZXN0YXJ0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9lYXNlKGZ1bmN0aW9uKGspIHtcbiAgICAgICAgICAgIHRyLnNldEJlYXJpbmdBcm91bmQoaW50ZXJwb2xhdGUoc3RhcnQsIGJlYXJpbmcsIGspLCBhcm91bmQpO1xuICAgICAgICAgICAgdGhpcy5maXJlKCdtb3ZlJykuZmlyZSgncm90YXRlJyk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5yb3RhdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5maXJlKCdtb3ZlZW5kJyk7XG4gICAgICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIG1hcCBiZWFyaW5nIHRvIDAgKG5vcnRoKSB3aXRoIGVhc2luZ1xuICAgICAqXG4gICAgICogQHBhcmFtIHtBbmltYXRpb25PcHRpb25zfSBbb3B0aW9uc11cbiAgICAgKiBAZmlyZXMgbW92ZXN0YXJ0XG4gICAgICogQGZpcmVzIG1vdmVlbmRcbiAgICAgKiBAcmV0dXJucyB7TWFwfSBgdGhpc2BcbiAgICAgKi9cbiAgICByZXNldE5vcnRoOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMucm90YXRlVG8oMCwgdXRpbC5leHRlbmQoe2R1cmF0aW9uOiAxMDAwfSwgb3B0aW9ucykpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQW5pbWF0ZXMgbWFwIGJlYXJpbmcgdG8gMCAobm9ydGgpIGlmIGl0J3MgYWxyZWFkeSBjbG9zZSB0byBpdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QW5pbWF0aW9uT3B0aW9uc30gW29wdGlvbnNdXG4gICAgICogQGZpcmVzIG1vdmVzdGFydFxuICAgICAqIEBmaXJlcyBtb3ZlZW5kXG4gICAgICogQHJldHVybnMge01hcH0gYHRoaXNgXG4gICAgICovXG4gICAgc25hcFRvTm9ydGg6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKE1hdGguYWJzKHRoaXMuZ2V0QmVhcmluZygpKSA8IHRoaXMub3B0aW9ucy5iZWFyaW5nU25hcCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzZXROb3J0aChvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IGFuZ2xlIGluIGRlZ3JlZXNcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldFBpdGNoOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMudHJhbnNmb3JtLnBpdGNoOyB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBhIG1hcCBhbmdsZS4gRXF1aXZhbGVudCB0byBganVtcFRvKHtwaXRjaDogcGl0Y2h9KWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGl0Y2ggVGhlIGFuZ2xlIGF0IHdoaWNoIHRoZSBjYW1lcmEgaXMgbG9va2luZyBhdCB0aGUgZ3JvdW5kXG4gICAgICogQGZpcmVzIG1vdmVzdGFydFxuICAgICAqIEBmaXJlcyBtb3ZlZW5kXG4gICAgICogQHJldHVybnMge01hcH0gYHRoaXNgXG4gICAgICovXG4gICAgc2V0UGl0Y2g6IGZ1bmN0aW9uKHBpdGNoKSB7XG4gICAgICAgIHRoaXMuanVtcFRvKHtwaXRjaDogcGl0Y2h9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogWm9vbSB0byBjb250YWluIGNlcnRhaW4gZ2VvZ3JhcGhpY2FsIGJvdW5kc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtMbmdMYXRCb3VuZHN8QXJyYXk8QXJyYXk8bnVtYmVyPj59IGJvdW5kcyBbW21pbkxuZywgbWluTGF0XSwgW21heExuZywgbWF4TGF0XV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGluZWFyXSBXaGVuIHRydWUsIHRoZSBtYXAgdHJhbnNpdGlvbnMgdG8gdGhlIG5ldyBjYW1lcmEgdXNpbmdcbiAgICAgKiAgICAge0BsaW5rICNNYXAuZWFzZVRvfS4gV2hlbiBmYWxzZSwgdGhlIG1hcCB0cmFuc2l0aW9ucyB1c2luZyB7QGxpbmsgI01hcC5mbHlUb30uIFNlZVxuICAgICAqICAgICB7QGxpbmsgI01hcC5mbHlUb30gZm9yIGluZm9ybWF0aW9uIG9uIG9wdGlvbnMgc3BlY2lmaWMgdG8gdGhhdCBhbmltYXRpb24gdHJhbnNpdGlvbi5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLmVhc2luZ1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnBhZGRpbmcgaG93IG11Y2ggcGFkZGluZyB0aGVyZSBpcyBhcm91bmQgdGhlIGdpdmVuIGJvdW5kcyBvbiBlYWNoIHNpZGUgaW4gcGl4ZWxzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMubWF4Wm9vbSBUaGUgcmVzdWx0aW5nIHpvb20gbGV2ZWwgd2lsbCBiZSBhdCBtb3N0XG4gICAgICogICAgIHRoaXMgdmFsdWUuXG4gICAgICogQGZpcmVzIG1vdmVzdGFydFxuICAgICAqIEBmaXJlcyBtb3ZlZW5kXG4gICAgICogQHJldHVybnMge01hcH0gYHRoaXNgXG4gICAgICovXG4gICAgZml0Qm91bmRzOiBmdW5jdGlvbihib3VuZHMsIG9wdGlvbnMpIHtcblxuICAgICAgICBvcHRpb25zID0gdXRpbC5leHRlbmQoe1xuICAgICAgICAgICAgcGFkZGluZzogMCxcbiAgICAgICAgICAgIG9mZnNldDogWzAsIDBdLFxuICAgICAgICAgICAgbWF4Wm9vbTogSW5maW5pdHlcbiAgICAgICAgfSwgb3B0aW9ucyk7XG5cbiAgICAgICAgYm91bmRzID0gTG5nTGF0Qm91bmRzLmNvbnZlcnQoYm91bmRzKTtcblxuICAgICAgICB2YXIgb2Zmc2V0ID0gUG9pbnQuY29udmVydChvcHRpb25zLm9mZnNldCksXG4gICAgICAgICAgICB0ciA9IHRoaXMudHJhbnNmb3JtLFxuICAgICAgICAgICAgbncgPSB0ci5wcm9qZWN0KGJvdW5kcy5nZXROb3J0aFdlc3QoKSksXG4gICAgICAgICAgICBzZSA9IHRyLnByb2plY3QoYm91bmRzLmdldFNvdXRoRWFzdCgpKSxcbiAgICAgICAgICAgIHNpemUgPSBzZS5zdWIobncpLFxuICAgICAgICAgICAgc2NhbGVYID0gKHRyLndpZHRoIC0gb3B0aW9ucy5wYWRkaW5nICogMiAtIE1hdGguYWJzKG9mZnNldC54KSAqIDIpIC8gc2l6ZS54LFxuICAgICAgICAgICAgc2NhbGVZID0gKHRyLmhlaWdodCAtIG9wdGlvbnMucGFkZGluZyAqIDIgLSBNYXRoLmFicyhvZmZzZXQueSkgKiAyKSAvIHNpemUueTtcblxuICAgICAgICBvcHRpb25zLmNlbnRlciA9IHRyLnVucHJvamVjdChudy5hZGQoc2UpLmRpdigyKSk7XG4gICAgICAgIG9wdGlvbnMuem9vbSA9IE1hdGgubWluKHRyLnNjYWxlWm9vbSh0ci5zY2FsZSAqIE1hdGgubWluKHNjYWxlWCwgc2NhbGVZKSksIG9wdGlvbnMubWF4Wm9vbSk7XG4gICAgICAgIG9wdGlvbnMuYmVhcmluZyA9IDA7XG5cbiAgICAgICAgcmV0dXJuIG9wdGlvbnMubGluZWFyID9cbiAgICAgICAgICAgIHRoaXMuZWFzZVRvKG9wdGlvbnMpIDpcbiAgICAgICAgICAgIHRoaXMuZmx5VG8ob3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoYW5nZSBhbnkgY29tYmluYXRpb24gb2YgY2VudGVyLCB6b29tLCBiZWFyaW5nLCBhbmQgcGl0Y2gsIHdpdGhvdXRcbiAgICAgKiBhIHRyYW5zaXRpb24uIFRoZSBtYXAgd2lsbCByZXRhaW4gdGhlIGN1cnJlbnQgdmFsdWVzIGZvciBhbnkgb3B0aW9uc1xuICAgICAqIG5vdCBpbmNsdWRlZCBpbiBgb3B0aW9uc2AuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbWVyYU9wdGlvbnN9IG9wdGlvbnMgbWFwIHZpZXcgb3B0aW9uc1xuICAgICAqIEBmaXJlcyBtb3Zlc3RhcnRcbiAgICAgKiBAZmlyZXMgbW92ZWVuZFxuICAgICAqIEByZXR1cm5zIHtNYXB9IGB0aGlzYFxuICAgICAqL1xuICAgIGp1bXBUbzogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB0aGlzLnN0b3AoKTtcblxuICAgICAgICB2YXIgdHIgPSB0aGlzLnRyYW5zZm9ybSxcbiAgICAgICAgICAgIHpvb21DaGFuZ2VkID0gZmFsc2UsXG4gICAgICAgICAgICBiZWFyaW5nQ2hhbmdlZCA9IGZhbHNlLFxuICAgICAgICAgICAgcGl0Y2hDaGFuZ2VkID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKCd6b29tJyBpbiBvcHRpb25zICYmIHRyLnpvb20gIT09ICtvcHRpb25zLnpvb20pIHtcbiAgICAgICAgICAgIHpvb21DaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRyLnpvb20gPSArb3B0aW9ucy56b29tO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCdjZW50ZXInIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRyLmNlbnRlciA9IExuZ0xhdC5jb252ZXJ0KG9wdGlvbnMuY2VudGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgnYmVhcmluZycgaW4gb3B0aW9ucyAmJiB0ci5iZWFyaW5nICE9PSArb3B0aW9ucy5iZWFyaW5nKSB7XG4gICAgICAgICAgICBiZWFyaW5nQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB0ci5iZWFyaW5nID0gK29wdGlvbnMuYmVhcmluZztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgncGl0Y2gnIGluIG9wdGlvbnMgJiYgdHIucGl0Y2ggIT09ICtvcHRpb25zLnBpdGNoKSB7XG4gICAgICAgICAgICBwaXRjaENoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgdHIucGl0Y2ggPSArb3B0aW9ucy5waXRjaDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZmlyZSgnbW92ZXN0YXJ0JylcbiAgICAgICAgICAgIC5maXJlKCdtb3ZlJyk7XG5cbiAgICAgICAgaWYgKHpvb21DaGFuZ2VkKSB7XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ3pvb20nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChiZWFyaW5nQ2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy5maXJlKCdyb3RhdGUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwaXRjaENoYW5nZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgncGl0Y2gnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmZpcmUoJ21vdmVlbmQnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hhbmdlIGFueSBjb21iaW5hdGlvbiBvZiBjZW50ZXIsIHpvb20sIGJlYXJpbmcsIGFuZCBwaXRjaCwgd2l0aCBhIHNtb290aCBhbmltYXRpb25cbiAgICAgKiBiZXR3ZWVuIG9sZCBhbmQgbmV3IHZhbHVlcy4gVGhlIG1hcCB3aWxsIHJldGFpbiB0aGUgY3VycmVudCB2YWx1ZXMgZm9yIGFueSBvcHRpb25zXG4gICAgICogbm90IGluY2x1ZGVkIGluIGBvcHRpb25zYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FtZXJhT3B0aW9uc3xBbmltYXRpb25PcHRpb25zfSBvcHRpb25zIG1hcCB2aWV3IGFuZCBhbmltYXRpb24gb3B0aW9uc1xuICAgICAqIEBmaXJlcyBtb3Zlc3RhcnRcbiAgICAgKiBAZmlyZXMgbW92ZWVuZFxuICAgICAqIEByZXR1cm5zIHtNYXB9IGB0aGlzYFxuICAgICAqL1xuICAgIGVhc2VUbzogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB0aGlzLnN0b3AoKTtcblxuICAgICAgICBvcHRpb25zID0gdXRpbC5leHRlbmQoe1xuICAgICAgICAgICAgb2Zmc2V0OiBbMCwgMF0sXG4gICAgICAgICAgICBkdXJhdGlvbjogNTAwLFxuICAgICAgICAgICAgZWFzaW5nOiB1dGlsLmVhc2VcbiAgICAgICAgfSwgb3B0aW9ucyk7XG5cbiAgICAgICAgdmFyIHRyID0gdGhpcy50cmFuc2Zvcm0sXG4gICAgICAgICAgICBvZmZzZXQgPSBQb2ludC5jb252ZXJ0KG9wdGlvbnMub2Zmc2V0KS5yb3RhdGUoLXRyLmFuZ2xlKSxcbiAgICAgICAgICAgIGZyb20gPSB0ci5wb2ludCxcbiAgICAgICAgICAgIHN0YXJ0V29ybGRTaXplID0gdHIud29ybGRTaXplLFxuICAgICAgICAgICAgc3RhcnRab29tID0gdGhpcy5nZXRab29tKCksXG4gICAgICAgICAgICBzdGFydEJlYXJpbmcgPSB0aGlzLmdldEJlYXJpbmcoKSxcbiAgICAgICAgICAgIHN0YXJ0UGl0Y2ggPSB0aGlzLmdldFBpdGNoKCksXG5cbiAgICAgICAgICAgIHpvb20gPSAnem9vbScgaW4gb3B0aW9ucyA/ICtvcHRpb25zLnpvb20gOiBzdGFydFpvb20sXG4gICAgICAgICAgICBiZWFyaW5nID0gJ2JlYXJpbmcnIGluIG9wdGlvbnMgPyB0aGlzLl9ub3JtYWxpemVCZWFyaW5nKG9wdGlvbnMuYmVhcmluZywgc3RhcnRCZWFyaW5nKSA6IHN0YXJ0QmVhcmluZyxcbiAgICAgICAgICAgIHBpdGNoID0gJ3BpdGNoJyBpbiBvcHRpb25zID8gK29wdGlvbnMucGl0Y2ggOiBzdGFydFBpdGNoLFxuXG4gICAgICAgICAgICBzY2FsZSA9IHRyLnpvb21TY2FsZSh6b29tIC0gc3RhcnRab29tKSxcbiAgICAgICAgICAgIHRvID0gJ2NlbnRlcicgaW4gb3B0aW9ucyA/IHRyLnByb2plY3QoTG5nTGF0LmNvbnZlcnQob3B0aW9ucy5jZW50ZXIpKS5zdWIob2Zmc2V0LmRpdihzY2FsZSkpIDogZnJvbSxcbiAgICAgICAgICAgIGFyb3VuZCA9ICdjZW50ZXInIGluIG9wdGlvbnMgPyBudWxsIDogTG5nTGF0LmNvbnZlcnQob3B0aW9ucy5hcm91bmQpO1xuXG4gICAgICAgIGlmICh6b29tICE9PSBzdGFydFpvb20pIHtcbiAgICAgICAgICAgIHRoaXMuem9vbWluZyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0QmVhcmluZyAhPT0gYmVhcmluZykge1xuICAgICAgICAgICAgdGhpcy5yb3RhdGluZyA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGl0Y2ggIT09IHN0YXJ0UGl0Y2gpIHtcbiAgICAgICAgICAgIHRoaXMucGl0Y2hpbmcgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuem9vbWluZyAmJiAhYXJvdW5kKSB7XG4gICAgICAgICAgICBhcm91bmQgPSB0ci5wb2ludExvY2F0aW9uKHRyLmNlbnRlclBvaW50LmFkZCh0by5zdWIoZnJvbSkuZGl2KDEgLSAxIC8gc2NhbGUpKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmZpcmUoJ21vdmVzdGFydCcpO1xuXG4gICAgICAgIHRoaXMuX2Vhc2UoZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnpvb21pbmcgJiYgYXJvdW5kKSB7XG4gICAgICAgICAgICAgICAgdHIuc2V0Wm9vbUFyb3VuZChpbnRlcnBvbGF0ZShzdGFydFpvb20sIHpvb20sIGspLCBhcm91bmQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy56b29taW5nKSB0ci56b29tID0gaW50ZXJwb2xhdGUoc3RhcnRab29tLCB6b29tLCBrKTtcbiAgICAgICAgICAgICAgICB0ci5jZW50ZXIgPSB0ci51bnByb2plY3QoZnJvbS5hZGQodG8uc3ViKGZyb20pLm11bHQoaykpLCBzdGFydFdvcmxkU2l6ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnJvdGF0aW5nKSB7XG4gICAgICAgICAgICAgICAgdHIuYmVhcmluZyA9IGludGVycG9sYXRlKHN0YXJ0QmVhcmluZywgYmVhcmluZywgayk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnBpdGNoaW5nKSB7XG4gICAgICAgICAgICAgICAgdHIucGl0Y2ggPSBpbnRlcnBvbGF0ZShzdGFydFBpdGNoLCBwaXRjaCwgayk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZmlyZSgnbW92ZScpO1xuICAgICAgICAgICAgaWYgKHRoaXMuem9vbWluZykge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyZSgnem9vbScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMucm90YXRpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmUoJ3JvdGF0ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMucGl0Y2hpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmUoJ3BpdGNoJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy56b29taW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnJvdGF0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnBpdGNoaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ21vdmVlbmQnKTtcbiAgICAgICAgfSwgb3B0aW9ucyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoYW5nZSBhbnkgY29tYmluYXRpb24gb2YgY2VudGVyLCB6b29tLCBiZWFyaW5nLCBhbmQgcGl0Y2gsIGFuaW1hdGVkIGFsb25nIGEgY3VydmUgdGhhdFxuICAgICAqIGV2b2tlcyBmbGlnaHQuIFRoZSB0cmFuc2l0aW9uIGFuaW1hdGlvbiBzZWFtbGVzc2x5IGluY29ycG9yYXRlcyB6b29taW5nIGFuZCBwYW5uaW5nIHRvIGhlbHBcbiAgICAgKiB0aGUgdXNlciBmaW5kIGhpcyBvciBoZXIgYmVhcmluZ3MgZXZlbiBhZnRlciB0cmF2ZXJzaW5nIGEgZ3JlYXQgZGlzdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbWVyYU9wdGlvbnN8QW5pbWF0aW9uT3B0aW9uc30gb3B0aW9ucyBtYXAgdmlldyBhbmQgYW5pbWF0aW9uIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuY3VydmU9MS40Ml0gUmVsYXRpdmUgYW1vdW50IG9mIHpvb21pbmcgdGhhdCB0YWtlcyBwbGFjZSBhbG9uZyB0aGVcbiAgICAgKiAgICAgZmxpZ2h0IHBhdGguIEEgaGlnaCB2YWx1ZSBtYXhpbWl6ZXMgem9vbWluZyBmb3IgYW4gZXhhZ2dlcmF0ZWQgYW5pbWF0aW9uLCB3aGlsZSBhIGxvd1xuICAgICAqICAgICB2YWx1ZSBtaW5pbWl6ZXMgem9vbWluZyBmb3Igc29tZXRoaW5nIGNsb3NlciB0byB7QGxpbmsgI01hcC5lYXNlVG99LiAxLjQyIGlzIHRoZSBhdmVyYWdlXG4gICAgICogICAgIHZhbHVlIHNlbGVjdGVkIGJ5IHBhcnRpY2lwYW50cyBpbiB0aGUgdXNlciBzdHVkeSBpblxuICAgICAqICAgICBbdmFuIFdpamsgKDIwMDMpXShodHRwczovL3d3dy53aW4udHVlLm5sL352YW53aWprL3pvb21wYW4ucGRmKS4gQSB2YWx1ZSBvZlxuICAgICAqICAgICBgTWF0aC5wb3coNiwgMC4yNSlgIHdvdWxkIGJlIGVxdWl2YWxlbnQgdG8gdGhlIHJvb3QgbWVhbiBzcXVhcmVkIGF2ZXJhZ2UgdmVsb2NpdHkuIEFcbiAgICAgKiAgICAgdmFsdWUgb2YgMSB3b3VsZCBwcm9kdWNlIGEgY2lyY3VsYXIgbW90aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5taW5ab29tXSBaZXJvLWJhc2VkIHpvb20gbGV2ZWwgYXQgdGhlIHBlYWsgb2YgdGhlIGZsaWdodCBwYXRoLiBJZlxuICAgICAqICAgICBgb3B0aW9ucy5jdXJ2ZWAgaXMgc3BlY2lmaWVkLCB0aGlzIG9wdGlvbiBpcyBpZ25vcmVkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5zcGVlZD0xLjJdIEF2ZXJhZ2Ugc3BlZWQgb2YgdGhlIGFuaW1hdGlvbi4gQSBzcGVlZCBvZiAxLjIgbWVhbnMgdGhhdFxuICAgICAqICAgICB0aGUgbWFwIGFwcGVhcnMgdG8gbW92ZSBhbG9uZyB0aGUgZmxpZ2h0IHBhdGggYnkgMS4yIHRpbWVzIGBvcHRpb25zLmN1cnZlYCBzY3JlZW5mdWxzIGV2ZXJ5XG4gICAgICogICAgIHNlY29uZC4gQSBfc2NyZWVuZnVsXyBpcyB0aGUgdmlzaWJsZSBzcGFuIGluIHBpeGVscy4gSXQgZG9lcyBub3QgY29ycmVzcG9uZCB0byBhIGZpeGVkXG4gICAgICogICAgIHBoeXNpY2FsIGRpc3RhbmNlIGJ1dCByYXRoZXIgdmFyaWVzIGJ5IHpvb20gbGV2ZWwuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnNjcmVlblNwZWVkXSBBdmVyYWdlIHNwZWVkIG9mIHRoZSBhbmltYXRpb24sIG1lYXN1cmVkIGluIHNjcmVlbmZ1bHNcbiAgICAgKiAgICAgcGVyIHNlY29uZCwgYXNzdW1pbmcgYSBsaW5lYXIgdGltaW5nIGN1cnZlLiBJZiBgb3B0aW9ucy5zcGVlZGAgaXMgc3BlY2lmaWVkLCB0aGlzIG9wdGlvblxuICAgICAqICAgICBpcyBpZ25vcmVkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmVhc2luZ10gVHJhbnNpdGlvbiB0aW1pbmcgY3VydmVcbiAgICAgKiBAZmlyZXMgbW92ZXN0YXJ0XG4gICAgICogQGZpcmVzIG1vdmVlbmRcbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGZseSB3aXRoIGRlZmF1bHQgb3B0aW9ucyB0byBudWxsIGlzbGFuZFxuICAgICAqIG1hcC5mbHlUbyh7Y2VudGVyOiBbMCwgMF0sIHpvb206IDl9KTtcbiAgICAgKiAvLyB1c2luZyBmbHlUbyBvcHRpb25zXG4gICAgICogbWFwLmZseVRvKHtcbiAgICAgKiAgIGNlbnRlcjogWzAsIDBdLFxuICAgICAqICAgem9vbTogOSxcbiAgICAgKiAgIHNwZWVkOiAwLjIsXG4gICAgICogICBjdXJ2ZTogMSxcbiAgICAgKiAgIGVhc2luZzogZnVuY3Rpb24odCkge1xuICAgICAqICAgICByZXR1cm4gdDtcbiAgICAgKiAgIH1cbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBmbHlUbzogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAvLyBUaGlzIG1ldGhvZCBpbXBsZW1lbnRzIGFuIOKAnG9wdGltYWwgcGF0aOKAnSBhbmltYXRpb24sIGFzIGRldGFpbGVkIGluOlxuICAgICAgICAvL1xuICAgICAgICAvLyBWYW4gV2lqaywgSmFya2UgSi47IE51aWosIFdpbSBBLiBBLiDigJxTbW9vdGggYW5kIGVmZmljaWVudCB6b29taW5nIGFuZCBwYW5uaW5nLuKAnSBJTkZPVklTXG4gICAgICAgIC8vICAg4oCZMDMuIHBwLiAxNeKAkzIyLiA8aHR0cHM6Ly93d3cud2luLnR1ZS5ubC9+dmFud2lqay96b29tcGFuLnBkZiNwYWdlPTU+LlxuICAgICAgICAvL1xuICAgICAgICAvLyBXaGVyZSBhcHBsaWNhYmxlLCBsb2NhbCB2YXJpYWJsZSBkb2N1bWVudGF0aW9uIGJlZ2lucyB3aXRoIHRoZSBhc3NvY2lhdGVkIHZhcmlhYmxlIG9yXG4gICAgICAgIC8vIGZ1bmN0aW9uIGluIHZhbiBXaWprICgyMDAzKS5cblxuICAgICAgICB0aGlzLnN0b3AoKTtcblxuICAgICAgICBvcHRpb25zID0gdXRpbC5leHRlbmQoe1xuICAgICAgICAgICAgb2Zmc2V0OiBbMCwgMF0sXG4gICAgICAgICAgICBzcGVlZDogMS4yLFxuICAgICAgICAgICAgY3VydmU6IDEuNDIsXG4gICAgICAgICAgICBlYXNpbmc6IHV0aWwuZWFzZVxuICAgICAgICB9LCBvcHRpb25zKTtcblxuICAgICAgICB2YXIgdHIgPSB0aGlzLnRyYW5zZm9ybSxcbiAgICAgICAgICAgIG9mZnNldCA9IFBvaW50LmNvbnZlcnQob3B0aW9ucy5vZmZzZXQpLFxuICAgICAgICAgICAgc3RhcnRab29tID0gdGhpcy5nZXRab29tKCksXG4gICAgICAgICAgICBzdGFydEJlYXJpbmcgPSB0aGlzLmdldEJlYXJpbmcoKSxcbiAgICAgICAgICAgIHN0YXJ0UGl0Y2ggPSB0aGlzLmdldFBpdGNoKCk7XG5cbiAgICAgICAgdmFyIGNlbnRlciA9ICdjZW50ZXInIGluIG9wdGlvbnMgPyBMbmdMYXQuY29udmVydChvcHRpb25zLmNlbnRlcikgOiB0aGlzLmdldENlbnRlcigpO1xuICAgICAgICB2YXIgem9vbSA9ICd6b29tJyBpbiBvcHRpb25zID8gICtvcHRpb25zLnpvb20gOiBzdGFydFpvb207XG4gICAgICAgIHZhciBiZWFyaW5nID0gJ2JlYXJpbmcnIGluIG9wdGlvbnMgPyB0aGlzLl9ub3JtYWxpemVCZWFyaW5nKG9wdGlvbnMuYmVhcmluZywgc3RhcnRCZWFyaW5nKSA6IHN0YXJ0QmVhcmluZztcbiAgICAgICAgdmFyIHBpdGNoID0gJ3BpdGNoJyBpbiBvcHRpb25zID8gK29wdGlvbnMucGl0Y2ggOiBzdGFydFBpdGNoO1xuXG4gICAgICAgIC8vIElmIGEgcGF0aCBjcm9zc2luZyB0aGUgYW50aW1lcmlkaWFuIHdvdWxkIGJlIHNob3J0ZXIsIGV4dGVuZCB0aGUgZmluYWwgY29vcmRpbmF0ZSBzbyB0aGF0XG4gICAgICAgIC8vIGludGVycG9sYXRpbmcgYmV0d2VlbiB0aGUgdHdvIGVuZHBvaW50cyB3aWxsIGNyb3NzIGl0LlxuICAgICAgICBpZiAoTWF0aC5hYnModHIuY2VudGVyLmxuZykgKyBNYXRoLmFicyhjZW50ZXIubG5nKSA+IDE4MCkge1xuICAgICAgICAgICAgaWYgKHRyLmNlbnRlci5sbmcgPiAwICYmIGNlbnRlci5sbmcgPCAwKSB7XG4gICAgICAgICAgICAgICAgY2VudGVyLmxuZyArPSAzNjA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRyLmNlbnRlci5sbmcgPCAwICYmIGNlbnRlci5sbmcgPiAwKSB7XG4gICAgICAgICAgICAgICAgY2VudGVyLmxuZyAtPSAzNjA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2NhbGUgPSB0ci56b29tU2NhbGUoem9vbSAtIHN0YXJ0Wm9vbSksXG4gICAgICAgICAgICBmcm9tID0gdHIucG9pbnQsXG4gICAgICAgICAgICB0byA9ICdjZW50ZXInIGluIG9wdGlvbnMgPyB0ci5wcm9qZWN0KGNlbnRlcikuc3ViKG9mZnNldC5kaXYoc2NhbGUpKSA6IGZyb207XG5cbiAgICAgICAgdmFyIHN0YXJ0V29ybGRTaXplID0gdHIud29ybGRTaXplLFxuICAgICAgICAgICAgcmhvID0gb3B0aW9ucy5jdXJ2ZSxcblxuICAgICAgICAgICAgLy8gd+KCgDogSW5pdGlhbCB2aXNpYmxlIHNwYW4sIG1lYXN1cmVkIGluIHBpeGVscyBhdCB0aGUgaW5pdGlhbCBzY2FsZS5cbiAgICAgICAgICAgIHcwID0gTWF0aC5tYXgodHIud2lkdGgsIHRyLmhlaWdodCksXG4gICAgICAgICAgICAvLyB34oKBOiBGaW5hbCB2aXNpYmxlIHNwYW4sIG1lYXN1cmVkIGluIHBpeGVscyB3aXRoIHJlc3BlY3QgdG8gdGhlIGluaXRpYWwgc2NhbGUuXG4gICAgICAgICAgICB3MSA9IHcwIC8gc2NhbGUsXG4gICAgICAgICAgICAvLyBMZW5ndGggb2YgdGhlIGZsaWdodCBwYXRoIGFzIHByb2plY3RlZCBvbnRvIHRoZSBncm91bmQgcGxhbmUsIG1lYXN1cmVkIGluIHBpeGVscyBmcm9tXG4gICAgICAgICAgICAvLyB0aGUgd29ybGQgaW1hZ2Ugb3JpZ2luIGF0IHRoZSBpbml0aWFsIHNjYWxlLlxuICAgICAgICAgICAgdTEgPSB0by5zdWIoZnJvbSkubWFnKCk7XG5cbiAgICAgICAgaWYgKCdtaW5ab29tJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgbWluWm9vbSA9IHV0aWwuY2xhbXAoTWF0aC5taW4ob3B0aW9ucy5taW5ab29tLCBzdGFydFpvb20sIHpvb20pLCB0ci5taW5ab29tLCB0ci5tYXhab29tKTtcbiAgICAgICAgICAgIC8vIHc8c3ViPm08L3N1Yj46IE1heGltdW0gdmlzaWJsZSBzcGFuLCBtZWFzdXJlZCBpbiBwaXhlbHMgd2l0aCByZXNwZWN0IHRvIHRoZSBpbml0aWFsXG4gICAgICAgICAgICAvLyBzY2FsZS5cbiAgICAgICAgICAgIHZhciB3TWF4ID0gdzAgLyB0ci56b29tU2NhbGUobWluWm9vbSAtIHN0YXJ0Wm9vbSk7XG4gICAgICAgICAgICByaG8gPSBNYXRoLnNxcnQod01heCAvIHUxICogMik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyDPgcKyXG4gICAgICAgIHZhciByaG8yID0gcmhvICogcmhvO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBy4bWiOiBSZXR1cm5zIHRoZSB6b29tLW91dCBmYWN0b3IgYXQgb25lIGVuZCBvZiB0aGUgYW5pbWF0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gaSAwIGZvciB0aGUgYXNjZW50IG9yIDEgZm9yIHRoZSBkZXNjZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gcihpKSB7XG4gICAgICAgICAgICB2YXIgYiA9ICh3MSAqIHcxIC0gdzAgKiB3MCArIChpID8gLTEgOiAxKSAqIHJobzIgKiByaG8yICogdTEgKiB1MSkgLyAoMiAqIChpID8gdzEgOiB3MCkgKiByaG8yICogdTEpO1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgubG9nKE1hdGguc3FydChiICogYiArIDEpIC0gYik7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBzaW5oKG4pIHsgcmV0dXJuIChNYXRoLmV4cChuKSAtIE1hdGguZXhwKC1uKSkgLyAyOyB9XG4gICAgICAgIGZ1bmN0aW9uIGNvc2gobikgeyByZXR1cm4gKE1hdGguZXhwKG4pICsgTWF0aC5leHAoLW4pKSAvIDI7IH1cbiAgICAgICAgZnVuY3Rpb24gdGFuaChuKSB7IHJldHVybiBzaW5oKG4pIC8gY29zaChuKTsgfVxuXG4gICAgICAgIC8vIHLigoA6IFpvb20tb3V0IGZhY3RvciBkdXJpbmcgYXNjZW50LlxuICAgICAgICB2YXIgcjAgPSByKDApLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiB3KHMpOiBSZXR1cm5zIHRoZSB2aXNpYmxlIHNwYW4gb24gdGhlIGdyb3VuZCwgbWVhc3VyZWQgaW4gcGl4ZWxzIHdpdGggcmVzcGVjdCB0byB0aGVcbiAgICAgICAgICAgICAqIGluaXRpYWwgc2NhbGUuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQXNzdW1lcyBhbiBhbmd1bGFyIGZpZWxkIG9mIHZpZXcgb2YgMiBhcmN0YW4gwr0g4omIIDUzwrAuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHcgPSBmdW5jdGlvbiAocykgeyByZXR1cm4gKGNvc2gocjApIC8gY29zaChyMCArIHJobyAqIHMpKTsgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogdShzKTogUmV0dXJucyB0aGUgZGlzdGFuY2UgYWxvbmcgdGhlIGZsaWdodCBwYXRoIGFzIHByb2plY3RlZCBvbnRvIHRoZSBncm91bmQgcGxhbmUsXG4gICAgICAgICAgICAgKiBtZWFzdXJlZCBpbiBwaXhlbHMgZnJvbSB0aGUgd29ybGQgaW1hZ2Ugb3JpZ2luIGF0IHRoZSBpbml0aWFsIHNjYWxlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB1ID0gZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHcwICogKChjb3NoKHIwKSAqIHRhbmgocjAgKyByaG8gKiBzKSAtIHNpbmgocjApKSAvIHJobzIpIC8gdTE7IH0sXG4gICAgICAgICAgICAvLyBTOiBUb3RhbCBsZW5ndGggb2YgdGhlIGZsaWdodCBwYXRoLCBtZWFzdXJlZCBpbiDPgS1zY3JlZW5mdWxzLlxuICAgICAgICAgICAgUyA9IChyKDEpIC0gcjApIC8gcmhvO1xuXG4gICAgICAgIC8vIFdoZW4gdeKCgCA9IHXigoEsIHRoZSBvcHRpbWFsIHBhdGggZG9lc27igJl0IHJlcXVpcmUgYm90aCBhc2NlbnQgYW5kIGRlc2NlbnQuXG4gICAgICAgIGlmIChNYXRoLmFicyh1MSkgPCAwLjAwMDAwMSkge1xuICAgICAgICAgICAgLy8gUGVyZm9ybSBhIG1vcmUgb3IgbGVzcyBpbnN0YW50YW5lb3VzIHRyYW5zaXRpb24gaWYgdGhlIHBhdGggaXMgdG9vIHNob3J0LlxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHcwIC0gdzEpIDwgMC4wMDAwMDEpIHJldHVybiB0aGlzLmVhc2VUbyhvcHRpb25zKTtcblxuICAgICAgICAgICAgdmFyIGsgPSB3MSA8IHcwID8gLTEgOiAxO1xuICAgICAgICAgICAgUyA9IE1hdGguYWJzKE1hdGgubG9nKHcxIC8gdzApKSAvIHJobztcblxuICAgICAgICAgICAgdSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiAgICAgICAgICAgIHcgPSBmdW5jdGlvbihzKSB7IHJldHVybiBNYXRoLmV4cChrICogcmhvICogcyk7IH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoJ2R1cmF0aW9uJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICBvcHRpb25zLmR1cmF0aW9uID0gK29wdGlvbnMuZHVyYXRpb247XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgViA9ICdzY3JlZW5TcGVlZCcgaW4gb3B0aW9ucyA/ICtvcHRpb25zLnNjcmVlblNwZWVkIC8gcmhvIDogK29wdGlvbnMuc3BlZWQ7XG4gICAgICAgICAgICBvcHRpb25zLmR1cmF0aW9uID0gMTAwMCAqIFMgLyBWO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy56b29taW5nID0gdHJ1ZTtcbiAgICAgICAgaWYgKHN0YXJ0QmVhcmluZyAhPT0gYmVhcmluZykgdGhpcy5yb3RhdGluZyA9IHRydWU7XG4gICAgICAgIGlmIChzdGFydFBpdGNoICE9PSBwaXRjaCkgdGhpcy5waXRjaGluZyA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5maXJlKCdtb3Zlc3RhcnQnKTtcblxuICAgICAgICB0aGlzLl9lYXNlKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICAvLyBzOiBUaGUgZGlzdGFuY2UgdHJhdmVsZWQgYWxvbmcgdGhlIGZsaWdodCBwYXRoLCBtZWFzdXJlZCBpbiDPgS1zY3JlZW5mdWxzLlxuICAgICAgICAgICAgdmFyIHMgPSBrICogUyxcbiAgICAgICAgICAgICAgICB1cyA9IHUocyk7XG5cbiAgICAgICAgICAgIHRyLnpvb20gPSBzdGFydFpvb20gKyB0ci5zY2FsZVpvb20oMSAvIHcocykpO1xuICAgICAgICAgICAgdHIuY2VudGVyID0gdHIudW5wcm9qZWN0KGZyb20uYWRkKHRvLnN1Yihmcm9tKS5tdWx0KHVzKSksIHN0YXJ0V29ybGRTaXplKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMucm90YXRpbmcpIHtcbiAgICAgICAgICAgICAgICB0ci5iZWFyaW5nID0gaW50ZXJwb2xhdGUoc3RhcnRCZWFyaW5nLCBiZWFyaW5nLCBrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnBpdGNoaW5nKSB7XG4gICAgICAgICAgICAgICAgdHIucGl0Y2ggPSBpbnRlcnBvbGF0ZShzdGFydFBpdGNoLCBwaXRjaCwgayk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZmlyZSgnbW92ZScpLmZpcmUoJ3pvb20nKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJvdGF0aW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlKCdyb3RhdGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnBpdGNoaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlKCdwaXRjaCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuem9vbWluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5yb3RhdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5waXRjaGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5maXJlKCdtb3ZlZW5kJyk7XG4gICAgICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBpc0Vhc2luZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2Fib3J0Rm47XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN0b3AgY3VycmVudCBhbmltYXRpb25cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtNYXB9IGB0aGlzYFxuICAgICAqL1xuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fYWJvcnRGbikge1xuICAgICAgICAgICAgdGhpcy5fYWJvcnRGbigpO1xuICAgICAgICAgICAgdGhpcy5fZmluaXNoRWFzZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfZWFzZTogZnVuY3Rpb24oZnJhbWUsIGZpbmlzaCwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLl9maW5pc2hGbiA9IGZpbmlzaDtcbiAgICAgICAgdGhpcy5fYWJvcnRGbiA9IGJyb3dzZXIudGltZWQoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIGZyYW1lLmNhbGwodGhpcywgb3B0aW9ucy5lYXNpbmcodCkpO1xuICAgICAgICAgICAgaWYgKHQgPT09IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9maW5pc2hFYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIG9wdGlvbnMuYW5pbWF0ZSA9PT0gZmFsc2UgPyAwIDogb3B0aW9ucy5kdXJhdGlvbiwgdGhpcyk7XG4gICAgfSxcblxuICAgIF9maW5pc2hFYXNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2Fib3J0Rm47XG4gICAgICAgIC8vIFRoZSBmaW5pc2ggZnVuY3Rpb24gbWlnaHQgZW1pdCBldmVudHMgd2hpY2ggdHJpZ2dlciBuZXcgZWFzZXMsIHdoaWNoXG4gICAgICAgIC8vIHNldCBhIG5ldyBfZmluaXNoRm4uIEVuc3VyZSB3ZSBkb24ndCBkZWxldGUgaXQgdW5pbnRlbnRpb25hbGx5LlxuICAgICAgICB2YXIgZmluaXNoID0gdGhpcy5fZmluaXNoRm47XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9maW5pc2hGbjtcbiAgICAgICAgZmluaXNoLmNhbGwodGhpcyk7XG4gICAgfSxcblxuICAgIC8vIGNvbnZlcnQgYmVhcmluZyBzbyB0aGF0IGl0J3MgbnVtZXJpY2FsbHkgY2xvc2UgdG8gdGhlIGN1cnJlbnQgb25lIHNvIHRoYXQgaXQgaW50ZXJwb2xhdGVzIHByb3Blcmx5XG4gICAgX25vcm1hbGl6ZUJlYXJpbmc6IGZ1bmN0aW9uKGJlYXJpbmcsIGN1cnJlbnRCZWFyaW5nKSB7XG4gICAgICAgIGJlYXJpbmcgPSB1dGlsLndyYXAoYmVhcmluZywgLTE4MCwgMTgwKTtcbiAgICAgICAgdmFyIGRpZmYgPSBNYXRoLmFicyhiZWFyaW5nIC0gY3VycmVudEJlYXJpbmcpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoYmVhcmluZyAtIDM2MCAtIGN1cnJlbnRCZWFyaW5nKSA8IGRpZmYpIGJlYXJpbmcgLT0gMzYwO1xuICAgICAgICBpZiAoTWF0aC5hYnMoYmVhcmluZyArIDM2MCAtIGN1cnJlbnRCZWFyaW5nKSA8IGRpZmYpIGJlYXJpbmcgKz0gMzYwO1xuICAgICAgICByZXR1cm4gYmVhcmluZztcbiAgICB9LFxuXG4gICAgX3VwZGF0ZUVhc2luZzogZnVuY3Rpb24oZHVyYXRpb24sIHpvb20sIGJlemllcikge1xuICAgICAgICB2YXIgZWFzaW5nO1xuXG4gICAgICAgIGlmICh0aGlzLmVhc2UpIHtcbiAgICAgICAgICAgIHZhciBlYXNlID0gdGhpcy5lYXNlLFxuICAgICAgICAgICAgICAgIHQgPSAoRGF0ZS5ub3coKSAtIGVhc2Uuc3RhcnQpIC8gZWFzZS5kdXJhdGlvbixcbiAgICAgICAgICAgICAgICBzcGVlZCA9IGVhc2UuZWFzaW5nKHQgKyAwLjAxKSAtIGVhc2UuZWFzaW5nKHQpLFxuXG4gICAgICAgICAgICAgICAgLy8gUXVpY2sgaGFjayB0byBtYWtlIG5ldyBiZXppZXIgdGhhdCBpcyBjb250aW51b3VzIHdpdGggbGFzdFxuICAgICAgICAgICAgICAgIHggPSAwLjI3IC8gTWF0aC5zcXJ0KHNwZWVkICogc3BlZWQgKyAwLjAwMDEpICogMC4wMSxcbiAgICAgICAgICAgICAgICB5ID0gTWF0aC5zcXJ0KDAuMjcgKiAwLjI3IC0geCAqIHgpO1xuXG4gICAgICAgICAgICBlYXNpbmcgPSB1dGlsLmJlemllcih4LCB5LCAwLjI1LCAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVhc2luZyA9IGJlemllciA/IHV0aWwuYmV6aWVyLmFwcGx5KHV0aWwsIGJlemllcikgOiB1dGlsLmVhc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzdG9yZSBpbmZvcm1hdGlvbiBvbiBjdXJyZW50IGVhc2luZ1xuICAgICAgICB0aGlzLmVhc2UgPSB7XG4gICAgICAgICAgICBzdGFydDogKG5ldyBEYXRlKCkpLmdldFRpbWUoKSxcbiAgICAgICAgICAgIHRvOiBNYXRoLnBvdygyLCB6b29tKSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcbiAgICAgICAgICAgIGVhc2luZzogZWFzaW5nXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGVhc2luZztcbiAgICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIENvbnRyb2wgPSByZXF1aXJlKCcuL2NvbnRyb2wnKTtcbnZhciBET00gPSByZXF1aXJlKCcuLi8uLi91dGlsL2RvbScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL3V0aWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBBdHRyaWJ1dGlvbjtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGF0dHJpYnV0aW9uIGNvbnRyb2xcbiAqIEBjbGFzcyBBdHRyaWJ1dGlvblxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBvc2l0aW9uPSdib3R0b20tcmlnaHQnXSBBIHN0cmluZyBpbmRpY2F0aW5nIHRoZSBjb250cm9sJ3MgcG9zaXRpb24gb24gdGhlIG1hcC4gT3B0aW9ucyBhcmUgYHRvcC1yaWdodGAsIGB0b3AtbGVmdGAsIGBib3R0b20tcmlnaHRgLCBgYm90dG9tLWxlZnRgXG4gKiBAZXhhbXBsZVxuICogdmFyIG1hcCA9IG5ldyBtYXBib3hnbC5NYXAoe2F0dHJpYnV0aW9uQ29udHJvOiBmYWxzZX0pXG4gKiAgICAgLmFkZENvbnRyb2wobmV3IG1hcGJveGdsLk5hdmlnYXRpb24oe3Bvc2l0aW9uOiAndG9wLWxlZnQnfSkpO1xuICovXG5mdW5jdGlvbiBBdHRyaWJ1dGlvbihvcHRpb25zKSB7XG4gICAgdXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xufVxuXG5BdHRyaWJ1dGlvbi5wcm90b3R5cGUgPSB1dGlsLmluaGVyaXQoQ29udHJvbCwge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgcG9zaXRpb246ICdib3R0b20tcmlnaHQnXG4gICAgfSxcblxuICAgIG9uQWRkOiBmdW5jdGlvbihtYXApIHtcbiAgICAgICAgdmFyIGNsYXNzTmFtZSA9ICdtYXBib3hnbC1jdHJsLWF0dHJpYicsXG4gICAgICAgICAgICBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSBET00uY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUsIG1hcC5nZXRDb250YWluZXIoKSk7XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgICAgIG1hcC5vbignc291cmNlLmxvYWQnLCB0aGlzLl91cGRhdGUuYmluZCh0aGlzKSk7XG4gICAgICAgIG1hcC5vbignc291cmNlLmNoYW5nZScsIHRoaXMuX3VwZGF0ZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgbWFwLm9uKCdzb3VyY2UucmVtb3ZlJywgdGhpcy5fdXBkYXRlLmJpbmQodGhpcykpO1xuICAgICAgICBtYXAub24oJ21vdmVlbmQnLCB0aGlzLl91cGRhdGVFZGl0TGluay5iaW5kKHRoaXMpKTtcblxuICAgICAgICByZXR1cm4gY29udGFpbmVyO1xuICAgIH0sXG5cbiAgICBfdXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0aW9ucyA9IFtdO1xuXG4gICAgICAgIGlmICh0aGlzLl9tYXAuc3R5bGUpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGlkIGluIHRoaXMuX21hcC5zdHlsZS5zb3VyY2VzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuX21hcC5zdHlsZS5zb3VyY2VzW2lkXTtcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlLmF0dHJpYnV0aW9uICYmIGF0dHJpYnV0aW9ucy5pbmRleE9mKHNvdXJjZS5hdHRyaWJ1dGlvbikgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0aW9ucy5wdXNoKHNvdXJjZS5hdHRyaWJ1dGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY29udGFpbmVyLmlubmVySFRNTCA9IGF0dHJpYnV0aW9ucy5qb2luKCcgfCAnKTtcbiAgICAgICAgdGhpcy5fZWRpdExpbmsgPSB0aGlzLl9jb250YWluZXIuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnbWFwYm94LWltcHJvdmUtbWFwJylbMF07XG4gICAgICAgIHRoaXMuX3VwZGF0ZUVkaXRMaW5rKCk7XG4gICAgfSxcblxuICAgIF91cGRhdGVFZGl0TGluazogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9lZGl0TGluaykge1xuICAgICAgICAgICAgdmFyIGNlbnRlciA9IHRoaXMuX21hcC5nZXRDZW50ZXIoKTtcbiAgICAgICAgICAgIHRoaXMuX2VkaXRMaW5rLmhyZWYgPSAnaHR0cHM6Ly93d3cubWFwYm94LmNvbS9tYXAtZmVlZGJhY2svIy8nICtcbiAgICAgICAgICAgICAgICAgICAgY2VudGVyLmxuZyArICcvJyArIGNlbnRlci5sYXQgKyAnLycgKyBNYXRoLnJvdW5kKHRoaXMuX21hcC5nZXRab29tKCkgKyAxKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRyb2w7XG5cbi8qKlxuICogQSBiYXNlIGNsYXNzIGZvciBtYXAtcmVsYXRlZCBpbnRlcmZhY2UgZWxlbWVudHMuXG4gKlxuICogQGNsYXNzIENvbnRyb2xcbiAqL1xuZnVuY3Rpb24gQ29udHJvbCgpIHt9XG5cbkNvbnRyb2wucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIEFkZCB0aGlzIGNvbnRyb2wgdG8gdGhlIG1hcCwgcmV0dXJuaW5nIHRoZSBjb250cm9sIGl0c2VsZlxuICAgICAqIGZvciBjaGFpbmluZy4gVGhpcyB3aWxsIGluc2VydCB0aGUgY29udHJvbCdzIERPTSBlbGVtZW50IGludG9cbiAgICAgKiB0aGUgbWFwJ3MgRE9NIGVsZW1lbnQgaWYgdGhlIGNvbnRyb2wgaGFzIGEgYHBvc2l0aW9uYCBzcGVjaWZpZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge01hcH0gbWFwXG4gICAgICogQHJldHVybnMge0NvbnRyb2x9IGB0aGlzYFxuICAgICAqL1xuICAgIGFkZFRvOiBmdW5jdGlvbihtYXApIHtcbiAgICAgICAgdGhpcy5fbWFwID0gbWFwO1xuICAgICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gdGhpcy5vbkFkZChtYXApO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5wb3NpdGlvbikge1xuICAgICAgICAgICAgdmFyIHBvcyA9IHRoaXMub3B0aW9ucy5wb3NpdGlvbjtcbiAgICAgICAgICAgIHZhciBjb3JuZXIgPSBtYXAuX2NvbnRyb2xDb3JuZXJzW3Bvc107XG4gICAgICAgICAgICBjb250YWluZXIuY2xhc3NOYW1lICs9ICcgbWFwYm94Z2wtY3RybCc7XG4gICAgICAgICAgICBpZiAocG9zLmluZGV4T2YoJ2JvdHRvbScpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGNvcm5lci5pbnNlcnRCZWZvcmUoY29udGFpbmVyLCBjb3JuZXIuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvcm5lci5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSB0aGlzIGNvbnRyb2wgZnJvbSB0aGUgbWFwIGl0IGhhcyBiZWVuIGFkZGVkIHRvLlxuICAgICAqXG4gICAgICogQHJldHVybnMge0NvbnRyb2x9IGB0aGlzYFxuICAgICAqL1xuICAgIHJlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX2NvbnRhaW5lci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuX2NvbnRhaW5lcik7XG4gICAgICAgIGlmICh0aGlzLm9uUmVtb3ZlKSB0aGlzLm9uUmVtb3ZlKHRoaXMuX21hcCk7XG4gICAgICAgIHRoaXMuX21hcCA9IG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBDb250cm9sID0gcmVxdWlyZSgnLi9jb250cm9sJyk7XG52YXIgRE9NID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9kb20nKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC91dGlsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gTmF2aWdhdGlvbjtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmF2aWdhdGlvbiBjb250cm9sIHdpdGggem9vbSBidXR0b25zIGFuZCBhIGNvbXBhc3NcbiAqIEBjbGFzcyBOYXZpZ2F0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucG9zaXRpb249J3RvcC1yaWdodCddIEEgc3RyaW5nIGluZGljYXRpbmcgdGhlIGNvbnRyb2wncyBwb3NpdGlvbiBvbiB0aGUgbWFwLiBPcHRpb25zIGFyZSBgdG9wLXJpZ2h0YCwgYHRvcC1sZWZ0YCwgYGJvdHRvbS1yaWdodGAsIGBib3R0b20tbGVmdGBcbiAqIEBleGFtcGxlXG4gKiBtYXAuYWRkQ29udHJvbChuZXcgbWFwYm94Z2wuTmF2aWdhdGlvbih7cG9zaXRpb246ICd0b3AtbGVmdCd9KSk7IC8vIHBvc2l0aW9uIGlzIG9wdGlvbmFsXG4gKi9cbmZ1bmN0aW9uIE5hdmlnYXRpb24ob3B0aW9ucykge1xuICAgIHV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcbn1cblxuTmF2aWdhdGlvbi5wcm90b3R5cGUgPSB1dGlsLmluaGVyaXQoQ29udHJvbCwge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgcG9zaXRpb246ICd0b3AtcmlnaHQnXG4gICAgfSxcblxuICAgIG9uQWRkOiBmdW5jdGlvbihtYXApIHtcbiAgICAgICAgdmFyIGNsYXNzTmFtZSA9ICdtYXBib3hnbC1jdHJsJztcblxuICAgICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gRE9NLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lICsgJy1ncm91cCcsIG1hcC5nZXRDb250YWluZXIoKSk7XG4gICAgICAgIHRoaXMuX2NvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIHRoaXMuX29uQ29udGV4dE1lbnUuYmluZCh0aGlzKSk7XG5cbiAgICAgICAgdGhpcy5fem9vbUluQnV0dG9uID0gdGhpcy5fY3JlYXRlQnV0dG9uKGNsYXNzTmFtZSArICctaWNvbiAnICsgY2xhc3NOYW1lICsgJy16b29tLWluJywgbWFwLnpvb21Jbi5iaW5kKG1hcCkpO1xuICAgICAgICB0aGlzLl96b29tT3V0QnV0dG9uID0gdGhpcy5fY3JlYXRlQnV0dG9uKGNsYXNzTmFtZSArICctaWNvbiAnICsgY2xhc3NOYW1lICsgJy16b29tLW91dCcsIG1hcC56b29tT3V0LmJpbmQobWFwKSk7XG4gICAgICAgIHRoaXMuX2NvbXBhc3MgPSB0aGlzLl9jcmVhdGVCdXR0b24oY2xhc3NOYW1lICsgJy1pY29uICcgKyBjbGFzc05hbWUgKyAnLWNvbXBhc3MnLCBtYXAucmVzZXROb3J0aC5iaW5kKG1hcCkpO1xuXG4gICAgICAgIHRoaXMuX2NvbXBhc3NBcnJvdyA9IERPTS5jcmVhdGUoJ2RpdicsICdhcnJvdycsIHRoaXMuX2NvbXBhc3MpO1xuXG4gICAgICAgIHRoaXMuX2NvbXBhc3MuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5fb25Db21wYXNzRG93bi5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5fb25Db21wYXNzTW92ZSA9IHRoaXMuX29uQ29tcGFzc01vdmUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5fb25Db21wYXNzVXAgPSB0aGlzLl9vbkNvbXBhc3NVcC5iaW5kKHRoaXMpO1xuXG4gICAgICAgIG1hcC5vbigncm90YXRlJywgdGhpcy5fcm90YXRlQ29tcGFzc0Fycm93LmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLl9yb3RhdGVDb21wYXNzQXJyb3coKTtcblxuICAgICAgICB0aGlzLl9lbCA9IG1hcC5nZXRDYW52YXNDb250YWluZXIoKTtcblxuICAgICAgICByZXR1cm4gY29udGFpbmVyO1xuICAgIH0sXG5cbiAgICBfb25Db250ZXh0TWVudTogZnVuY3Rpb24oZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSxcblxuICAgIF9vbkNvbXBhc3NEb3duOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmIChlLmJ1dHRvbiAhPT0gMCkgcmV0dXJuO1xuXG4gICAgICAgIERPTS5kaXNhYmxlRHJhZygpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9vbkNvbXBhc3NNb3ZlKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX29uQ29tcGFzc1VwKTtcblxuICAgICAgICB0aGlzLl9lbC5kaXNwYXRjaEV2ZW50KGNvcHlNb3VzZUV2ZW50KGUpKTtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9LFxuXG4gICAgX29uQ29tcGFzc01vdmU6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKGUuYnV0dG9uICE9PSAwKSByZXR1cm47XG5cbiAgICAgICAgdGhpcy5fZWwuZGlzcGF0Y2hFdmVudChjb3B5TW91c2VFdmVudChlKSk7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSxcblxuICAgIF9vbkNvbXBhc3NVcDogZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoZS5idXR0b24gIT09IDApIHJldHVybjtcblxuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9vbkNvbXBhc3NNb3ZlKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX29uQ29tcGFzc1VwKTtcbiAgICAgICAgRE9NLmVuYWJsZURyYWcoKTtcblxuICAgICAgICB0aGlzLl9lbC5kaXNwYXRjaEV2ZW50KGNvcHlNb3VzZUV2ZW50KGUpKTtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9LFxuXG4gICAgX2NyZWF0ZUJ1dHRvbjogZnVuY3Rpb24oY2xhc3NOYW1lLCBmbikge1xuICAgICAgICB2YXIgYSA9IERPTS5jcmVhdGUoJ2J1dHRvbicsIGNsYXNzTmFtZSwgdGhpcy5fY29udGFpbmVyKTtcbiAgICAgICAgYS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKCkgeyBmbigpOyB9KTtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfSxcblxuICAgIF9yb3RhdGVDb21wYXNzQXJyb3c6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcm90YXRlID0gJ3JvdGF0ZSgnICsgKHRoaXMuX21hcC50cmFuc2Zvcm0uYW5nbGUgKiAoMTgwIC8gTWF0aC5QSSkpICsgJ2RlZyknO1xuICAgICAgICB0aGlzLl9jb21wYXNzQXJyb3cuc3R5bGUudHJhbnNmb3JtID0gcm90YXRlO1xuICAgIH1cbn0pO1xuXG5cbmZ1bmN0aW9uIGNvcHlNb3VzZUV2ZW50KGUpIHtcbiAgICByZXR1cm4gbmV3IE1vdXNlRXZlbnQoZS50eXBlLCB7XG4gICAgICAgIGJ1dHRvbjogMiwgICAgLy8gcmlnaHQgY2xpY2tcbiAgICAgICAgYnV0dG9uczogMiwgICAvLyByaWdodCBjbGlja1xuICAgICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgICBkZXRhaWw6IGUuZGV0YWlsLFxuICAgICAgICB2aWV3OiBlLnZpZXcsXG4gICAgICAgIHNjcmVlblg6IGUuc2NyZWVuWCxcbiAgICAgICAgc2NyZWVuWTogZS5zY3JlZW5ZLFxuICAgICAgICBjbGllbnRYOiBlLmNsaWVudFgsXG4gICAgICAgIGNsaWVudFk6IGUuY2xpZW50WSxcbiAgICAgICAgbW92ZW1lbnRYOiBlLm1vdmVtZW50WCxcbiAgICAgICAgbW92ZW1lbnRZOiBlLm1vdmVtZW50WSxcbiAgICAgICAgY3RybEtleTogZS5jdHJsS2V5LFxuICAgICAgICBzaGlmdEtleTogZS5zaGlmdEtleSxcbiAgICAgICAgYWx0S2V5OiBlLmFsdEtleSxcbiAgICAgICAgbWV0YUtleTogZS5tZXRhS2V5XG4gICAgfSk7XG59XG5cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIERPTSA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvZG9tJyksXG4gICAgTG5nTGF0Qm91bmRzID0gcmVxdWlyZSgnLi4vLi4vZ2VvL2xuZ19sYXRfYm91bmRzJyksXG4gICAgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvdXRpbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJveFpvb207XG5cblxuZnVuY3Rpb24gQm94Wm9vbShtYXApIHtcbiAgICB0aGlzLl9tYXAgPSBtYXA7XG4gICAgdGhpcy5fZWwgPSBtYXAuZ2V0Q2FudmFzQ29udGFpbmVyKCk7XG4gICAgdGhpcy5fY29udGFpbmVyID0gbWFwLmdldENvbnRhaW5lcigpO1xuXG4gICAgdXRpbC5iaW5kSGFuZGxlcnModGhpcyk7XG59XG5cbkJveFpvb20ucHJvdG90eXBlID0ge1xuICAgIGVuYWJsZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9lbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9vbk1vdXNlRG93biwgZmFsc2UpO1xuICAgIH0sXG5cbiAgICBkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2VsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuX29uTW91c2VEb3duKTtcbiAgICB9LFxuXG4gICAgX29uTW91c2VEb3duOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoIShlLnNoaWZ0S2V5ICYmIGUuYnV0dG9uID09PSAwKSkgcmV0dXJuO1xuXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCBmYWxzZSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9vbktleURvd24sIGZhbHNlKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX29uTW91c2VVcCwgZmFsc2UpO1xuXG4gICAgICAgIHRoaXMuX3N0YXJ0UG9zID0gRE9NLm1vdXNlUG9zKHRoaXMuX2VsLCBlKTtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICAgIH0sXG5cbiAgICBfb25Nb3VzZU1vdmU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBwMCA9IHRoaXMuX3N0YXJ0UG9zLFxuICAgICAgICAgICAgcDEgPSBET00ubW91c2VQb3ModGhpcy5fZWwsIGUpO1xuXG4gICAgICAgIGlmICghdGhpcy5fYm94KSB7XG4gICAgICAgICAgICB0aGlzLl9ib3ggPSBET00uY3JlYXRlKCdkaXYnLCAnbWFwYm94Z2wtYm94em9vbScsIHRoaXMuX2NvbnRhaW5lcik7XG4gICAgICAgICAgICB0aGlzLl9jb250YWluZXIuY2xhc3NMaXN0LmFkZCgnbWFwYm94Z2wtY3Jvc3NoYWlyJyk7XG5cbiAgICAgICAgICAgIERPTS5kaXNhYmxlRHJhZygpO1xuXG4gICAgICAgICAgICB0aGlzLl9maXJlRXZlbnQoJ2JveHpvb21zdGFydCcsIGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1pblggPSBNYXRoLm1pbihwMC54LCBwMS54KSxcbiAgICAgICAgICAgIG1heFggPSBNYXRoLm1heChwMC54LCBwMS54KSxcbiAgICAgICAgICAgIG1pblkgPSBNYXRoLm1pbihwMC55LCBwMS55KSxcbiAgICAgICAgICAgIG1heFkgPSBNYXRoLm1heChwMC55LCBwMS55KTtcblxuICAgICAgICBET00uc2V0VHJhbnNmb3JtKHRoaXMuX2JveCwgJ3RyYW5zbGF0ZSgnICsgbWluWCArICdweCwnICsgbWluWSArICdweCknKTtcblxuICAgICAgICB0aGlzLl9ib3guc3R5bGUud2lkdGggPSAobWF4WCAtIG1pblgpICsgJ3B4JztcbiAgICAgICAgdGhpcy5fYm94LnN0eWxlLmhlaWdodCA9IChtYXhZIC0gbWluWSkgKyAncHgnO1xuICAgIH0sXG5cbiAgICBfb25Nb3VzZVVwOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoZS5idXR0b24gIT09IDApIHJldHVybjtcblxuICAgICAgICB2YXIgcDAgPSB0aGlzLl9zdGFydFBvcyxcbiAgICAgICAgICAgIHAxID0gRE9NLm1vdXNlUG9zKHRoaXMuX2VsLCBlKSxcbiAgICAgICAgICAgIGJvdW5kcyA9IG5ldyBMbmdMYXRCb3VuZHModGhpcy5fbWFwLnVucHJvamVjdChwMCksIHRoaXMuX21hcC51bnByb2plY3QocDEpKTtcblxuICAgICAgICB0aGlzLl9maW5pc2goKTtcblxuICAgICAgICBpZiAocDAueCA9PT0gcDEueCAmJiBwMC55ID09PSBwMS55KSB7XG4gICAgICAgICAgICB0aGlzLl9maXJlRXZlbnQoJ2JveHpvb21jYW5jZWwnLCBlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX21hcFxuICAgICAgICAgICAgICAgIC5maXRCb3VuZHMoYm91bmRzLCB7bGluZWFyOiB0cnVlfSlcbiAgICAgICAgICAgICAgICAuZmlyZSgnYm94em9vbWVuZCcsIHsgb3JpZ2luYWxFdmVudDogZSwgYm94Wm9vbUJvdW5kczogYm91bmRzIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9vbktleURvd246IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChlLmtleUNvZGUgPT09IDI3KSB7XG4gICAgICAgICAgICB0aGlzLl9maW5pc2goKTtcbiAgICAgICAgICAgIHRoaXMuX2ZpcmVFdmVudCgnYm94em9vbWNhbmNlbCcsIGUpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9maW5pc2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcblxuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSwgZmFsc2UpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5fb25LZXlEb3duLCBmYWxzZSk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9vbk1vdXNlVXAsIGZhbHNlKTtcblxuICAgICAgICB0aGlzLl9jb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZSgnbWFwYm94Z2wtY3Jvc3NoYWlyJyk7XG5cbiAgICAgICAgaWYgKHRoaXMuX2JveCkge1xuICAgICAgICAgICAgdGhpcy5fYm94LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5fYm94KTtcbiAgICAgICAgICAgIHRoaXMuX2JveCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBET00uZW5hYmxlRHJhZygpO1xuICAgIH0sXG5cbiAgICBfZmlyZUV2ZW50OiBmdW5jdGlvbiAodHlwZSwgZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLmZpcmUodHlwZSwgeyBvcmlnaW5hbEV2ZW50OiBlIH0pO1xuICAgIH1cbn07XG5cbi8qKlxuICogQm94em9vbSBzdGFydCBldmVudC4gVGhpcyBldmVudCBpcyBlbWl0dGVkIGF0IHRoZSBzdGFydCBvZiBhIGJveCB6b29tIGludGVyYWN0aW9uLlxuICpcbiAqIEBldmVudCBib3h6b29tc3RhcnRcbiAqIEBtZW1iZXJvZiBNYXBcbiAqIEBpbnN0YW5jZVxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcm9wZXJ0eSB7RXZlbnR9IG9yaWdpbmFsRXZlbnQgdGhlIG9yaWdpbmFsIERPTSBldmVudFxuICovXG5cbi8qKlxuICogQm94em9vbSBlbmQgZXZlbnQuIFRoaXMgZXZlbnQgaXMgZW1pdHRlZCBhdCB0aGUgZW5kIG9mIGEgYm94IHpvb20gaW50ZXJhY3Rpb25cbiAqXG4gKiBAZXZlbnQgYm94em9vbWVuZFxuICogQG1lbWJlcm9mIE1hcFxuICogQGluc3RhbmNlXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByb3BlcnR5IHtFdmVudH0gb3JpZ2luYWxFdmVudCB0aGUgb3JpZ2luYWwgRE9NIGV2ZW50XG4gKiBAcHJvcGVydHkge0xuZ0xhdEJvdW5kc30gYm94Wm9vbUJvdW5kcyB0aGUgYm91bmRzIG9mIHRoZSBib3ggem9vbSB0YXJnZXRcbiAqL1xuXG4vKipcbiAqIEJveHpvb20gY2FuY2VsIGV2ZW50LiAgVGhpcyBldmVudCBpcyBlbWl0dGVkIHdoZW4gdGhlIHVzZXIgY2FuY2VscyBhIGJveCB6b29tIGludGVyYWN0aW9uLFxuICogICBvciB3aGVuIHRoZSBib3ggem9vbSBkb2VzIG5vdCBtZWV0IHRoZSBtaW5pbXVtIHNpemUgdGhyZXNob2xkLlxuICpcbiAqIEBldmVudCBib3h6b29tY2FuY2VsXG4gKiBAbWVtYmVyb2YgTWFwXG4gKiBAaW5zdGFuY2VcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJvcGVydHkge0V2ZW50fSBvcmlnaW5hbEV2ZW50IHRoZSBvcmlnaW5hbCBET00gZXZlbnRcbiAqL1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERvdWJsZUNsaWNrWm9vbTtcblxuZnVuY3Rpb24gRG91YmxlQ2xpY2tab29tKG1hcCkge1xuICAgIHRoaXMuX21hcCA9IG1hcDtcbiAgICB0aGlzLl9vbkRibENsaWNrID0gdGhpcy5fb25EYmxDbGljay5iaW5kKHRoaXMpO1xufVxuXG5Eb3VibGVDbGlja1pvb20ucHJvdG90eXBlID0ge1xuICAgIGVuYWJsZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9tYXAub24oJ2RibGNsaWNrJywgdGhpcy5fb25EYmxDbGljayk7XG4gICAgfSxcblxuICAgIGRpc2FibGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fbWFwLm9mZignZGJsY2xpY2snLCB0aGlzLl9vbkRibENsaWNrKTtcbiAgICB9LFxuXG4gICAgX29uRGJsQ2xpY2s6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHRoaXMuX21hcC56b29tVG8odGhpcy5fbWFwLmdldFpvb20oKSArXG4gICAgICAgICAgICAoZS5vcmlnaW5hbEV2ZW50LnNoaWZ0S2V5ID8gLTEgOiAxKSwge2Fyb3VuZDogZS5sbmdMYXR9KTtcbiAgICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRE9NID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9kb20nKSxcbiAgICB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC91dGlsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gRHJhZ1BhbjtcblxudmFyIGluZXJ0aWFMaW5lYXJpdHkgPSAwLjMsXG4gICAgaW5lcnRpYUVhc2luZyA9IHV0aWwuYmV6aWVyKDAsIDAsIGluZXJ0aWFMaW5lYXJpdHksIDEpLFxuICAgIGluZXJ0aWFNYXhTcGVlZCA9IDE0MDAsIC8vIHB4L3NcbiAgICBpbmVydGlhRGVjZWxlcmF0aW9uID0gMjUwMDsgLy8gcHgvc14yXG5cblxuZnVuY3Rpb24gRHJhZ1BhbihtYXApIHtcbiAgICB0aGlzLl9tYXAgPSBtYXA7XG4gICAgdGhpcy5fZWwgPSBtYXAuZ2V0Q2FudmFzQ29udGFpbmVyKCk7XG5cbiAgICB1dGlsLmJpbmRIYW5kbGVycyh0aGlzKTtcbn1cblxuRHJhZ1Bhbi5wcm90b3R5cGUgPSB7XG4gICAgZW5hYmxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2VsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuX29uRG93bik7XG4gICAgICAgIHRoaXMuX2VsLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLl9vbkRvd24pO1xuICAgIH0sXG5cbiAgICBkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2VsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuX29uRG93bik7XG4gICAgICAgIHRoaXMuX2VsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLl9vbkRvd24pO1xuICAgIH0sXG5cbiAgICBfb25Eb3duOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAodGhpcy5faWdub3JlRXZlbnQoZSkpIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlKSByZXR1cm47XG5cbiAgICAgICAgaWYgKGUudG91Y2hlcykge1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5fb25Nb3ZlKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5fb25Ub3VjaEVuZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdmUpO1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX29uTW91c2VVcCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9zdGFydFBvcyA9IHRoaXMuX3BvcyA9IERPTS5tb3VzZVBvcyh0aGlzLl9lbCwgZSk7XG4gICAgICAgIHRoaXMuX2luZXJ0aWEgPSBbW0RhdGUubm93KCksIHRoaXMuX3Bvc11dO1xuICAgIH0sXG5cbiAgICBfb25Nb3ZlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAodGhpcy5faWdub3JlRXZlbnQoZSkpIHJldHVybjtcblxuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9maXJlRXZlbnQoJ2RyYWdzdGFydCcsIGUpO1xuICAgICAgICAgICAgdGhpcy5fZmlyZUV2ZW50KCdtb3Zlc3RhcnQnLCBlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwb3MgPSBET00ubW91c2VQb3ModGhpcy5fZWwsIGUpLFxuICAgICAgICAgICAgbWFwID0gdGhpcy5fbWFwO1xuXG4gICAgICAgIG1hcC5zdG9wKCk7XG4gICAgICAgIHRoaXMuX2RyYWluSW5lcnRpYUJ1ZmZlcigpO1xuICAgICAgICB0aGlzLl9pbmVydGlhLnB1c2goW0RhdGUubm93KCksIHBvc10pO1xuXG4gICAgICAgIG1hcC50cmFuc2Zvcm0uc2V0TG9jYXRpb25BdFBvaW50KG1hcC50cmFuc2Zvcm0ucG9pbnRMb2NhdGlvbih0aGlzLl9wb3MpLCBwb3MpO1xuXG4gICAgICAgIHRoaXMuX2ZpcmVFdmVudCgnZHJhZycsIGUpO1xuICAgICAgICB0aGlzLl9maXJlRXZlbnQoJ21vdmUnLCBlKTtcblxuICAgICAgICB0aGlzLl9wb3MgPSBwb3M7XG5cbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0sXG5cbiAgICBfb25VcDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZSkgcmV0dXJuO1xuXG4gICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2ZpcmVFdmVudCgnZHJhZ2VuZCcsIGUpO1xuICAgICAgICB0aGlzLl9kcmFpbkluZXJ0aWFCdWZmZXIoKTtcblxuICAgICAgICB2YXIgZmluaXNoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLl9maXJlRXZlbnQoJ21vdmVlbmQnLCBlKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgICAgIHZhciBpbmVydGlhID0gdGhpcy5faW5lcnRpYTtcbiAgICAgICAgaWYgKGluZXJ0aWEubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGFzdCA9IGluZXJ0aWFbaW5lcnRpYS5sZW5ndGggLSAxXSxcbiAgICAgICAgICAgIGZpcnN0ID0gaW5lcnRpYVswXSxcbiAgICAgICAgICAgIGZsaW5nT2Zmc2V0ID0gbGFzdFsxXS5zdWIoZmlyc3RbMV0pLFxuICAgICAgICAgICAgZmxpbmdEdXJhdGlvbiA9IChsYXN0WzBdIC0gZmlyc3RbMF0pIC8gMTAwMDtcblxuICAgICAgICBpZiAoZmxpbmdEdXJhdGlvbiA9PT0gMCB8fCBsYXN0WzFdLmVxdWFscyhmaXJzdFsxXSkpIHtcbiAgICAgICAgICAgIGZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHB4L3MgdmVsb2NpdHkgJiBhZGp1c3QgZm9yIGluY3JlYXNlZCBpbml0aWFsIGFuaW1hdGlvbiBzcGVlZCB3aGVuIGVhc2luZyBvdXRcbiAgICAgICAgdmFyIHZlbG9jaXR5ID0gZmxpbmdPZmZzZXQubXVsdChpbmVydGlhTGluZWFyaXR5IC8gZmxpbmdEdXJhdGlvbiksXG4gICAgICAgICAgICBzcGVlZCA9IHZlbG9jaXR5Lm1hZygpOyAvLyBweC9zXG5cbiAgICAgICAgaWYgKHNwZWVkID4gaW5lcnRpYU1heFNwZWVkKSB7XG4gICAgICAgICAgICBzcGVlZCA9IGluZXJ0aWFNYXhTcGVlZDtcbiAgICAgICAgICAgIHZlbG9jaXR5Ll91bml0KCkuX211bHQoc3BlZWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGR1cmF0aW9uID0gc3BlZWQgLyAoaW5lcnRpYURlY2VsZXJhdGlvbiAqIGluZXJ0aWFMaW5lYXJpdHkpLFxuICAgICAgICAgICAgb2Zmc2V0ID0gdmVsb2NpdHkubXVsdCgtZHVyYXRpb24gLyAyKTtcblxuICAgICAgICB0aGlzLl9tYXAucGFuQnkob2Zmc2V0LCB7XG4gICAgICAgICAgICBkdXJhdGlvbjogZHVyYXRpb24gKiAxMDAwLFxuICAgICAgICAgICAgZWFzaW5nOiBpbmVydGlhRWFzaW5nLFxuICAgICAgICAgICAgbm9Nb3ZlU3RhcnQ6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIF9vbk1vdXNlVXA6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICh0aGlzLl9pZ25vcmVFdmVudChlKSkgcmV0dXJuO1xuICAgICAgICB0aGlzLl9vblVwKGUpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdmUpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5fb25Nb3VzZVVwKTtcbiAgICB9LFxuXG4gICAgX29uVG91Y2hFbmQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICh0aGlzLl9pZ25vcmVFdmVudChlKSkgcmV0dXJuO1xuICAgICAgICB0aGlzLl9vblVwKGUpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl9vbk1vdmUpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX29uVG91Y2hFbmQpO1xuICAgIH0sXG5cbiAgICBfZmlyZUV2ZW50OiBmdW5jdGlvbiAodHlwZSwgZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLmZpcmUodHlwZSwgeyBvcmlnaW5hbEV2ZW50OiBlIH0pO1xuICAgIH0sXG5cbiAgICBfaWdub3JlRXZlbnQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cbiAgICAgICAgaWYgKG1hcC5ib3hab29tICYmIG1hcC5ib3hab29tLmFjdGl2ZSkgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChtYXAuZHJhZ1JvdGF0ZSAmJiBtYXAuZHJhZ1JvdGF0ZS5hY3RpdmUpIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAoZS50b3VjaGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gKGUudG91Y2hlcy5sZW5ndGggPiAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChlLmN0cmxLZXkpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgdmFyIGJ1dHRvbnMgPSAxLCAgLy8gbGVmdCBidXR0b25cbiAgICAgICAgICAgICAgICBidXR0b24gPSAwOyAgIC8vIGxlZnQgYnV0dG9uXG4gICAgICAgICAgICByZXR1cm4gKGUudHlwZSA9PT0gJ21vdXNlbW92ZScgPyBlLmJ1dHRvbnMgJiBidXR0b25zID09PSAwIDogZS5idXR0b24gIT09IGJ1dHRvbik7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2RyYWluSW5lcnRpYUJ1ZmZlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaW5lcnRpYSA9IHRoaXMuX2luZXJ0aWEsXG4gICAgICAgICAgICBub3cgPSBEYXRlLm5vdygpLFxuICAgICAgICAgICAgY3V0b2ZmID0gMTYwOyAgIC8vIG1zZWNcblxuICAgICAgICB3aGlsZSAoaW5lcnRpYS5sZW5ndGggPiAwICYmIG5vdyAtIGluZXJ0aWFbMF1bMF0gPiBjdXRvZmYpIGluZXJ0aWEuc2hpZnQoKTtcbiAgICB9XG59O1xuXG5cblxuLyoqXG4gKiBEcmFnIHN0YXJ0IGV2ZW50LiBUaGlzIGV2ZW50IGlzIGVtaXR0ZWQgYXQgdGhlIHN0YXJ0IG9mIGEgdXNlci1pbml0aWF0ZWQgcGFuIGludGVyYWN0aW9uLlxuICpcbiAqIEBldmVudCBkcmFnc3RhcnRcbiAqIEBtZW1iZXJvZiBNYXBcbiAqIEBpbnN0YW5jZVxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcm9wZXJ0eSB7RXZlbnR9IG9yaWdpbmFsRXZlbnQgdGhlIG9yaWdpbmFsIERPTSBldmVudFxuICovXG5cbi8qKlxuICogRHJhZyBldmVudC4gVGhpcyBldmVudCBpcyBlbWl0dGVkIHJlcGVhdGVkbHkgZHVyaW5nIGEgdXNlci1pbml0aWF0ZWQgcGFuIGludGVyYWN0aW9uLlxuICpcbiAqIEBldmVudCBkcmFnXG4gKiBAbWVtYmVyb2YgTWFwXG4gKiBAaW5zdGFuY2VcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJvcGVydHkge0V2ZW50fSBvcmlnaW5hbEV2ZW50IHRoZSBvcmlnaW5hbCBET00gZXZlbnRcbiAqL1xuXG4vKipcbiAqIERyYWcgZW5kIGV2ZW50LiBUaGlzIGV2ZW50IGlzIGVtaXR0ZWQgYXQgdGhlIGVuZCBvZiBhIHVzZXItaW5pdGlhdGVkIHBhbiBpbnRlcmFjdGlvbi5cbiAqXG4gKiBAZXZlbnQgZHJhZ2VuZFxuICogQG1lbWJlcm9mIE1hcFxuICogQGluc3RhbmNlXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByb3BlcnR5IHtFdmVudH0gb3JpZ2luYWxFdmVudCB0aGUgb3JpZ2luYWwgRE9NIGV2ZW50XG4gKi9cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIERPTSA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvZG9tJyksXG4gICAgUG9pbnQgPSByZXF1aXJlKCdwb2ludC1nZW9tZXRyeScpLFxuICAgIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL3V0aWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBEcmFnUm90YXRlO1xuXG52YXIgaW5lcnRpYUxpbmVhcml0eSA9IDAuMjUsXG4gICAgaW5lcnRpYUVhc2luZyA9IHV0aWwuYmV6aWVyKDAsIDAsIGluZXJ0aWFMaW5lYXJpdHksIDEpLFxuICAgIGluZXJ0aWFNYXhTcGVlZCA9IDE4MCwgLy8gZGVnL3NcbiAgICBpbmVydGlhRGVjZWxlcmF0aW9uID0gNzIwOyAvLyBkZWcvc14yXG5cblxuZnVuY3Rpb24gRHJhZ1JvdGF0ZShtYXApIHtcbiAgICB0aGlzLl9tYXAgPSBtYXA7XG4gICAgdGhpcy5fZWwgPSBtYXAuZ2V0Q2FudmFzQ29udGFpbmVyKCk7XG5cbiAgICB1dGlsLmJpbmRIYW5kbGVycyh0aGlzKTtcbn1cblxuRHJhZ1JvdGF0ZS5wcm90b3R5cGUgPSB7XG4gICAgZW5hYmxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2VsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuX29uRG93bik7XG4gICAgfSxcblxuICAgIGRpc2FibGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5fb25Eb3duKTtcbiAgICB9LFxuXG4gICAgX29uRG93bjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lnbm9yZUV2ZW50KGUpKSByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSkgcmV0dXJuO1xuXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX29uTW92ZSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9vblVwKTtcblxuICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pbmVydGlhID0gW1tEYXRlLm5vdygpLCB0aGlzLl9tYXAuZ2V0QmVhcmluZygpXV07XG4gICAgICAgIHRoaXMuX3N0YXJ0UG9zID0gdGhpcy5fcG9zID0gRE9NLm1vdXNlUG9zKHRoaXMuX2VsLCBlKTtcbiAgICAgICAgdGhpcy5fY2VudGVyID0gdGhpcy5fbWFwLnRyYW5zZm9ybS5jZW50ZXJQb2ludDsgIC8vIENlbnRlciBvZiByb3RhdGlvblxuXG4gICAgICAgIC8vIElmIHRoZSBmaXJzdCBjbGljayB3YXMgdG9vIGNsb3NlIHRvIHRoZSBjZW50ZXIsIG1vdmUgdGhlIGNlbnRlciBvZiByb3RhdGlvbiBieSAyMDAgcGl4ZWxzXG4gICAgICAgIC8vIGluIHRoZSBkaXJlY3Rpb24gb2YgdGhlIGNsaWNrLlxuICAgICAgICB2YXIgc3RhcnRUb0NlbnRlciA9IHRoaXMuX3N0YXJ0UG9zLnN1Yih0aGlzLl9jZW50ZXIpLFxuICAgICAgICAgICAgc3RhcnRUb0NlbnRlckRpc3QgPSBzdGFydFRvQ2VudGVyLm1hZygpO1xuXG4gICAgICAgIGlmIChzdGFydFRvQ2VudGVyRGlzdCA8IDIwMCkge1xuICAgICAgICAgICAgdGhpcy5fY2VudGVyID0gdGhpcy5fc3RhcnRQb3MuYWRkKG5ldyBQb2ludCgtMjAwLCAwKS5fcm90YXRlKHN0YXJ0VG9DZW50ZXIuYW5nbGUoKSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0sXG5cbiAgICBfb25Nb3ZlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAodGhpcy5faWdub3JlRXZlbnQoZSkpIHJldHVybjtcblxuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9maXJlRXZlbnQoJ3JvdGF0ZXN0YXJ0JywgZSk7XG4gICAgICAgICAgICB0aGlzLl9maXJlRXZlbnQoJ21vdmVzdGFydCcsIGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1hcCA9IHRoaXMuX21hcDtcbiAgICAgICAgbWFwLnN0b3AoKTtcblxuICAgICAgICB2YXIgcDEgPSB0aGlzLl9wb3MsXG4gICAgICAgICAgICBwMiA9IERPTS5tb3VzZVBvcyh0aGlzLl9lbCwgZSksXG4gICAgICAgICAgICBjZW50ZXIgPSB0aGlzLl9jZW50ZXIsXG4gICAgICAgICAgICBiZWFyaW5nRGlmZiA9IHAxLnN1YihjZW50ZXIpLmFuZ2xlV2l0aChwMi5zdWIoY2VudGVyKSkgLyBNYXRoLlBJICogMTgwLFxuICAgICAgICAgICAgYmVhcmluZyA9IG1hcC5nZXRCZWFyaW5nKCkgLSBiZWFyaW5nRGlmZixcbiAgICAgICAgICAgIGluZXJ0aWEgPSB0aGlzLl9pbmVydGlhLFxuICAgICAgICAgICAgbGFzdCA9IGluZXJ0aWFbaW5lcnRpYS5sZW5ndGggLSAxXTtcblxuICAgICAgICB0aGlzLl9kcmFpbkluZXJ0aWFCdWZmZXIoKTtcbiAgICAgICAgaW5lcnRpYS5wdXNoKFtEYXRlLm5vdygpLCBtYXAuX25vcm1hbGl6ZUJlYXJpbmcoYmVhcmluZywgbGFzdFsxXSldKTtcblxuICAgICAgICBtYXAudHJhbnNmb3JtLmJlYXJpbmcgPSBiZWFyaW5nO1xuXG4gICAgICAgIHRoaXMuX2ZpcmVFdmVudCgncm90YXRlJywgZSk7XG4gICAgICAgIHRoaXMuX2ZpcmVFdmVudCgnbW92ZScsIGUpO1xuXG4gICAgICAgIHRoaXMuX3BvcyA9IHAyO1xuICAgIH0sXG5cbiAgICBfb25VcDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lnbm9yZUV2ZW50KGUpKSByZXR1cm47XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX29uTW92ZSk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9vblVwKTtcblxuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlKSByZXR1cm47XG5cbiAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZmlyZUV2ZW50KCdyb3RhdGVlbmQnLCBlKTtcbiAgICAgICAgdGhpcy5fZHJhaW5JbmVydGlhQnVmZmVyKCk7XG5cbiAgICAgICAgdmFyIG1hcCA9IHRoaXMuX21hcCxcbiAgICAgICAgICAgIG1hcEJlYXJpbmcgPSBtYXAuZ2V0QmVhcmluZygpLFxuICAgICAgICAgICAgaW5lcnRpYSA9IHRoaXMuX2luZXJ0aWE7XG5cbiAgICAgICAgdmFyIGZpbmlzaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKG1hcEJlYXJpbmcpIDwgbWFwLm9wdGlvbnMuYmVhcmluZ1NuYXApIHtcbiAgICAgICAgICAgICAgICBtYXAucmVzZXROb3J0aCh7bm9Nb3ZlU3RhcnQ6IHRydWV9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZmlyZUV2ZW50KCdtb3ZlZW5kJywgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0uYmluZCh0aGlzKTtcblxuICAgICAgICBpZiAoaW5lcnRpYS5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICBmaW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmaXJzdCA9IGluZXJ0aWFbMF0sXG4gICAgICAgICAgICBsYXN0ID0gaW5lcnRpYVtpbmVydGlhLmxlbmd0aCAtIDFdLFxuICAgICAgICAgICAgcHJldmlvdXMgPSBpbmVydGlhW2luZXJ0aWEubGVuZ3RoIC0gMl0sXG4gICAgICAgICAgICBiZWFyaW5nID0gbWFwLl9ub3JtYWxpemVCZWFyaW5nKG1hcEJlYXJpbmcsIHByZXZpb3VzWzFdKSxcbiAgICAgICAgICAgIGZsaW5nRGlmZiA9IGxhc3RbMV0gLSBmaXJzdFsxXSxcbiAgICAgICAgICAgIHNpZ24gPSBmbGluZ0RpZmYgPCAwID8gLTEgOiAxLFxuICAgICAgICAgICAgZmxpbmdEdXJhdGlvbiA9IChsYXN0WzBdIC0gZmlyc3RbMF0pIC8gMTAwMDtcblxuICAgICAgICBpZiAoZmxpbmdEaWZmID09PSAwIHx8IGZsaW5nRHVyYXRpb24gPT09IDApIHtcbiAgICAgICAgICAgIGZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNwZWVkID0gTWF0aC5hYnMoZmxpbmdEaWZmICogKGluZXJ0aWFMaW5lYXJpdHkgLyBmbGluZ0R1cmF0aW9uKSk7ICAvLyBkZWcvc1xuICAgICAgICBpZiAoc3BlZWQgPiBpbmVydGlhTWF4U3BlZWQpIHtcbiAgICAgICAgICAgIHNwZWVkID0gaW5lcnRpYU1heFNwZWVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGR1cmF0aW9uID0gc3BlZWQgLyAoaW5lcnRpYURlY2VsZXJhdGlvbiAqIGluZXJ0aWFMaW5lYXJpdHkpLFxuICAgICAgICAgICAgb2Zmc2V0ID0gc2lnbiAqIHNwZWVkICogKGR1cmF0aW9uIC8gMik7XG5cbiAgICAgICAgYmVhcmluZyArPSBvZmZzZXQ7XG5cbiAgICAgICAgaWYgKE1hdGguYWJzKG1hcC5fbm9ybWFsaXplQmVhcmluZyhiZWFyaW5nLCAwKSkgPCBtYXAub3B0aW9ucy5iZWFyaW5nU25hcCkge1xuICAgICAgICAgICAgYmVhcmluZyA9IG1hcC5fbm9ybWFsaXplQmVhcmluZygwLCBiZWFyaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1hcC5yb3RhdGVUbyhiZWFyaW5nLCB7XG4gICAgICAgICAgICBkdXJhdGlvbjogZHVyYXRpb24gKiAxMDAwLFxuICAgICAgICAgICAgZWFzaW5nOiBpbmVydGlhRWFzaW5nLFxuICAgICAgICAgICAgbm9Nb3ZlU3RhcnQ6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIF9maXJlRXZlbnQ6IGZ1bmN0aW9uICh0eXBlLCBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAuZmlyZSh0eXBlLCB7IG9yaWdpbmFsRXZlbnQ6IGUgfSk7XG4gICAgfSxcblxuICAgIF9pZ25vcmVFdmVudDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIG1hcCA9IHRoaXMuX21hcDtcblxuICAgICAgICBpZiAobWFwLmJveFpvb20gJiYgbWFwLmJveFpvb20uYWN0aXZlKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKG1hcC5kcmFnUGFuICYmIG1hcC5kcmFnUGFuLmFjdGl2ZSkgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChlLnRvdWNoZXMpIHtcbiAgICAgICAgICAgIHJldHVybiAoZS50b3VjaGVzLmxlbmd0aCA+IDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGJ1dHRvbnMgPSAoZS5jdHJsS2V5ID8gMSA6IDIpLCAgLy8gPyBjdHJsK2xlZnQgYnV0dG9uIDogcmlnaHQgYnV0dG9uXG4gICAgICAgICAgICAgICAgYnV0dG9uID0gKGUuY3RybEtleSA/IDAgOiAyKTsgICAvLyA/IGN0cmwrbGVmdCBidXR0b24gOiByaWdodCBidXR0b25cbiAgICAgICAgICAgIHJldHVybiAoZS50eXBlID09PSAnbW91c2Vtb3ZlJyA/IGUuYnV0dG9ucyAmIGJ1dHRvbnMgPT09IDAgOiBlLmJ1dHRvbiAhPT0gYnV0dG9uKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfZHJhaW5JbmVydGlhQnVmZmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbmVydGlhID0gdGhpcy5faW5lcnRpYSxcbiAgICAgICAgICAgIG5vdyA9IERhdGUubm93KCksXG4gICAgICAgICAgICBjdXRvZmYgPSAxNjA7ICAgLy9tc2VjXG5cbiAgICAgICAgd2hpbGUgKGluZXJ0aWEubGVuZ3RoID4gMCAmJiBub3cgLSBpbmVydGlhWzBdWzBdID4gY3V0b2ZmKVxuICAgICAgICAgICAgaW5lcnRpYS5zaGlmdCgpO1xuICAgIH1cblxufTtcblxuXG4vKipcbiAqIFJvdGF0ZSBzdGFydCBldmVudC4gVGhpcyBldmVudCBpcyBlbWl0dGVkIGF0IHRoZSBzdGFydCBvZiBhIHVzZXItaW5pdGlhdGVkIHJvdGF0ZSBpbnRlcmFjdGlvbi5cbiAqXG4gKiBAZXZlbnQgcm90YXRlc3RhcnRcbiAqIEBtZW1iZXJvZiBNYXBcbiAqIEBpbnN0YW5jZVxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcm9wZXJ0eSB7RXZlbnR9IG9yaWdpbmFsRXZlbnQgdGhlIG9yaWdpbmFsIERPTSBldmVudFxuICovXG5cbi8qKlxuICogUm90YXRlIGV2ZW50LiBUaGlzIGV2ZW50IGlzIGVtaXR0ZWQgcmVwZWF0ZWRseSBkdXJpbmcgYSB1c2VyLWluaXRpYXRlZCByb3RhdGUgaW50ZXJhY3Rpb24uXG4gKlxuICogQGV2ZW50IHJvdGF0ZVxuICogQG1lbWJlcm9mIE1hcFxuICogQGluc3RhbmNlXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByb3BlcnR5IHtFdmVudH0gb3JpZ2luYWxFdmVudCB0aGUgb3JpZ2luYWwgRE9NIGV2ZW50XG4gKi9cblxuLyoqXG4gKiBSb3RhdGUgZW5kIGV2ZW50LiBUaGlzIGV2ZW50IGlzIGVtaXR0ZWQgYXQgdGhlIGVuZCBvZiBhIHVzZXItaW5pdGlhdGVkIHJvdGF0ZSBpbnRlcmFjdGlvbi5cbiAqXG4gKiBAZXZlbnQgcm90YXRlZW5kXG4gKiBAbWVtYmVyb2YgTWFwXG4gKiBAaW5zdGFuY2VcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJvcGVydHkge0V2ZW50fSBvcmlnaW5hbEV2ZW50IHRoZSBvcmlnaW5hbCBET00gZXZlbnRcbiAqL1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEtleWJvYXJkO1xuXG5cbnZhciBwYW5EZWx0YSA9IDgwLFxuICAgIHJvdGF0ZURlbHRhID0gMixcbiAgICBwaXRjaERlbHRhID0gNTtcblxuLyoqXG4gKiBUaGUgYEtleWJvYXJkYCBoYW5kbGVyIHJlc3BvbmRzIHRvIGtleWJvYXJkIGlucHV0IGJ5IHpvb21pbmcsIHJvdGF0aW5nLCBvciBwYW5uaW5nIHRoZVxuICogbWFwLiBUaGUgZm9sbG93aW5nIGtleWJvYXJkIHNob3J0Y3V0cyBhcmUgc3VwcG9ydGVkOlxuICogICogYD1gIC8gYCtgOiBpbmNyZWFzZSB6b29tIGxldmVsIGJ5IDFcbiAqICAqIGBTaGlmdC09YCAvIGBTaGlmdC0rYDogaW5jcmVhc2Ugem9vbSBsZXZlbCBieSAyXG4gKiAgKiBgLWA6IGRlY3JlYXNlIHpvb20gbGV2ZWwgYnkgMVxuICogICogYFNoaWZ0LS1gOiBkZWNyZWFzZSB6b29tIGxldmVsIGJ5IDJcbiAqICAqIEFycm93IGtleXM6IHBhbiBieSA4MCBwaXhlbHNcbiAqICAqIGBTaGlmdCvih6JgOiBpbmNyZWFzZSByb3RhdGlvbiBieSAyIGRlZ3JlZXNcbiAqICAqIGBTaGlmdCvih6BgOiBkZWNyZWFzZSByb3RhdGlvbiBieSAyIGRlZ3JlZXNcbiAqICAqIGBTaGlmdCvih6FgOiBpbmNyZWFzZSBwaXRjaCBieSA1IGRlZ3JlZXNcbiAqICAqIGBTaGlmdCvih6NgOiBkZWNyZWFzZSBwaXRjaCBieSA1IGRlZ3JlZXNcbiAqIEBjbGFzcyBLZXlib2FyZFxuICogQGV4YW1wbGVcbiAqICAgLy8gRGlzYWJsZSB0aGUga2V5Ym9hcmQgaGFuZGxlclxuICogICBtYXAua2V5Ym9hcmQuZGlzYWJsZSgpO1xuICogQGV4YW1wbGVcbiAqICAgLy8gRW5hYmxlIHRoZSBrZXlib2FyZCBoYW5kbGVyXG4gKiAgIG1hcC5rZXlib2FyZC5lbmFibGUoKTtcbiAqL1xuZnVuY3Rpb24gS2V5Ym9hcmQobWFwKSB7XG4gICAgdGhpcy5fbWFwID0gbWFwO1xuICAgIHRoaXMuX2VsID0gbWFwLmdldENhbnZhc0NvbnRhaW5lcigpO1xuXG4gICAgdGhpcy5fb25LZXlEb3duID0gdGhpcy5fb25LZXlEb3duLmJpbmQodGhpcyk7XG59XG5cbktleWJvYXJkLnByb3RvdHlwZSA9IHtcbiAgICBlbmFibGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fZWwuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX29uS2V5RG93biwgZmFsc2UpO1xuICAgIH0sXG5cbiAgICBkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2VsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9vbktleURvd24pO1xuICAgIH0sXG5cbiAgICBfb25LZXlEb3duOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoZS5hbHRLZXkgfHwgZS5jdHJsS2V5IHx8IGUubWV0YUtleSkgcmV0dXJuO1xuXG4gICAgICAgIHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cbiAgICAgICAgc3dpdGNoIChlLmtleUNvZGUpIHtcbiAgICAgICAgY2FzZSA2MTpcbiAgICAgICAgY2FzZSAxMDc6XG4gICAgICAgIGNhc2UgMTcxOlxuICAgICAgICBjYXNlIDE4NzpcbiAgICAgICAgICAgIG1hcC56b29tVG8oTWF0aC5yb3VuZChtYXAuZ2V0Wm9vbSgpKSArIChlLnNoaWZ0S2V5ID8gMiA6IDEpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMTg5OlxuICAgICAgICBjYXNlIDEwOTpcbiAgICAgICAgY2FzZSAxNzM6XG4gICAgICAgICAgICBtYXAuem9vbVRvKE1hdGgucm91bmQobWFwLmdldFpvb20oKSkgLSAoZS5zaGlmdEtleSA/IDIgOiAxKSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDM3OlxuICAgICAgICAgICAgaWYgKGUuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgICAgICBtYXAuZWFzZVRvKHsgYmVhcmluZzogbWFwLmdldEJlYXJpbmcoKSAtIHJvdGF0ZURlbHRhIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtYXAucGFuQnkoWy1wYW5EZWx0YSwgMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAzOTpcbiAgICAgICAgICAgIGlmIChlLnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgbWFwLmVhc2VUbyh7IGJlYXJpbmc6IG1hcC5nZXRCZWFyaW5nKCkgKyByb3RhdGVEZWx0YSB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWFwLnBhbkJ5KFtwYW5EZWx0YSwgMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAzODpcbiAgICAgICAgICAgIGlmIChlLnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgbWFwLmVhc2VUbyh7IHBpdGNoOiBtYXAuZ2V0UGl0Y2goKSArIHBpdGNoRGVsdGEgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1hcC5wYW5CeShbMCwgLXBhbkRlbHRhXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDQwOlxuICAgICAgICAgICAgaWYgKGUuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgICAgICBtYXAuZWFzZVRvKHsgcGl0Y2g6IE1hdGgubWF4KG1hcC5nZXRQaXRjaCgpIC0gcGl0Y2hEZWx0YSwgMCkgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1hcC5wYW5CeShbMCwgcGFuRGVsdGFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIERPTSA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvZG9tJyksXG4gICAgYnJvd3NlciA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvYnJvd3NlcicpLFxuICAgIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL3V0aWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTY3JvbGxab29tO1xuXG5cbnZhciB1YSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnID8gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpIDogJycsXG4gICAgZmlyZWZveCA9IHVhLmluZGV4T2YoJ2ZpcmVmb3gnKSAhPT0gLTEsXG4gICAgc2FmYXJpID0gdWEuaW5kZXhPZignc2FmYXJpJykgIT09IC0xICYmIHVhLmluZGV4T2YoJ2Nocm9tJykgPT09IC0xO1xuXG5cbmZ1bmN0aW9uIFNjcm9sbFpvb20obWFwKSB7XG4gICAgdGhpcy5fbWFwID0gbWFwO1xuICAgIHRoaXMuX2VsID0gbWFwLmdldENhbnZhc0NvbnRhaW5lcigpO1xuXG4gICAgdXRpbC5iaW5kSGFuZGxlcnModGhpcyk7XG59XG5cblNjcm9sbFpvb20ucHJvdG90eXBlID0ge1xuICAgIGVuYWJsZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9lbC5hZGRFdmVudExpc3RlbmVyKCd3aGVlbCcsIHRoaXMuX29uV2hlZWwsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5fZWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V3aGVlbCcsIHRoaXMuX29uV2hlZWwsIGZhbHNlKTtcbiAgICB9LFxuXG4gICAgZGlzYWJsZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9lbC5yZW1vdmVFdmVudExpc3RlbmVyKCd3aGVlbCcsIHRoaXMuX29uV2hlZWwpO1xuICAgICAgICB0aGlzLl9lbC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXdoZWVsJywgdGhpcy5fb25XaGVlbCk7XG4gICAgfSxcblxuICAgIF9vbldoZWVsOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgdmFsdWU7XG5cbiAgICAgICAgaWYgKGUudHlwZSA9PT0gJ3doZWVsJykge1xuICAgICAgICAgICAgdmFsdWUgPSBlLmRlbHRhWTtcbiAgICAgICAgICAgIC8vIEZpcmVmb3ggZG91YmxlcyB0aGUgdmFsdWVzIG9uIHJldGluYSBzY3JlZW5zLi4uXG4gICAgICAgICAgICBpZiAoZmlyZWZveCAmJiBlLmRlbHRhTW9kZSA9PT0gd2luZG93LldoZWVsRXZlbnQuRE9NX0RFTFRBX1BJWEVMKSB2YWx1ZSAvPSBicm93c2VyLmRldmljZVBpeGVsUmF0aW87XG4gICAgICAgICAgICBpZiAoZS5kZWx0YU1vZGUgPT09IHdpbmRvdy5XaGVlbEV2ZW50LkRPTV9ERUxUQV9MSU5FKSB2YWx1ZSAqPSA0MDtcblxuICAgICAgICB9IGVsc2UgaWYgKGUudHlwZSA9PT0gJ21vdXNld2hlZWwnKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IC1lLndoZWVsRGVsdGFZO1xuICAgICAgICAgICAgaWYgKHNhZmFyaSkgdmFsdWUgPSB2YWx1ZSAvIDM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbm93ID0gKHdpbmRvdy5wZXJmb3JtYW5jZSB8fCBEYXRlKS5ub3coKSxcbiAgICAgICAgICAgIHRpbWVEZWx0YSA9IG5vdyAtICh0aGlzLl90aW1lIHx8IDApO1xuXG4gICAgICAgIHRoaXMuX3BvcyA9IERPTS5tb3VzZVBvcyh0aGlzLl9lbCwgZSk7XG4gICAgICAgIHRoaXMuX3RpbWUgPSBub3c7XG5cbiAgICAgICAgaWYgKHZhbHVlICE9PSAwICYmICh2YWx1ZSAlIDQuMDAwMjQ0MTQwNjI1KSA9PT0gMCkge1xuICAgICAgICAgICAgLy8gVGhpcyBvbmUgaXMgZGVmaW5pdGVseSBhIG1vdXNlIHdoZWVsIGV2ZW50LlxuICAgICAgICAgICAgdGhpcy5fdHlwZSA9ICd3aGVlbCc7XG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgdGhpcyB2YWx1ZSB0byBtYXRjaCB0cmFja3BhZC5cbiAgICAgICAgICAgIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSAvIDQpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgIT09IDAgJiYgTWF0aC5hYnModmFsdWUpIDwgNCkge1xuICAgICAgICAgICAgLy8gVGhpcyBvbmUgaXMgZGVmaW5pdGVseSBhIHRyYWNrcGFkIGV2ZW50IGJlY2F1c2UgaXQgaXMgc28gc21hbGwuXG4gICAgICAgICAgICB0aGlzLl90eXBlID0gJ3RyYWNrcGFkJztcblxuICAgICAgICB9IGVsc2UgaWYgKHRpbWVEZWx0YSA+IDQwMCkge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyBsaWtlbHkgYSBuZXcgc2Nyb2xsIGFjdGlvbi5cbiAgICAgICAgICAgIHRoaXMuX3R5cGUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fbGFzdFZhbHVlID0gdmFsdWU7XG5cbiAgICAgICAgICAgIC8vIFN0YXJ0IGEgdGltZW91dCBpbiBjYXNlIHRoaXMgd2FzIGEgc2luZ3VsYXIgZXZlbnQsIGFuZCBkZWx5IGl0IGJ5IHVwIHRvIDQwbXMuXG4gICAgICAgICAgICB0aGlzLl90aW1lb3V0ID0gc2V0VGltZW91dCh0aGlzLl9vblRpbWVvdXQsIDQwKTtcblxuICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLl90eXBlKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgcmVwZWF0aW5nIGV2ZW50LCBidXQgd2UgZG9uJ3Qga25vdyB0aGUgdHlwZSBvZiBldmVudCBqdXN0IHlldC5cbiAgICAgICAgICAgIC8vIElmIHRoZSBkZWx0YSBwZXIgdGltZSBpcyBzbWFsbCwgd2UgYXNzdW1lIGl0J3MgYSBmYXN0IHRyYWNrcGFkOyBvdGhlcndpc2Ugd2Ugc3dpdGNoIGludG8gd2hlZWwgbW9kZS5cbiAgICAgICAgICAgIHRoaXMuX3R5cGUgPSAoTWF0aC5hYnModGltZURlbHRhICogdmFsdWUpIDwgMjAwKSA/ICd0cmFja3BhZCcgOiAnd2hlZWwnO1xuXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgb3VyIGRlbGF5ZWQgZXZlbnQgaXNuJ3QgZmlyZWQgYWdhaW4sIGJlY2F1c2Ugd2UgYWNjdW11bGF0ZVxuICAgICAgICAgICAgLy8gdGhlIHByZXZpb3VzIGV2ZW50ICh3aGljaCB3YXMgbGVzcyB0aGFuIDQwbXMgYWdvKSBpbnRvIHRoaXMgZXZlbnQuXG4gICAgICAgICAgICBpZiAodGhpcy5fdGltZW91dCkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KTtcbiAgICAgICAgICAgICAgICB0aGlzLl90aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB2YWx1ZSArPSB0aGlzLl9sYXN0VmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTbG93IGRvd24gem9vbSBpZiBzaGlmdCBrZXkgaXMgaGVsZCBmb3IgbW9yZSBwcmVjaXNlIHpvb21pbmdcbiAgICAgICAgaWYgKGUuc2hpZnRLZXkgJiYgdmFsdWUpIHZhbHVlID0gdmFsdWUgLyA0O1xuXG4gICAgICAgIC8vIE9ubHkgZmlyZSB0aGUgY2FsbGJhY2sgaWYgd2UgYWN0dWFsbHkga25vdyB3aGF0IHR5cGUgb2Ygc2Nyb2xsaW5nIGRldmljZSB0aGUgdXNlciB1c2VzLlxuICAgICAgICBpZiAodGhpcy5fdHlwZSkgdGhpcy5fem9vbSgtdmFsdWUpO1xuXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9LFxuXG4gICAgX29uVGltZW91dDogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl90eXBlID0gJ3doZWVsJztcbiAgICAgICAgdGhpcy5fem9vbSgtdGhpcy5fbGFzdFZhbHVlKTtcbiAgICB9LFxuXG4gICAgX3pvb206IGZ1bmN0aW9uIChkZWx0YSkge1xuICAgICAgICB2YXIgbWFwID0gdGhpcy5fbWFwO1xuXG4gICAgICAgIC8vIFNjYWxlIGJ5IHNpZ21vaWQgb2Ygc2Nyb2xsIHdoZWVsIGRlbHRhLlxuICAgICAgICB2YXIgc2NhbGUgPSAyIC8gKDEgKyBNYXRoLmV4cCgtTWF0aC5hYnMoZGVsdGEgLyAxMDApKSk7XG4gICAgICAgIGlmIChkZWx0YSA8IDAgJiYgc2NhbGUgIT09IDApIHNjYWxlID0gMSAvIHNjYWxlO1xuXG4gICAgICAgIHZhciBmcm9tU2NhbGUgPSBtYXAuZWFzZSA/IG1hcC5lYXNlLnRvIDogbWFwLnRyYW5zZm9ybS5zY2FsZSxcbiAgICAgICAgICAgIHRhcmdldFpvb20gPSBtYXAudHJhbnNmb3JtLnNjYWxlWm9vbShmcm9tU2NhbGUgKiBzY2FsZSk7XG5cbiAgICAgICAgbWFwLnpvb21Ubyh0YXJnZXRab29tLCB7XG4gICAgICAgICAgICBkdXJhdGlvbjogMCxcbiAgICAgICAgICAgIGFyb3VuZDogbWFwLnVucHJvamVjdCh0aGlzLl9wb3MpXG4gICAgICAgIH0pO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBET00gPSByZXF1aXJlKCcuLi8uLi91dGlsL2RvbScpLFxuICAgIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL3V0aWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBUb3VjaFpvb21Sb3RhdGU7XG5cbnZhciBpbmVydGlhTGluZWFyaXR5ID0gMC4xNSxcbiAgICBpbmVydGlhRWFzaW5nID0gdXRpbC5iZXppZXIoMCwgMCwgaW5lcnRpYUxpbmVhcml0eSwgMSksXG4gICAgaW5lcnRpYURlY2VsZXJhdGlvbiA9IDEyLCAvLyBzY2FsZSAvIHNeMlxuICAgIGluZXJ0aWFNYXhTcGVlZCA9IDIuNSwgLy8gc2NhbGUgLyBzXG4gICAgc2lnbmlmaWNhbnRTY2FsZVRocmVzaG9sZCA9IDAuMTUsXG4gICAgc2lnbmlmaWNhbnRSb3RhdGVUaHJlc2hvbGQgPSA0O1xuXG5cbmZ1bmN0aW9uIFRvdWNoWm9vbVJvdGF0ZShtYXApIHtcbiAgICB0aGlzLl9tYXAgPSBtYXA7XG4gICAgdGhpcy5fZWwgPSBtYXAuZ2V0Q2FudmFzQ29udGFpbmVyKCk7XG5cbiAgICB1dGlsLmJpbmRIYW5kbGVycyh0aGlzKTtcbn1cblxuVG91Y2hab29tUm90YXRlLnByb3RvdHlwZSA9IHtcbiAgICBlbmFibGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fZWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuX29uU3RhcnQsIGZhbHNlKTtcbiAgICB9LFxuXG4gICAgZGlzYWJsZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9lbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5fb25TdGFydCk7XG4gICAgfSxcblxuICAgIGRpc2FibGVSb3RhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX3JvdGF0aW9uRGlzYWJsZWQgPSB0cnVlO1xuICAgIH0sXG5cbiAgICBlbmFibGVSb3RhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX3JvdGF0aW9uRGlzYWJsZWQgPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgX29uU3RhcnQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChlLnRvdWNoZXMubGVuZ3RoICE9PSAyKSByZXR1cm47XG5cbiAgICAgICAgdmFyIHAwID0gRE9NLm1vdXNlUG9zKHRoaXMuX2VsLCBlLnRvdWNoZXNbMF0pLFxuICAgICAgICAgICAgcDEgPSBET00ubW91c2VQb3ModGhpcy5fZWwsIGUudG91Y2hlc1sxXSk7XG5cbiAgICAgICAgdGhpcy5fc3RhcnRWZWMgPSBwMC5zdWIocDEpO1xuICAgICAgICB0aGlzLl9zdGFydFNjYWxlID0gdGhpcy5fbWFwLnRyYW5zZm9ybS5zY2FsZTtcbiAgICAgICAgdGhpcy5fc3RhcnRCZWFyaW5nID0gdGhpcy5fbWFwLnRyYW5zZm9ybS5iZWFyaW5nO1xuICAgICAgICB0aGlzLl9nZXN0dXJlSW50ZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9pbmVydGlhID0gW107XG5cbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5fb25Nb3ZlLCBmYWxzZSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5fb25FbmQsIGZhbHNlKTtcbiAgICB9LFxuXG4gICAgX29uTW92ZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKGUudG91Y2hlcy5sZW5ndGggIT09IDIpIHJldHVybjtcblxuICAgICAgICB2YXIgcDAgPSBET00ubW91c2VQb3ModGhpcy5fZWwsIGUudG91Y2hlc1swXSksXG4gICAgICAgICAgICBwMSA9IERPTS5tb3VzZVBvcyh0aGlzLl9lbCwgZS50b3VjaGVzWzFdKSxcbiAgICAgICAgICAgIHAgPSBwMC5hZGQocDEpLmRpdigyKSxcbiAgICAgICAgICAgIHZlYyA9IHAwLnN1YihwMSksXG4gICAgICAgICAgICBzY2FsZSA9IHZlYy5tYWcoKSAvIHRoaXMuX3N0YXJ0VmVjLm1hZygpLFxuICAgICAgICAgICAgYmVhcmluZyA9IHRoaXMuX3JvdGF0aW9uRGlzYWJsZWQgPyAwIDogdmVjLmFuZ2xlV2l0aCh0aGlzLl9zdGFydFZlYykgKiAxODAgLyBNYXRoLlBJLFxuICAgICAgICAgICAgbWFwID0gdGhpcy5fbWFwO1xuXG4gICAgICAgIC8vIERldGVybWluZSAnaW50ZW50JyBieSB3aGljaGV2ZXIgdGhyZXNob2xkIGlzIHN1cnBhc3NlZCBmaXJzdCxcbiAgICAgICAgLy8gdGhlbiBrZWVwIHRoYXQgc3RhdGUgZm9yIHRoZSBkdXJhdGlvbiBvZiB0aGlzIGdlc3R1cmUuXG4gICAgICAgIGlmICghdGhpcy5fZ2VzdHVyZUludGVudCkge1xuICAgICAgICAgICAgdmFyIHNjYWxpbmdTaWduaWZpY2FudGx5ID0gKE1hdGguYWJzKDEgLSBzY2FsZSkgPiBzaWduaWZpY2FudFNjYWxlVGhyZXNob2xkKSxcbiAgICAgICAgICAgICAgICByb3RhdGluZ1NpZ25pZmljYW50bHkgPSAoTWF0aC5hYnMoYmVhcmluZykgPiBzaWduaWZpY2FudFJvdGF0ZVRocmVzaG9sZCk7XG5cbiAgICAgICAgICAgIGlmIChyb3RhdGluZ1NpZ25pZmljYW50bHkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9nZXN0dXJlSW50ZW50ID0gJ3JvdGF0ZSc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNjYWxpbmdTaWduaWZpY2FudGx5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZ2VzdHVyZUludGVudCA9ICd6b29tJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuX2dlc3R1cmVJbnRlbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydFZlYyA9IHZlYztcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydFNjYWxlID0gbWFwLnRyYW5zZm9ybS5zY2FsZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydEJlYXJpbmcgPSBtYXAudHJhbnNmb3JtLmJlYXJpbmc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwYXJhbSA9IHsgZHVyYXRpb246IDAsIGFyb3VuZDogbWFwLnVucHJvamVjdChwKSB9O1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fZ2VzdHVyZUludGVudCA9PT0gJ3JvdGF0ZScpIHtcbiAgICAgICAgICAgICAgICBwYXJhbS5iZWFyaW5nID0gdGhpcy5fc3RhcnRCZWFyaW5nICsgYmVhcmluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9nZXN0dXJlSW50ZW50ID09PSAnem9vbScgfHwgdGhpcy5fZ2VzdHVyZUludGVudCA9PT0gJ3JvdGF0ZScpIHtcbiAgICAgICAgICAgICAgICBwYXJhbS56b29tID0gbWFwLnRyYW5zZm9ybS5zY2FsZVpvb20odGhpcy5fc3RhcnRTY2FsZSAqIHNjYWxlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWFwLnN0b3AoKTtcbiAgICAgICAgICAgIHRoaXMuX2RyYWluSW5lcnRpYUJ1ZmZlcigpO1xuICAgICAgICAgICAgdGhpcy5faW5lcnRpYS5wdXNoKFtEYXRlLm5vdygpLCBzY2FsZSwgcF0pO1xuXG4gICAgICAgICAgICBtYXAuZWFzZVRvKHBhcmFtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9LFxuXG4gICAgX29uRW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX29uTW92ZSk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5fb25FbmQpO1xuICAgICAgICB0aGlzLl9kcmFpbkluZXJ0aWFCdWZmZXIoKTtcblxuICAgICAgICB2YXIgaW5lcnRpYSA9IHRoaXMuX2luZXJ0aWEsXG4gICAgICAgICAgICBtYXAgPSB0aGlzLl9tYXA7XG5cbiAgICAgICAgaWYgKGluZXJ0aWEubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgbWFwLnNuYXBUb05vcnRoKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGFzdCA9IGluZXJ0aWFbaW5lcnRpYS5sZW5ndGggLSAxXSxcbiAgICAgICAgICAgIGZpcnN0ID0gaW5lcnRpYVswXSxcbiAgICAgICAgICAgIGxhc3RTY2FsZSA9IG1hcC50cmFuc2Zvcm0uc2NhbGVab29tKHRoaXMuX3N0YXJ0U2NhbGUgKiBsYXN0WzFdKSxcbiAgICAgICAgICAgIGZpcnN0U2NhbGUgPSBtYXAudHJhbnNmb3JtLnNjYWxlWm9vbSh0aGlzLl9zdGFydFNjYWxlICogZmlyc3RbMV0pLFxuICAgICAgICAgICAgc2NhbGVPZmZzZXQgPSBsYXN0U2NhbGUgLSBmaXJzdFNjYWxlLFxuICAgICAgICAgICAgc2NhbGVEdXJhdGlvbiA9IChsYXN0WzBdIC0gZmlyc3RbMF0pIC8gMTAwMCxcbiAgICAgICAgICAgIHAgPSBsYXN0WzJdO1xuXG4gICAgICAgIGlmIChzY2FsZUR1cmF0aW9uID09PSAwIHx8IGxhc3RTY2FsZSA9PT0gZmlyc3RTY2FsZSkge1xuICAgICAgICAgICAgbWFwLnNuYXBUb05vcnRoKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjYWxjdWxhdGUgc2NhbGUvcyBzcGVlZCBhbmQgYWRqdXN0IGZvciBpbmNyZWFzZWQgaW5pdGlhbCBhbmltYXRpb24gc3BlZWQgd2hlbiBlYXNpbmdcbiAgICAgICAgdmFyIHNwZWVkID0gc2NhbGVPZmZzZXQgKiBpbmVydGlhTGluZWFyaXR5IC8gc2NhbGVEdXJhdGlvbjsgLy8gc2NhbGUvc1xuXG4gICAgICAgIGlmIChNYXRoLmFicyhzcGVlZCkgPiBpbmVydGlhTWF4U3BlZWQpIHtcbiAgICAgICAgICAgIGlmIChzcGVlZCA+IDApIHtcbiAgICAgICAgICAgICAgICBzcGVlZCA9IGluZXJ0aWFNYXhTcGVlZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3BlZWQgPSAtaW5lcnRpYU1heFNwZWVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGR1cmF0aW9uID0gTWF0aC5hYnMoc3BlZWQgLyAoaW5lcnRpYURlY2VsZXJhdGlvbiAqIGluZXJ0aWFMaW5lYXJpdHkpKSAqIDEwMDAsXG4gICAgICAgICAgICB0YXJnZXRTY2FsZSA9IGxhc3RTY2FsZSArIHNwZWVkICogZHVyYXRpb24gLyAyMDAwO1xuXG4gICAgICAgIGlmICh0YXJnZXRTY2FsZSA8IDApIHtcbiAgICAgICAgICAgIHRhcmdldFNjYWxlID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIG1hcC5lYXNlVG8oe1xuICAgICAgICAgICAgem9vbTogdGFyZ2V0U2NhbGUsXG4gICAgICAgICAgICBkdXJhdGlvbjogZHVyYXRpb24sXG4gICAgICAgICAgICBlYXNpbmc6IGluZXJ0aWFFYXNpbmcsXG4gICAgICAgICAgICBhcm91bmQ6IG1hcC51bnByb2plY3QocClcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIF9kcmFpbkluZXJ0aWFCdWZmZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaW5lcnRpYSA9IHRoaXMuX2luZXJ0aWEsXG4gICAgICAgICAgICBub3cgPSBEYXRlLm5vdygpLFxuICAgICAgICAgICAgY3V0b2ZmID0gMTYwOyAvLyBtc2VjXG5cbiAgICAgICAgd2hpbGUgKGluZXJ0aWEubGVuZ3RoID4gMiAmJiBub3cgLSBpbmVydGlhWzBdWzBdID4gY3V0b2ZmKSBpbmVydGlhLnNoaWZ0KCk7XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLypcbiAqIEFkZHMgcG9zaXRpb25hbCBjb29yZGluYXRlcyB0byBVUkwgaGFzaGVzLiBQYXNzZWQgYXMgYW4gb3B0aW9uIHRvIHRoZSBtYXAgb2JqZWN0XG4gKlxuICogQGNsYXNzIG1hcGJveGdsLkhhc2hcbiAqIEByZXR1cm5zIHtIYXNofSBgdGhpc2BcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBIYXNoO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xuXG5mdW5jdGlvbiBIYXNoKCkge1xuICAgIHV0aWwuYmluZEFsbChbXG4gICAgICAgICdfb25IYXNoQ2hhbmdlJyxcbiAgICAgICAgJ191cGRhdGVIYXNoJ1xuICAgIF0sIHRoaXMpO1xufVxuXG5IYXNoLnByb3RvdHlwZSA9IHtcbiAgICAvKiBNYXAgZWxlbWVudCB0byBsaXN0ZW4gZm9yIGNvb3JkaW5hdGUgY2hhbmdlc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1hcFxuICAgICAqIEByZXR1cm5zIHtIYXNofSBgdGhpc2BcbiAgICAgKi9cbiAgICBhZGRUbzogZnVuY3Rpb24obWFwKSB7XG4gICAgICAgIHRoaXMuX21hcCA9IG1hcDtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2hhc2hjaGFuZ2UnLCB0aGlzLl9vbkhhc2hDaGFuZ2UsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5fbWFwLm9uKCdtb3ZlZW5kJywgdGhpcy5fdXBkYXRlSGFzaCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKiBSZW1vdmVzIGhhc2hcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQb3B1cH0gYHRoaXNgXG4gICAgICovXG4gICAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2hhc2hjaGFuZ2UnLCB0aGlzLl9vbkhhc2hDaGFuZ2UsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5fbWFwLm9mZignbW92ZWVuZCcsIHRoaXMuX3VwZGF0ZUhhc2gpO1xuICAgICAgICBkZWxldGUgdGhpcy5fbWFwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX29uSGFzaENoYW5nZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBsb2MgPSBsb2NhdGlvbi5oYXNoLnJlcGxhY2UoJyMnLCAnJykuc3BsaXQoJy8nKTtcbiAgICAgICAgaWYgKGxvYy5sZW5ndGggPj0gMykge1xuICAgICAgICAgICAgdGhpcy5fbWFwLmp1bXBUbyh7XG4gICAgICAgICAgICAgICAgY2VudGVyOiBbK2xvY1syXSwgK2xvY1sxXV0sXG4gICAgICAgICAgICAgICAgem9vbTogK2xvY1swXSxcbiAgICAgICAgICAgICAgICBiZWFyaW5nOiArKGxvY1szXSB8fCAwKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIF91cGRhdGVIYXNoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNlbnRlciA9IHRoaXMuX21hcC5nZXRDZW50ZXIoKSxcbiAgICAgICAgICAgIHpvb20gPSB0aGlzLl9tYXAuZ2V0Wm9vbSgpLFxuICAgICAgICAgICAgYmVhcmluZyA9IHRoaXMuX21hcC5nZXRCZWFyaW5nKCksXG4gICAgICAgICAgICBwcmVjaXNpb24gPSBNYXRoLm1heCgwLCBNYXRoLmNlaWwoTWF0aC5sb2coem9vbSkgLyBNYXRoLkxOMikpLFxuXG4gICAgICAgICAgICBoYXNoID0gJyMnICsgKE1hdGgucm91bmQoem9vbSAqIDEwMCkgLyAxMDApICtcbiAgICAgICAgICAgICAgICAnLycgKyBjZW50ZXIubGF0LnRvRml4ZWQocHJlY2lzaW9uKSArXG4gICAgICAgICAgICAgICAgJy8nICsgY2VudGVyLmxuZy50b0ZpeGVkKHByZWNpc2lvbikgK1xuICAgICAgICAgICAgICAgIChiZWFyaW5nID8gJy8nICsgKE1hdGgucm91bmQoYmVhcmluZyAqIDEwKSAvIDEwKSA6ICcnKTtcblxuICAgICAgICB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoJycsICcnLCBoYXNoKTtcbiAgICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFuZGxlcnMgPSB7XG4gICAgc2Nyb2xsWm9vbTogcmVxdWlyZSgnLi9oYW5kbGVyL3Njcm9sbF96b29tJyksXG4gICAgYm94Wm9vbTogcmVxdWlyZSgnLi9oYW5kbGVyL2JveF96b29tJyksXG4gICAgZHJhZ1JvdGF0ZTogcmVxdWlyZSgnLi9oYW5kbGVyL2RyYWdfcm90YXRlJyksXG4gICAgZHJhZ1BhbjogcmVxdWlyZSgnLi9oYW5kbGVyL2RyYWdfcGFuJyksXG4gICAga2V5Ym9hcmQ6IHJlcXVpcmUoJy4vaGFuZGxlci9rZXlib2FyZCcpLFxuICAgIGRvdWJsZUNsaWNrWm9vbTogcmVxdWlyZSgnLi9oYW5kbGVyL2RibGNsaWNrX3pvb20nKSxcbiAgICB0b3VjaFpvb21Sb3RhdGU6IHJlcXVpcmUoJy4vaGFuZGxlci90b3VjaF96b29tX3JvdGF0ZScpXG59O1xuXG52YXIgRE9NID0gcmVxdWlyZSgnLi4vdXRpbC9kb20nKSxcbiAgICB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gSW50ZXJhY3Rpb247XG5cbmZ1bmN0aW9uIEludGVyYWN0aW9uKG1hcCkge1xuICAgIHRoaXMuX21hcCA9IG1hcDtcbiAgICB0aGlzLl9lbCA9IG1hcC5nZXRDYW52YXNDb250YWluZXIoKTtcblxuICAgIGZvciAodmFyIG5hbWUgaW4gaGFuZGxlcnMpIHtcbiAgICAgICAgbWFwW25hbWVdID0gbmV3IGhhbmRsZXJzW25hbWVdKG1hcCk7XG4gICAgfVxuXG4gICAgdXRpbC5iaW5kSGFuZGxlcnModGhpcyk7XG59XG5cbkludGVyYWN0aW9uLnByb3RvdHlwZSA9IHtcbiAgICBlbmFibGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLl9tYXAub3B0aW9ucyxcbiAgICAgICAgICAgIGVsID0gdGhpcy5fZWw7XG5cbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBoYW5kbGVycykge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnNbbmFtZV0pIHRoaXMuX21hcFtuYW1lXS5lbmFibGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuX29uTW91c2VEb3duLCBmYWxzZSk7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9vbk1vdXNlVXAsIGZhbHNlKTtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuX29uVG91Y2hTdGFydCwgZmFsc2UpO1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX29uQ2xpY2ssIGZhbHNlKTtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIGZhbHNlKTtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignZGJsY2xpY2snLCB0aGlzLl9vbkRibENsaWNrLCBmYWxzZSk7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgdGhpcy5fb25Db250ZXh0TWVudSwgZmFsc2UpO1xuICAgIH0sXG5cbiAgICBkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5fbWFwLm9wdGlvbnMsXG4gICAgICAgICAgICBlbCA9IHRoaXMuX2VsO1xuXG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gaGFuZGxlcnMpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zW25hbWVdKSB0aGlzLl9tYXBbbmFtZV0uZGlzYWJsZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5fb25Nb3VzZURvd24pO1xuICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5fb25Nb3VzZVVwKTtcbiAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuX29uVG91Y2hTdGFydCk7XG4gICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fb25DbGljayk7XG4gICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlKTtcbiAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGJsY2xpY2snLCB0aGlzLl9vbkRibENsaWNrKTtcbiAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCB0aGlzLl9vbkNvbnRleHRNZW51KTtcbiAgICB9LFxuXG4gICAgX29uTW91c2VEb3duOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICB0aGlzLl9tYXAuc3RvcCgpO1xuICAgICAgICB0aGlzLl9zdGFydFBvcyA9IERPTS5tb3VzZVBvcyh0aGlzLl9lbCwgZSk7XG4gICAgICAgIHRoaXMuX2ZpcmVFdmVudCgnbW91c2Vkb3duJywgZSk7XG4gICAgfSxcblxuICAgIF9vbk1vdXNlVXA6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBtYXAgPSB0aGlzLl9tYXAsXG4gICAgICAgICAgICByb3RhdGluZyA9IG1hcC5kcmFnUm90YXRlICYmIG1hcC5kcmFnUm90YXRlLmFjdGl2ZTtcblxuICAgICAgICBpZiAodGhpcy5fY29udGV4dE1lbnVFdmVudCAmJiAhcm90YXRpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpcmVFdmVudCgnY29udGV4dG1lbnUnLCB0aGlzLl9jb250ZXh0TWVudUV2ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2NvbnRleHRNZW51RXZlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLl9maXJlRXZlbnQoJ21vdXNldXAnLCBlKTtcbiAgICB9LFxuXG4gICAgX29uVG91Y2hTdGFydDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKCFlLnRvdWNoZXMgfHwgZS50b3VjaGVzLmxlbmd0aCA+IDEpIHJldHVybjtcblxuICAgICAgICBpZiAoIXRoaXMuX3RhcHBlZCkge1xuICAgICAgICAgICAgdGhpcy5fdGFwcGVkID0gc2V0VGltZW91dCh0aGlzLl9vblRpbWVvdXQsIDMwMCk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90YXBwZWQpO1xuICAgICAgICAgICAgdGhpcy5fdGFwcGVkID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2ZpcmVFdmVudCgnZGJsY2xpY2snLCBlKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfb25UaW1lb3V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3RhcHBlZCA9IG51bGw7XG4gICAgfSxcblxuICAgIF9vbk1vdXNlTW92ZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIG1hcCA9IHRoaXMuX21hcCxcbiAgICAgICAgICAgIGVsID0gdGhpcy5fZWw7XG5cbiAgICAgICAgaWYgKG1hcC5kcmFnUGFuICYmIG1hcC5kcmFnUGFuLmFjdGl2ZSkgcmV0dXJuO1xuICAgICAgICBpZiAobWFwLmRyYWdSb3RhdGUgJiYgbWFwLmRyYWdSb3RhdGUuYWN0aXZlKSByZXR1cm47XG5cbiAgICAgICAgdmFyIHRhcmdldCA9IGUudG9FbGVtZW50IHx8IGUudGFyZ2V0O1xuICAgICAgICB3aGlsZSAodGFyZ2V0ICYmIHRhcmdldCAhPT0gZWwpIHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodGFyZ2V0ICE9PSBlbCkgcmV0dXJuO1xuXG4gICAgICAgIHRoaXMuX2ZpcmVFdmVudCgnbW91c2Vtb3ZlJywgZSk7XG4gICAgfSxcblxuICAgIF9vbkNsaWNrOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgcG9zID0gRE9NLm1vdXNlUG9zKHRoaXMuX2VsLCBlKTtcblxuICAgICAgICBpZiAocG9zLmVxdWFscyh0aGlzLl9zdGFydFBvcykpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpcmVFdmVudCgnY2xpY2snLCBlKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfb25EYmxDbGljazogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdGhpcy5fZmlyZUV2ZW50KCdkYmxjbGljaycsIGUpO1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSxcblxuICAgIF9vbkNvbnRleHRNZW51OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICB0aGlzLl9jb250ZXh0TWVudUV2ZW50ID0gZTtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0sXG5cbiAgICBfZmlyZUV2ZW50OiBmdW5jdGlvbiAodHlwZSwgZSkge1xuICAgICAgICB2YXIgcG9zID0gRE9NLm1vdXNlUG9zKHRoaXMuX2VsLCBlKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLmZpcmUodHlwZSwge1xuICAgICAgICAgICAgbG5nTGF0OiB0aGlzLl9tYXAudW5wcm9qZWN0KHBvcyksXG4gICAgICAgICAgICBwb2ludDogcG9zLFxuICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZVxuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG5cbi8qKlxuICogTW91c2UgZG93biBldmVudC5cbiAqXG4gKiBAZXZlbnQgbW91c2Vkb3duXG4gKiBAbWVtYmVyb2YgTWFwXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByb3BlcnR5IHtQb2ludH0gcG9pbnQgdGhlIHBpeGVsIGxvY2F0aW9uIG9mIHRoZSBldmVudFxuICogQHByb3BlcnR5IHtMbmdMYXR9IGxuZ0xhdCB0aGUgZ2VvZ3JhcGhpYyBsb2NhdGlvbiBvZiB0aGUgZXZlbnRcbiAqIEBwcm9wZXJ0eSB7RXZlbnR9IG9yaWdpbmFsRXZlbnQgdGhlIG9yaWdpbmFsIERPTSBldmVudFxuICovXG5cbi8qKlxuICogTW91c2UgdXAgZXZlbnQuXG4gKlxuICogQGV2ZW50IG1vdXNldXBcbiAqIEBtZW1iZXJvZiBNYXBcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJvcGVydHkge1BvaW50fSBwb2ludCB0aGUgcGl4ZWwgbG9jYXRpb24gb2YgdGhlIGV2ZW50XG4gKiBAcHJvcGVydHkge0xuZ0xhdH0gbG5nTGF0IHRoZSBnZW9ncmFwaGljIGxvY2F0aW9uIG9mIHRoZSBldmVudFxuICogQHByb3BlcnR5IHtFdmVudH0gb3JpZ2luYWxFdmVudCB0aGUgb3JpZ2luYWwgRE9NIGV2ZW50XG4gKi9cblxuLyoqXG4gKiBNb3VzZSBtb3ZlIGV2ZW50LlxuICpcbiAqIEBldmVudCBtb3VzZW1vdmVcbiAqIEBtZW1iZXJvZiBNYXBcbiAqIEBpbnN0YW5jZVxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcm9wZXJ0eSB7UG9pbnR9IHBvaW50IHRoZSBwaXhlbCBsb2NhdGlvbiBvZiB0aGUgZXZlbnRcbiAqIEBwcm9wZXJ0eSB7TG5nTGF0fSBsbmdMYXQgdGhlIGdlb2dyYXBoaWMgbG9jYXRpb24gb2YgdGhlIGV2ZW50XG4gKiBAcHJvcGVydHkge0V2ZW50fSBvcmlnaW5hbEV2ZW50IHRoZSBvcmlnaW5hbCBET00gZXZlbnRcbiAqL1xuXG4vKipcbiAqIENsaWNrIGV2ZW50LlxuICpcbiAqIEBldmVudCBjbGlja1xuICogQG1lbWJlcm9mIE1hcFxuICogQGluc3RhbmNlXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByb3BlcnR5IHtQb2ludH0gcG9pbnQgdGhlIHBpeGVsIGxvY2F0aW9uIG9mIHRoZSBldmVudFxuICogQHByb3BlcnR5IHtMbmdMYXR9IGxuZ0xhdCB0aGUgZ2VvZ3JhcGhpYyBsb2NhdGlvbiBvZiB0aGUgZXZlbnRcbiAqIEBwcm9wZXJ0eSB7RXZlbnR9IG9yaWdpbmFsRXZlbnQgdGhlIG9yaWdpbmFsIERPTSBldmVudFxuICovXG5cbi8qKlxuICogRG91YmxlIGNsaWNrIGV2ZW50LlxuICpcbiAqIEBldmVudCBkYmxjbGlja1xuICogQG1lbWJlcm9mIE1hcFxuICogQGluc3RhbmNlXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByb3BlcnR5IHtQb2ludH0gcG9pbnQgdGhlIHBpeGVsIGxvY2F0aW9uIG9mIHRoZSBldmVudFxuICogQHByb3BlcnR5IHtMbmdMYXR9IGxuZ0xhdCB0aGUgZ2VvZ3JhcGhpYyBsb2NhdGlvbiBvZiB0aGUgZXZlbnRcbiAqIEBwcm9wZXJ0eSB7RXZlbnR9IG9yaWdpbmFsRXZlbnQgdGhlIG9yaWdpbmFsIERPTSBldmVudFxuICovXG5cbi8qKlxuICogQ29udGV4dCBtZW51IGV2ZW50LlxuICpcbiAqIEBldmVudCBjb250ZXh0bWVudVxuICogQG1lbWJlcm9mIE1hcFxuICogQGluc3RhbmNlXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByb3BlcnR5IHtQb2ludH0gcG9pbnQgdGhlIHBpeGVsIGxvY2F0aW9uIG9mIHRoZSBldmVudFxuICogQHByb3BlcnR5IHtMbmdMYXR9IGxuZ0xhdCB0aGUgZ2VvZ3JhcGhpYyBsb2NhdGlvbiBvZiB0aGUgZXZlbnRcbiAqIEBwcm9wZXJ0eSB7RXZlbnR9IG9yaWdpbmFsRXZlbnQgdGhlIG9yaWdpbmFsIERPTSBldmVudFxuICovXG5cbi8qKlxuICogTG9hZCBldmVudC4gVGhpcyBldmVudCBpcyBlbWl0dGVkIGltbWVkaWF0ZWx5IGFmdGVyIGFsbCBuZWNlc3NhcnkgcmVzb3VyY2VzIGhhdmUgYmVlbiBkb3dubG9hZGVkXG4gKiBhbmQgdGhlIGZpcnN0IHZpc3VhbGx5IGNvbXBsZXRlIHJlbmRlcmluZyBoYXMgb2NjdXJyZWQuXG4gKlxuICogQGV2ZW50IGxvYWRcbiAqIEBtZW1iZXJvZiBNYXBcbiAqIEBpbnN0YW5jZVxuICogQHR5cGUge09iamVjdH1cbiAqL1xuXG4vKipcbiAqIE1vdmUgc3RhcnQgZXZlbnQuIFRoaXMgZXZlbnQgaXMgZW1pdHRlZCBqdXN0IGJlZm9yZSB0aGUgbWFwIGJlZ2lucyBhIHRyYW5zaXRpb24gZnJvbSBvbmVcbiAqIHZpZXcgdG8gYW5vdGhlciwgZWl0aGVyIGFzIGEgcmVzdWx0IG9mIHVzZXIgaW50ZXJhY3Rpb24gb3IgdGhlIHVzZSBvZiBtZXRob2RzIHN1Y2ggYXMgYE1hcCNqdW1wVG9gLlxuICpcbiAqIEBldmVudCBtb3Zlc3RhcnRcbiAqIEBtZW1iZXJvZiBNYXBcbiAqIEBpbnN0YW5jZVxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcm9wZXJ0eSB7RXZlbnR9IG9yaWdpbmFsRXZlbnQgdGhlIG9yaWdpbmFsIERPTSBldmVudCwgb25seSBwcmVzZW50IGlmIHRyaWdnZXJlZCBieSB1c2VyIGludGVyYWN0aW9uXG4gKi9cblxuLyoqXG4gKiBNb3ZlIGV2ZW50LiBUaGlzIGV2ZW50IGlzIGVtaXR0ZWQgcmVwZWF0ZWRseSBkdXJpbmcgYW5pbWF0ZWQgdHJhbnNpdGlvbnMgZnJvbSBvbmUgdmlldyB0b1xuICogYW5vdGhlciwgZWl0aGVyIGFzIGEgcmVzdWx0IG9mIHVzZXIgaW50ZXJhY3Rpb24gb3IgdGhlIHVzZSBvZiBtZXRob2RzIHN1Y2ggYXMgYE1hcCNqdW1wVG9gLlxuICpcbiAqIEBldmVudCBtb3ZlXG4gKiBAbWVtYmVyb2YgTWFwXG4gKiBAaW5zdGFuY2VcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJvcGVydHkge0V2ZW50fSBvcmlnaW5hbEV2ZW50IHRoZSBvcmlnaW5hbCBET00gZXZlbnQsIG9ubHkgcHJlc2VudCBpZiB0cmlnZ2VyZWQgYnkgdXNlciBpbnRlcmFjdGlvblxuICovXG5cbi8qKlxuICogTW92ZSBlbmQgZXZlbnQuIFRoaXMgZXZlbnQgaXMgZW1pdHRlZCBqdXN0IGFmdGVyIHRoZSBtYXAgY29tcGxldGVzIGEgdHJhbnNpdGlvbiBmcm9tIG9uZVxuICogdmlldyB0byBhbm90aGVyLCBlaXRoZXIgYXMgYSByZXN1bHQgb2YgdXNlciBpbnRlcmFjdGlvbiBvciB0aGUgdXNlIG9mIG1ldGhvZHMgc3VjaCBhcyBgTWFwI2p1bXBUb2AuXG4gKlxuICogQGV2ZW50IG1vdmVlbmRcbiAqIEBtZW1iZXJvZiBNYXBcbiAqIEBpbnN0YW5jZVxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcm9wZXJ0eSB7RXZlbnR9IG9yaWdpbmFsRXZlbnQgdGhlIG9yaWdpbmFsIERPTSBldmVudCwgb25seSBwcmVzZW50IGlmIHRyaWdnZXJlZCBieSB1c2VyIGludGVyYWN0aW9uXG4gKi9cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIENhbnZhcyA9IHJlcXVpcmUoJy4uL3V0aWwvY2FudmFzJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xudmFyIGJyb3dzZXIgPSByZXF1aXJlKCcuLi91dGlsL2Jyb3dzZXInKTtcbnZhciBFdmVudGVkID0gcmVxdWlyZSgnLi4vdXRpbC9ldmVudGVkJyk7XG52YXIgRE9NID0gcmVxdWlyZSgnLi4vdXRpbC9kb20nKTtcblxudmFyIFN0eWxlID0gcmVxdWlyZSgnLi4vc3R5bGUvc3R5bGUnKTtcbnZhciBBbmltYXRpb25Mb29wID0gcmVxdWlyZSgnLi4vc3R5bGUvYW5pbWF0aW9uX2xvb3AnKTtcbnZhciBQYWludGVyID0gcmVxdWlyZSgnLi4vcmVuZGVyL3BhaW50ZXInKTtcblxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4uL2dlby90cmFuc2Zvcm0nKTtcbnZhciBIYXNoID0gcmVxdWlyZSgnLi9oYXNoJyk7XG5cbnZhciBJbnRlcmFjdGlvbiA9IHJlcXVpcmUoJy4vaW50ZXJhY3Rpb24nKTtcblxudmFyIENhbWVyYSA9IHJlcXVpcmUoJy4vY2FtZXJhJyk7XG52YXIgTG5nTGF0ID0gcmVxdWlyZSgnLi4vZ2VvL2xuZ19sYXQnKTtcbnZhciBMbmdMYXRCb3VuZHMgPSByZXF1aXJlKCcuLi9nZW8vbG5nX2xhdF9ib3VuZHMnKTtcbnZhciBQb2ludCA9IHJlcXVpcmUoJ3BvaW50LWdlb21ldHJ5Jyk7XG52YXIgQXR0cmlidXRpb24gPSByZXF1aXJlKCcuL2NvbnRyb2wvYXR0cmlidXRpb24nKTtcblxuLyoqXG4gKiBPcHRpb25zIGNvbW1vbiB0byBNYXAjYWRkQ2xhc3MsIE1hcCNyZW1vdmVDbGFzcywgYW5kIE1hcCNzZXRDbGFzc2VzLCBjb250cm9sbGluZ1xuICogd2hldGhlciBvciBub3QgdG8gc21vb3RobHkgdHJhbnNpdGlvbiBwcm9wZXJ0eSBjaGFuZ2VzIHRyaWdnZXJlZCBieSB0aGUgY2xhc3MgY2hhbmdlLlxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFN0eWxlT3B0aW9uc1xuICogQHByb3BlcnR5IHtib29sZWFufSB0cmFuc2l0aW9uXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGluc3RhbmNlLlxuICogQGNsYXNzIE1hcFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7c3RyaW5nfEVsZW1lbnR9IG9wdGlvbnMuY29udGFpbmVyIEhUTUwgZWxlbWVudCB0byBpbml0aWFsaXplIHRoZSBtYXAgaW4gKG9yIGVsZW1lbnQgaWQgYXMgc3RyaW5nKVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1pblpvb209MF0gTWluaW11bSB6b29tIG9mIHRoZSBtYXBcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhab29tPTIwXSBNYXhpbXVtIHpvb20gb2YgdGhlIG1hcFxuICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBbb3B0aW9ucy5zdHlsZV0gTWFwIHN0eWxlLiBUaGlzIG11c3QgYmUgYW4gYW4gb2JqZWN0IGNvbmZvcm1pbmcgdG8gdGhlIHNjaGVtYSBkZXNjcmliZWQgaW4gdGhlIFtzdHlsZSByZWZlcmVuY2VdKGh0dHBzOi8vbWFwYm94LmNvbS9tYXBib3gtZ2wtc3R5bGUtc3BlYy8pLCBvciBhIFVSTCB0byBhIEpTT04gc3R5bGUuIFRvIGxvYWQgYSBzdHlsZSBmcm9tIHRoZSBNYXBib3ggQVBJLCB5b3UgY2FuIHVzZSBhIFVSTCBvZiB0aGUgZm9ybSBgbWFwYm94Oi8vc3R5bGVzLzpvd25lci86c3R5bGVgLCB3aGVyZSBgOm93bmVyYCBpcyB5b3VyIE1hcGJveCBhY2NvdW50IG5hbWUgYW5kIGA6c3R5bGVgIGlzIHRoZSBzdHlsZSBJRC4gT3IgeW91IGNhbiB1c2Ugb25lIG9mIHRoZSBwcmVkZWZpbmVkIE1hcGJveCBzdHlsZXM6XG4gKiAgICogYG1hcGJveDovL3N0eWxlcy9tYXBib3gvYmFzaWMtdjhgIC0gU2ltcGxlIGFuZCBmbGV4aWJsZSBzdGFydGluZyB0ZW1wbGF0ZS5cbiAqICAgKiBgbWFwYm94Oi8vc3R5bGVzL21hcGJveC9icmlnaHQtdjhgIC0gVGVtcGxhdGUgZm9yIGNvbXBsZXggY3VzdG9tIGJhc2VtYXBzLlxuICogICAqIGBtYXBib3g6Ly9zdHlsZXMvbWFwYm94L3N0cmVldHMtdjhgIC0gQSByZWFkeS10by11c2UgYmFzZW1hcCwgcGVyZmVjdCBmb3IgbWlub3IgY3VzdG9taXphdGlvbiBvciBpbmNvcnBvcmF0aW5nIHlvdXIgb3duIGRhdGEuXG4gKiAgICogYG1hcGJveDovL3N0eWxlcy9tYXBib3gvbGlnaHQtdjhgIC0gU3VidGxlIGxpZ2h0IGJhY2tkcm9wIGZvciBkYXRhIHZpenVhbGl6YXRpb25zLlxuICogICAqIGBtYXBib3g6Ly9zdHlsZXMvbWFwYm94L2RhcmstdjhgIC0gU3VidGxlIGRhcmsgYmFja2Ryb3AgZm9yIGRhdGEgdml6dWFsaXphdGlvbnMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmhhc2g9ZmFsc2VdIElmIGB0cnVlYCwgdGhlIG1hcCB3aWxsIHRyYWNrIGFuZCB1cGRhdGUgdGhlIHBhZ2UgVVJMIGFjY29yZGluZyB0byBtYXAgcG9zaXRpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuaW50ZXJhY3RpdmU9dHJ1ZV0gSWYgYGZhbHNlYCwgbm8gbW91c2UsIHRvdWNoLCBvciBrZXlib2FyZCBsaXN0ZW5lcnMgYXJlIGF0dGFjaGVkIHRvIHRoZSBtYXAsIHNvIGl0IHdpbGwgbm90IHJlc3BvbmQgdG8gaW5wdXRcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5iZWFyaW5nU25hcD03XSBTbmFwIHRvIG5vcnRoIHRocmVzaG9sZCBpbiBkZWdyZWVzLlxuICogQHBhcmFtIHtBcnJheX0gW29wdGlvbnMuY2xhc3Nlc10gU3R5bGUgY2xhc3MgbmFtZXMgd2l0aCB3aGljaCB0byBpbml0aWFsaXplIHRoZSBtYXBcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYXR0cmlidXRpb25Db250cm9sPXRydWVdIElmIGB0cnVlYCwgYW4gYXR0cmlidXRpb24gY29udHJvbCB3aWxsIGJlIGFkZGVkIHRvIHRoZSBtYXAuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQ9ZmFsc2VdIElmIGB0cnVlYCwgbWFwIGNyZWF0aW9uIHdpbGwgZmFpbCBpZiB0aGUgaW1wbGVtZW50YXRpb24gZGV0ZXJtaW5lcyB0aGF0IHRoZSBwZXJmb3JtYW5jZSBvZiB0aGUgY3JlYXRlZCBXZWJHTCBjb250ZXh0IHdvdWxkIGJlIGRyYW1hdGljYWxseSBsb3dlciB0aGFuIGV4cGVjdGVkLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXI9ZmFsc2VdIElmIGB0cnVlYCwgVGhlIG1hcHMgY2FudmFzIGNhbiBiZSBleHBvcnRlZCB0byBhIFBORyB1c2luZyBgbWFwLmdldENhbnZhcygpLnRvRGF0YVVSTCgpO2AuIFRoaXMgaXMgZmFsc2UgYnkgZGVmYXVsdCBhcyBhIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbi5cbiAqIEBwYXJhbSB7TG5nTGF0Qm91bmRzfEFycmF5PEFycmF5PG51bWJlcj4+fSBbb3B0aW9ucy5tYXhCb3VuZHNdIElmIHNldCwgdGhlIG1hcCBpcyBjb25zdHJhaW5lZCB0byB0aGUgZ2l2ZW4gYm91bmRzLlxuICogQGV4YW1wbGVcbiAqIHZhciBtYXAgPSBuZXcgbWFwYm94Z2wuTWFwKHtcbiAqICAgY29udGFpbmVyOiAnbWFwJyxcbiAqICAgY2VudGVyOiBbLTEyMi40MjA2NzksIDM3Ljc3MjUzN10sXG4gKiAgIHpvb206IDEzLFxuICogICBzdHlsZTogc3R5bGVfb2JqZWN0LFxuICogICBoYXNoOiB0cnVlXG4gKiB9KTtcbiAqL1xudmFyIE1hcCA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob3B0aW9ucykge1xuXG4gICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyA9IHV0aWwuaW5oZXJpdCh0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5hbmltYXRpb25Mb29wID0gbmV3IEFuaW1hdGlvbkxvb3AoKTtcbiAgICB0aGlzLnRyYW5zZm9ybSA9IG5ldyBUcmFuc2Zvcm0ob3B0aW9ucy5taW5ab29tLCBvcHRpb25zLm1heFpvb20pO1xuXG4gICAgaWYgKG9wdGlvbnMubWF4Qm91bmRzKSB7XG4gICAgICAgIHZhciBiID0gTG5nTGF0Qm91bmRzLmNvbnZlcnQob3B0aW9ucy5tYXhCb3VuZHMpO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybS5sbmdSYW5nZSA9IFtiLmdldFdlc3QoKSwgYi5nZXRFYXN0KCldO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybS5sYXRSYW5nZSA9IFtiLmdldFNvdXRoKCksIGIuZ2V0Tm9ydGgoKV07XG4gICAgfVxuXG4gICAgdXRpbC5iaW5kQWxsKFtcbiAgICAgICAgJ19mb3J3YXJkU3R5bGVFdmVudCcsXG4gICAgICAgICdfZm9yd2FyZFNvdXJjZUV2ZW50JyxcbiAgICAgICAgJ19mb3J3YXJkTGF5ZXJFdmVudCcsXG4gICAgICAgICdfZm9yd2FyZFRpbGVFdmVudCcsXG4gICAgICAgICdfb25TdHlsZUxvYWQnLFxuICAgICAgICAnX29uU3R5bGVDaGFuZ2UnLFxuICAgICAgICAnX29uU291cmNlQWRkJyxcbiAgICAgICAgJ19vblNvdXJjZVJlbW92ZScsXG4gICAgICAgICdfb25Tb3VyY2VVcGRhdGUnLFxuICAgICAgICAnX29uV2luZG93UmVzaXplJyxcbiAgICAgICAgJ29uRXJyb3InLFxuICAgICAgICAnX3VwZGF0ZScsXG4gICAgICAgICdfcmVuZGVyJ1xuICAgIF0sIHRoaXMpO1xuXG4gICAgdGhpcy5fc2V0dXBDb250YWluZXIoKTtcbiAgICB0aGlzLl9zZXR1cFBhaW50ZXIoKTtcblxuICAgIHRoaXMub24oJ21vdmUnLCB0aGlzLl91cGRhdGUuYmluZCh0aGlzLCBmYWxzZSkpO1xuICAgIHRoaXMub24oJ3pvb20nLCB0aGlzLl91cGRhdGUuYmluZCh0aGlzLCB0cnVlKSk7XG4gICAgdGhpcy5vbignbW92ZWVuZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmFuaW1hdGlvbkxvb3Auc2V0KDMwMCk7IC8vIHRleHQgZmFkaW5nXG4gICAgICAgIHRoaXMuX3JlcmVuZGVyKCk7XG4gICAgfS5iaW5kKHRoaXMpKTtcblxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fb25XaW5kb3dSZXNpemUsIGZhbHNlKTtcbiAgICB9XG5cbiAgICB0aGlzLmludGVyYWN0aW9uID0gbmV3IEludGVyYWN0aW9uKHRoaXMpO1xuXG4gICAgaWYgKG9wdGlvbnMuaW50ZXJhY3RpdmUpIHtcbiAgICAgICAgdGhpcy5pbnRlcmFjdGlvbi5lbmFibGUoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9oYXNoID0gb3B0aW9ucy5oYXNoICYmIChuZXcgSGFzaCgpKS5hZGRUbyh0aGlzKTtcbiAgICAvLyBkb24ndCBzZXQgcG9zaXRpb24gZnJvbSBvcHRpb25zIGlmIHNldCB0aHJvdWdoIGhhc2hcbiAgICBpZiAoIXRoaXMuX2hhc2ggfHwgIXRoaXMuX2hhc2guX29uSGFzaENoYW5nZSgpKSB7XG4gICAgICAgIHRoaXMuanVtcFRvKG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHRoaXMuc291cmNlcyA9IHt9O1xuICAgIHRoaXMuc3RhY2tzID0ge307XG4gICAgdGhpcy5fY2xhc3NlcyA9IHt9O1xuXG4gICAgdGhpcy5yZXNpemUoKTtcblxuICAgIGlmIChvcHRpb25zLmNsYXNzZXMpIHRoaXMuc2V0Q2xhc3NlcyhvcHRpb25zLmNsYXNzZXMpO1xuICAgIGlmIChvcHRpb25zLnN0eWxlKSB0aGlzLnNldFN0eWxlKG9wdGlvbnMuc3R5bGUpO1xuICAgIGlmIChvcHRpb25zLmF0dHJpYnV0aW9uQ29udHJvbCkgdGhpcy5hZGRDb250cm9sKG5ldyBBdHRyaWJ1dGlvbihvcHRpb25zLmF0dHJpYnV0aW9uQ29udHJvbCkpO1xuXG4gICAgdGhpcy5vbignc3R5bGUuZXJyb3InLCB0aGlzLm9uRXJyb3IpO1xuICAgIHRoaXMub24oJ3NvdXJjZS5lcnJvcicsIHRoaXMub25FcnJvcik7XG4gICAgdGhpcy5vbigndGlsZS5lcnJvcicsIHRoaXMub25FcnJvcik7XG59O1xuXG51dGlsLmV4dGVuZChNYXAucHJvdG90eXBlLCBFdmVudGVkKTtcbnV0aWwuZXh0ZW5kKE1hcC5wcm90b3R5cGUsIENhbWVyYS5wcm90b3R5cGUpO1xudXRpbC5leHRlbmQoTWFwLnByb3RvdHlwZSwgLyoqIEBsZW5kcyBNYXAucHJvdG90eXBlICove1xuXG4gICAgb3B0aW9uczoge1xuICAgICAgICBjZW50ZXI6IFswLCAwXSxcbiAgICAgICAgem9vbTogMCxcbiAgICAgICAgYmVhcmluZzogMCxcbiAgICAgICAgcGl0Y2g6IDAsXG5cbiAgICAgICAgbWluWm9vbTogMCxcbiAgICAgICAgbWF4Wm9vbTogMjAsXG5cbiAgICAgICAgaW50ZXJhY3RpdmU6IHRydWUsXG5cbiAgICAgICAgc2Nyb2xsWm9vbTogdHJ1ZSxcbiAgICAgICAgYm94Wm9vbTogdHJ1ZSxcbiAgICAgICAgZHJhZ1JvdGF0ZTogdHJ1ZSxcbiAgICAgICAgZHJhZ1BhbjogdHJ1ZSxcbiAgICAgICAga2V5Ym9hcmQ6IHRydWUsXG4gICAgICAgIGRvdWJsZUNsaWNrWm9vbTogdHJ1ZSxcbiAgICAgICAgdG91Y2hab29tUm90YXRlOiB0cnVlLFxuXG4gICAgICAgIGJlYXJpbmdTbmFwOiA3LFxuXG4gICAgICAgIGhhc2g6IGZhbHNlLFxuXG4gICAgICAgIGF0dHJpYnV0aW9uQ29udHJvbDogdHJ1ZSxcblxuICAgICAgICBmYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0OiBmYWxzZSxcbiAgICAgICAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiBmYWxzZVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgY29udHJvbCB0byB0aGUgbWFwLCBjYWxsaW5nIGBjb250cm9sLmFkZFRvKHRoaXMpYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q29udHJvbH0gY29udHJvbFxuICAgICAqIEByZXR1cm5zIHtNYXB9IGB0aGlzYFxuICAgICAqL1xuICAgIGFkZENvbnRyb2w6IGZ1bmN0aW9uKGNvbnRyb2wpIHtcbiAgICAgICAgY29udHJvbC5hZGRUbyh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBzdHlsZSBjbGFzcyB0byBhIG1hcFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtsYXNzIG5hbWUgb2Ygc3R5bGUgY2xhc3NcbiAgICAgKiBAcGFyYW0ge1N0eWxlT3B0aW9uc30gW29wdGlvbnNdXG4gICAgICogQGZpcmVzIGNoYW5nZVxuICAgICAqIEByZXR1cm5zIHtNYXB9IGB0aGlzYFxuICAgICAqL1xuICAgIGFkZENsYXNzOiBmdW5jdGlvbihrbGFzcywgb3B0aW9ucykge1xuICAgICAgICBpZiAodGhpcy5fY2xhc3Nlc1trbGFzc10pIHJldHVybjtcbiAgICAgICAgdGhpcy5fY2xhc3Nlc1trbGFzc10gPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5zdHlsZSkgdGhpcy5zdHlsZS5fY2FzY2FkZSh0aGlzLl9jbGFzc2VzLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIHN0eWxlIGNsYXNzIGZyb20gYSBtYXBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrbGFzcyBuYW1lIG9mIHN0eWxlIGNsYXNzXG4gICAgICogQHBhcmFtIHtTdHlsZU9wdGlvbnN9IFtvcHRpb25zXVxuICAgICAqIEBmaXJlcyBjaGFuZ2VcbiAgICAgKiBAcmV0dXJucyB7TWFwfSBgdGhpc2BcbiAgICAgKi9cbiAgICByZW1vdmVDbGFzczogZnVuY3Rpb24oa2xhc3MsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jbGFzc2VzW2tsYXNzXSkgcmV0dXJuO1xuICAgICAgICBkZWxldGUgdGhpcy5fY2xhc3Nlc1trbGFzc107XG4gICAgICAgIGlmICh0aGlzLnN0eWxlKSB0aGlzLnN0eWxlLl9jYXNjYWRlKHRoaXMuX2NsYXNzZXMsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgbWV0aG9kIHRvIGFkZCBtb3JlIHRoYW4gb25lIGNsYXNzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGtsYXNzZXMgQW4gYXJyYXkgb2YgY2xhc3MgbmFtZXNcbiAgICAgKiBAcGFyYW0ge1N0eWxlT3B0aW9uc30gW29wdGlvbnNdXG4gICAgICogQGZpcmVzIGNoYW5nZVxuICAgICAqIEByZXR1cm5zIHtNYXB9IGB0aGlzYFxuICAgICAqL1xuICAgIHNldENsYXNzZXM6IGZ1bmN0aW9uKGtsYXNzZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fY2xhc3NlcyA9IHt9O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtsYXNzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuX2NsYXNzZXNba2xhc3Nlc1tpXV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0eWxlKSB0aGlzLnN0eWxlLl9jYXNjYWRlKHRoaXMuX2NsYXNzZXMsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayB3aGV0aGVyIGEgc3R5bGUgY2xhc3MgaXMgYWN0aXZlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2xhc3MgTmFtZSBvZiBzdHlsZSBjbGFzc1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGhhc0NsYXNzOiBmdW5jdGlvbihrbGFzcykge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9jbGFzc2VzW2tsYXNzXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGFuIGFycmF5IG9mIHRoZSBjdXJyZW50IGFjdGl2ZSBzdHlsZSBjbGFzc2VzXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBnZXRDbGFzc2VzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX2NsYXNzZXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZXRlY3QgdGhlIG1hcCdzIG5ldyB3aWR0aCBhbmQgaGVpZ2h0IGFuZCByZXNpemUgaXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7TWFwfSBgdGhpc2BcbiAgICAgKi9cbiAgICByZXNpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgd2lkdGggPSAwLCBoZWlnaHQgPSAwO1xuXG4gICAgICAgIGlmICh0aGlzLl9jb250YWluZXIpIHtcbiAgICAgICAgICAgIHdpZHRoID0gdGhpcy5fY29udGFpbmVyLm9mZnNldFdpZHRoIHx8IDQwMDtcbiAgICAgICAgICAgIGhlaWdodCA9IHRoaXMuX2NvbnRhaW5lci5vZmZzZXRIZWlnaHQgfHwgMzAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY2FudmFzLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0ucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB0aGlzLnBhaW50ZXIucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgICAgICAuZmlyZSgnbW92ZXN0YXJ0JylcbiAgICAgICAgICAgIC5maXJlKCdtb3ZlJylcbiAgICAgICAgICAgIC5maXJlKCdyZXNpemUnKVxuICAgICAgICAgICAgLmZpcmUoJ21vdmVlbmQnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBtYXAncyBnZW9ncmFwaGljYWwgYm91bmRzXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7TG5nTGF0Qm91bmRzfVxuICAgICAqL1xuICAgIGdldEJvdW5kczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgTG5nTGF0Qm91bmRzKFxuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0ucG9pbnRMb2NhdGlvbihuZXcgUG9pbnQoMCwgMCkpLFxuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0ucG9pbnRMb2NhdGlvbih0aGlzLnRyYW5zZm9ybS5zaXplKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBwaXhlbCBjb29yZGluYXRlcyAocmVsYXRpdmUgdG8gbWFwIGNvbnRhaW5lcikgZ2l2ZW4gYSBnZW9ncmFwaGljYWwgbG9jYXRpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TG5nTGF0fSBsbmdsYXRcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBgeGAgYW5kIGB5YCBjb29yZGluYXRlc1xuICAgICAqL1xuICAgIHByb2plY3Q6IGZ1bmN0aW9uKGxuZ2xhdCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0ubG9jYXRpb25Qb2ludChMbmdMYXQuY29udmVydChsbmdsYXQpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcyBnaXZlbiBwaXhlbCBjb29yZGluYXRlc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBwb2ludCBbeCwgeV0gcGl4ZWwgY29vcmRpbmF0ZXNcbiAgICAgKiBAcmV0dXJucyB7TG5nTGF0fVxuICAgICAqL1xuICAgIHVucHJvamVjdDogZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLnBvaW50TG9jYXRpb24oUG9pbnQuY29udmVydChwb2ludCkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBRdWVyeSBmZWF0dXJlcyBhdCBhIHBvaW50LCBvciB3aXRoaW4gYSBjZXJ0YWluIHJhZGl1cyB0aGVyZW9mLlxuICAgICAqXG4gICAgICogVG8gdXNlIHRoaXMgbWV0aG9kLCB5b3UgbXVzdCBzZXQgdGhlIHN0eWxlIHByb3BlcnR5IGBcImludGVyYWN0aXZlXCI6IHRydWVgIG9uIGxheWVycyB5b3Ugd2lzaCB0byBxdWVyeS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gcG9pbnQgW3gsIHldIHBpeGVsIGNvb3JkaW5hdGVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW1zLnJhZGl1cz0wXSBSYWRpdXMgaW4gcGl4ZWxzIHRvIHNlYXJjaCBpblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfEFycmF5PHN0cmluZz59IFtwYXJhbXMubGF5ZXJdIE9ubHkgcmV0dXJuIGZlYXR1cmVzIGZyb20gYSBnaXZlbiBsYXllciBvciBsYXllcnNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhcmFtcy50eXBlXSBFaXRoZXIgYHJhc3RlcmAgb3IgYHZlY3RvcmBcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtwYXJhbXMuaW5jbHVkZUdlb21ldHJ5PWZhbHNlXSBJZiBgdHJ1ZWAsIGdlb21ldHJ5IG9mIGZlYXR1cmVzIHdpbGwgYmUgaW5jbHVkZWQgaW4gdGhlIHJlc3VsdHMgYXQgdGhlIGV4cGVuc2Ugb2YgYSBtdWNoIHNsb3dlciBxdWVyeSB0aW1lLlxuICAgICAqIEBwYXJhbSB7ZmVhdHVyZXNDYWxsYmFja30gY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCByZWNlaXZlcyB0aGUgcmVzdWx0c1xuICAgICAqXG4gICAgICogQHJldHVybnMge01hcH0gYHRoaXNgXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIG1hcC5mZWF0dXJlc0F0KFsxMCwgMjBdLCB7IHJhZGl1czogMTAgfSwgZnVuY3Rpb24oZXJyLCBmZWF0dXJlcykge1xuICAgICAqICAgY29uc29sZS5sb2coZmVhdHVyZXMpO1xuICAgICAqIH0pO1xuICAgICAqL1xuICAgIGZlYXR1cmVzQXQ6IGZ1bmN0aW9uKHBvaW50LCBwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBsb2NhdGlvbiA9IHRoaXMudW5wcm9qZWN0KHBvaW50KS53cmFwKCk7XG4gICAgICAgIHZhciBjb29yZCA9IHRoaXMudHJhbnNmb3JtLmxvY2F0aW9uQ29vcmRpbmF0ZShsb2NhdGlvbik7XG4gICAgICAgIHRoaXMuc3R5bGUuZmVhdHVyZXNBdChjb29yZCwgcGFyYW1zLCBjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBRdWVyeSBmZWF0dXJlcyB3aXRoaW4gYSByZWN0YW5nbGUuXG4gICAgICpcbiAgICAgKiBUbyB1c2UgdGhpcyBtZXRob2QsIHlvdSBtdXN0IHNldCB0aGUgc3R5bGUgcHJvcGVydHkgYFwiaW50ZXJhY3RpdmVcIjogdHJ1ZWAgb24gbGF5ZXJzIHlvdSB3aXNoIHRvIHF1ZXJ5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheTxQb2ludD58QXJyYXk8QXJyYXk8bnVtYmVyPj59IFtib3VuZHNdIENvb3JkaW5hdGVzIG9mIG9wcG9zaXRlIGNvcm5lcnMgb2YgYm91bmRpbmcgcmVjdGFuZ2xlLCBpbiBwaXhlbCBjb29yZGluYXRlcy4gT3B0aW9uYWw6IHVzZSBlbnRpcmUgdmlld3BvcnQgaWYgb21pdHRlZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtzdHJpbmd8QXJyYXk8c3RyaW5nPn0gW3BhcmFtcy5sYXllcl0gT25seSByZXR1cm4gZmVhdHVyZXMgZnJvbSBhIGdpdmVuIGxheWVyIG9yIGxheWVyc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFyYW1zLnR5cGVdIEVpdGhlciBgcmFzdGVyYCBvciBgdmVjdG9yYFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3BhcmFtcy5pbmNsdWRlR2VvbWV0cnk9ZmFsc2VdIElmIGB0cnVlYCwgZ2VvbWV0cnkgb2YgZmVhdHVyZXMgd2lsbCBiZSBpbmNsdWRlZCBpbiB0aGUgcmVzdWx0cyBhdCB0aGUgZXhwZW5zZSBvZiBhIG11Y2ggc2xvd2VyIHF1ZXJ5IHRpbWUuXG4gICAgICogQHBhcmFtIHtmZWF0dXJlc0NhbGxiYWNrfSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IHJlY2VpdmVzIHRoZSByZXN1bHRzXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7TWFwfSBgdGhpc2BcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogbWFwLmZlYXR1cmVzSW4oW1sxMCwgMjBdLCBbMzAsIDUwXV0sIHsgbGF5ZXI6ICdteS1sYXllci1uYW1lJyB9LCBmdW5jdGlvbihlcnIsIGZlYXR1cmVzKSB7XG4gICAgICogICBjb25zb2xlLmxvZyhmZWF0dXJlcyk7XG4gICAgICogfSk7XG4gICAgICovXG4gICAgZmVhdHVyZXNJbjogZnVuY3Rpb24oYm91bmRzLCBwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IHBhcmFtcztcbiAgICAgICAgICAgIHBhcmFtcyA9IGJvdW5kcztcbiAgICAgICAgICAvLyBib3VuZHMgd2FzIG9taXR0ZWQ6IHVzZSBmdWxsIHZpZXdwb3J0XG4gICAgICAgICAgICBib3VuZHMgPSBbXG4gICAgICAgICAgICAgICAgUG9pbnQuY29udmVydChbMCwgMF0pLFxuICAgICAgICAgICAgICAgIFBvaW50LmNvbnZlcnQoW3RoaXMudHJhbnNmb3JtLndpZHRoLCB0aGlzLnRyYW5zZm9ybS5oZWlnaHRdKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICBib3VuZHMgPSBib3VuZHMubWFwKFBvaW50LmNvbnZlcnQuYmluZChQb2ludCkpO1xuICAgICAgICBib3VuZHMgPSBbXG4gICAgICAgICAgICBuZXcgUG9pbnQoXG4gICAgICAgICAgICBNYXRoLm1pbihib3VuZHNbMF0ueCwgYm91bmRzWzFdLngpLFxuICAgICAgICAgICAgTWF0aC5taW4oYm91bmRzWzBdLnksIGJvdW5kc1sxXS55KVxuICAgICAgICAgICksXG4gICAgICAgICAgICBuZXcgUG9pbnQoXG4gICAgICAgICAgICBNYXRoLm1heChib3VuZHNbMF0ueCwgYm91bmRzWzFdLngpLFxuICAgICAgICAgICAgTWF0aC5tYXgoYm91bmRzWzBdLnksIGJvdW5kc1sxXS55KVxuICAgICAgICAgIClcbiAgICAgICAgXS5tYXAodGhpcy50cmFuc2Zvcm0ucG9pbnRDb29yZGluYXRlLmJpbmQodGhpcy50cmFuc2Zvcm0pKTtcbiAgICAgICAgdGhpcy5zdHlsZS5mZWF0dXJlc0luKGJvdW5kcywgcGFyYW1zLCBjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBseSBtdWx0aXBsZSBzdHlsZSBtdXRhdGlvbnMgaW4gYSBiYXRjaFxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gd29yayBGdW5jdGlvbiB3aGljaCBhY2NlcHRzIGEgYFN0eWxlQmF0Y2hgIG9iamVjdCxcbiAgICAgKiAgICAgIGEgc3Vic2V0IG9mIGBNYXBgLCB3aXRoIGBhZGRMYXllcmAsIGByZW1vdmVMYXllcmAsXG4gICAgICogICAgICBgc2V0UGFpbnRQcm9wZXJ0eWAsIGBzZXRMYXlvdXRQcm9wZXJ0eWAsIGBzZXRGaWx0ZXJgLFxuICAgICAqICAgICAgYHNldExheWVyWm9vbVJhbmdlYCwgYGFkZFNvdXJjZWAsIGFuZCBgcmVtb3ZlU291cmNlYFxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBtYXAuYmF0Y2goZnVuY3Rpb24gKGJhdGNoKSB7XG4gICAgICogICAgIGJhdGNoLmFkZExheWVyKGxheWVyMSk7XG4gICAgICogICAgIGJhdGNoLmFkZExheWVyKGxheWVyMik7XG4gICAgICogICAgIC4uLlxuICAgICAqICAgICBiYXRjaC5hZGRMYXllcihsYXllck4pO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICovXG4gICAgYmF0Y2g6IGZ1bmN0aW9uKHdvcmspIHtcbiAgICAgICAgdGhpcy5zdHlsZS5iYXRjaCh3b3JrKTtcblxuICAgICAgICB0aGlzLnN0eWxlLl9jYXNjYWRlKHRoaXMuX2NsYXNzZXMpO1xuICAgICAgICB0aGlzLl91cGRhdGUodHJ1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlcGxhY2VzIHRoZSBtYXAncyBzdHlsZSBvYmplY3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZSBBIHN0eWxlIG9iamVjdCBmb3JtYXR0ZWQgYXMgSlNPTlxuICAgICAqIEByZXR1cm5zIHtNYXB9IGB0aGlzYFxuICAgICAqL1xuICAgIHNldFN0eWxlOiBmdW5jdGlvbihzdHlsZSkge1xuICAgICAgICBpZiAodGhpcy5zdHlsZSkge1xuICAgICAgICAgICAgdGhpcy5zdHlsZVxuICAgICAgICAgICAgICAgIC5vZmYoJ2xvYWQnLCB0aGlzLl9vblN0eWxlTG9hZClcbiAgICAgICAgICAgICAgICAub2ZmKCdlcnJvcicsIHRoaXMuX2ZvcndhcmRTdHlsZUV2ZW50KVxuICAgICAgICAgICAgICAgIC5vZmYoJ2NoYW5nZScsIHRoaXMuX29uU3R5bGVDaGFuZ2UpXG4gICAgICAgICAgICAgICAgLm9mZignc291cmNlLmFkZCcsIHRoaXMuX29uU291cmNlQWRkKVxuICAgICAgICAgICAgICAgIC5vZmYoJ3NvdXJjZS5yZW1vdmUnLCB0aGlzLl9vblNvdXJjZVJlbW92ZSlcbiAgICAgICAgICAgICAgICAub2ZmKCdzb3VyY2UubG9hZCcsIHRoaXMuX29uU291cmNlVXBkYXRlKVxuICAgICAgICAgICAgICAgIC5vZmYoJ3NvdXJjZS5lcnJvcicsIHRoaXMuX2ZvcndhcmRTb3VyY2VFdmVudClcbiAgICAgICAgICAgICAgICAub2ZmKCdzb3VyY2UuY2hhbmdlJywgdGhpcy5fb25Tb3VyY2VVcGRhdGUpXG4gICAgICAgICAgICAgICAgLm9mZignbGF5ZXIuYWRkJywgdGhpcy5fZm9yd2FyZExheWVyRXZlbnQpXG4gICAgICAgICAgICAgICAgLm9mZignbGF5ZXIucmVtb3ZlJywgdGhpcy5fZm9yd2FyZExheWVyRXZlbnQpXG4gICAgICAgICAgICAgICAgLm9mZigndGlsZS5hZGQnLCB0aGlzLl9mb3J3YXJkVGlsZUV2ZW50KVxuICAgICAgICAgICAgICAgIC5vZmYoJ3RpbGUucmVtb3ZlJywgdGhpcy5fZm9yd2FyZFRpbGVFdmVudClcbiAgICAgICAgICAgICAgICAub2ZmKCd0aWxlLmxvYWQnLCB0aGlzLl91cGRhdGUpXG4gICAgICAgICAgICAgICAgLm9mZigndGlsZS5lcnJvcicsIHRoaXMuX2ZvcndhcmRUaWxlRXZlbnQpXG4gICAgICAgICAgICAgICAgLm9mZigndGlsZS5zdGF0cycsIHRoaXMuX2ZvcndhcmRUaWxlRXZlbnQpXG4gICAgICAgICAgICAgICAgLl9yZW1vdmUoKTtcblxuICAgICAgICAgICAgdGhpcy5vZmYoJ3JvdGF0ZScsIHRoaXMuc3R5bGUuX3JlZG9QbGFjZW1lbnQpO1xuICAgICAgICAgICAgdGhpcy5vZmYoJ3BpdGNoJywgdGhpcy5zdHlsZS5fcmVkb1BsYWNlbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXN0eWxlKSB7XG4gICAgICAgICAgICB0aGlzLnN0eWxlID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2UgaWYgKHN0eWxlIGluc3RhbmNlb2YgU3R5bGUpIHtcbiAgICAgICAgICAgIHRoaXMuc3R5bGUgPSBzdHlsZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3R5bGUgPSBuZXcgU3R5bGUoc3R5bGUsIHRoaXMuYW5pbWF0aW9uTG9vcCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN0eWxlXG4gICAgICAgICAgICAub24oJ2xvYWQnLCB0aGlzLl9vblN0eWxlTG9hZClcbiAgICAgICAgICAgIC5vbignZXJyb3InLCB0aGlzLl9mb3J3YXJkU3R5bGVFdmVudClcbiAgICAgICAgICAgIC5vbignY2hhbmdlJywgdGhpcy5fb25TdHlsZUNoYW5nZSlcbiAgICAgICAgICAgIC5vbignc291cmNlLmFkZCcsIHRoaXMuX29uU291cmNlQWRkKVxuICAgICAgICAgICAgLm9uKCdzb3VyY2UucmVtb3ZlJywgdGhpcy5fb25Tb3VyY2VSZW1vdmUpXG4gICAgICAgICAgICAub24oJ3NvdXJjZS5sb2FkJywgdGhpcy5fb25Tb3VyY2VVcGRhdGUpXG4gICAgICAgICAgICAub24oJ3NvdXJjZS5lcnJvcicsIHRoaXMuX2ZvcndhcmRTb3VyY2VFdmVudClcbiAgICAgICAgICAgIC5vbignc291cmNlLmNoYW5nZScsIHRoaXMuX29uU291cmNlVXBkYXRlKVxuICAgICAgICAgICAgLm9uKCdsYXllci5hZGQnLCB0aGlzLl9mb3J3YXJkTGF5ZXJFdmVudClcbiAgICAgICAgICAgIC5vbignbGF5ZXIucmVtb3ZlJywgdGhpcy5fZm9yd2FyZExheWVyRXZlbnQpXG4gICAgICAgICAgICAub24oJ3RpbGUuYWRkJywgdGhpcy5fZm9yd2FyZFRpbGVFdmVudClcbiAgICAgICAgICAgIC5vbigndGlsZS5yZW1vdmUnLCB0aGlzLl9mb3J3YXJkVGlsZUV2ZW50KVxuICAgICAgICAgICAgLm9uKCd0aWxlLmxvYWQnLCB0aGlzLl91cGRhdGUpXG4gICAgICAgICAgICAub24oJ3RpbGUuZXJyb3InLCB0aGlzLl9mb3J3YXJkVGlsZUV2ZW50KVxuICAgICAgICAgICAgLm9uKCd0aWxlLnN0YXRzJywgdGhpcy5fZm9yd2FyZFRpbGVFdmVudCk7XG5cbiAgICAgICAgdGhpcy5vbigncm90YXRlJywgdGhpcy5zdHlsZS5fcmVkb1BsYWNlbWVudCk7XG4gICAgICAgIHRoaXMub24oJ3BpdGNoJywgdGhpcy5zdHlsZS5fcmVkb1BsYWNlbWVudCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCBhIHNvdXJjZSB0byB0aGUgbWFwIHN0eWxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIElEIG9mIHRoZSBzb3VyY2UuIE11c3Qgbm90IGJlIHVzZWQgYnkgYW55IGV4aXN0aW5nIHNvdXJjZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIHNvdXJjZSBzcGVjaWZpY2F0aW9uLCBmb2xsb3dpbmcgdGhlXG4gICAgICogW01hcGJveCBHTCBTdHlsZSBSZWZlcmVuY2VdKGh0dHBzOi8vd3d3Lm1hcGJveC5jb20vbWFwYm94LWdsLXN0eWxlLXNwZWMvI3NvdXJjZXMpXG4gICAgICogQGZpcmVzIHNvdXJjZS5hZGRcbiAgICAgKiBAcmV0dXJucyB7TWFwfSBgdGhpc2BcbiAgICAgKi9cbiAgICBhZGRTb3VyY2U6IGZ1bmN0aW9uKGlkLCBzb3VyY2UpIHtcbiAgICAgICAgdGhpcy5zdHlsZS5hZGRTb3VyY2UoaWQsIHNvdXJjZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYW4gZXhpc3Rpbmcgc291cmNlIGZyb20gdGhlIG1hcCBzdHlsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBJRCBvZiB0aGUgc291cmNlIHRvIHJlbW92ZVxuICAgICAqIEBmaXJlcyBzb3VyY2UucmVtb3ZlXG4gICAgICogQHJldHVybnMge01hcH0gYHRoaXNgXG4gICAgICovXG4gICAgcmVtb3ZlU291cmNlOiBmdW5jdGlvbihpZCkge1xuICAgICAgICB0aGlzLnN0eWxlLnJlbW92ZVNvdXJjZShpZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHN0eWxlIHNvdXJjZSBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gYGlkYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBzb3VyY2UgSURcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGdldFNvdXJjZTogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3R5bGUuZ2V0U291cmNlKGlkKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGEgbGF5ZXIgdG8gdGhlIG1hcCBzdHlsZS4gVGhlIGxheWVyIHdpbGwgYmUgaW5zZXJ0ZWQgYmVmb3JlIHRoZSBsYXllciB3aXRoXG4gICAgICogSUQgYGJlZm9yZWAsIG9yIGFwcGVuZGVkIGlmIGBiZWZvcmVgIGlzIG9taXR0ZWQuXG4gICAgICogQHBhcmFtIHtTdHlsZUxheWVyfE9iamVjdH0gbGF5ZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IGJlZm9yZSAgSUQgb2YgYW4gZXhpc3RpbmcgbGF5ZXIgdG8gaW5zZXJ0IGJlZm9yZVxuICAgICAqIEBmaXJlcyBsYXllci5hZGRcbiAgICAgKiBAcmV0dXJucyB7TWFwfSBgdGhpc2BcbiAgICAgKi9cbiAgICBhZGRMYXllcjogZnVuY3Rpb24obGF5ZXIsIGJlZm9yZSkge1xuICAgICAgICB0aGlzLnN0eWxlLmFkZExheWVyKGxheWVyLCBiZWZvcmUpO1xuICAgICAgICB0aGlzLnN0eWxlLl9jYXNjYWRlKHRoaXMuX2NsYXNzZXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHRoZSBsYXllciB3aXRoIHRoZSBnaXZlbiBgaWRgIGZyb20gdGhlIG1hcC4gQW55IGxheWVycyB3aGljaCByZWZlciB0byB0aGVcbiAgICAgKiBzcGVjaWZpZWQgbGF5ZXIgdmlhIGEgYHJlZmAgcHJvcGVydHkgYXJlIGFsc28gcmVtb3ZlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBsYXllciBpZFxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBpZiBubyBsYXllciB3aXRoIHRoZSBnaXZlbiBgaWRgIGV4aXN0c1xuICAgICAqIEBmaXJlcyBsYXllci5yZW1vdmVcbiAgICAgKiBAcmV0dXJucyB7TWFwfSBgdGhpc2BcbiAgICAgKi9cbiAgICByZW1vdmVMYXllcjogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgdGhpcy5zdHlsZS5yZW1vdmVMYXllcihpZCk7XG4gICAgICAgIHRoaXMuc3R5bGUuX2Nhc2NhZGUodGhpcy5fY2xhc3Nlcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHN0eWxlIGxheWVyIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBgaWRgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIGxheWVyIGlkXG4gICAgICogQHJldHVybnMgez9PYmplY3R9IGEgbGF5ZXIsIGlmIG9uZSB3aXRoIHRoZSBnaXZlbiBgaWRgIGV4aXN0c1xuICAgICAqL1xuICAgIGdldExheWVyOiBmdW5jdGlvbihpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHlsZS5nZXRMYXllcihpZCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgZmlsdGVyIGZvciBhIGdpdmVuIHN0eWxlIGxheWVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxheWVyIElEIG9mIGEgbGF5ZXJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBmaWx0ZXIgZmlsdGVyIHNwZWNpZmljYXRpb24sIGFzIGRlZmluZWQgaW4gdGhlIFtTdHlsZSBTcGVjaWZpY2F0aW9uXShodHRwczovL3d3dy5tYXBib3guY29tL21hcGJveC1nbC1zdHlsZS1zcGVjLyN0eXBlcy1maWx0ZXIpXG4gICAgICogQHJldHVybnMge01hcH0gYHRoaXNgXG4gICAgICovXG4gICAgc2V0RmlsdGVyOiBmdW5jdGlvbihsYXllciwgZmlsdGVyKSB7XG4gICAgICAgIHRoaXMuc3R5bGUuc2V0RmlsdGVyKGxheWVyLCBmaWx0ZXIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSB6b29tIGV4dGVudCBmb3IgYSBnaXZlbiBzdHlsZSBsYXllci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsYXllcklkIElEIG9mIGEgbGF5ZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWluem9vbSBtaW5pbXVtIHpvb20gZXh0ZW50XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1heHpvb20gbWF4aW11bSB6b29tIGV4dGVudFxuICAgICAqIEByZXR1cm5zIHtNYXB9IGB0aGlzYFxuICAgICAqL1xuICAgIHNldExheWVyWm9vbVJhbmdlOiBmdW5jdGlvbihsYXllcklkLCBtaW56b29tLCBtYXh6b29tKSB7XG4gICAgICAgIHRoaXMuc3R5bGUuc2V0TGF5ZXJab29tUmFuZ2UobGF5ZXJJZCwgbWluem9vbSwgbWF4em9vbSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGZpbHRlciBmb3IgYSBnaXZlbiBzdHlsZSBsYXllci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsYXllciBJRCBvZiBhIGxheWVyXG4gICAgICogQHJldHVybnMge0FycmF5fSBmaWx0ZXIgc3BlY2lmaWNhdGlvbiwgYXMgZGVmaW5lZCBpbiB0aGUgW1N0eWxlIFNwZWNpZmljYXRpb25dKGh0dHBzOi8vd3d3Lm1hcGJveC5jb20vbWFwYm94LWdsLXN0eWxlLXNwZWMvI2ZpbHRlcilcbiAgICAgKi9cbiAgICBnZXRGaWx0ZXI6IGZ1bmN0aW9uKGxheWVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0eWxlLmdldEZpbHRlcihsYXllcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgdmFsdWUgb2YgYSBwYWludCBwcm9wZXJ0eSBpbiBhIGdpdmVuIHN0eWxlIGxheWVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxheWVyIElEIG9mIGEgbGF5ZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBuYW1lIG9mIGEgcGFpbnQgcHJvcGVydHlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIHZhbHVlIGZvciB0aGUgcGFpbnQgcHJvcGVyeTsgbXVzdCBoYXZlIHRoZSB0eXBlIGFwcHJvcHJpYXRlIGZvciB0aGUgcHJvcGVydHkgYXMgZGVmaW5lZCBpbiB0aGUgW1N0eWxlIFNwZWNpZmljYXRpb25dKGh0dHBzOi8vd3d3Lm1hcGJveC5jb20vbWFwYm94LWdsLXN0eWxlLXNwZWMvKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0ga2xhc3Mgb3B0aW9uYWwgY2xhc3Mgc3BlY2lmaWVyIGZvciB0aGUgcHJvcGVydHlcbiAgICAgKiBAcmV0dXJucyB7TWFwfSBgdGhpc2BcbiAgICAgKi9cbiAgICBzZXRQYWludFByb3BlcnR5OiBmdW5jdGlvbihsYXllciwgbmFtZSwgdmFsdWUsIGtsYXNzKSB7XG4gICAgICAgIHRoaXMuYmF0Y2goZnVuY3Rpb24oYmF0Y2gpIHtcbiAgICAgICAgICAgIGJhdGNoLnNldFBhaW50UHJvcGVydHkobGF5ZXIsIG5hbWUsIHZhbHVlLCBrbGFzcyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHZhbHVlIG9mIGEgcGFpbnQgcHJvcGVydHkgaW4gYSBnaXZlbiBzdHlsZSBsYXllci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsYXllciBJRCBvZiBhIGxheWVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgbmFtZSBvZiBhIHBhaW50IHByb3BlcnR5XG4gICAgICogQHBhcmFtIHtzdHJpbmc9fSBrbGFzcyBvcHRpb25hbCBjbGFzcyBzcGVjaWZpZXIgZm9yIHRoZSBwcm9wZXJ0eVxuICAgICAqIEByZXR1cm5zIHsqfSB2YWx1ZSBmb3IgdGhlIHBhaW50IHByb3BlcnlcbiAgICAgKi9cbiAgICBnZXRQYWludFByb3BlcnR5OiBmdW5jdGlvbihsYXllciwgbmFtZSwga2xhc3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3R5bGUuZ2V0UGFpbnRQcm9wZXJ0eShsYXllciwgbmFtZSwga2xhc3MpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHZhbHVlIG9mIGEgbGF5b3V0IHByb3BlcnR5IGluIGEgZ2l2ZW4gc3R5bGUgbGF5ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXIgSUQgb2YgYSBsYXllclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIG5hbWUgb2YgYSBsYXlvdXQgcHJvcGVydHlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIHZhbHVlIGZvciB0aGUgbGF5b3V0IHByb3Blcnk7IG11c3QgaGF2ZSB0aGUgdHlwZSBhcHByb3ByaWF0ZSBmb3IgdGhlIHByb3BlcnR5IGFzIGRlZmluZWQgaW4gdGhlIFtTdHlsZSBTcGVjaWZpY2F0aW9uXShodHRwczovL3d3dy5tYXBib3guY29tL21hcGJveC1nbC1zdHlsZS1zcGVjLylcbiAgICAgKiBAcmV0dXJucyB7TWFwfSBgdGhpc2BcbiAgICAgKi9cbiAgICBzZXRMYXlvdXRQcm9wZXJ0eTogZnVuY3Rpb24obGF5ZXIsIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYmF0Y2goZnVuY3Rpb24oYmF0Y2gpIHtcbiAgICAgICAgICAgIGJhdGNoLnNldExheW91dFByb3BlcnR5KGxheWVyLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHZhbHVlIG9mIGEgbGF5b3V0IHByb3BlcnR5IGluIGEgZ2l2ZW4gc3R5bGUgbGF5ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXIgSUQgb2YgYSBsYXllclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIG5hbWUgb2YgYSBsYXlvdXQgcHJvcGVydHlcbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IGtsYXNzIG9wdGlvbmFsIGNsYXNzIHNwZWNpZmllciBmb3IgdGhlIHByb3BlcnR5XG4gICAgICogQHJldHVybnMgeyp9IHZhbHVlIGZvciB0aGUgbGF5b3V0IHByb3BlcnlcbiAgICAgKi9cbiAgICBnZXRMYXlvdXRQcm9wZXJ0eTogZnVuY3Rpb24obGF5ZXIsIG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3R5bGUuZ2V0TGF5b3V0UHJvcGVydHkobGF5ZXIsIG5hbWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIE1hcCdzIGNvbnRhaW5lciBhcyBhbiBIVE1MIGVsZW1lbnRcbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lclxuICAgICAqL1xuICAgIGdldENvbnRhaW5lcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250YWluZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY29udGFpbmVyIGZvciB0aGUgbWFwIGBjYW52YXNgIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiB5b3Ugd2FudCB0byBhZGQgbm9uLUdMIG92ZXJsYXlzIHRvIHRoZSBtYXAsIHlvdSBzaG91bGQgYXBwZW5kIHRoZW0gdG8gdGhpcyBlbGVtZW50LiBUaGlzXG4gICAgICogaXMgdGhlIGVsZW1lbnQgdG8gd2hpY2ggZXZlbnQgYmluZGluZ3MgZm9yIG1hcCBpbnRlcmFjdGl2aXR5IHN1Y2ggYXMgcGFubmluZyBhbmQgem9vbWluZyBhcmVcbiAgICAgKiBhdHRhY2hlZC4gSXQgd2lsbCByZWNlaXZlIGJ1YmJsZWQgZXZlbnRzIGZvciBjaGlsZCBlbGVtZW50cyBzdWNoIGFzIHRoZSBgY2FudmFzYCwgYnV0IG5vdCBmb3JcbiAgICAgKiBtYXAgY29udHJvbHMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lclxuICAgICAqL1xuICAgIGdldENhbnZhc0NvbnRhaW5lcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYW52YXNDb250YWluZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgTWFwJ3MgY2FudmFzIGFzIGFuIEhUTUwgY2FudmFzXG4gICAgICogQHJldHVybnMge0hUTUxFbGVtZW50fSBjYW52YXNcbiAgICAgKi9cbiAgICBnZXRDYW52YXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FudmFzLmdldEVsZW1lbnQoKTtcbiAgICB9LFxuXG4gICAgX3NldHVwQ29udGFpbmVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGlkID0gdGhpcy5vcHRpb25zLmNvbnRhaW5lcjtcblxuICAgICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gdHlwZW9mIGlkID09PSAnc3RyaW5nJyA/IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKSA6IGlkO1xuICAgICAgICBjb250YWluZXIuY2xhc3NMaXN0LmFkZCgnbWFwYm94Z2wtbWFwJyk7XG5cbiAgICAgICAgdmFyIGNhbnZhc0NvbnRhaW5lciA9IHRoaXMuX2NhbnZhc0NvbnRhaW5lciA9IERPTS5jcmVhdGUoJ2RpdicsICdtYXBib3hnbC1jYW52YXMtY29udGFpbmVyJywgY29udGFpbmVyKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZSkge1xuICAgICAgICAgICAgY2FudmFzQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ21hcGJveGdsLWludGVyYWN0aXZlJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2FudmFzID0gbmV3IENhbnZhcyh0aGlzLCBjYW52YXNDb250YWluZXIpO1xuXG4gICAgICAgIHZhciBjb250cm9sQ29udGFpbmVyID0gdGhpcy5fY29udHJvbENvbnRhaW5lciA9IERPTS5jcmVhdGUoJ2RpdicsICdtYXBib3hnbC1jb250cm9sLWNvbnRhaW5lcicsIGNvbnRhaW5lcik7XG4gICAgICAgIHZhciBjb3JuZXJzID0gdGhpcy5fY29udHJvbENvcm5lcnMgPSB7fTtcbiAgICAgICAgWyd0b3AtbGVmdCcsICd0b3AtcmlnaHQnLCAnYm90dG9tLWxlZnQnLCAnYm90dG9tLXJpZ2h0J10uZm9yRWFjaChmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgICAgICBjb3JuZXJzW3Bvc10gPSBET00uY3JlYXRlKCdkaXYnLCAnbWFwYm94Z2wtY3RybC0nICsgcG9zLCBjb250cm9sQ29udGFpbmVyKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIF9zZXR1cFBhaW50ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZ2wgPSB0aGlzLl9jYW52YXMuZ2V0V2ViR0xDb250ZXh0KHtcbiAgICAgICAgICAgIGZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQ6IHRoaXMub3B0aW9ucy5mYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0LFxuICAgICAgICAgICAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiB0aGlzLm9wdGlvbnMucHJlc2VydmVEcmF3aW5nQnVmZmVyXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghZ2wpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBpbml0aWFsaXplIFdlYkdMJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnBhaW50ZXIgPSBuZXcgUGFpbnRlcihnbCwgdGhpcy50cmFuc2Zvcm0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXZWJHTCBDb250ZXh0IExvc3QgZXZlbnQuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgd2ViZ2xjb250ZXh0bG9zdFxuICAgICAqIEBtZW1iZXJvZiBNYXBcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7RXZlbnR9IG9yaWdpbmFsRXZlbnQgdGhlIG9yaWdpbmFsIERPTSBldmVudFxuICAgICAqL1xuICAgIF9jb250ZXh0TG9zdDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgaWYgKHRoaXMuX2ZyYW1lSWQpIHtcbiAgICAgICAgICAgIGJyb3dzZXIuY2FuY2VsRnJhbWUodGhpcy5fZnJhbWVJZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5maXJlKFwid2ViZ2xjb250ZXh0bG9zdFwiLCB7b3JpZ2luYWxFdmVudDogZXZlbnR9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2ViR0wgQ29udGV4dCBSZXN0b3JlZCBldmVudC5cbiAgICAgKlxuICAgICAqIEBldmVudCB3ZWJnbGNvbnRleHRyZXN0b3JlZFxuICAgICAqIEBtZW1iZXJvZiBNYXBcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIF9jb250ZXh0UmVzdG9yZWQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuX3NldHVwUGFpbnRlcigpO1xuICAgICAgICB0aGlzLnJlc2l6ZSgpO1xuICAgICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICAgICAgdGhpcy5maXJlKFwid2ViZ2xjb250ZXh0cmVzdG9yZWRcIiwge29yaWdpbmFsRXZlbnQ6IGV2ZW50fSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIElzIHRoaXMgbWFwIGZ1bGx5IGxvYWRlZD8gSWYgdGhlIHN0eWxlIGlzbid0IGxvYWRlZFxuICAgICAqIG9yIGl0IGhhcyBhIGNoYW5nZSB0byB0aGUgc291cmNlcyBvciBzdHlsZSB0aGF0IGlzbid0XG4gICAgICogcHJvcGFnYXRlZCB0byBpdHMgc3R5bGUsIHJldHVybiBmYWxzZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIHRoZSBtYXAgaXMgbG9hZGVkXG4gICAgICovXG4gICAgbG9hZGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0eWxlRGlydHkgfHwgdGhpcy5fc291cmNlc0RpcnR5KVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5zdHlsZSAmJiAhdGhpcy5zdHlsZS5sb2FkZWQoKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGlzIG1hcCdzIHN0eWxlIGFuZCBzb3VyY2VzLCBhbmQgcmUtcmVuZGVyIHRoZSBtYXAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHVwZGF0ZVN0eWxlIG1hcmsgdGhlIG1hcCdzIHN0eWxlIGZvciByZXByb2Nlc3NpbmcgYXNcbiAgICAgKiB3ZWxsIGFzIGl0cyBzb3VyY2VzXG4gICAgICogQHJldHVybnMge01hcH0gdGhpc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3VwZGF0ZTogZnVuY3Rpb24odXBkYXRlU3R5bGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLnN0eWxlKSByZXR1cm4gdGhpcztcblxuICAgICAgICB0aGlzLl9zdHlsZURpcnR5ID0gdGhpcy5fc3R5bGVEaXJ0eSB8fCB1cGRhdGVTdHlsZTtcbiAgICAgICAgdGhpcy5fc291cmNlc0RpcnR5ID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLl9yZXJlbmRlcigpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxsIHdoZW4gYSAocmUtKXJlbmRlciBvZiB0aGUgbWFwIGlzIHJlcXVpcmVkLCBlLmcuIHdoZW4gdGhlXG4gICAgICogdXNlciBwYW5uZWQgb3Igem9vbWVkLGYgb3IgbmV3IGRhdGEgaXMgYXZhaWxhYmxlLlxuICAgICAqIEByZXR1cm5zIHtNYXB9IHRoaXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5zdHlsZSAmJiB0aGlzLl9zdHlsZURpcnR5KSB7XG4gICAgICAgICAgICB0aGlzLl9zdHlsZURpcnR5ID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnN0eWxlLl9yZWNhbGN1bGF0ZSh0aGlzLnRyYW5zZm9ybS56b29tKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnN0eWxlICYmIHRoaXMuX3NvdXJjZXNEaXJ0eSAmJiAhdGhpcy5fc291cmNlc0RpcnR5VGltZW91dCkge1xuICAgICAgICAgICAgdGhpcy5fc291cmNlc0RpcnR5ID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9zb3VyY2VzRGlydHlUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zb3VyY2VzRGlydHlUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSwgNTApO1xuICAgICAgICAgICAgdGhpcy5zdHlsZS5fdXBkYXRlU291cmNlcyh0aGlzLnRyYW5zZm9ybSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnBhaW50ZXIucmVuZGVyKHRoaXMuc3R5bGUsIHtcbiAgICAgICAgICAgIGRlYnVnOiB0aGlzLmRlYnVnLFxuICAgICAgICAgICAgdmVydGljZXM6IHRoaXMudmVydGljZXMsXG4gICAgICAgICAgICByb3RhdGluZzogdGhpcy5yb3RhdGluZyxcbiAgICAgICAgICAgIHpvb21pbmc6IHRoaXMuem9vbWluZ1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmZpcmUoJ3JlbmRlcicpO1xuXG4gICAgICAgIGlmICh0aGlzLmxvYWRlZCgpICYmICF0aGlzLl9sb2FkZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ2xvYWQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2ZyYW1lSWQgPSBudWxsO1xuXG4gICAgICAgIGlmICghdGhpcy5hbmltYXRpb25Mb29wLnN0b3BwZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5fc3R5bGVEaXJ0eSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fc291cmNlc0RpcnR5IHx8IHRoaXMuX3JlcGFpbnQgfHwgIXRoaXMuYW5pbWF0aW9uTG9vcC5zdG9wcGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcmVuZGVyKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgdGhlIG1hcCdzIHVuZGVybHlpbmcgcmVzb3VyY2VzLCBpbmNsdWRpbmcgd2ViIHdvcmtlcnMgYW5kIERPTSBlbGVtZW50cy4gQWZ0ZXJ3YXJkcyxcbiAgICAgKiB5b3UgbXVzdCBub3QgY2FsbCBhbnkgZnVydGhlciBtZXRob2RzIG9uIHRoaXMgTWFwIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICAgKi9cbiAgICByZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5faGFzaCkgdGhpcy5faGFzaC5yZW1vdmUoKTtcbiAgICAgICAgYnJvd3Nlci5jYW5jZWxGcmFtZSh0aGlzLl9mcmFtZUlkKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3NvdXJjZXNEaXJ0eVRpbWVvdXQpO1xuICAgICAgICB0aGlzLnNldFN0eWxlKG51bGwpO1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9vbldpbmRvd1Jlc2l6ZSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJlbW92ZU5vZGUodGhpcy5fY2FudmFzQ29udGFpbmVyKTtcbiAgICAgICAgcmVtb3ZlTm9kZSh0aGlzLl9jb250cm9sQ29udGFpbmVyKTtcbiAgICAgICAgdGhpcy5fY29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoJ21hcGJveGdsLW1hcCcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIGRlZmF1bHQgZXJyb3IgaGFuZGxlciBmb3IgYHN0eWxlLmVycm9yYCwgYHNvdXJjZS5lcnJvcmAsIGFuZCBgdGlsZS5lcnJvcmAgZXZlbnRzLlxuICAgICAqIEl0IGxvZ3MgdGhlIGVycm9yIHZpYSBgY29uc29sZS5lcnJvcmAuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIERpc2FibGUgdGhlIGRlZmF1bHQgZXJyb3IgaGFuZGxlclxuICAgICAqIG1hcC5vZmYoJ3N0eWxlLmVycm9yJywgbWFwLm9uRXJyb3IpO1xuICAgICAqIG1hcC5vZmYoJ3NvdXJjZS5lcnJvcicsIG1hcC5vbkVycm9yKTtcbiAgICAgKiBtYXAub2ZmKCd0aWxlLmVycm9yJywgbWFwLm9uRXJyb3IpO1xuICAgICAqL1xuICAgIG9uRXJyb3I6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlLmVycm9yKTtcbiAgICB9LFxuXG4gICAgX3JlcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuc3R5bGUgJiYgIXRoaXMuX2ZyYW1lSWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZyYW1lSWQgPSBicm93c2VyLmZyYW1lKHRoaXMuX3JlbmRlcik7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2ZvcndhcmRTdHlsZUV2ZW50OiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHRoaXMuZmlyZSgnc3R5bGUuJyArIGUudHlwZSwgdXRpbC5leHRlbmQoe3N0eWxlOiBlLnRhcmdldH0sIGUpKTtcbiAgICB9LFxuXG4gICAgX2ZvcndhcmRTb3VyY2VFdmVudDogZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGlzLmZpcmUoZS50eXBlLCB1dGlsLmV4dGVuZCh7c3R5bGU6IGUudGFyZ2V0fSwgZSkpO1xuICAgIH0sXG5cbiAgICBfZm9yd2FyZExheWVyRXZlbnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdGhpcy5maXJlKGUudHlwZSwgdXRpbC5leHRlbmQoe3N0eWxlOiBlLnRhcmdldH0sIGUpKTtcbiAgICB9LFxuXG4gICAgX2ZvcndhcmRUaWxlRXZlbnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdGhpcy5maXJlKGUudHlwZSwgdXRpbC5leHRlbmQoe3N0eWxlOiBlLnRhcmdldH0sIGUpKTtcbiAgICB9LFxuXG4gICAgX29uU3R5bGVMb2FkOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmICh0aGlzLnRyYW5zZm9ybS51bm1vZGlmaWVkKSB7XG4gICAgICAgICAgICB0aGlzLmp1bXBUbyh0aGlzLnN0eWxlLnN0eWxlc2hlZXQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3R5bGUuX2Nhc2NhZGUodGhpcy5fY2xhc3Nlcywge3RyYW5zaXRpb246IGZhbHNlfSk7XG4gICAgICAgIHRoaXMuX2ZvcndhcmRTdHlsZUV2ZW50KGUpO1xuICAgIH0sXG5cbiAgICBfb25TdHlsZUNoYW5nZTogZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGlzLl91cGRhdGUodHJ1ZSk7XG4gICAgICAgIHRoaXMuX2ZvcndhcmRTdHlsZUV2ZW50KGUpO1xuICAgIH0sXG5cbiAgICBfb25Tb3VyY2VBZGQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGUuc291cmNlO1xuICAgICAgICBpZiAoc291cmNlLm9uQWRkKVxuICAgICAgICAgICAgc291cmNlLm9uQWRkKHRoaXMpO1xuICAgICAgICB0aGlzLl9mb3J3YXJkU291cmNlRXZlbnQoZSk7XG4gICAgfSxcblxuICAgIF9vblNvdXJjZVJlbW92ZTogZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgc291cmNlID0gZS5zb3VyY2U7XG4gICAgICAgIGlmIChzb3VyY2Uub25SZW1vdmUpXG4gICAgICAgICAgICBzb3VyY2Uub25SZW1vdmUodGhpcyk7XG4gICAgICAgIHRoaXMuX2ZvcndhcmRTb3VyY2VFdmVudChlKTtcbiAgICB9LFxuXG4gICAgX29uU291cmNlVXBkYXRlOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgICB0aGlzLl9mb3J3YXJkU291cmNlRXZlbnQoZSk7XG4gICAgfSxcblxuICAgIF9vbldpbmRvd1Jlc2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc3RvcCgpLnJlc2l6ZSgpLl91cGRhdGUoKTtcbiAgICB9XG59KTtcblxuXG4vKipcbiAqIENhbGxiYWNrIHRvIHJlY2VpdmUgcmVzdWx0cyBmcm9tIGBNYXAjZmVhdHVyZXNBdGAgYW5kIGBNYXAjZmVhdHVyZXNJbmAuXG4gKlxuICogTm90ZTogYmVjYXVzZSBmZWF0dXJlcyBjb21lIGZyb20gdmVjdG9yIHRpbGVzIG9yIEdlb0pTT04gZGF0YSB0aGF0IGlzIGNvbnZlcnRlZCB0byB2ZWN0b3IgdGlsZXMgaW50ZXJuYWxseSwgdGhlIHJldHVybmVkIGZlYXR1cmVzIHdpbGwgYmU6XG4gKlxuICogMS4gVHJ1bmNhdGVkIGF0IHRpbGUgYm91bmRhcmllcy5cbiAqIDIuIER1cGxpY2F0ZWQgYWNyb3NzIHRpbGUgYm91bmRhcmllcy5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgc3VwcG9zZSB0aGVyZSBpcyBhIGhpZ2h3YXkgcnVubmluZyB0aHJvdWdoIHlvdXIgcmVjdGFuZ2xlIGluIGEgYGZlYXR1cmVzSW5gIHF1ZXJ5LiBgZmVhdHVyZXNJbmAgd2lsbCBvbmx5IGdpdmUgeW91IHRoZSBwYXJ0cyBvZiB0aGUgaGlnaHdheSBmZWF0dXJlIHRoYXQgbGllIHdpdGhpbiB0aGUgbWFwIHRpbGVzIGNvdmVyaW5nIHlvdXIgcmVjdGFuZ2xlLCBldmVuIGlmIHRoZSByb2FkIGFjdHVhbGx5IGV4dGVuZHMgaW50byBvdGhlciB0aWxlcy4gQWxzbywgdGhlIHBvcnRpb24gb2YgdGhlIGhpZ2h3YXkgd2l0aGluIGVhY2ggbWFwIHRpbGUgd2lsbCBjb21lIGJhY2sgYXMgYSBzZXBhcmF0ZSBmZWF0dXJlLlxuICpcbiAqIEBjYWxsYmFjayBmZWF0dXJlc0NhbGxiYWNrXG4gKiBAcGFyYW0gez9FcnJvcn0gZXJyIC0gQW4gZXJyb3IgdGhhdCBvY2N1cnJlZCBkdXJpbmcgcXVlcnkgcHJvY2Vzc2luZywgaWYgYW55LiBJZiB0aGlzIHBhcmFtZXRlciBpcyBub24tbnVsbCwgdGhlIGBmZWF0dXJlc2AgcGFyYW1ldGVyIHdpbGwgYmUgbnVsbC5cbiAqIEBwYXJhbSB7P0FycmF5PE9iamVjdD59IGZlYXR1cmVzIC0gQW4gYXJyYXkgb2YgW0dlb0pTT05dKGh0dHA6Ly9nZW9qc29uLm9yZy8pIGZlYXR1cmVzIG1hdGNoaW5nIHRoZSBxdWVyeSBwYXJhbWV0ZXJzLiBUaGUgR2VvSlNPTiBwcm9wZXJ0aWVzIG9mIGVhY2ggZmVhdHVyZSBhcmUgdGFrZW4gZnJvbSB0aGUgb3JpZ2luYWwgc291cmNlLiBFYWNoIGZlYXR1cmUgb2JqZWN0IGFsc28gY29udGFpbnMgYSB0b3AtbGV2ZWwgYGxheWVyYCBwcm9wZXJ0eSB3aG9zZSB2YWx1ZSBpcyBhbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBzdHlsZSBsYXllciB0byB3aGljaCB0aGUgZmVhdHVyZSBiZWxvbmdzLiBMYXlvdXQgYW5kIHBhaW50IHByb3BlcnRpZXMgaW4gdGhpcyBvYmplY3QgY29udGFpbiB2YWx1ZXMgd2hpY2ggYXJlIGZ1bGx5IGV2YWx1YXRlZCBmb3IgdGhlIGdpdmVuIHpvb20gbGV2ZWwgYW5kIGZlYXR1cmUuXG4gKi9cblxuXG51dGlsLmV4dGVuZEFsbChNYXAucHJvdG90eXBlLCAvKiogQGxlbmRzIE1hcC5wcm90b3R5cGUgKi97XG5cbiAgICAvKipcbiAgICAgKiBFbmFibGUgZGVidWdnaW5nIG1vZGVcbiAgICAgKlxuICAgICAqIEBuYW1lIGRlYnVnXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgX2RlYnVnOiBmYWxzZSxcbiAgICBnZXQgZGVidWcoKSB7IHJldHVybiB0aGlzLl9kZWJ1ZzsgfSxcbiAgICBzZXQgZGVidWcodmFsdWUpIHsgdGhpcy5fZGVidWcgPSB2YWx1ZTsgdGhpcy5fdXBkYXRlKCk7IH0sXG5cbiAgICAvKipcbiAgICAgKiBTaG93IGNvbGxpc2lvbiBib3hlczogdXNlZnVsIGZvciBkZWJ1Z2dpbmcgbGFiZWwgcGxhY2VtZW50XG4gICAgICogaW4gc3R5bGVzLlxuICAgICAqXG4gICAgICogQG5hbWUgY29sbGlzaW9uRGVidWdcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBfY29sbGlzaW9uRGVidWc6IGZhbHNlLFxuICAgIGdldCBjb2xsaXNpb25EZWJ1ZygpIHsgcmV0dXJuIHRoaXMuX2NvbGxpc2lvbkRlYnVnOyB9LFxuICAgIHNldCBjb2xsaXNpb25EZWJ1Zyh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9jb2xsaXNpb25EZWJ1ZyA9IHZhbHVlO1xuICAgICAgICB0aGlzLnN0eWxlLl9yZWRvUGxhY2VtZW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEVuYWJsZSBjb250aW51b3VzIHJlcGFpbnQgdG8gYW5hbHl6ZSBwZXJmb3JtYW5jZVxuICAgICAqXG4gICAgICogQG5hbWUgcmVwYWludFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIF9yZXBhaW50OiBmYWxzZSxcbiAgICBnZXQgcmVwYWludCgpIHsgcmV0dXJuIHRoaXMuX3JlcGFpbnQ7IH0sXG4gICAgc2V0IHJlcGFpbnQodmFsdWUpIHsgdGhpcy5fcmVwYWludCA9IHZhbHVlOyB0aGlzLl91cGRhdGUoKTsgfSxcblxuICAgIC8vIHNob3cgdmVydGljZXNcbiAgICBfdmVydGljZXM6IGZhbHNlLFxuICAgIGdldCB2ZXJ0aWNlcygpIHsgcmV0dXJuIHRoaXMuX3ZlcnRpY2VzOyB9LFxuICAgIHNldCB2ZXJ0aWNlcyh2YWx1ZSkgeyB0aGlzLl92ZXJ0aWNlcyA9IHZhbHVlOyB0aGlzLl91cGRhdGUoKTsgfVxufSk7XG5cbmZ1bmN0aW9uIHJlbW92ZU5vZGUobm9kZSkge1xuICAgIGlmIChub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgbm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBQb3B1cDtcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcbnZhciBFdmVudGVkID0gcmVxdWlyZSgnLi4vdXRpbC9ldmVudGVkJyk7XG52YXIgRE9NID0gcmVxdWlyZSgnLi4vdXRpbC9kb20nKTtcbnZhciBMbmdMYXQgPSByZXF1aXJlKCcuLi9nZW8vbG5nX2xhdCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBwb3B1cCBjb21wb25lbnRcbiAqIEBjbGFzcyBQb3B1cFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5jbG9zZUJ1dHRvblxuICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmNsb3NlT25DbGlja1xuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuYW5jaG9yIC0gT25lIG9mIFwidG9wXCIsIFwiYm90dG9tXCIsIFwibGVmdFwiLCBcInJpZ2h0XCIsIFwidG9wLWxlZnRcIixcbiAqIFwidG9wLXJpZ2h0XCIsIFwiYm90dG9tLWxlZnRcIiwgb3IgXCJib3R0b20tcmlnaHRcIiwgZGVzY3JpYmluZyB3aGVyZSB0aGUgcG9wdXAncyBhbmNob3JcbiAqIHJlbGF0aXZlIHRvIHRoZSBjb29yZGluYXRlIHNldCB2aWEgYHNldExuZ0xhdGAuXG4gKiBAZXhhbXBsZVxuICogdmFyIHRvb2x0aXAgPSBuZXcgbWFwYm94Z2wuUG9wdXAoKVxuICogICAuc2V0TG5nTGF0KGUubG5nTGF0KVxuICogICAuc2V0SFRNTChcIjxoMT5IZWxsbyBXb3JsZCE8L2gxPlwiKVxuICogICAuYWRkVG8obWFwKTtcbiAqL1xuZnVuY3Rpb24gUG9wdXAob3B0aW9ucykge1xuICAgIHV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcbiAgICB1dGlsLmJpbmRBbGwoW1xuICAgICAgICAnX3VwZGF0ZScsXG4gICAgICAgICdfb25DbGlja0Nsb3NlJ10sXG4gICAgICAgIHRoaXMpO1xufVxuXG5Qb3B1cC5wcm90b3R5cGUgPSB1dGlsLmluaGVyaXQoRXZlbnRlZCwgLyoqIEBsZW5kcyBQb3B1cC5wcm90b3R5cGUgKi97XG4gICAgb3B0aW9uczoge1xuICAgICAgICBjbG9zZUJ1dHRvbjogdHJ1ZSxcbiAgICAgICAgY2xvc2VPbkNsaWNrOiB0cnVlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEF0dGFjaGVzIHRoZSBwb3B1cCB0byBhIG1hcFxuICAgICAqIEBwYXJhbSB7TWFwfSBtYXBcbiAgICAgKiBAcmV0dXJucyB7UG9wdXB9IGB0aGlzYFxuICAgICAqL1xuICAgIGFkZFRvOiBmdW5jdGlvbihtYXApIHtcbiAgICAgICAgdGhpcy5fbWFwID0gbWFwO1xuICAgICAgICB0aGlzLl9tYXAub24oJ21vdmUnLCB0aGlzLl91cGRhdGUpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmNsb3NlT25DbGljaykge1xuICAgICAgICAgICAgdGhpcy5fbWFwLm9uKCdjbGljaycsIHRoaXMuX29uQ2xpY2tDbG9zZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBwb3B1cCBmcm9tIHRoZSBtYXBcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciBwb3B1cCA9IG5ldyBtYXBib3hnbC5Qb3B1cCgpLmFkZFRvKG1hcCk7XG4gICAgICogcG9wdXAucmVtb3ZlKCk7XG4gICAgICogQHJldHVybnMge1BvcHVwfSBgdGhpc2BcbiAgICAgKi9cbiAgICByZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fY29udGVudCAmJiB0aGlzLl9jb250ZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRlbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLl9jb250ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9jb250YWluZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRhaW5lci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuX2NvbnRhaW5lcik7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fY29udGFpbmVyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX21hcCkge1xuICAgICAgICAgICAgdGhpcy5fbWFwLm9mZignbW92ZScsIHRoaXMuX3VwZGF0ZSk7XG4gICAgICAgICAgICB0aGlzLl9tYXAub2ZmKCdjbGljaycsIHRoaXMuX29uQ2xpY2tDbG9zZSk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fbWFwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudCBjb29yZGluYXRlcyBvZiBwb3B1cCBlbGVtZW50IHJlbGF0aXZlIHRvIG1hcFxuICAgICAqIEByZXR1cm5zIHtMbmdMYXR9XG4gICAgICovXG4gICAgZ2V0TG5nTGF0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xuZ0xhdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBjb29yZGluYXRlcyBvZiBhIHBvcHVwIGVsZW1lbnQgdG8gYSBtYXBcbiAgICAgKiBAcGFyYW0ge0xuZ0xhdH0gbG5nbGF0XG4gICAgICogQHJldHVybnMge1BvcHVwfSBgdGhpc2BcbiAgICAgKi9cbiAgICBzZXRMbmdMYXQ6IGZ1bmN0aW9uKGxuZ2xhdCkge1xuICAgICAgICB0aGlzLl9sbmdMYXQgPSBMbmdMYXQuY29udmVydChsbmdsYXQpO1xuICAgICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbGwgYSBwb3B1cCBlbGVtZW50IHdpdGggdGV4dCBvbmx5IGNvbnRlbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgICAqIEByZXR1cm5zIHtQb3B1cH0gYHRoaXNgXG4gICAgICovXG4gICAgc2V0VGV4dDogZnVuY3Rpb24odGV4dCkge1xuICAgICAgICB0aGlzLl9jcmVhdGVDb250ZW50KCk7XG4gICAgICAgIHRoaXMuX2NvbnRlbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dCkpO1xuXG4gICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmlsbCBhIHBvcHVwIGVsZW1lbnQgd2l0aCBIVE1MIGNvbnRlbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuICAgICAqIEByZXR1cm5zIHtQb3B1cH0gYHRoaXNgXG4gICAgICovXG4gICAgc2V0SFRNTDogZnVuY3Rpb24oaHRtbCkge1xuICAgICAgICB0aGlzLl9jcmVhdGVDb250ZW50KCk7XG5cbiAgICAgICAgdmFyIHRlbXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdib2R5JyksIGNoaWxkO1xuICAgICAgICB0ZW1wLmlubmVySFRNTCA9IGh0bWw7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBjaGlsZCA9IHRlbXAuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIGlmICghY2hpbGQpIGJyZWFrO1xuICAgICAgICAgICAgdGhpcy5fY29udGVudC5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF9jcmVhdGVDb250ZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NvbnRlbnQgJiYgdGhpcy5fY29udGVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICB0aGlzLl9jb250ZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5fY29udGVudCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jb250ZW50ID0gRE9NLmNyZWF0ZSgnZGl2JywgJ21hcGJveGdsLXBvcHVwLWNvbnRlbnQnLCB0aGlzLl9jb250YWluZXIpO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuY2xvc2VCdXR0b24pIHtcbiAgICAgICAgICAgIHRoaXMuX2Nsb3NlQnV0dG9uID0gRE9NLmNyZWF0ZSgnYnV0dG9uJywgJ21hcGJveGdsLXBvcHVwLWNsb3NlLWJ1dHRvbicsIHRoaXMuX2NvbnRlbnQpO1xuICAgICAgICAgICAgdGhpcy5fY2xvc2VCdXR0b24uaW5uZXJIVE1MID0gJyYjMjE1Oyc7XG4gICAgICAgICAgICB0aGlzLl9jbG9zZUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX29uQ2xpY2tDbG9zZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX3VwZGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5fbWFwIHx8ICF0aGlzLl9sbmdMYXQgfHwgIXRoaXMuX2NvbnRlbnQpIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl9jb250YWluZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRhaW5lciA9IERPTS5jcmVhdGUoJ2RpdicsICdtYXBib3hnbC1wb3B1cCcsIHRoaXMuX21hcC5nZXRDb250YWluZXIoKSk7XG4gICAgICAgICAgICB0aGlzLl90aXAgICAgICAgPSBET00uY3JlYXRlKCdkaXYnLCAnbWFwYm94Z2wtcG9wdXAtdGlwJywgdGhpcy5fY29udGFpbmVyKTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl9jb250ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwb3MgPSB0aGlzLl9tYXAucHJvamVjdCh0aGlzLl9sbmdMYXQpLnJvdW5kKCksXG4gICAgICAgICAgICBhbmNob3IgPSB0aGlzLm9wdGlvbnMuYW5jaG9yO1xuXG4gICAgICAgIGlmICghYW5jaG9yKSB7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSB0aGlzLl9jb250YWluZXIub2Zmc2V0V2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gdGhpcy5fY29udGFpbmVyLm9mZnNldEhlaWdodDtcblxuICAgICAgICAgICAgaWYgKHBvcy55IDwgaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgYW5jaG9yID0gWyd0b3AnXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocG9zLnkgPiB0aGlzLl9tYXAudHJhbnNmb3JtLmhlaWdodCAtIGhlaWdodCkge1xuICAgICAgICAgICAgICAgIGFuY2hvciA9IFsnYm90dG9tJ107XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFuY2hvciA9IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocG9zLnggPCB3aWR0aCAvIDIpIHtcbiAgICAgICAgICAgICAgICBhbmNob3IucHVzaCgnbGVmdCcpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwb3MueCA+IHRoaXMuX21hcC50cmFuc2Zvcm0ud2lkdGggLSB3aWR0aCAvIDIpIHtcbiAgICAgICAgICAgICAgICBhbmNob3IucHVzaCgncmlnaHQnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGFuY2hvci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBhbmNob3IgPSAnYm90dG9tJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYW5jaG9yID0gYW5jaG9yLmpvaW4oJy0nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhbmNob3JUcmFuc2xhdGUgPSB7XG4gICAgICAgICAgICAndG9wJzogJ3RyYW5zbGF0ZSgtNTAlLDApJyxcbiAgICAgICAgICAgICd0b3AtbGVmdCc6ICd0cmFuc2xhdGUoMCwwKScsXG4gICAgICAgICAgICAndG9wLXJpZ2h0JzogJ3RyYW5zbGF0ZSgtMTAwJSwwKScsXG4gICAgICAgICAgICAnYm90dG9tJzogJ3RyYW5zbGF0ZSgtNTAlLC0xMDAlKScsXG4gICAgICAgICAgICAnYm90dG9tLWxlZnQnOiAndHJhbnNsYXRlKDAsLTEwMCUpJyxcbiAgICAgICAgICAgICdib3R0b20tcmlnaHQnOiAndHJhbnNsYXRlKC0xMDAlLC0xMDAlKScsXG4gICAgICAgICAgICAnbGVmdCc6ICd0cmFuc2xhdGUoMCwtNTAlKScsXG4gICAgICAgICAgICAncmlnaHQnOiAndHJhbnNsYXRlKC0xMDAlLC01MCUpJ1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBjbGFzc0xpc3QgPSB0aGlzLl9jb250YWluZXIuY2xhc3NMaXN0O1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gYW5jaG9yVHJhbnNsYXRlKSB7XG4gICAgICAgICAgICBjbGFzc0xpc3QucmVtb3ZlKCdtYXBib3hnbC1wb3B1cC1hbmNob3ItJyArIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgY2xhc3NMaXN0LmFkZCgnbWFwYm94Z2wtcG9wdXAtYW5jaG9yLScgKyBhbmNob3IpO1xuXG4gICAgICAgIERPTS5zZXRUcmFuc2Zvcm0odGhpcy5fY29udGFpbmVyLCBhbmNob3JUcmFuc2xhdGVbYW5jaG9yXSArICcgdHJhbnNsYXRlKCcgKyBwb3MueCArICdweCwnICsgcG9zLnkgKyAncHgpJyk7XG4gICAgfSxcblxuICAgIF9vbkNsaWNrQ2xvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFjdG9yO1xuXG4vKipcbiAqIEFuIGltcGxlbWVudGF0aW9uIG9mIHRoZSBbQWN0b3IgZGVzaWduIHBhdHRlcm5dKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQWN0b3JfbW9kZWwpXG4gKiB0aGF0IG1haW50YWlucyB0aGUgcmVsYXRpb25zaGlwIGJldHdlZW4gYXN5bmNocm9ub3VzIHRhc2tzIGFuZCB0aGUgb2JqZWN0c1xuICogdGhhdCBzcGluIHRoZW0gb2ZmIC0gaW4gdGhpcyBjYXNlLCB0YXNrcyBsaWtlIHBhcnNpbmcgcGFydHMgb2Ygc3R5bGVzLFxuICogb3duZWQgYnkgdGhlIHN0eWxlc1xuICpcbiAqIEBwYXJhbSB7V2ViV29ya2VyfSB0YXJnZXRcbiAqIEBwYXJhbSB7V2ViV29ya2VyfSBwYXJlbnRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEFjdG9yKHRhcmdldCwgcGFyZW50KSB7XG4gICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgdGhpcy5jYWxsYmFja3MgPSB7fTtcbiAgICB0aGlzLmNhbGxiYWNrSUQgPSAwO1xuICAgIHRoaXMucmVjZWl2ZSA9IHRoaXMucmVjZWl2ZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMudGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLnJlY2VpdmUsIGZhbHNlKTtcbn1cblxuQWN0b3IucHJvdG90eXBlLnJlY2VpdmUgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgdmFyIGRhdGEgPSBtZXNzYWdlLmRhdGEsXG4gICAgICAgIGNhbGxiYWNrO1xuXG4gICAgaWYgKGRhdGEudHlwZSA9PT0gJzxyZXNwb25zZT4nKSB7XG4gICAgICAgIGNhbGxiYWNrID0gdGhpcy5jYWxsYmFja3NbZGF0YS5pZF07XG4gICAgICAgIGRlbGV0ZSB0aGlzLmNhbGxiYWNrc1tkYXRhLmlkXTtcbiAgICAgICAgY2FsbGJhY2soZGF0YS5lcnJvciB8fCBudWxsLCBkYXRhLmRhdGEpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRhdGEuaWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhciBpZCA9IGRhdGEuaWQ7XG4gICAgICAgIHRoaXMucGFyZW50W2RhdGEudHlwZV0oZGF0YS5kYXRhLCBmdW5jdGlvbihlcnIsIGRhdGEsIGJ1ZmZlcnMpIHtcbiAgICAgICAgICAgIHRoaXMucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIHR5cGU6ICc8cmVzcG9uc2U+JyxcbiAgICAgICAgICAgICAgICBpZDogU3RyaW5nKGlkKSxcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyID8gU3RyaW5nKGVycikgOiBudWxsLFxuICAgICAgICAgICAgICAgIGRhdGE6IGRhdGFcbiAgICAgICAgICAgIH0sIGJ1ZmZlcnMpO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucGFyZW50W2RhdGEudHlwZV0oZGF0YS5kYXRhKTtcbiAgICB9XG59O1xuXG5BY3Rvci5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKHR5cGUsIGRhdGEsIGNhbGxiYWNrLCBidWZmZXJzKSB7XG4gICAgdmFyIGlkID0gbnVsbDtcbiAgICBpZiAoY2FsbGJhY2spIHRoaXMuY2FsbGJhY2tzW2lkID0gdGhpcy5jYWxsYmFja0lEKytdID0gY2FsbGJhY2s7XG4gICAgdGhpcy5wb3N0TWVzc2FnZSh7IHR5cGU6IHR5cGUsIGlkOiBTdHJpbmcoaWQpLCBkYXRhOiBkYXRhIH0sIGJ1ZmZlcnMpO1xufTtcblxuLyoqXG4gKiBXcmFwcGVkIHBvc3RNZXNzYWdlIEFQSSB0aGF0IGFic3RyYWN0cyBhcm91bmQgSUUncyBsYWNrIG9mXG4gKiBgdHJhbnNmZXJMaXN0YCBzdXBwb3J0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBtZXNzYWdlXG4gKiBAcGFyYW0ge09iamVjdH0gdHJhbnNmZXJMaXN0XG4gKiBAcHJpdmF0ZVxuICovXG5BY3Rvci5wcm90b3R5cGUucG9zdE1lc3NhZ2UgPSBmdW5jdGlvbihtZXNzYWdlLCB0cmFuc2Zlckxpc3QpIHtcbiAgICB0cnkge1xuICAgICAgICB0aGlzLnRhcmdldC5wb3N0TWVzc2FnZShtZXNzYWdlLCB0cmFuc2Zlckxpc3QpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhpcy50YXJnZXQucG9zdE1lc3NhZ2UobWVzc2FnZSk7IC8vIE5vIHN1cHBvcnQgZm9yIHRyYW5zZmVyTGlzdCBvbiBJRVxuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuZ2V0SlNPTiA9IGZ1bmN0aW9uKHVybCwgY2FsbGJhY2spIHtcbiAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgeGhyLm9wZW4oJ0dFVCcsIHVybCwgdHJ1ZSk7XG4gICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIGNhbGxiYWNrKGUpO1xuICAgIH07XG4gICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoeGhyLnN0YXR1cyA+PSAyMDAgJiYgeGhyLnN0YXR1cyA8IDMwMCAmJiB4aHIucmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHZhciBkYXRhO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBkYXRhID0gSlNPTi5wYXJzZSh4aHIucmVzcG9uc2UpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCBkYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcih4aHIuc3RhdHVzVGV4dCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB4aHIuc2VuZCgpO1xuICAgIHJldHVybiB4aHI7XG59O1xuXG5leHBvcnRzLmdldEFycmF5QnVmZmVyID0gZnVuY3Rpb24odXJsLCBjYWxsYmFjaykge1xuICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB4aHIub3BlbignR0VUJywgdXJsLCB0cnVlKTtcbiAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgY2FsbGJhY2soZSk7XG4gICAgfTtcbiAgICB4aHIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh4aHIuc3RhdHVzID49IDIwMCAmJiB4aHIuc3RhdHVzIDwgMzAwICYmIHhoci5yZXNwb25zZSkge1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgeGhyLnJlc3BvbnNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcih4aHIuc3RhdHVzVGV4dCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB4aHIuc2VuZCgpO1xuICAgIHJldHVybiB4aHI7XG59O1xuXG5mdW5jdGlvbiBzYW1lT3JpZ2luKHVybCkge1xuICAgIHZhciBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgIGEuaHJlZiA9IHVybDtcbiAgICByZXR1cm4gYS5wcm90b2NvbCA9PT0gZG9jdW1lbnQubG9jYXRpb24ucHJvdG9jb2wgJiYgYS5ob3N0ID09PSBkb2N1bWVudC5sb2NhdGlvbi5ob3N0O1xufVxuXG5leHBvcnRzLmdldEltYWdlID0gZnVuY3Rpb24odXJsLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBleHBvcnRzLmdldEFycmF5QnVmZmVyKHVybCwgZnVuY3Rpb24oZXJyLCBpbWdEYXRhKSB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICB2YXIgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGltZyk7XG4gICAgICAgICAgICAod2luZG93LlVSTCB8fCB3aW5kb3cud2Via2l0VVJMKS5yZXZva2VPYmplY3RVUkwoaW1nLnNyYyk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBibG9iID0gbmV3IEJsb2IoW25ldyBVaW50OEFycmF5KGltZ0RhdGEpXSwgeyB0eXBlOiAnaW1hZ2UvcG5nJyB9KTtcbiAgICAgICAgaW1nLnNyYyA9ICh3aW5kb3cuVVJMIHx8IHdpbmRvdy53ZWJraXRVUkwpLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICAgICAgaW1nLmdldERhdGEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICBjYW52YXMud2lkdGggPSBpbWcud2lkdGg7XG4gICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaW1nLmhlaWdodDtcbiAgICAgICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKGltZywgMCwgMCk7XG4gICAgICAgICAgICByZXR1cm4gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgaW1nLndpZHRoLCBpbWcuaGVpZ2h0KS5kYXRhO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gaW1nO1xuICAgIH0pO1xufTtcblxuZXhwb3J0cy5nZXRWaWRlbyA9IGZ1bmN0aW9uKHVybHMsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHZpZGVvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKTtcbiAgICB2aWRlby5vbmxvYWRzdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjYWxsYmFjayhudWxsLCB2aWRlbyk7XG4gICAgfTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVybHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzb3VyY2UnKTtcbiAgICAgICAgaWYgKCFzYW1lT3JpZ2luKHVybHNbaV0pKSB7XG4gICAgICAgICAgICB2aWRlby5jcm9zc09yaWdpbiA9ICdBbm9ueW1vdXMnO1xuICAgICAgICB9XG4gICAgICAgIHMuc3JjID0gdXJsc1tpXTtcbiAgICAgICAgdmlkZW8uYXBwZW5kQ2hpbGQocyk7XG4gICAgfVxuICAgIHZpZGVvLmdldERhdGEgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHZpZGVvOyB9O1xuICAgIHJldHVybiB2aWRlbztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBDYW52YXMgPSByZXF1aXJlKCcuL2NhbnZhcycpO1xuXG52YXIgZnJhbWUgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgIHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG5cbmV4cG9ydHMuZnJhbWUgPSBmdW5jdGlvbihmbikge1xuICAgIHJldHVybiBmcmFtZShmbik7XG59O1xuXG52YXIgY2FuY2VsID0gd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgd2luZG93Lm1vekNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgd2luZG93LndlYmtpdENhbmNlbEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgd2luZG93Lm1zQ2FuY2VsQW5pbWF0aW9uRnJhbWU7XG5cbmV4cG9ydHMuY2FuY2VsRnJhbWUgPSBmdW5jdGlvbihpZCkge1xuICAgIGNhbmNlbChpZCk7XG59O1xuXG5leHBvcnRzLnRpbWVkID0gZnVuY3Rpb24gKGZuLCBkdXIsIGN0eCkge1xuICAgIGlmICghZHVyKSB7XG4gICAgICAgIGZuLmNhbGwoY3R4LCAxKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGFib3J0ID0gZmFsc2UsXG4gICAgICAgIHN0YXJ0ID0gd2luZG93LnBlcmZvcm1hbmNlID8gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpIDogRGF0ZS5ub3coKTtcblxuICAgIGZ1bmN0aW9uIHRpY2sobm93KSB7XG4gICAgICAgIGlmIChhYm9ydCkgcmV0dXJuO1xuICAgICAgICBpZiAoIXdpbmRvdy5wZXJmb3JtYW5jZSkgbm93ID0gRGF0ZS5ub3coKTtcblxuICAgICAgICBpZiAobm93ID49IHN0YXJ0ICsgZHVyKSB7XG4gICAgICAgICAgICBmbi5jYWxsKGN0eCwgMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmbi5jYWxsKGN0eCwgKG5vdyAtIHN0YXJ0KSAvIGR1cik7XG4gICAgICAgICAgICBleHBvcnRzLmZyYW1lKHRpY2spO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZXhwb3J0cy5mcmFtZSh0aWNrKTtcblxuICAgIHJldHVybiBmdW5jdGlvbigpIHsgYWJvcnQgPSB0cnVlOyB9O1xufTtcblxuLyoqXG4gKiBUZXN0IHdoZXRoZXIgdGhlIGJhc2ljIEphdmFTY3JpcHQgYW5kIERPTSBmZWF0dXJlcyByZXF1aXJlZCBmb3IgTWFwYm94IEdMIGFyZSBwcmVzZW50LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdD1mYWxzZV0gSWYgYHRydWVgLCBtYXAgY3JlYXRpb24gd2lsbCBmYWlsIGlmIHRoZSBpbXBsZW1lbnRhdGlvbiBkZXRlcm1pbmVzIHRoYXQgdGhlIHBlcmZvcm1hbmNlIG9mIHRoZSBjcmVhdGVkIFdlYkdMIGNvbnRleHQgd291bGQgYmUgZHJhbWF0aWNhbGx5IGxvd2VyIHRoYW4gZXhwZWN0ZWQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgTWFwYm94IEdMIHNob3VsZCBiZSBleHBlY3RlZCB0byB3b3JrLCBhbmQgZmFsc2UgaWYgbm90LlxuICogQG1lbWJlcm9mIG1hcGJveGdsXG4gKiBAc3RhdGljXG4gKi9cbmV4cG9ydHMuc3VwcG9ydGVkID0gZnVuY3Rpb24ob3B0aW9ucykge1xuXG4gICAgdmFyIHN1cHBvcnRzID0gW1xuXG4gICAgICAgIGZ1bmN0aW9uKCkgeyByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7IH0sXG5cbiAgICAgICAgZnVuY3Rpb24oKSB7IHJldHVybiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnOyB9LFxuXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAhIShBcnJheS5wcm90b3R5cGUgJiZcbiAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUuZXZlcnkgJiZcbiAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUuZmlsdGVyICYmXG4gICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2ggJiZcbiAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiAmJlxuICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZiAmJlxuICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5tYXAgJiZcbiAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUuc29tZSAmJlxuICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5yZWR1Y2UgJiZcbiAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucmVkdWNlUmlnaHQgJiZcbiAgICAgICAgICAgICAgICBBcnJheS5pc0FycmF5KTtcbiAgICAgICAgfSxcblxuICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiAhIShGdW5jdGlvbi5wcm90b3R5cGUgJiYgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQpICYmXG4gICAgICAgICAgICAgICAgISEoT2JqZWN0LmtleXMgJiZcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmNyZWF0ZSAmJlxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZ2V0UHJvdG90eXBlT2YgJiZcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgJiZcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmlzU2VhbGVkICYmXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5pc0Zyb3plbiAmJlxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuaXNFeHRlbnNpYmxlICYmXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgJiZcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzICYmXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5zZWFsICYmXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5mcmVlemUgJiZcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKTtcbiAgICAgICAgfSxcblxuICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiAnSlNPTicgaW4gd2luZG93ICYmICdwYXJzZScgaW4gSlNPTiAmJiAnc3RyaW5naWZ5JyBpbiBKU09OO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDYW52YXMoKS5zdXBwb3J0c1dlYkdMQ29udGV4dCgob3B0aW9ucyAmJiBvcHRpb25zLmZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQpIHx8IGZhbHNlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBmdW5jdGlvbigpIHsgcmV0dXJuICdXb3JrZXInIGluIHdpbmRvdzsgfVxuICAgIF07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN1cHBvcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghc3VwcG9ydHNbaV0oKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbmV4cG9ydHMuaGFyZHdhcmVDb25jdXJyZW5jeSA9IG5hdmlnYXRvci5oYXJkd2FyZUNvbmN1cnJlbmN5IHx8IDg7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnZGV2aWNlUGl4ZWxSYXRpbycsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gd2luZG93LmRldmljZVBpeGVsUmF0aW87IH1cbn0pO1xuXG5leHBvcnRzLnN1cHBvcnRzV2VicCA9IGZhbHNlO1xuXG52YXIgd2VicEltZ1Rlc3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbndlYnBJbWdUZXN0Lm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgIGV4cG9ydHMuc3VwcG9ydHNXZWJwID0gdHJ1ZTtcbn07XG53ZWJwSW1nVGVzdC5zcmMgPSAnZGF0YTppbWFnZS93ZWJwO2Jhc2U2NCxVa2xHUmg0QUFBQlhSVUpRVmxBNFRCRUFBQUF2QVFBQUFBZlEvLzczdi8rQmlPaC9BQUE9JztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FudmFzO1xuXG5mdW5jdGlvbiBDYW52YXMocGFyZW50LCBjb250YWluZXIpIHtcbiAgICB0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuXG4gICAgaWYgKHBhcmVudCAmJiBjb250YWluZXIpIHtcbiAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICB0aGlzLmNhbnZhcy5jbGFzc0xpc3QuYWRkKCdtYXBib3hnbC1jYW52YXMnKTtcbiAgICAgICAgdGhpcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0bG9zdCcsIHBhcmVudC5fY29udGV4dExvc3QuYmluZChwYXJlbnQpLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmdsY29udGV4dHJlc3RvcmVkJywgcGFyZW50Ll9jb250ZXh0UmVzdG9yZWQuYmluZChwYXJlbnQpLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuY2FudmFzLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAwKTtcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuY2FudmFzKTtcbiAgICB9XG59XG5cbkNhbnZhcy5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuICAgIHZhciBwaXhlbFJhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcblxuICAgIC8vIFJlcXVlc3QgdGhlIHJlcXVpcmVkIGNhbnZhcyBzaXplIHRha2luZyB0aGUgcGl4ZWxyYXRpbyBpbnRvIGFjY291bnQuXG4gICAgdGhpcy5jYW52YXMud2lkdGggPSBwaXhlbFJhdGlvICogd2lkdGg7XG4gICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gcGl4ZWxSYXRpbyAqIGhlaWdodDtcblxuICAgIC8vIE1haW50YWluIHRoZSBzYW1lIGNhbnZhcyBzaXplLCBwb3RlbnRpYWxseSBkb3duc2NhbGluZyBpdCBmb3IgSGlEUEkgZGlzcGxheXNcbiAgICB0aGlzLmNhbnZhcy5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICB0aGlzLmNhbnZhcy5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xufTtcblxudmFyIHJlcXVpcmVkQ29udGV4dEF0dHJpYnV0ZXMgPSB7XG4gICAgYW50aWFsaWFzOiBmYWxzZSxcbiAgICBhbHBoYTogdHJ1ZSxcbiAgICBzdGVuY2lsOiB0cnVlLFxuICAgIGRlcHRoOiB0cnVlXG59O1xuXG5DYW52YXMucHJvdG90eXBlLmdldFdlYkdMQ29udGV4dCA9IGZ1bmN0aW9uKGF0dHJpYnV0ZXMpIHtcbiAgICBhdHRyaWJ1dGVzID0gdXRpbC5leHRlbmQoe30sIGF0dHJpYnV0ZXMsIHJlcXVpcmVkQ29udGV4dEF0dHJpYnV0ZXMpO1xuXG4gICAgcmV0dXJuIHRoaXMuY2FudmFzLmdldENvbnRleHQoJ3dlYmdsJywgYXR0cmlidXRlcykgfHxcbiAgICAgICAgdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnZXhwZXJpbWVudGFsLXdlYmdsJywgYXR0cmlidXRlcyk7XG59O1xuXG5DYW52YXMucHJvdG90eXBlLnN1cHBvcnRzV2ViR0xDb250ZXh0ID0gZnVuY3Rpb24oZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdCkge1xuICAgIHZhciBhdHRyaWJ1dGVzID0gdXRpbC5leHRlbmQoe1xuICAgICAgICBmYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0OiBmYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0XG4gICAgfSwgcmVxdWlyZWRDb250ZXh0QXR0cmlidXRlcyk7XG5cbiAgICBpZiAoJ3Byb2JhYmx5U3VwcG9ydHNDb250ZXh0JyBpbiB0aGlzLmNhbnZhcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jYW52YXMucHJvYmFibHlTdXBwb3J0c0NvbnRleHQoJ3dlYmdsJywgYXR0cmlidXRlcykgfHxcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLnByb2JhYmx5U3VwcG9ydHNDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnLCBhdHRyaWJ1dGVzKTtcbiAgICB9IGVsc2UgaWYgKCdzdXBwb3J0c0NvbnRleHQnIGluIHRoaXMuY2FudmFzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbnZhcy5zdXBwb3J0c0NvbnRleHQoJ3dlYmdsJywgYXR0cmlidXRlcykgfHxcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLnN1cHBvcnRzQ29udGV4dCgnZXhwZXJpbWVudGFsLXdlYmdsJywgYXR0cmlidXRlcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuICEhd2luZG93LldlYkdMUmVuZGVyaW5nQ29udGV4dCAmJiAhIXRoaXMuZ2V0V2ViR0xDb250ZXh0KGZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQpO1xufTtcblxuQ2FudmFzLnByb3RvdHlwZS5nZXRFbGVtZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FudmFzO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEFjdG9yID0gcmVxdWlyZSgnLi4vYWN0b3InKTtcbnZhciBXZWJXb3JraWZ5ID0gcmVxdWlyZSgnd2Vid29ya2lmeScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERpc3BhdGNoZXI7XG5cbmZ1bmN0aW9uIERpc3BhdGNoZXIobGVuZ3RoLCBwYXJlbnQpIHtcbiAgICB0aGlzLmFjdG9ycyA9IFtdO1xuICAgIHRoaXMuY3VycmVudEFjdG9yID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB3b3JrZXIgPSBuZXcgV2ViV29ya2lmeShyZXF1aXJlKCcuLi8uLi9zb3VyY2Uvd29ya2VyJykpO1xuICAgICAgICB2YXIgYWN0b3IgPSBuZXcgQWN0b3Iod29ya2VyLCBwYXJlbnQpO1xuICAgICAgICBhY3Rvci5uYW1lID0gXCJXb3JrZXIgXCIgKyBpO1xuICAgICAgICB0aGlzLmFjdG9ycy5wdXNoKGFjdG9yKTtcbiAgICB9XG59XG5cbkRpc3BhdGNoZXIucHJvdG90eXBlID0ge1xuICAgIGJyb2FkY2FzdDogZnVuY3Rpb24odHlwZSwgZGF0YSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYWN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmFjdG9yc1tpXS5zZW5kKHR5cGUsIGRhdGEpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHNlbmQ6IGZ1bmN0aW9uKHR5cGUsIGRhdGEsIGNhbGxiYWNrLCB0YXJnZXRJRCwgYnVmZmVycykge1xuICAgICAgICBpZiAodHlwZW9mIHRhcmdldElEICE9PSAnbnVtYmVyJyB8fCBpc05hTih0YXJnZXRJRCkpIHtcbiAgICAgICAgICAgIC8vIFVzZSByb3VuZCByb2JpbiB0byBzZW5kIHJlcXVlc3RzIHRvIHdlYiB3b3JrZXJzLlxuICAgICAgICAgICAgdGFyZ2V0SUQgPSB0aGlzLmN1cnJlbnRBY3RvciA9ICh0aGlzLmN1cnJlbnRBY3RvciArIDEpICUgdGhpcy5hY3RvcnMubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5hY3RvcnNbdGFyZ2V0SURdLnNlbmQodHlwZSwgZGF0YSwgY2FsbGJhY2ssIGJ1ZmZlcnMpO1xuICAgICAgICByZXR1cm4gdGFyZ2V0SUQ7XG4gICAgfSxcblxuICAgIHJlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hY3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuYWN0b3JzW2ldLnRhcmdldC50ZXJtaW5hdGUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFjdG9ycyA9IFtdO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBQb2ludCA9IHJlcXVpcmUoJ3BvaW50LWdlb21ldHJ5Jyk7XG5cbmV4cG9ydHMuY3JlYXRlID0gZnVuY3Rpb24gKHRhZ05hbWUsIGNsYXNzTmFtZSwgY29udGFpbmVyKSB7XG4gICAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgICBpZiAoY2xhc3NOYW1lKSBlbC5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgaWYgKGNvbnRhaW5lcikgY29udGFpbmVyLmFwcGVuZENoaWxkKGVsKTtcbiAgICByZXR1cm4gZWw7XG59O1xuXG52YXIgZG9jU3R5bGUgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGU7XG5cbmZ1bmN0aW9uIHRlc3RQcm9wKHByb3BzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAocHJvcHNbaV0gaW4gZG9jU3R5bGUpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9wc1tpXTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxudmFyIHNlbGVjdFByb3AgPSB0ZXN0UHJvcChbJ3VzZXJTZWxlY3QnLCAnTW96VXNlclNlbGVjdCcsICdXZWJraXRVc2VyU2VsZWN0JywgJ21zVXNlclNlbGVjdCddKSxcbiAgICB1c2VyU2VsZWN0O1xuZXhwb3J0cy5kaXNhYmxlRHJhZyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc2VsZWN0UHJvcCkge1xuICAgICAgICB1c2VyU2VsZWN0ID0gZG9jU3R5bGVbc2VsZWN0UHJvcF07XG4gICAgICAgIGRvY1N0eWxlW3NlbGVjdFByb3BdID0gJ25vbmUnO1xuICAgIH1cbn07XG5leHBvcnRzLmVuYWJsZURyYWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHNlbGVjdFByb3ApIHtcbiAgICAgICAgZG9jU3R5bGVbc2VsZWN0UHJvcF0gPSB1c2VyU2VsZWN0O1xuICAgIH1cbn07XG5cbnZhciB0cmFuc2Zvcm1Qcm9wID0gdGVzdFByb3AoWyd0cmFuc2Zvcm0nLCAnV2Via2l0VHJhbnNmb3JtJ10pO1xuZXhwb3J0cy5zZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbihlbCwgdmFsdWUpIHtcbiAgICBlbC5zdHlsZVt0cmFuc2Zvcm1Qcm9wXSA9IHZhbHVlO1xufTtcblxuLy8gU3VwcHJlc3MgdGhlIG5leHQgY2xpY2ssIGJ1dCBvbmx5IGlmIGl0J3MgaW1tZWRpYXRlLlxuZnVuY3Rpb24gc3VwcHJlc3NDbGljayhlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgc3VwcHJlc3NDbGljaywgdHJ1ZSk7XG59XG5leHBvcnRzLnN1cHByZXNzQ2xpY2sgPSBmdW5jdGlvbigpIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBzdXBwcmVzc0NsaWNrLCB0cnVlKTtcbiAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgc3VwcHJlc3NDbGljaywgdHJ1ZSk7XG4gICAgfSwgMCk7XG59O1xuXG5leHBvcnRzLm1vdXNlUG9zID0gZnVuY3Rpb24gKGVsLCBlKSB7XG4gICAgdmFyIHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBlID0gZS50b3VjaGVzID8gZS50b3VjaGVzWzBdIDogZTtcbiAgICByZXR1cm4gbmV3IFBvaW50KFxuICAgICAgICBlLmNsaWVudFggLSByZWN0LmxlZnQgLSBlbC5jbGllbnRMZWZ0LFxuICAgICAgICBlLmNsaWVudFkgLSByZWN0LnRvcCAtIGVsLmNsaWVudFRvcCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBBUElfVVJMOiAnaHR0cHM6Ly9hcGkubWFwYm94LmNvbScsXG4gICAgUkVRVUlSRV9BQ0NFU1NfVE9LRU46IHRydWVcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbi8qKlxuICogTWV0aG9kcyBtaXhlZCBpbiB0byBvdGhlciBjbGFzc2VzIGZvciBldmVudCBjYXBhYmlsaXRpZXMuXG4gKiBAbWl4aW4gRXZlbnRlZFxuICovXG52YXIgRXZlbnRlZCA9IHtcblxuICAgIC8qKlxuICAgICAqIFN1YnNjcmliZSB0byBhIHNwZWNpZmllZCBldmVudCB3aXRoIGEgbGlzdGVuZXIgZnVuY3Rpb24gdGhlIGxhdHRlciBnZXRzIHRoZSBkYXRhIG9iamVjdCB0aGF0IHdhcyBwYXNzZWQgdG8gYGZpcmVgIGFuZCBhZGRpdGlvbmFsbHkgYHRhcmdldGAgYW5kIGB0eXBlYCBwcm9wZXJ0aWVzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBFdmVudCB0eXBlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgRnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdoZW4gdGhlIGV2ZW50IGlzIGZpcmVkXG4gICAgICovXG4gICAgb246IGZ1bmN0aW9uKHR5cGUsIGZuKSB7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gdGhpcy5fZXZlbnRzW3R5cGVdIHx8IFtdO1xuICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChmbik7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIGV2ZW50IGxpc3RlbmVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVdIEV2ZW50IHR5cGUuIElmIG5vbmUgaXMgc3BlY2lmaWVkLCByZW1vdmUgYWxsIGxpc3RlbmVyc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtsaXN0ZW5lcl0gRnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdoZW4gdGhlIGV2ZW50IGlzIGZpcmVkLiBJZiBub25lIGlzIHNwZWNpZmllZCBhbGwgbGlzdGVuZXJzIGFyZSByZW1vdmVkXG4gICAgICovXG4gICAgb2ZmOiBmdW5jdGlvbih0eXBlLCBmbikge1xuICAgICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgICAgIC8vIGNsZWFyIGFsbCBsaXN0ZW5lcnMgaWYgbm8gYXJndW1lbnRzIHNwZWNpZmllZFxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50cztcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLmxpc3RlbnModHlwZSkpIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGlmIChmbikge1xuICAgICAgICAgICAgdmFyIGlkeCA9IHRoaXMuX2V2ZW50c1t0eXBlXS5pbmRleE9mKGZuKTtcbiAgICAgICAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGwgYSBmdW5jdGlvbiBvbmNlIHdoZW4gYW4gZXZlbnQgaGFzIGZpcmVkXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBFdmVudCB0eXBlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIEZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbmNlIHdoZW4gdGhlIGV2ZW50IGlzIGZpcmVkXG4gICAgICovXG4gICAgb25jZTogZnVuY3Rpb24odHlwZSwgZm4pIHtcbiAgICAgICAgdmFyIHdyYXBwZXIgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICB0aGlzLm9mZih0eXBlLCB3cmFwcGVyKTtcbiAgICAgICAgICAgIGZuLmNhbGwodGhpcywgZGF0YSk7XG4gICAgICAgIH0uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbih0eXBlLCB3cmFwcGVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpcmUgZXZlbnQgb2YgYSBnaXZlbiBzdHJpbmcgdHlwZSB3aXRoIHRoZSBnaXZlbiBkYXRhIG9iamVjdFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgRXZlbnQgdHlwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbZGF0YV0gT3B0aW9uYWwgZGF0YSBwYXNzZWQgZG93biB0byB0aGUgZXZlbnQgb2JqZWN0XG4gICAgICogQHJldHVybnMge09iamVjdH0gYHRoaXNgXG4gICAgICovXG4gICAgZmlyZTogZnVuY3Rpb24odHlwZSwgZGF0YSkge1xuICAgICAgICBpZiAoIXRoaXMubGlzdGVucyh0eXBlKSkgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgZGF0YSA9IHV0aWwuZXh0ZW5kKHt9LCBkYXRhKTtcbiAgICAgICAgdXRpbC5leHRlbmQoZGF0YSwge3R5cGU6IHR5cGUsIHRhcmdldDogdGhpc30pO1xuXG4gICAgICAgIC8vIG1ha2Ugc3VyZSBhZGRpbmcvcmVtb3ZpbmcgbGlzdGVuZXJzIGluc2lkZSBvdGhlciBsaXN0ZW5lcnMgd29uJ3QgY2F1c2UgaW5maW5pdGUgbG9vcFxuICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdLnNsaWNlKCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxpc3RlbmVyc1tpXS5jYWxsKHRoaXMsIGRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGFuIGV2ZW50IGlzIHJlZ2lzdGVyZWQgdG8gYSB0eXBlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgRXZlbnQgdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIHJlZ2lzdGVyZWQgbGlzdGVuZXIgZm9yIGV2ZW50cyBvZiB0eXBlIGB0eXBlYFxuICAgICAqL1xuICAgIGxpc3RlbnM6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuICEhKHRoaXMuX2V2ZW50cyAmJiB0aGlzLl9ldmVudHNbdHlwZV0pO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRlZDtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBHbHlwaHM7XG5cbmZ1bmN0aW9uIEdseXBocyhwYmYsIGVuZCkge1xuICAgIHRoaXMuc3RhY2tzID0gcGJmLnJlYWRGaWVsZHMocmVhZEZvbnRzdGFja3MsIFtdLCBlbmQpO1xufVxuXG5mdW5jdGlvbiByZWFkRm9udHN0YWNrcyh0YWcsIHN0YWNrcywgcGJmKSB7XG4gICAgaWYgKHRhZyA9PT0gMSkge1xuICAgICAgICB2YXIgZm9udHN0YWNrID0gcGJmLnJlYWRNZXNzYWdlKHJlYWRGb250c3RhY2ssIHtnbHlwaHM6IHt9fSk7XG4gICAgICAgIHN0YWNrcy5wdXNoKGZvbnRzdGFjayk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZWFkRm9udHN0YWNrKHRhZywgZm9udHN0YWNrLCBwYmYpIHtcbiAgICBpZiAodGFnID09PSAxKSBmb250c3RhY2submFtZSA9IHBiZi5yZWFkU3RyaW5nKCk7XG4gICAgZWxzZSBpZiAodGFnID09PSAyKSBmb250c3RhY2sucmFuZ2UgPSBwYmYucmVhZFN0cmluZygpO1xuICAgIGVsc2UgaWYgKHRhZyA9PT0gMykge1xuICAgICAgICB2YXIgZ2x5cGggPSBwYmYucmVhZE1lc3NhZ2UocmVhZEdseXBoLCB7fSk7XG4gICAgICAgIGZvbnRzdGFjay5nbHlwaHNbZ2x5cGguaWRdID0gZ2x5cGg7XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZWFkR2x5cGgodGFnLCBnbHlwaCwgcGJmKSB7XG4gICAgaWYgKHRhZyA9PT0gMSkgZ2x5cGguaWQgPSBwYmYucmVhZFZhcmludCgpO1xuICAgIGVsc2UgaWYgKHRhZyA9PT0gMikgZ2x5cGguYml0bWFwID0gcGJmLnJlYWRCeXRlcygpO1xuICAgIGVsc2UgaWYgKHRhZyA9PT0gMykgZ2x5cGgud2lkdGggPSBwYmYucmVhZFZhcmludCgpO1xuICAgIGVsc2UgaWYgKHRhZyA9PT0gNCkgZ2x5cGguaGVpZ2h0ID0gcGJmLnJlYWRWYXJpbnQoKTtcbiAgICBlbHNlIGlmICh0YWcgPT09IDUpIGdseXBoLmxlZnQgPSBwYmYucmVhZFNWYXJpbnQoKTtcbiAgICBlbHNlIGlmICh0YWcgPT09IDYpIGdseXBoLnRvcCA9IHBiZi5yZWFkU1ZhcmludCgpO1xuICAgIGVsc2UgaWYgKHRhZyA9PT0gNykgZ2x5cGguYWR2YW5jZSA9IHBiZi5yZWFkVmFyaW50KCk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gaW50ZXJwb2xhdGU7XG5cbmZ1bmN0aW9uIGludGVycG9sYXRlKGEsIGIsIHQpIHtcbiAgICByZXR1cm4gKGEgKiAoMSAtIHQpKSArIChiICogdCk7XG59XG5cbmludGVycG9sYXRlLm51bWJlciA9IGludGVycG9sYXRlO1xuXG5pbnRlcnBvbGF0ZS52ZWMyID0gZnVuY3Rpb24oZnJvbSwgdG8sIHQpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBpbnRlcnBvbGF0ZShmcm9tWzBdLCB0b1swXSwgdCksXG4gICAgICAgIGludGVycG9sYXRlKGZyb21bMV0sIHRvWzFdLCB0KVxuICAgIF07XG59O1xuXG4vKlxuICogSW50ZXJwb2xhdGUgYmV0d2VlbiB0d28gY29sb3JzIGdpdmVuIGFzIDQtZWxlbWVudCBhcnJheXMuXG4gKlxuICogQHBhcmFtIHtDb2xvcn0gZnJvbVxuICogQHBhcmFtIHtDb2xvcn0gdG9cbiAqIEBwYXJhbSB7bnVtYmVyfSB0IGludGVycG9sYXRpb24gZmFjdG9yIGJldHdlZW4gMCBhbmQgMVxuICogQHJldHVybnMge0NvbG9yfSBpbnRlcnBvbGF0ZWQgY29sb3JcbiAqL1xuaW50ZXJwb2xhdGUuY29sb3IgPSBmdW5jdGlvbihmcm9tLCB0bywgdCkge1xuICAgIHJldHVybiBbXG4gICAgICAgIGludGVycG9sYXRlKGZyb21bMF0sIHRvWzBdLCB0KSxcbiAgICAgICAgaW50ZXJwb2xhdGUoZnJvbVsxXSwgdG9bMV0sIHQpLFxuICAgICAgICBpbnRlcnBvbGF0ZShmcm9tWzJdLCB0b1syXSwgdCksXG4gICAgICAgIGludGVycG9sYXRlKGZyb21bM10sIHRvWzNdLCB0KVxuICAgIF07XG59O1xuXG5pbnRlcnBvbGF0ZS5hcnJheSA9IGZ1bmN0aW9uKGZyb20sIHRvLCB0KSB7XG4gICAgcmV0dXJuIGZyb20ubWFwKGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgcmV0dXJuIGludGVycG9sYXRlKGQsIHRvW2ldLCB0KTtcbiAgICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZycpO1xudmFyIGJyb3dzZXIgPSByZXF1aXJlKCcuL2Jyb3dzZXInKTtcblxuZnVuY3Rpb24gbm9ybWFsaXplVVJMKHVybCwgcGF0aFByZWZpeCwgYWNjZXNzVG9rZW4pIHtcbiAgICBhY2Nlc3NUb2tlbiA9IGFjY2Vzc1Rva2VuIHx8IGNvbmZpZy5BQ0NFU1NfVE9LRU47XG5cbiAgICBpZiAoIWFjY2Vzc1Rva2VuICYmIGNvbmZpZy5SRVFVSVJFX0FDQ0VTU19UT0tFTikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FuIEFQSSBhY2Nlc3MgdG9rZW4gaXMgcmVxdWlyZWQgdG8gdXNlIE1hcGJveCBHTC4gJyArXG4gICAgICAgICAgICAnU2VlIGh0dHBzOi8vd3d3Lm1hcGJveC5jb20vZGV2ZWxvcGVycy9hcGkvI2FjY2Vzcy10b2tlbnMnKTtcbiAgICB9XG5cbiAgICB1cmwgPSB1cmwucmVwbGFjZSgvXm1hcGJveDpcXC9cXC8vLCBjb25maWcuQVBJX1VSTCArIHBhdGhQcmVmaXgpO1xuICAgIHVybCArPSB1cmwuaW5kZXhPZignPycpICE9PSAtMSA/ICcmYWNjZXNzX3Rva2VuPScgOiAnP2FjY2Vzc190b2tlbj0nO1xuXG4gICAgaWYgKGNvbmZpZy5SRVFVSVJFX0FDQ0VTU19UT0tFTikge1xuICAgICAgICBpZiAoYWNjZXNzVG9rZW5bMF0gPT09ICdzJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVc2UgYSBwdWJsaWMgYWNjZXNzIHRva2VuIChway4qKSB3aXRoIE1hcGJveCBHTCBKUywgbm90IGEgc2VjcmV0IGFjY2VzcyB0b2tlbiAoc2suKikuICcgK1xuICAgICAgICAgICAgICAgICdTZWUgaHR0cHM6Ly93d3cubWFwYm94LmNvbS9kZXZlbG9wZXJzL2FwaS8jYWNjZXNzLXRva2VucycpO1xuICAgICAgICB9XG5cbiAgICAgICAgdXJsICs9IGFjY2Vzc1Rva2VuO1xuICAgIH1cblxuICAgIHJldHVybiB1cmw7XG59XG5cbm1vZHVsZS5leHBvcnRzLm5vcm1hbGl6ZVN0eWxlVVJMID0gZnVuY3Rpb24odXJsLCBhY2Nlc3NUb2tlbikge1xuICAgIGlmICghdXJsLm1hdGNoKC9ebWFwYm94OlxcL1xcL3N0eWxlc1xcLy8pKVxuICAgICAgICByZXR1cm4gdXJsO1xuXG4gICAgdmFyIHNwbGl0ID0gdXJsLnNwbGl0KCcvJyk7XG4gICAgdmFyIHVzZXIgPSBzcGxpdFszXTtcbiAgICB2YXIgc3R5bGUgPSBzcGxpdFs0XTtcbiAgICB2YXIgZHJhZnQgPSBzcGxpdFs1XSA/ICcvZHJhZnQnIDogJyc7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZVVSTCgnbWFwYm94Oi8vJyArIHVzZXIgKyAnLycgKyBzdHlsZSArIGRyYWZ0LCAnL3N0eWxlcy92MS8nLCBhY2Nlc3NUb2tlbik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5ub3JtYWxpemVTb3VyY2VVUkwgPSBmdW5jdGlvbih1cmwsIGFjY2Vzc1Rva2VuKSB7XG4gICAgaWYgKCF1cmwubWF0Y2goL15tYXBib3g6XFwvXFwvLykpXG4gICAgICAgIHJldHVybiB1cmw7XG5cbiAgICAvLyBUaWxlSlNPTiByZXF1ZXN0cyBuZWVkIGEgc2VjdXJlIGZsYWcgYXBwZW5kZWQgdG8gdGhlaXIgVVJMcyBzb1xuICAgIC8vIHRoYXQgdGhlIHNlcnZlciBrbm93cyB0byBzZW5kIFNTTC1pZmllZCByZXNvdXJjZSByZWZlcmVuY2VzLlxuICAgIHJldHVybiBub3JtYWxpemVVUkwodXJsICsgJy5qc29uJywgJy92NC8nLCBhY2Nlc3NUb2tlbikgKyAnJnNlY3VyZSc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5ub3JtYWxpemVHbHlwaHNVUkwgPSBmdW5jdGlvbih1cmwsIGFjY2Vzc1Rva2VuKSB7XG4gICAgaWYgKCF1cmwubWF0Y2goL15tYXBib3g6XFwvXFwvLykpXG4gICAgICAgIHJldHVybiB1cmw7XG5cbiAgICB2YXIgdXNlciA9IHVybC5zcGxpdCgnLycpWzNdO1xuICAgIHJldHVybiBub3JtYWxpemVVUkwoJ21hcGJveDovLycgKyB1c2VyICsgJy97Zm9udHN0YWNrfS97cmFuZ2V9LnBiZicsICcvZm9udHMvdjEvJywgYWNjZXNzVG9rZW4pO1xufTtcblxubW9kdWxlLmV4cG9ydHMubm9ybWFsaXplU3ByaXRlVVJMID0gZnVuY3Rpb24odXJsLCBmb3JtYXQsIGV4dCwgYWNjZXNzVG9rZW4pIHtcbiAgICBpZiAoIXVybC5tYXRjaCgvXm1hcGJveDpcXC9cXC9zcHJpdGVzXFwvLykpXG4gICAgICAgIHJldHVybiB1cmwgKyBmb3JtYXQgKyBleHQ7XG5cbiAgICB2YXIgc3BsaXQgPSB1cmwuc3BsaXQoJy8nKTtcbiAgICB2YXIgdXNlciA9IHNwbGl0WzNdO1xuICAgIHZhciBzdHlsZSA9IHNwbGl0WzRdO1xuICAgIHZhciBkcmFmdCA9IHNwbGl0WzVdID8gJy9kcmFmdCcgOiAnJztcbiAgICByZXR1cm4gbm9ybWFsaXplVVJMKCdtYXBib3g6Ly8nICsgdXNlciArICcvJyArIHN0eWxlICsgZHJhZnQgKyAnL3Nwcml0ZScgKyBmb3JtYXQgKyBleHQsICcvc3R5bGVzL3YxLycsIGFjY2Vzc1Rva2VuKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLm5vcm1hbGl6ZVRpbGVVUkwgPSBmdW5jdGlvbih1cmwsIHNvdXJjZVVybCkge1xuICAgIGlmICghc291cmNlVXJsIHx8ICFzb3VyY2VVcmwubWF0Y2goL15tYXBib3g6XFwvXFwvLykpXG4gICAgICAgIHJldHVybiB1cmw7XG5cbiAgICB1cmwgPSB1cmwucmVwbGFjZSgvKFs/Jl1hY2Nlc3NfdG9rZW49KXRrXFwuW14mXSsvLCAnJDEnICsgY29uZmlnLkFDQ0VTU19UT0tFTik7XG4gICAgdmFyIGV4dGVuc2lvbiA9IGJyb3dzZXIuc3VwcG9ydHNXZWJwID8gJ3dlYnAnIDogJyQxJztcbiAgICByZXR1cm4gdXJsLnJlcGxhY2UoL1xcLigoPzpwbmd8anBnKVxcZCopKD89JHxcXD8pLywgYnJvd3Nlci5kZXZpY2VQaXhlbFJhdGlvID49IDIgPyAnQDJ4LicgKyBleHRlbnNpb24gOiAnLicgKyBleHRlbnNpb24pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBBIFttb3N0LXJlY2VudGx5LXVzZWQgY2FjaGVdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2FjaGVfYWxnb3JpdGhtcylcbiAqIHdpdGggaGFzaCBsb29rdXAgbWFkZSBwb3NzaWJsZSBieSBrZWVwaW5nIGEgbGlzdCBvZiBrZXlzIGluIHBhcmFsbGVsIHRvXG4gKiBhbiBhcnJheSBvZiBkaWN0aW9uYXJ5IG9mIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXggbnVtYmVyIG9mIHBlcm1pdHRlZCB2YWx1ZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG9uUmVtb3ZlIGNhbGxiYWNrIGNhbGxlZCB3aXRoIGl0ZW1zIHdoZW4gdGhleSBleHBpcmVcbiAqIEBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gTVJVQ2FjaGU7XG5mdW5jdGlvbiBNUlVDYWNoZShtYXgsIG9uUmVtb3ZlKSB7XG4gICAgdGhpcy5tYXggPSBtYXg7XG4gICAgdGhpcy5vblJlbW92ZSA9IG9uUmVtb3ZlO1xuICAgIHRoaXMucmVzZXQoKTtcbn1cblxuLyoqXG4gKiBDbGVhciB0aGUgY2FjaGVcbiAqXG4gKiBAcmV0dXJucyB7TVJVQ2FjaGV9IHRoaXMgY2FjaGVcbiAqIEBwcml2YXRlXG4gKi9cbk1SVUNhY2hlLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmxpc3QpIHtcbiAgICAgICAgdGhpcy5vblJlbW92ZSh0aGlzLmxpc3Rba2V5XSk7XG4gICAgfVxuXG4gICAgdGhpcy5saXN0ID0ge307XG4gICAgdGhpcy5vcmRlciA9IFtdO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZCBhIGtleSwgdmFsdWUgY29tYmluYXRpb24gdG8gdGhlIGNhY2hlLCB0cmltbWluZyBpdHMgc2l6ZSBpZiB0aGlzIHB1c2hlc1xuICogaXQgb3ZlciBtYXggbGVuZ3RoLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgbG9va3VwIGtleSBmb3IgdGhlIGl0ZW1cbiAqIEBwYXJhbSB7Kn0gZGF0YSBhbnkgdmFsdWVcbiAqXG4gKiBAcmV0dXJucyB7TVJVQ2FjaGV9IHRoaXMgY2FjaGVcbiAqIEBwcml2YXRlXG4gKi9cbk1SVUNhY2hlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihrZXksIGRhdGEpIHtcbiAgICB0aGlzLmxpc3Rba2V5XSA9IGRhdGE7XG4gICAgdGhpcy5vcmRlci5wdXNoKGtleSk7XG5cbiAgICBpZiAodGhpcy5vcmRlci5sZW5ndGggPiB0aGlzLm1heCkge1xuICAgICAgICB2YXIgcmVtb3ZlZERhdGEgPSB0aGlzLmdldCh0aGlzLm9yZGVyWzBdKTtcbiAgICAgICAgaWYgKHJlbW92ZWREYXRhKSB0aGlzLm9uUmVtb3ZlKHJlbW92ZWREYXRhKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lIHdoZXRoZXIgdGhlIHZhbHVlIGF0dGFjaGVkIHRvIGBrZXlgIGlzIHByZXNlbnRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHRoZSBrZXkgdG8gYmUgbG9va2VkLXVwXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciB0aGUgY2FjaGUgaGFzIHRoaXMgdmFsdWVcbiAqIEBwcml2YXRlXG4gKi9cbk1SVUNhY2hlLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4ga2V5IGluIHRoaXMubGlzdDtcbn07XG5cbi8qKlxuICogTGlzdCBhbGwga2V5cyBpbiB0aGUgY2FjaGVcbiAqXG4gKiBAcmV0dXJucyB7QXJyYXk8c3RyaW5nPn0gYW4gYXJyYXkgb2Yga2V5cyBpbiB0aGlzIGNhY2hlLlxuICogQHByaXZhdGVcbiAqL1xuTVJVQ2FjaGUucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5vcmRlcjtcbn07XG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBhdHRhY2hlZCB0byBhIHNwZWNpZmljIGtleS4gSWYgdGhlIGtleSBpcyBub3QgZm91bmQsXG4gKiByZXR1cm5zIGBudWxsYFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgdGhlIGtleSB0byBsb29rIHVwXG4gKiBAcmV0dXJucyB7Kn0gdGhlIGRhdGEsIG9yIG51bGwgaWYgaXQgaXNuJ3QgZm91bmRcbiAqIEBwcml2YXRlXG4gKi9cbk1SVUNhY2hlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoIXRoaXMuaGFzKGtleSkpIHsgcmV0dXJuIG51bGw7IH1cblxuICAgIHZhciBkYXRhID0gdGhpcy5saXN0W2tleV07XG5cbiAgICBkZWxldGUgdGhpcy5saXN0W2tleV07XG4gICAgdGhpcy5vcmRlci5zcGxpY2UodGhpcy5vcmRlci5pbmRleE9mKGtleSksIDEpO1xuXG4gICAgcmV0dXJuIGRhdGE7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlc29sdmVUb2tlbnM7XG5cbi8qKlxuICogUmVwbGFjZSB0b2tlbnMgaW4gYSBzdHJpbmcgdGVtcGxhdGUgd2l0aCB2YWx1ZXMgaW4gYW4gb2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXMgYSBrZXkvdmFsdWUgcmVsYXRpb25zaGlwIGJldHdlZW4gdG9rZW5zIGFuZCByZXBsYWNlbWVudHNcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IHRoZSB0ZW1wbGF0ZSBzdHJpbmdcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSB0ZW1wbGF0ZSB3aXRoIHRva2VucyByZXBsYWNlZFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZVRva2Vucyhwcm9wZXJ0aWVzLCB0ZXh0KSB7XG4gICAgcmV0dXJuIHRleHQucmVwbGFjZSgveyhbXnt9KClcXFtcXF08PiQ9OjsuLF5dKyl9L2csIGZ1bmN0aW9uKG1hdGNoLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIGtleSBpbiBwcm9wZXJ0aWVzID8gcHJvcGVydGllc1trZXldIDogJyc7XG4gICAgfSk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBVbml0QmV6aWVyID0gcmVxdWlyZSgndW5pdGJlemllcicpO1xudmFyIENvb3JkaW5hdGUgPSByZXF1aXJlKCcuLi9nZW8vY29vcmRpbmF0ZScpO1xuXG4vKipcbiAqIEdpdmVuIGEgdmFsdWUgYHRgIHRoYXQgdmFyaWVzIGJldHdlZW4gMCBhbmQgMSwgcmV0dXJuXG4gKiBhbiBpbnRlcnBvbGF0aW9uIGZ1bmN0aW9uIHRoYXQgZWFzZXMgYmV0d2VlbiAwIGFuZCAxIGluIGEgcGxlYXNpbmdcbiAqIGN1YmljIGluLW91dCBmYXNoaW9uLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB0IGlucHV0XG4gKiBAcmV0dXJucyB7bnVtYmVyfSBpbnB1dFxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy5lYXNlQ3ViaWNJbk91dCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgaWYgKHQgPD0gMCkgcmV0dXJuIDA7XG4gICAgaWYgKHQgPj0gMSkgcmV0dXJuIDE7XG4gICAgdmFyIHQyID0gdCAqIHQsXG4gICAgICAgIHQzID0gdDIgKiB0O1xuICAgIHJldHVybiA0ICogKHQgPCAwLjUgPyB0MyA6IDMgKiAodCAtIHQyKSArIHQzIC0gMC43NSk7XG59O1xuXG4vKipcbiAqIEdpdmVuIGdpdmVuICh4LCB5KSwgKHgxLCB5MSkgY29udHJvbCBwb2ludHMgZm9yIGEgYmV6aWVyIGN1cnZlLFxuICogcmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBpbnRlcnBvbGF0ZXMgYWxvbmcgdGhhdCBjdXJ2ZS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gcDF4IGNvbnRyb2wgcG9pbnQgMSB4IGNvb3JkaW5hdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBwMXkgY29udHJvbCBwb2ludCAxIHkgY29vcmRpbmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHAyeCBjb250cm9sIHBvaW50IDIgeCBjb29yZGluYXRlXG4gKiBAcGFyYW0ge251bWJlcn0gcDJ5IGNvbnRyb2wgcG9pbnQgMiB5IGNvb3JkaW5hdGVcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gaW50ZXJwb2xhdG9yOiByZWNlaXZlcyBudW1iZXIgdmFsdWUsIHJldHVybnNcbiAqIG51bWJlciB2YWx1ZS5cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMuYmV6aWVyID0gZnVuY3Rpb24ocDF4LCBwMXksIHAyeCwgcDJ5KSB7XG4gICAgdmFyIGJlemllciA9IG5ldyBVbml0QmV6aWVyKHAxeCwgcDF5LCBwMngsIHAyeSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIGJlemllci5zb2x2ZSh0KTtcbiAgICB9O1xufTtcblxuLyoqXG4gKiBBIGRlZmF1bHQgYmV6aWVyLWN1cnZlIHBvd2VyZWQgZWFzaW5nIGZ1bmN0aW9uIHdpdGhcbiAqIGNvbnRyb2wgcG9pbnRzICgwLjI1LCAwLjEpIGFuZCAoMC4yNSwgMSlcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn0gb3V0cHV0XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnRzLmVhc2UgPSBleHBvcnRzLmJlemllcigwLjI1LCAwLjEsIDAuMjUsIDEpO1xuXG4vKipcbiAqIEdpdmVuIGEgZm91ci1lbGVtZW50IGFycmF5IG9mIG51bWJlcnMgdGhhdCByZXByZXNlbnRzIGEgY29sb3IgaW5cbiAqIFJHQkEsIHJldHVybiBhIHZlcnNpb24gZm9yIHdoaWNoIHRoZSBSR0IgY29tcG9uZW50cyBhcmUgbXVsdGlwbGllZFxuICogYnkgdGhlIEEgKGFscGhhKSBjb21wb25lbnRcbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGMgY29sb3IgYXJyYXlcbiAqIEByZXR1cm5zIHtBcnJheTxudW1iZXI+fSBwcmVtdWx0aXBsaWVkIGNvbG9yIGFycmF5XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnRzLnByZW11bHRpcGx5ID0gZnVuY3Rpb24gKGMpIHtcbiAgICBjWzBdICo9IGNbM107XG4gICAgY1sxXSAqPSBjWzNdO1xuICAgIGNbMl0gKj0gY1szXTtcbiAgICByZXR1cm4gYztcbn07XG5cbi8qKlxuICogY29uc3RyYWluIG4gdG8gdGhlIGdpdmVuIHJhbmdlIHZpYSBtaW4gKyBtYXhcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gbiB2YWx1ZVxuICogQHBhcmFtIHtudW1iZXJ9IG1pbiB0aGUgbWluaW11bSB2YWx1ZSB0byBiZSByZXR1cm5lZFxuICogQHBhcmFtIHtudW1iZXJ9IG1heCB0aGUgbWF4aW11bSB2YWx1ZSB0byBiZSByZXR1cm5lZFxuICogQHJldHVybnMge251bWJlcn0gdGhlIGNsYW1wZWQgdmFsdWVcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMuY2xhbXAgPSBmdW5jdGlvbiAobiwgbWluLCBtYXgpIHtcbiAgICByZXR1cm4gTWF0aC5taW4obWF4LCBNYXRoLm1heChtaW4sIG4pKTtcbn07XG5cbi8qXG4gKiBjb25zdHJhaW4gbiB0byB0aGUgZ2l2ZW4gcmFuZ2UsIGV4Y2x1ZGluZyB0aGUgbWluaW11bSwgdmlhIG1vZHVsYXIgYXJpdGhtZXRpY1xuICogQHBhcmFtIHtudW1iZXJ9IG4gdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gdGhlIG1pbmltdW0gdmFsdWUgdG8gYmUgcmV0dXJuZWQsIGV4Y2x1c2l2ZVxuICogQHBhcmFtIHtudW1iZXJ9IG1heCB0aGUgbWF4aW11bSB2YWx1ZSB0byBiZSByZXR1cm5lZCwgaW5jbHVzaXZlXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBjb25zdHJhaW5lZCBudW1iZXJcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMud3JhcCA9IGZ1bmN0aW9uIChuLCBtaW4sIG1heCkge1xuICAgIHZhciBkID0gbWF4IC0gbWluO1xuICAgIHZhciB3ID0gKChuIC0gbWluKSAlIGQgKyBkKSAlIGQgKyBtaW47XG4gICAgcmV0dXJuICh3ID09PSBtaW4pID8gbWF4IDogdztcbn07XG5cbi8qXG4gKiByZXR1cm4gdGhlIGZpcnN0IG5vbi1udWxsIGFuZCBub24tdW5kZWZpbmVkIGFyZ3VtZW50IHRvIHRoaXMgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7Kn0gYXJndW1lbnRcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMuY29hbGVzY2UgPSBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYXJnID0gYXJndW1lbnRzW2ldO1xuICAgICAgICBpZiAoYXJnICE9PSBudWxsICYmIGFyZyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIGFyZztcbiAgICB9XG59O1xuXG4vKlxuICogQ2FsbCBhbiBhc3luY2hyb25vdXMgZnVuY3Rpb24gb24gYW4gYXJyYXkgb2YgYXJndW1lbnRzLFxuICogY2FsbGluZyBgY2FsbGJhY2tgIHdpdGggdGhlIGNvbXBsZXRlZCByZXN1bHRzIG9mIGFsbCBjYWxscy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBhcnJheSBpbnB1dCB0byBlYWNoIGNhbGwgb2YgdGhlIGFzeW5jIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gYW4gYXN5bmMgZnVuY3Rpb24gd2l0aCBzaWduYXR1cmUgKGRhdGEsIGNhbGxiYWNrKVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgYSBjYWxsYmFjayBydW4gYWZ0ZXIgYWxsIGFzeW5jIHdvcmsgaXMgZG9uZS5cbiAqIGNhbGxlZCB3aXRoIGFuIGFycmF5LCBjb250YWluaW5nIHRoZSByZXN1bHRzIG9mIGVhY2ggYXN5bmMgY2FsbC5cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnRzLmFzeW5jQWxsID0gZnVuY3Rpb24gKGFycmF5LCBmbiwgY2FsbGJhY2spIHtcbiAgICBpZiAoIWFycmF5Lmxlbmd0aCkgeyByZXR1cm4gY2FsbGJhY2sobnVsbCwgW10pOyB9XG4gICAgdmFyIHJlbWFpbmluZyA9IGFycmF5Lmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0cyA9IG5ldyBBcnJheShhcnJheS5sZW5ndGgpO1xuICAgIHZhciBlcnJvciA9IG51bGw7XG4gICAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSwgaSkge1xuICAgICAgICBmbihpdGVtLCBmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIGVycm9yID0gZXJyO1xuICAgICAgICAgICAgcmVzdWx0c1tpXSA9IHJlc3VsdDtcbiAgICAgICAgICAgIGlmICgtLXJlbWFpbmluZyA9PT0gMCkgY2FsbGJhY2soZXJyb3IsIHJlc3VsdHMpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5cbi8qXG4gKiBDb21wdXRlIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIGtleXMgaW4gb25lIG9iamVjdCBhbmQgdGhlIGtleXNcbiAqIGluIGFub3RoZXIgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlclxuICogQHJldHVybnMge0FycmF5PHN0cmluZz59IGtleXMgZGlmZmVyZW5jZVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy5rZXlzRGlmZmVyZW5jZSA9IGZ1bmN0aW9uIChvYmosIG90aGVyKSB7XG4gICAgdmFyIGRpZmZlcmVuY2UgPSBbXTtcbiAgICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgICAgICBpZiAoIShpIGluIG90aGVyKSkge1xuICAgICAgICAgICAgZGlmZmVyZW5jZS5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkaWZmZXJlbmNlO1xufTtcblxuLyoqXG4gKiBHaXZlbiBhIGRlc3RpbmF0aW9uIG9iamVjdCBhbmQgb3B0aW9uYWxseSBtYW55IHNvdXJjZSBvYmplY3RzLFxuICogY29weSBhbGwgcHJvcGVydGllcyBmcm9tIHRoZSBzb3VyY2Ugb2JqZWN0cyBpbnRvIHRoZSBkZXN0aW5hdGlvbi5cbiAqIFRoZSBsYXN0IHNvdXJjZSBvYmplY3QgZ2l2ZW4gb3ZlcnJpZGVzIHByb3BlcnRpZXMgZnJvbSBwcmV2aW91c1xuICogc291cmNlIG9iamVjdHMuXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzdCBkZXN0aW5hdGlvbiBvYmplY3RcbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBzb3VyY2VzIHNvdXJjZXMgZnJvbSB3aGljaCBwcm9wZXJ0aWVzIGFyZSBwdWxsZWRcbiAqIEByZXR1cm5zIHtPYmplY3R9IGRlc3RcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMuZXh0ZW5kID0gZnVuY3Rpb24gKGRlc3QpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc3JjID0gYXJndW1lbnRzW2ldO1xuICAgICAgICBmb3IgKHZhciBrIGluIHNyYykge1xuICAgICAgICAgICAgZGVzdFtrXSA9IHNyY1trXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVzdDtcbn07XG5cbi8qKlxuICogRXh0ZW5kIGEgZGVzdGluYXRpb24gb2JqZWN0IHdpdGggYWxsIHByb3BlcnRpZXMgb2YgdGhlIHNyYyBvYmplY3QsXG4gKiB1c2luZyBkZWZpbmVQcm9wZXJ0eSBpbnN0ZWFkIG9mIHNpbXBsZSBhc3NpZ25tZW50LlxuICogQHBhcmFtIHtPYmplY3R9IGRlc3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBzcmNcbiAqIEByZXR1cm5zIHtPYmplY3R9IGRlc3RcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMuZXh0ZW5kQWxsID0gZnVuY3Rpb24gKGRlc3QsIHNyYykge1xuICAgIGZvciAodmFyIGkgaW4gc3JjKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZXN0LCBpLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNyYywgaSkpO1xuICAgIH1cbiAgICByZXR1cm4gZGVzdDtcbn07XG5cbi8qKlxuICogRXh0ZW5kIGEgcGFyZW50J3MgcHJvdG90eXBlIHdpdGggYWxsIHByb3BlcnRpZXMgaW4gYSBwcm9wZXJ0aWVzXG4gKiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhcmVudFxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy5pbmhlcml0ID0gZnVuY3Rpb24gKHBhcmVudCwgcHJvcHMpIHtcbiAgICB2YXIgcGFyZW50UHJvdG8gPSB0eXBlb2YgcGFyZW50ID09PSAnZnVuY3Rpb24nID8gcGFyZW50LnByb3RvdHlwZSA6IHBhcmVudCxcbiAgICAgICAgcHJvdG8gPSBPYmplY3QuY3JlYXRlKHBhcmVudFByb3RvKTtcbiAgICBleHBvcnRzLmV4dGVuZEFsbChwcm90bywgcHJvcHMpO1xuICAgIHJldHVybiBwcm90bztcbn07XG5cbi8qKlxuICogR2l2ZW4gYW4gb2JqZWN0IGFuZCBhIG51bWJlciBvZiBwcm9wZXJ0aWVzIGFzIHN0cmluZ3MsIHJldHVybiB2ZXJzaW9uXG4gKiBvZiB0aGF0IG9iamVjdCB3aXRoIG9ubHkgdGhvc2UgcHJvcGVydGllcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gc3JjIHRoZSBvYmplY3RcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gcHJvcGVydGllcyBhbiBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBjaG9zZW5cbiAqIHRvIGFwcGVhciBvbiB0aGUgcmVzdWx0aW5nIG9iamVjdC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IG9iamVjdCB3aXRoIGxpbWl0ZWQgcHJvcGVydGllcy5cbiAqIEBleGFtcGxlXG4gKiB2YXIgZm9vID0geyBuYW1lOiAnQ2hhcmxpZScsIGFnZTogMTAgfTtcbiAqIHZhciBqdXN0TmFtZSA9IHBpY2soZm9vLCBbJ25hbWUnXSk7XG4gKiAvLyBqdXN0TmFtZSA9IHsgbmFtZTogJ0NoYXJsaWUnIH1cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMucGljayA9IGZ1bmN0aW9uIChzcmMsIHByb3BlcnRpZXMpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBrID0gcHJvcGVydGllc1tpXTtcbiAgICAgICAgaWYgKGsgaW4gc3JjKSB7XG4gICAgICAgICAgICByZXN1bHRba10gPSBzcmNba107XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciBpZCA9IDE7XG5cbi8qKlxuICogUmV0dXJuIGEgdW5pcXVlIG51bWVyaWMgaWQsIHN0YXJ0aW5nIGF0IDEgYW5kIGluY3JlbWVudGluZyB3aXRoXG4gKiBlYWNoIGNhbGwuXG4gKlxuICogQHJldHVybnMge251bWJlcn0gdW5pcXVlIG51bWVyaWMgaWQuXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnRzLnVuaXF1ZUlkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBpZCsrO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSB2ZXJzaW9uIG9mIGBmbmAgdGhhdCBvbmx5IGZpcmVzIG9uY2UgZXZlcnkgYHRpbWVgIG1pbGxzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIHRoZSBmdW5jdGlvbiB0byBiZSB0aHJvdHRsZWRcbiAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lIG1pbGxzZWNvbmRzIHJlcXVpcmVkIGJldHdlZW4gZnVuY3Rpb24gY2FsbHNcbiAqIEBwYXJhbSB7Kn0gY29udGV4dCB0aGUgdmFsdWUgb2YgYHRoaXNgIHdpdGggd2hpY2ggdGhlIGZ1bmN0aW9uIGlzIGNhbGxlZFxuICogQHJldHVybnMge0Z1bmN0aW9ufSBkZWJvdW5jZWQgZnVuY3Rpb25cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMudGhyb3R0bGUgPSBmdW5jdGlvbiAoZm4sIHRpbWUsIGNvbnRleHQpIHtcbiAgICB2YXIgbG9jaywgYXJncywgd3JhcHBlckZuLCBsYXRlcjtcblxuICAgIGxhdGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyByZXNldCBsb2NrIGFuZCBjYWxsIGlmIHF1ZXVlZFxuICAgICAgICBsb2NrID0gZmFsc2U7XG4gICAgICAgIGlmIChhcmdzKSB7XG4gICAgICAgICAgICB3cmFwcGVyRm4uYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgICAgICBhcmdzID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgd3JhcHBlckZuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAobG9jaykge1xuICAgICAgICAgICAgLy8gY2FsbGVkIHRvbyBzb29uLCBxdWV1ZSB0byBjYWxsIGxhdGVyXG4gICAgICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBjYWxsIGFuZCBsb2NrIHVudGlsIGxhdGVyXG4gICAgICAgICAgICBmbi5hcHBseShjb250ZXh0LCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgc2V0VGltZW91dChsYXRlciwgdGltZSk7XG4gICAgICAgICAgICBsb2NrID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gd3JhcHBlckZuO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSB2ZXJzaW9uIG9mIGBmbmAgdGhhdCBpcyBvbmx5IGNhbGxlZCBgdGltZWAgbWlsbGlzZWNvbmRzXG4gKiBhZnRlciBpdHMgbGFzdCBpbnZvY2F0aW9uXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gdGhlIGZ1bmN0aW9uIHRvIGJlIGRlYm91bmNlZFxuICogQHBhcmFtIHtudW1iZXJ9IHRpbWUgbWlsbHNlY29uZHMgYWZ0ZXIgd2hpY2ggdGhlIGZ1bmN0aW9uIHdpbGwgYmUgaW52b2tlZFxuICogQHJldHVybnMge0Z1bmN0aW9ufSBkZWJvdW5jZWQgZnVuY3Rpb25cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMuZGVib3VuY2UgPSBmdW5jdGlvbihmbiwgdGltZSkge1xuICAgIHZhciB0aW1lciwgYXJncztcblxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcblxuICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgfSwgdGltZSk7XG4gICAgfTtcbn07XG5cbi8qKlxuICogR2l2ZW4gYW4gYXJyYXkgb2YgbWVtYmVyIGZ1bmN0aW9uIG5hbWVzIGFzIHN0cmluZ3MsIHJlcGxhY2UgYWxsIG9mIHRoZW1cbiAqIHdpdGggYm91bmQgdmVyc2lvbnMgdGhhdCB3aWxsIGFsd2F5cyByZWZlciB0byBgY29udGV4dGAgYXMgYHRoaXNgLiBUaGlzXG4gKiBpcyB1c2VmdWwgZm9yIGNsYXNzZXMgd2hlcmUgb3RoZXJ3aXNlIGV2ZW50IGJpbmRpbmdzIHdvdWxkIHJlYXNzaWduXG4gKiBgdGhpc2AgdG8gdGhlIGV2ZW50ZWQgb2JqZWN0IG9yIHNvbWUgb3RoZXIgdmFsdWU6IHRoaXMgbGV0cyB5b3UgZW5zdXJlXG4gKiB0aGUgYHRoaXNgIHZhbHVlIGFsd2F5cy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGZucyBsaXN0IG9mIG1lbWJlciBmdW5jdGlvbiBuYW1lc1xuICogQHBhcmFtIHsqfSBjb250ZXh0IHRoZSBjb250ZXh0IHZhbHVlXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfSBjaGFuZ2VzIGZ1bmN0aW9ucyBpbi1wbGFjZVxuICogQGV4YW1wbGVcbiAqIGZ1bmN0aW9uIE15Q2xhc3MoKSB7XG4gKiAgIGJpbmRBbGwoWydvbnRpbWVyJ10sIHRoaXMpO1xuICogICB0aGlzLm5hbWUgPSAnVG9tJztcbiAqIH1cbiAqIE15Q2xhc3MucHJvdG90eXBlLm9udGltZXIgPSBmdW5jdGlvbigpIHtcbiAqICAgYWxlcnQodGhpcy5uYW1lKTtcbiAqIH07XG4gKiB2YXIgbXlDbGFzcyA9IG5ldyBNeUNsYXNzKCk7XG4gKiBzZXRUaW1lb3V0KG15Q2xhc3Mub250aW1lciwgMTAwKTtcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMuYmluZEFsbCA9IGZ1bmN0aW9uKGZucywgY29udGV4dCkge1xuICAgIGZucy5mb3JFYWNoKGZ1bmN0aW9uKGZuKSB7XG4gICAgICAgIGNvbnRleHRbZm5dID0gY29udGV4dFtmbl0uYmluZChjb250ZXh0KTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogR2l2ZW4gYSBjbGFzcywgYmluZCBhbGwgb2YgdGhlIG1ldGhvZHMgdGhhdCBsb29rIGxpa2UgaGFuZGxlcnM6IHRoYXRcbiAqIGJlZ2luIHdpdGggX29uLCBhbmQgYmluZCB0aGVtIHRvIHRoZSBjbGFzcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dCBhbiBvYmplY3Qgd2l0aCBtZXRob2RzXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnRzLmJpbmRIYW5kbGVycyA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICBmb3IgKHZhciBpIGluIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjb250ZXh0W2ldID09PSAnZnVuY3Rpb24nICYmIGkuaW5kZXhPZignX29uJykgPT09IDApIHtcbiAgICAgICAgICAgIGNvbnRleHRbaV0gPSBjb250ZXh0W2ldLmJpbmQoY29udGV4dCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIFNldCB0aGUgJ29wdGlvbnMnIHByb3BlcnR5IG9uIGBvYmpgIHdpdGggcHJvcGVydGllc1xuICogZnJvbSB0aGUgYG9wdGlvbnNgIGFyZ3VtZW50LiBQcm9wZXJ0aWVzIGluIHRoZSBgb3B0aW9uc2BcbiAqIG9iamVjdCB3aWxsIG92ZXJyaWRlIGV4aXN0aW5nIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBkZXN0aW5hdGlvbiBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIG9iamVjdCBvZiBvdmVycmlkZSBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBkZXJpdmVkIG9wdGlvbnMgb2JqZWN0LlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy5zZXRPcHRpb25zID0gZnVuY3Rpb24ob2JqLCBvcHRpb25zKSB7XG4gICAgaWYgKCFvYmouaGFzT3duUHJvcGVydHkoJ29wdGlvbnMnKSkge1xuICAgICAgICBvYmoub3B0aW9ucyA9IG9iai5vcHRpb25zID8gT2JqZWN0LmNyZWF0ZShvYmoub3B0aW9ucykgOiB7fTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSBpbiBvcHRpb25zKSB7XG4gICAgICAgIG9iai5vcHRpb25zW2ldID0gb3B0aW9uc1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIG9iai5vcHRpb25zO1xufTtcblxuLyoqXG4gKiBHaXZlbiBhIGxpc3Qgb2YgY29vcmRpbmF0ZXMsIGdldCB0aGVpciBjZW50ZXIgYXMgYSBjb29yZGluYXRlLlxuICogQHBhcmFtIHtBcnJheTxDb29yZGluYXRlPn0gY29vcmRzXG4gKiBAcmV0dXJucyB7Q29vcmRpbmF0ZX0gY2VudGVycG9pbnRcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMuZ2V0Q29vcmRpbmF0ZXNDZW50ZXIgPSBmdW5jdGlvbihjb29yZHMpIHtcbiAgICB2YXIgbWluWCA9IEluZmluaXR5O1xuICAgIHZhciBtaW5ZID0gSW5maW5pdHk7XG4gICAgdmFyIG1heFggPSAtSW5maW5pdHk7XG4gICAgdmFyIG1heFkgPSAtSW5maW5pdHk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBtaW5YID0gTWF0aC5taW4obWluWCwgY29vcmRzW2ldLmNvbHVtbik7XG4gICAgICAgIG1pblkgPSBNYXRoLm1pbihtaW5ZLCBjb29yZHNbaV0ucm93KTtcbiAgICAgICAgbWF4WCA9IE1hdGgubWF4KG1heFgsIGNvb3Jkc1tpXS5jb2x1bW4pO1xuICAgICAgICBtYXhZID0gTWF0aC5tYXgobWF4WSwgY29vcmRzW2ldLnJvdyk7XG4gICAgfVxuXG4gICAgdmFyIGR4ID0gbWF4WCAtIG1pblg7XG4gICAgdmFyIGR5ID0gbWF4WSAtIG1pblk7XG4gICAgdmFyIGRNYXggPSBNYXRoLm1heChkeCwgZHkpO1xuICAgIHJldHVybiBuZXcgQ29vcmRpbmF0ZSgobWluWCArIG1heFgpIC8gMiwgKG1pblkgKyBtYXhZKSAvIDIsIDApXG4gICAgICAgIC56b29tVG8oTWF0aC5mbG9vcigtTWF0aC5sb2coZE1heCkgLyBNYXRoLkxOMikpO1xufTtcbiIsIi8vIGh0dHA6Ly93aWtpLmNvbW1vbmpzLm9yZy93aWtpL1VuaXRfVGVzdGluZy8xLjBcbi8vXG4vLyBUSElTIElTIE5PVCBURVNURUQgTk9SIExJS0VMWSBUTyBXT1JLIE9VVFNJREUgVjghXG4vL1xuLy8gT3JpZ2luYWxseSBmcm9tIG5hcndoYWwuanMgKGh0dHA6Ly9uYXJ3aGFsanMub3JnKVxuLy8gQ29weXJpZ2h0IChjKSAyMDA5IFRob21hcyBSb2JpbnNvbiA8Mjgwbm9ydGguY29tPlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlICdTb2Z0d2FyZScpLCB0b1xuLy8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGVcbi8vIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vclxuLy8gc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCAnQVMgSVMnLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbi8vIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT05cbi8vIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyB3aGVuIHVzZWQgaW4gbm9kZSwgdGhpcyB3aWxsIGFjdHVhbGx5IGxvYWQgdGhlIHV0aWwgbW9kdWxlIHdlIGRlcGVuZCBvblxuLy8gdmVyc3VzIGxvYWRpbmcgdGhlIGJ1aWx0aW4gdXRpbCBtb2R1bGUgYXMgaGFwcGVucyBvdGhlcndpc2Vcbi8vIHRoaXMgaXMgYSBidWcgaW4gbm9kZSBtb2R1bGUgbG9hZGluZyBhcyBmYXIgYXMgSSBhbSBjb25jZXJuZWRcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbC8nKTtcblxudmFyIHBTbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4vLyAxLiBUaGUgYXNzZXJ0IG1vZHVsZSBwcm92aWRlcyBmdW5jdGlvbnMgdGhhdCB0aHJvd1xuLy8gQXNzZXJ0aW9uRXJyb3IncyB3aGVuIHBhcnRpY3VsYXIgY29uZGl0aW9ucyBhcmUgbm90IG1ldC4gVGhlXG4vLyBhc3NlcnQgbW9kdWxlIG11c3QgY29uZm9ybSB0byB0aGUgZm9sbG93aW5nIGludGVyZmFjZS5cblxudmFyIGFzc2VydCA9IG1vZHVsZS5leHBvcnRzID0gb2s7XG5cbi8vIDIuIFRoZSBBc3NlcnRpb25FcnJvciBpcyBkZWZpbmVkIGluIGFzc2VydC5cbi8vIG5ldyBhc3NlcnQuQXNzZXJ0aW9uRXJyb3IoeyBtZXNzYWdlOiBtZXNzYWdlLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdHVhbDogYWN0dWFsLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCB9KVxuXG5hc3NlcnQuQXNzZXJ0aW9uRXJyb3IgPSBmdW5jdGlvbiBBc3NlcnRpb25FcnJvcihvcHRpb25zKSB7XG4gIHRoaXMubmFtZSA9ICdBc3NlcnRpb25FcnJvcic7XG4gIHRoaXMuYWN0dWFsID0gb3B0aW9ucy5hY3R1YWw7XG4gIHRoaXMuZXhwZWN0ZWQgPSBvcHRpb25zLmV4cGVjdGVkO1xuICB0aGlzLm9wZXJhdG9yID0gb3B0aW9ucy5vcGVyYXRvcjtcbiAgaWYgKG9wdGlvbnMubWVzc2FnZSkge1xuICAgIHRoaXMubWVzc2FnZSA9IG9wdGlvbnMubWVzc2FnZTtcbiAgICB0aGlzLmdlbmVyYXRlZE1lc3NhZ2UgPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBnZXRNZXNzYWdlKHRoaXMpO1xuICAgIHRoaXMuZ2VuZXJhdGVkTWVzc2FnZSA9IHRydWU7XG4gIH1cbiAgdmFyIHN0YWNrU3RhcnRGdW5jdGlvbiA9IG9wdGlvbnMuc3RhY2tTdGFydEZ1bmN0aW9uIHx8IGZhaWw7XG5cbiAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgc3RhY2tTdGFydEZ1bmN0aW9uKTtcbiAgfVxuICBlbHNlIHtcbiAgICAvLyBub24gdjggYnJvd3NlcnMgc28gd2UgY2FuIGhhdmUgYSBzdGFja3RyYWNlXG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcigpO1xuICAgIGlmIChlcnIuc3RhY2spIHtcbiAgICAgIHZhciBvdXQgPSBlcnIuc3RhY2s7XG5cbiAgICAgIC8vIHRyeSB0byBzdHJpcCB1c2VsZXNzIGZyYW1lc1xuICAgICAgdmFyIGZuX25hbWUgPSBzdGFja1N0YXJ0RnVuY3Rpb24ubmFtZTtcbiAgICAgIHZhciBpZHggPSBvdXQuaW5kZXhPZignXFxuJyArIGZuX25hbWUpO1xuICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgIC8vIG9uY2Ugd2UgaGF2ZSBsb2NhdGVkIHRoZSBmdW5jdGlvbiBmcmFtZVxuICAgICAgICAvLyB3ZSBuZWVkIHRvIHN0cmlwIG91dCBldmVyeXRoaW5nIGJlZm9yZSBpdCAoYW5kIGl0cyBsaW5lKVxuICAgICAgICB2YXIgbmV4dF9saW5lID0gb3V0LmluZGV4T2YoJ1xcbicsIGlkeCArIDEpO1xuICAgICAgICBvdXQgPSBvdXQuc3Vic3RyaW5nKG5leHRfbGluZSArIDEpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnN0YWNrID0gb3V0O1xuICAgIH1cbiAgfVxufTtcblxuLy8gYXNzZXJ0LkFzc2VydGlvbkVycm9yIGluc3RhbmNlb2YgRXJyb3JcbnV0aWwuaW5oZXJpdHMoYXNzZXJ0LkFzc2VydGlvbkVycm9yLCBFcnJvcik7XG5cbmZ1bmN0aW9uIHJlcGxhY2VyKGtleSwgdmFsdWUpIHtcbiAgaWYgKHV0aWwuaXNVbmRlZmluZWQodmFsdWUpKSB7XG4gICAgcmV0dXJuICcnICsgdmFsdWU7XG4gIH1cbiAgaWYgKHV0aWwuaXNOdW1iZXIodmFsdWUpICYmICFpc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgfVxuICBpZiAodXRpbC5pc0Z1bmN0aW9uKHZhbHVlKSB8fCB1dGlsLmlzUmVnRXhwKHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gdHJ1bmNhdGUocywgbikge1xuICBpZiAodXRpbC5pc1N0cmluZyhzKSkge1xuICAgIHJldHVybiBzLmxlbmd0aCA8IG4gPyBzIDogcy5zbGljZSgwLCBuKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRNZXNzYWdlKHNlbGYpIHtcbiAgcmV0dXJuIHRydW5jYXRlKEpTT04uc3RyaW5naWZ5KHNlbGYuYWN0dWFsLCByZXBsYWNlciksIDEyOCkgKyAnICcgK1xuICAgICAgICAgc2VsZi5vcGVyYXRvciArICcgJyArXG4gICAgICAgICB0cnVuY2F0ZShKU09OLnN0cmluZ2lmeShzZWxmLmV4cGVjdGVkLCByZXBsYWNlciksIDEyOCk7XG59XG5cbi8vIEF0IHByZXNlbnQgb25seSB0aGUgdGhyZWUga2V5cyBtZW50aW9uZWQgYWJvdmUgYXJlIHVzZWQgYW5kXG4vLyB1bmRlcnN0b29kIGJ5IHRoZSBzcGVjLiBJbXBsZW1lbnRhdGlvbnMgb3Igc3ViIG1vZHVsZXMgY2FuIHBhc3Ncbi8vIG90aGVyIGtleXMgdG8gdGhlIEFzc2VydGlvbkVycm9yJ3MgY29uc3RydWN0b3IgLSB0aGV5IHdpbGwgYmVcbi8vIGlnbm9yZWQuXG5cbi8vIDMuIEFsbCBvZiB0aGUgZm9sbG93aW5nIGZ1bmN0aW9ucyBtdXN0IHRocm93IGFuIEFzc2VydGlvbkVycm9yXG4vLyB3aGVuIGEgY29ycmVzcG9uZGluZyBjb25kaXRpb24gaXMgbm90IG1ldCwgd2l0aCBhIG1lc3NhZ2UgdGhhdFxuLy8gbWF5IGJlIHVuZGVmaW5lZCBpZiBub3QgcHJvdmlkZWQuICBBbGwgYXNzZXJ0aW9uIG1ldGhvZHMgcHJvdmlkZVxuLy8gYm90aCB0aGUgYWN0dWFsIGFuZCBleHBlY3RlZCB2YWx1ZXMgdG8gdGhlIGFzc2VydGlvbiBlcnJvciBmb3Jcbi8vIGRpc3BsYXkgcHVycG9zZXMuXG5cbmZ1bmN0aW9uIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgb3BlcmF0b3IsIHN0YWNrU3RhcnRGdW5jdGlvbikge1xuICB0aHJvdyBuZXcgYXNzZXJ0LkFzc2VydGlvbkVycm9yKHtcbiAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgIGFjdHVhbDogYWN0dWFsLFxuICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICBvcGVyYXRvcjogb3BlcmF0b3IsXG4gICAgc3RhY2tTdGFydEZ1bmN0aW9uOiBzdGFja1N0YXJ0RnVuY3Rpb25cbiAgfSk7XG59XG5cbi8vIEVYVEVOU0lPTiEgYWxsb3dzIGZvciB3ZWxsIGJlaGF2ZWQgZXJyb3JzIGRlZmluZWQgZWxzZXdoZXJlLlxuYXNzZXJ0LmZhaWwgPSBmYWlsO1xuXG4vLyA0LiBQdXJlIGFzc2VydGlvbiB0ZXN0cyB3aGV0aGVyIGEgdmFsdWUgaXMgdHJ1dGh5LCBhcyBkZXRlcm1pbmVkXG4vLyBieSAhIWd1YXJkLlxuLy8gYXNzZXJ0Lm9rKGd1YXJkLCBtZXNzYWdlX29wdCk7XG4vLyBUaGlzIHN0YXRlbWVudCBpcyBlcXVpdmFsZW50IHRvIGFzc2VydC5lcXVhbCh0cnVlLCAhIWd1YXJkLFxuLy8gbWVzc2FnZV9vcHQpOy4gVG8gdGVzdCBzdHJpY3RseSBmb3IgdGhlIHZhbHVlIHRydWUsIHVzZVxuLy8gYXNzZXJ0LnN0cmljdEVxdWFsKHRydWUsIGd1YXJkLCBtZXNzYWdlX29wdCk7LlxuXG5mdW5jdGlvbiBvayh2YWx1ZSwgbWVzc2FnZSkge1xuICBpZiAoIXZhbHVlKSBmYWlsKHZhbHVlLCB0cnVlLCBtZXNzYWdlLCAnPT0nLCBhc3NlcnQub2spO1xufVxuYXNzZXJ0Lm9rID0gb2s7XG5cbi8vIDUuIFRoZSBlcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgc2hhbGxvdywgY29lcmNpdmUgZXF1YWxpdHkgd2l0aFxuLy8gPT0uXG4vLyBhc3NlcnQuZXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQuZXF1YWwgPSBmdW5jdGlvbiBlcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgIT0gZXhwZWN0ZWQpIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJz09JywgYXNzZXJ0LmVxdWFsKTtcbn07XG5cbi8vIDYuIFRoZSBub24tZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIGZvciB3aGV0aGVyIHR3byBvYmplY3RzIGFyZSBub3QgZXF1YWxcbi8vIHdpdGggIT0gYXNzZXJ0Lm5vdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0Lm5vdEVxdWFsID0gZnVuY3Rpb24gbm90RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsID09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnIT0nLCBhc3NlcnQubm90RXF1YWwpO1xuICB9XG59O1xuXG4vLyA3LiBUaGUgZXF1aXZhbGVuY2UgYXNzZXJ0aW9uIHRlc3RzIGEgZGVlcCBlcXVhbGl0eSByZWxhdGlvbi5cbi8vIGFzc2VydC5kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQuZGVlcEVxdWFsID0gZnVuY3Rpb24gZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKCFfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnZGVlcEVxdWFsJywgYXNzZXJ0LmRlZXBFcXVhbCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCkge1xuICAvLyA3LjEuIEFsbCBpZGVudGljYWwgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBhcyBkZXRlcm1pbmVkIGJ5ID09PS5cbiAgaWYgKGFjdHVhbCA9PT0gZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcblxuICB9IGVsc2UgaWYgKHV0aWwuaXNCdWZmZXIoYWN0dWFsKSAmJiB1dGlsLmlzQnVmZmVyKGV4cGVjdGVkKSkge1xuICAgIGlmIChhY3R1YWwubGVuZ3RoICE9IGV4cGVjdGVkLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhY3R1YWwubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhY3R1YWxbaV0gIT09IGV4cGVjdGVkW2ldKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG5cbiAgLy8gNy4yLiBJZiB0aGUgZXhwZWN0ZWQgdmFsdWUgaXMgYSBEYXRlIG9iamVjdCwgdGhlIGFjdHVhbCB2YWx1ZSBpc1xuICAvLyBlcXVpdmFsZW50IGlmIGl0IGlzIGFsc28gYSBEYXRlIG9iamVjdCB0aGF0IHJlZmVycyB0byB0aGUgc2FtZSB0aW1lLlxuICB9IGVsc2UgaWYgKHV0aWwuaXNEYXRlKGFjdHVhbCkgJiYgdXRpbC5pc0RhdGUoZXhwZWN0ZWQpKSB7XG4gICAgcmV0dXJuIGFjdHVhbC5nZXRUaW1lKCkgPT09IGV4cGVjdGVkLmdldFRpbWUoKTtcblxuICAvLyA3LjMgSWYgdGhlIGV4cGVjdGVkIHZhbHVlIGlzIGEgUmVnRXhwIG9iamVjdCwgdGhlIGFjdHVhbCB2YWx1ZSBpc1xuICAvLyBlcXVpdmFsZW50IGlmIGl0IGlzIGFsc28gYSBSZWdFeHAgb2JqZWN0IHdpdGggdGhlIHNhbWUgc291cmNlIGFuZFxuICAvLyBwcm9wZXJ0aWVzIChgZ2xvYmFsYCwgYG11bHRpbGluZWAsIGBsYXN0SW5kZXhgLCBgaWdub3JlQ2FzZWApLlxuICB9IGVsc2UgaWYgKHV0aWwuaXNSZWdFeHAoYWN0dWFsKSAmJiB1dGlsLmlzUmVnRXhwKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBhY3R1YWwuc291cmNlID09PSBleHBlY3RlZC5zb3VyY2UgJiZcbiAgICAgICAgICAgYWN0dWFsLmdsb2JhbCA9PT0gZXhwZWN0ZWQuZ2xvYmFsICYmXG4gICAgICAgICAgIGFjdHVhbC5tdWx0aWxpbmUgPT09IGV4cGVjdGVkLm11bHRpbGluZSAmJlxuICAgICAgICAgICBhY3R1YWwubGFzdEluZGV4ID09PSBleHBlY3RlZC5sYXN0SW5kZXggJiZcbiAgICAgICAgICAgYWN0dWFsLmlnbm9yZUNhc2UgPT09IGV4cGVjdGVkLmlnbm9yZUNhc2U7XG5cbiAgLy8gNy40LiBPdGhlciBwYWlycyB0aGF0IGRvIG5vdCBib3RoIHBhc3MgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnLFxuICAvLyBlcXVpdmFsZW5jZSBpcyBkZXRlcm1pbmVkIGJ5ID09LlxuICB9IGVsc2UgaWYgKCF1dGlsLmlzT2JqZWN0KGFjdHVhbCkgJiYgIXV0aWwuaXNPYmplY3QoZXhwZWN0ZWQpKSB7XG4gICAgcmV0dXJuIGFjdHVhbCA9PSBleHBlY3RlZDtcblxuICAvLyA3LjUgRm9yIGFsbCBvdGhlciBPYmplY3QgcGFpcnMsIGluY2x1ZGluZyBBcnJheSBvYmplY3RzLCBlcXVpdmFsZW5jZSBpc1xuICAvLyBkZXRlcm1pbmVkIGJ5IGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoYXMgdmVyaWZpZWRcbiAgLy8gd2l0aCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwpLCB0aGUgc2FtZSBzZXQgb2Yga2V5c1xuICAvLyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSwgZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5XG4gIC8vIGNvcnJlc3BvbmRpbmcga2V5LCBhbmQgYW4gaWRlbnRpY2FsICdwcm90b3R5cGUnIHByb3BlcnR5LiBOb3RlOiB0aGlzXG4gIC8vIGFjY291bnRzIGZvciBib3RoIG5hbWVkIGFuZCBpbmRleGVkIHByb3BlcnRpZXMgb24gQXJyYXlzLlxuICB9IGVsc2Uge1xuICAgIHJldHVybiBvYmpFcXVpdihhY3R1YWwsIGV4cGVjdGVkKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0FyZ3VtZW50cyhvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpID09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xufVxuXG5mdW5jdGlvbiBvYmpFcXVpdihhLCBiKSB7XG4gIGlmICh1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKGEpIHx8IHV0aWwuaXNOdWxsT3JVbmRlZmluZWQoYikpXG4gICAgcmV0dXJuIGZhbHNlO1xuICAvLyBhbiBpZGVudGljYWwgJ3Byb3RvdHlwZScgcHJvcGVydHkuXG4gIGlmIChhLnByb3RvdHlwZSAhPT0gYi5wcm90b3R5cGUpIHJldHVybiBmYWxzZTtcbiAgLy8gaWYgb25lIGlzIGEgcHJpbWl0aXZlLCB0aGUgb3RoZXIgbXVzdCBiZSBzYW1lXG4gIGlmICh1dGlsLmlzUHJpbWl0aXZlKGEpIHx8IHV0aWwuaXNQcmltaXRpdmUoYikpIHtcbiAgICByZXR1cm4gYSA9PT0gYjtcbiAgfVxuICB2YXIgYUlzQXJncyA9IGlzQXJndW1lbnRzKGEpLFxuICAgICAgYklzQXJncyA9IGlzQXJndW1lbnRzKGIpO1xuICBpZiAoKGFJc0FyZ3MgJiYgIWJJc0FyZ3MpIHx8ICghYUlzQXJncyAmJiBiSXNBcmdzKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmIChhSXNBcmdzKSB7XG4gICAgYSA9IHBTbGljZS5jYWxsKGEpO1xuICAgIGIgPSBwU2xpY2UuY2FsbChiKTtcbiAgICByZXR1cm4gX2RlZXBFcXVhbChhLCBiKTtcbiAgfVxuICB2YXIga2EgPSBvYmplY3RLZXlzKGEpLFxuICAgICAga2IgPSBvYmplY3RLZXlzKGIpLFxuICAgICAga2V5LCBpO1xuICAvLyBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGtleXMgaW5jb3Jwb3JhdGVzXG4gIC8vIGhhc093blByb3BlcnR5KVxuICBpZiAoa2EubGVuZ3RoICE9IGtiLmxlbmd0aClcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vdGhlIHNhbWUgc2V0IG9mIGtleXMgKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksXG4gIGthLnNvcnQoKTtcbiAga2Iuc29ydCgpO1xuICAvL35+fmNoZWFwIGtleSB0ZXN0XG4gIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKGthW2ldICE9IGtiW2ldKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5IGNvcnJlc3BvbmRpbmcga2V5LCBhbmRcbiAgLy9+fn5wb3NzaWJseSBleHBlbnNpdmUgZGVlcCB0ZXN0XG4gIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAga2V5ID0ga2FbaV07XG4gICAgaWYgKCFfZGVlcEVxdWFsKGFba2V5XSwgYltrZXldKSkgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyA4LiBUaGUgbm9uLWVxdWl2YWxlbmNlIGFzc2VydGlvbiB0ZXN0cyBmb3IgYW55IGRlZXAgaW5lcXVhbGl0eS5cbi8vIGFzc2VydC5ub3REZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQubm90RGVlcEVxdWFsID0gZnVuY3Rpb24gbm90RGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKF9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCkpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICdub3REZWVwRXF1YWwnLCBhc3NlcnQubm90RGVlcEVxdWFsKTtcbiAgfVxufTtcblxuLy8gOS4gVGhlIHN0cmljdCBlcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgc3RyaWN0IGVxdWFsaXR5LCBhcyBkZXRlcm1pbmVkIGJ5ID09PS5cbi8vIGFzc2VydC5zdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5zdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIHN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCAhPT0gZXhwZWN0ZWQpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICc9PT0nLCBhc3NlcnQuc3RyaWN0RXF1YWwpO1xuICB9XG59O1xuXG4vLyAxMC4gVGhlIHN0cmljdCBub24tZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIGZvciBzdHJpY3QgaW5lcXVhbGl0eSwgYXNcbi8vIGRldGVybWluZWQgYnkgIT09LiAgYXNzZXJ0Lm5vdFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0Lm5vdFN0cmljdEVxdWFsID0gZnVuY3Rpb24gbm90U3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsID09PSBleHBlY3RlZCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJyE9PScsIGFzc2VydC5ub3RTdHJpY3RFcXVhbCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpIHtcbiAgaWYgKCFhY3R1YWwgfHwgIWV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChleHBlY3RlZCkgPT0gJ1tvYmplY3QgUmVnRXhwXScpIHtcbiAgICByZXR1cm4gZXhwZWN0ZWQudGVzdChhY3R1YWwpO1xuICB9IGVsc2UgaWYgKGFjdHVhbCBpbnN0YW5jZW9mIGV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWQuY2FsbCh7fSwgYWN0dWFsKSA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBfdGhyb3dzKHNob3VsZFRocm93LCBibG9jaywgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgdmFyIGFjdHVhbDtcblxuICBpZiAodXRpbC5pc1N0cmluZyhleHBlY3RlZCkpIHtcbiAgICBtZXNzYWdlID0gZXhwZWN0ZWQ7XG4gICAgZXhwZWN0ZWQgPSBudWxsO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBibG9jaygpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgYWN0dWFsID0gZTtcbiAgfVxuXG4gIG1lc3NhZ2UgPSAoZXhwZWN0ZWQgJiYgZXhwZWN0ZWQubmFtZSA/ICcgKCcgKyBleHBlY3RlZC5uYW1lICsgJykuJyA6ICcuJykgK1xuICAgICAgICAgICAgKG1lc3NhZ2UgPyAnICcgKyBtZXNzYWdlIDogJy4nKTtcblxuICBpZiAoc2hvdWxkVGhyb3cgJiYgIWFjdHVhbCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgJ01pc3NpbmcgZXhwZWN0ZWQgZXhjZXB0aW9uJyArIG1lc3NhZ2UpO1xuICB9XG5cbiAgaWYgKCFzaG91bGRUaHJvdyAmJiBleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgJ0dvdCB1bndhbnRlZCBleGNlcHRpb24nICsgbWVzc2FnZSk7XG4gIH1cblxuICBpZiAoKHNob3VsZFRocm93ICYmIGFjdHVhbCAmJiBleHBlY3RlZCAmJlxuICAgICAgIWV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpKSB8fCAoIXNob3VsZFRocm93ICYmIGFjdHVhbCkpIHtcbiAgICB0aHJvdyBhY3R1YWw7XG4gIH1cbn1cblxuLy8gMTEuIEV4cGVjdGVkIHRvIHRocm93IGFuIGVycm9yOlxuLy8gYXNzZXJ0LnRocm93cyhibG9jaywgRXJyb3Jfb3B0LCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC50aHJvd3MgPSBmdW5jdGlvbihibG9jaywgLypvcHRpb25hbCovZXJyb3IsIC8qb3B0aW9uYWwqL21lc3NhZ2UpIHtcbiAgX3Rocm93cy5hcHBseSh0aGlzLCBbdHJ1ZV0uY29uY2F0KHBTbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbn07XG5cbi8vIEVYVEVOU0lPTiEgVGhpcyBpcyBhbm5veWluZyB0byB3cml0ZSBvdXRzaWRlIHRoaXMgbW9kdWxlLlxuYXNzZXJ0LmRvZXNOb3RUaHJvdyA9IGZ1bmN0aW9uKGJsb2NrLCAvKm9wdGlvbmFsKi9tZXNzYWdlKSB7XG4gIF90aHJvd3MuYXBwbHkodGhpcywgW2ZhbHNlXS5jb25jYXQocFNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xufTtcblxuYXNzZXJ0LmlmRXJyb3IgPSBmdW5jdGlvbihlcnIpIHsgaWYgKGVycikge3Rocm93IGVycjt9fTtcblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoaGFzT3duLmNhbGwob2JqLCBrZXkpKSBrZXlzLnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn07XG4iLCJpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gIH1cbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyByZXNvbHZlcyAuIGFuZCAuLiBlbGVtZW50cyBpbiBhIHBhdGggYXJyYXkgd2l0aCBkaXJlY3RvcnkgbmFtZXMgdGhlcmVcbi8vIG11c3QgYmUgbm8gc2xhc2hlcywgZW1wdHkgZWxlbWVudHMsIG9yIGRldmljZSBuYW1lcyAoYzpcXCkgaW4gdGhlIGFycmF5XG4vLyAoc28gYWxzbyBubyBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaGVzIC0gaXQgZG9lcyBub3QgZGlzdGluZ3Vpc2hcbi8vIHJlbGF0aXZlIGFuZCBhYnNvbHV0ZSBwYXRocylcbmZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5KHBhcnRzLCBhbGxvd0Fib3ZlUm9vdCkge1xuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gcGFydHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgbGFzdCA9IHBhcnRzW2ldO1xuICAgIGlmIChsYXN0ID09PSAnLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG4gIGlmIChhbGxvd0Fib3ZlUm9vdCkge1xuICAgIGZvciAoOyB1cC0tOyB1cCkge1xuICAgICAgcGFydHMudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFydHM7XG59XG5cbi8vIFNwbGl0IGEgZmlsZW5hbWUgaW50byBbcm9vdCwgZGlyLCBiYXNlbmFtZSwgZXh0XSwgdW5peCB2ZXJzaW9uXG4vLyAncm9vdCcgaXMganVzdCBhIHNsYXNoLCBvciBub3RoaW5nLlxudmFyIHNwbGl0UGF0aFJlID1cbiAgICAvXihcXC8/fCkoW1xcc1xcU10qPykoKD86XFwuezEsMn18W15cXC9dKz98KShcXC5bXi5cXC9dKnwpKSg/OltcXC9dKikkLztcbnZhciBzcGxpdFBhdGggPSBmdW5jdGlvbihmaWxlbmFtZSkge1xuICByZXR1cm4gc3BsaXRQYXRoUmUuZXhlYyhmaWxlbmFtZSkuc2xpY2UoMSk7XG59O1xuXG4vLyBwYXRoLnJlc29sdmUoW2Zyb20gLi4uXSwgdG8pXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLnJlc29sdmUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJlc29sdmVkUGF0aCA9ICcnLFxuICAgICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IGZhbHNlO1xuXG4gIGZvciAodmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTsgaSA+PSAtMSAmJiAhcmVzb2x2ZWRBYnNvbHV0ZTsgaS0tKSB7XG4gICAgdmFyIHBhdGggPSAoaSA+PSAwKSA/IGFyZ3VtZW50c1tpXSA6IHByb2Nlc3MuY3dkKCk7XG5cbiAgICAvLyBTa2lwIGVtcHR5IGFuZCBpbnZhbGlkIGVudHJpZXNcbiAgICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgdG8gcGF0aC5yZXNvbHZlIG11c3QgYmUgc3RyaW5ncycpO1xuICAgIH0gZWxzZSBpZiAoIXBhdGgpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHJlc29sdmVkUGF0aCA9IHBhdGggKyAnLycgKyByZXNvbHZlZFBhdGg7XG4gICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IHBhdGguY2hhckF0KDApID09PSAnLyc7XG4gIH1cblxuICAvLyBBdCB0aGlzIHBvaW50IHRoZSBwYXRoIHNob3VsZCBiZSByZXNvbHZlZCB0byBhIGZ1bGwgYWJzb2x1dGUgcGF0aCwgYnV0XG4gIC8vIGhhbmRsZSByZWxhdGl2ZSBwYXRocyB0byBiZSBzYWZlIChtaWdodCBoYXBwZW4gd2hlbiBwcm9jZXNzLmN3ZCgpIGZhaWxzKVxuXG4gIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICByZXNvbHZlZFBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocmVzb2x2ZWRQYXRoLnNwbGl0KCcvJyksIGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gISFwO1xuICB9KSwgIXJlc29sdmVkQWJzb2x1dGUpLmpvaW4oJy8nKTtcblxuICByZXR1cm4gKChyZXNvbHZlZEFic29sdXRlID8gJy8nIDogJycpICsgcmVzb2x2ZWRQYXRoKSB8fCAnLic7XG59O1xuXG4vLyBwYXRoLm5vcm1hbGl6ZShwYXRoKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5ub3JtYWxpemUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHZhciBpc0Fic29sdXRlID0gZXhwb3J0cy5pc0Fic29sdXRlKHBhdGgpLFxuICAgICAgdHJhaWxpbmdTbGFzaCA9IHN1YnN0cihwYXRoLCAtMSkgPT09ICcvJztcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcGF0aCA9IG5vcm1hbGl6ZUFycmF5KGZpbHRlcihwYXRoLnNwbGl0KCcvJyksIGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gISFwO1xuICB9KSwgIWlzQWJzb2x1dGUpLmpvaW4oJy8nKTtcblxuICBpZiAoIXBhdGggJiYgIWlzQWJzb2x1dGUpIHtcbiAgICBwYXRoID0gJy4nO1xuICB9XG4gIGlmIChwYXRoICYmIHRyYWlsaW5nU2xhc2gpIHtcbiAgICBwYXRoICs9ICcvJztcbiAgfVxuXG4gIHJldHVybiAoaXNBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHBhdGg7XG59O1xuXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLmlzQWJzb2x1dGUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5qb2luID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwYXRocyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gIHJldHVybiBleHBvcnRzLm5vcm1hbGl6ZShmaWx0ZXIocGF0aHMsIGZ1bmN0aW9uKHAsIGluZGV4KSB7XG4gICAgaWYgKHR5cGVvZiBwICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGguam9pbiBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG4gIH0pLmpvaW4oJy8nKSk7XG59O1xuXG5cbi8vIHBhdGgucmVsYXRpdmUoZnJvbSwgdG8pXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLnJlbGF0aXZlID0gZnVuY3Rpb24oZnJvbSwgdG8pIHtcbiAgZnJvbSA9IGV4cG9ydHMucmVzb2x2ZShmcm9tKS5zdWJzdHIoMSk7XG4gIHRvID0gZXhwb3J0cy5yZXNvbHZlKHRvKS5zdWJzdHIoMSk7XG5cbiAgZnVuY3Rpb24gdHJpbShhcnIpIHtcbiAgICB2YXIgc3RhcnQgPSAwO1xuICAgIGZvciAoOyBzdGFydCA8IGFyci5sZW5ndGg7IHN0YXJ0KyspIHtcbiAgICAgIGlmIChhcnJbc3RhcnRdICE9PSAnJykgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIGVuZCA9IGFyci5sZW5ndGggLSAxO1xuICAgIGZvciAoOyBlbmQgPj0gMDsgZW5kLS0pIHtcbiAgICAgIGlmIChhcnJbZW5kXSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChzdGFydCA+IGVuZCkgcmV0dXJuIFtdO1xuICAgIHJldHVybiBhcnIuc2xpY2Uoc3RhcnQsIGVuZCAtIHN0YXJ0ICsgMSk7XG4gIH1cblxuICB2YXIgZnJvbVBhcnRzID0gdHJpbShmcm9tLnNwbGl0KCcvJykpO1xuICB2YXIgdG9QYXJ0cyA9IHRyaW0odG8uc3BsaXQoJy8nKSk7XG5cbiAgdmFyIGxlbmd0aCA9IE1hdGgubWluKGZyb21QYXJ0cy5sZW5ndGgsIHRvUGFydHMubGVuZ3RoKTtcbiAgdmFyIHNhbWVQYXJ0c0xlbmd0aCA9IGxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmIChmcm9tUGFydHNbaV0gIT09IHRvUGFydHNbaV0pIHtcbiAgICAgIHNhbWVQYXJ0c0xlbmd0aCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB2YXIgb3V0cHV0UGFydHMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IHNhbWVQYXJ0c0xlbmd0aDsgaSA8IGZyb21QYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgIG91dHB1dFBhcnRzLnB1c2goJy4uJyk7XG4gIH1cblxuICBvdXRwdXRQYXJ0cyA9IG91dHB1dFBhcnRzLmNvbmNhdCh0b1BhcnRzLnNsaWNlKHNhbWVQYXJ0c0xlbmd0aCkpO1xuXG4gIHJldHVybiBvdXRwdXRQYXJ0cy5qb2luKCcvJyk7XG59O1xuXG5leHBvcnRzLnNlcCA9ICcvJztcbmV4cG9ydHMuZGVsaW1pdGVyID0gJzonO1xuXG5leHBvcnRzLmRpcm5hbWUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHZhciByZXN1bHQgPSBzcGxpdFBhdGgocGF0aCksXG4gICAgICByb290ID0gcmVzdWx0WzBdLFxuICAgICAgZGlyID0gcmVzdWx0WzFdO1xuXG4gIGlmICghcm9vdCAmJiAhZGlyKSB7XG4gICAgLy8gTm8gZGlybmFtZSB3aGF0c29ldmVyXG4gICAgcmV0dXJuICcuJztcbiAgfVxuXG4gIGlmIChkaXIpIHtcbiAgICAvLyBJdCBoYXMgYSBkaXJuYW1lLCBzdHJpcCB0cmFpbGluZyBzbGFzaFxuICAgIGRpciA9IGRpci5zdWJzdHIoMCwgZGlyLmxlbmd0aCAtIDEpO1xuICB9XG5cbiAgcmV0dXJuIHJvb3QgKyBkaXI7XG59O1xuXG5cbmV4cG9ydHMuYmFzZW5hbWUgPSBmdW5jdGlvbihwYXRoLCBleHQpIHtcbiAgdmFyIGYgPSBzcGxpdFBhdGgocGF0aClbMl07XG4gIC8vIFRPRE86IG1ha2UgdGhpcyBjb21wYXJpc29uIGNhc2UtaW5zZW5zaXRpdmUgb24gd2luZG93cz9cbiAgaWYgKGV4dCAmJiBmLnN1YnN0cigtMSAqIGV4dC5sZW5ndGgpID09PSBleHQpIHtcbiAgICBmID0gZi5zdWJzdHIoMCwgZi5sZW5ndGggLSBleHQubGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gZjtcbn07XG5cblxuZXhwb3J0cy5leHRuYW1lID0gZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gc3BsaXRQYXRoKHBhdGgpWzNdO1xufTtcblxuZnVuY3Rpb24gZmlsdGVyICh4cywgZikge1xuICAgIGlmICh4cy5maWx0ZXIpIHJldHVybiB4cy5maWx0ZXIoZik7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGYoeHNbaV0sIGksIHhzKSkgcmVzLnB1c2goeHNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG4vLyBTdHJpbmcucHJvdG90eXBlLnN1YnN0ciAtIG5lZ2F0aXZlIGluZGV4IGRvbid0IHdvcmsgaW4gSUU4XG52YXIgc3Vic3RyID0gJ2FiJy5zdWJzdHIoLTEpID09PSAnYidcbiAgICA/IGZ1bmN0aW9uIChzdHIsIHN0YXJ0LCBsZW4pIHsgcmV0dXJuIHN0ci5zdWJzdHIoc3RhcnQsIGxlbikgfVxuICAgIDogZnVuY3Rpb24gKHN0ciwgc3RhcnQsIGxlbikge1xuICAgICAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IHN0ci5sZW5ndGggKyBzdGFydDtcbiAgICAgICAgcmV0dXJuIHN0ci5zdWJzdHIoc3RhcnQsIGxlbik7XG4gICAgfVxuO1xuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHNldFRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZHJhaW5RdWV1ZSwgMCk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQnVmZmVyKGFyZykge1xuICByZXR1cm4gYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnXG4gICAgJiYgdHlwZW9mIGFyZy5jb3B5ID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5maWxsID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5yZWFkVUludDggPT09ICdmdW5jdGlvbic7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbihmKSB7XG4gIGlmICghaXNTdHJpbmcoZikpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvYmplY3RzLnB1c2goaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuICB9XG5cbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclaic6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gIH0pO1xuICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkge1xuICAgIGlmIChpc051bGwoeCkgfHwgIWlzT2JqZWN0KHgpKSB7XG4gICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgJyArIGluc3BlY3QoeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG5cbi8vIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4vLyBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuLy8gSWYgLS1uby1kZXByZWNhdGlvbiBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbmV4cG9ydHMuZGVwcmVjYXRlID0gZnVuY3Rpb24oZm4sIG1zZykge1xuICAvLyBBbGxvdyBmb3IgZGVwcmVjYXRpbmcgdGhpbmdzIGluIHRoZSBwcm9jZXNzIG9mIHN0YXJ0aW5nIHVwLlxuICBpZiAoaXNVbmRlZmluZWQoZ2xvYmFsLnByb2Nlc3MpKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVwcmVjYXRlKGZuLCBtc2cpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLm5vRGVwcmVjYXRpb24gPT09IHRydWUpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChwcm9jZXNzLnRocm93RGVwcmVjYXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbikge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufTtcblxuXG52YXIgZGVidWdzID0ge307XG52YXIgZGVidWdFbnZpcm9uO1xuZXhwb3J0cy5kZWJ1Z2xvZyA9IGZ1bmN0aW9uKHNldCkge1xuICBpZiAoaXNVbmRlZmluZWQoZGVidWdFbnZpcm9uKSlcbiAgICBkZWJ1Z0Vudmlyb24gPSBwcm9jZXNzLmVudi5OT0RFX0RFQlVHIHx8ICcnO1xuICBzZXQgPSBzZXQudG9VcHBlckNhc2UoKTtcbiAgaWYgKCFkZWJ1Z3Nbc2V0XSkge1xuICAgIGlmIChuZXcgUmVnRXhwKCdcXFxcYicgKyBzZXQgKyAnXFxcXGInLCAnaScpLnRlc3QoZGVidWdFbnZpcm9uKSkge1xuICAgICAgdmFyIHBpZCA9IHByb2Nlc3MucGlkO1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1zZyA9IGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJyVzICVkOiAlcycsIHNldCwgcGlkLCBtc2cpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHt9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVidWdzW3NldF07XG59O1xuXG5cbi8qKlxuICogRWNob3MgdGhlIHZhbHVlIG9mIGEgdmFsdWUuIFRyeXMgdG8gcHJpbnQgdGhlIHZhbHVlIG91dFxuICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHByaW50IG91dC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHRoYXQgYWx0ZXJzIHRoZSBvdXRwdXQuXG4gKi9cbi8qIGxlZ2FjeTogb2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKi9cbmZ1bmN0aW9uIGluc3BlY3Qob2JqLCBvcHRzKSB7XG4gIC8vIGRlZmF1bHQgb3B0aW9uc1xuICB2YXIgY3R4ID0ge1xuICAgIHNlZW46IFtdLFxuICAgIHN0eWxpemU6IHN0eWxpemVOb0NvbG9yXG4gIH07XG4gIC8vIGxlZ2FjeS4uLlxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSBjdHguZGVwdGggPSBhcmd1bWVudHNbMl07XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIGN0eC5jb2xvcnMgPSBhcmd1bWVudHNbM107XG4gIGlmIChpc0Jvb2xlYW4ob3B0cykpIHtcbiAgICAvLyBsZWdhY3kuLi5cbiAgICBjdHguc2hvd0hpZGRlbiA9IG9wdHM7XG4gIH0gZWxzZSBpZiAob3B0cykge1xuICAgIC8vIGdvdCBhbiBcIm9wdGlvbnNcIiBvYmplY3RcbiAgICBleHBvcnRzLl9leHRlbmQoY3R4LCBvcHRzKTtcbiAgfVxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gIGlmIChpc1VuZGVmaW5lZChjdHguc2hvd0hpZGRlbikpIGN0eC5zaG93SGlkZGVuID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguZGVwdGgpKSBjdHguZGVwdGggPSAyO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmNvbG9ycykpIGN0eC5jb2xvcnMgPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jdXN0b21JbnNwZWN0KSkgY3R4LmN1c3RvbUluc3BlY3QgPSB0cnVlO1xuICBpZiAoY3R4LmNvbG9ycykgY3R4LnN0eWxpemUgPSBzdHlsaXplV2l0aENvbG9yO1xuICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCBvYmosIGN0eC5kZXB0aCk7XG59XG5leHBvcnRzLmluc3BlY3QgPSBpbnNwZWN0O1xuXG5cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljc1xuaW5zcGVjdC5jb2xvcnMgPSB7XG4gICdib2xkJyA6IFsxLCAyMl0sXG4gICdpdGFsaWMnIDogWzMsIDIzXSxcbiAgJ3VuZGVybGluZScgOiBbNCwgMjRdLFxuICAnaW52ZXJzZScgOiBbNywgMjddLFxuICAnd2hpdGUnIDogWzM3LCAzOV0sXG4gICdncmV5JyA6IFs5MCwgMzldLFxuICAnYmxhY2snIDogWzMwLCAzOV0sXG4gICdibHVlJyA6IFszNCwgMzldLFxuICAnY3lhbicgOiBbMzYsIDM5XSxcbiAgJ2dyZWVuJyA6IFszMiwgMzldLFxuICAnbWFnZW50YScgOiBbMzUsIDM5XSxcbiAgJ3JlZCcgOiBbMzEsIDM5XSxcbiAgJ3llbGxvdycgOiBbMzMsIDM5XVxufTtcblxuLy8gRG9uJ3QgdXNlICdibHVlJyBub3QgdmlzaWJsZSBvbiBjbWQuZXhlXG5pbnNwZWN0LnN0eWxlcyA9IHtcbiAgJ3NwZWNpYWwnOiAnY3lhbicsXG4gICdudW1iZXInOiAneWVsbG93JyxcbiAgJ2Jvb2xlYW4nOiAneWVsbG93JyxcbiAgJ3VuZGVmaW5lZCc6ICdncmV5JyxcbiAgJ251bGwnOiAnYm9sZCcsXG4gICdzdHJpbmcnOiAnZ3JlZW4nLFxuICAnZGF0ZSc6ICdtYWdlbnRhJyxcbiAgLy8gXCJuYW1lXCI6IGludGVudGlvbmFsbHkgbm90IHN0eWxpbmdcbiAgJ3JlZ2V4cCc6ICdyZWQnXG59O1xuXG5cbmZ1bmN0aW9uIHN0eWxpemVXaXRoQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgdmFyIHN0eWxlID0gaW5zcGVjdC5zdHlsZXNbc3R5bGVUeXBlXTtcblxuICBpZiAoc3R5bGUpIHtcbiAgICByZXR1cm4gJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVswXSArICdtJyArIHN0ciArXG4gICAgICAgICAgICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMV0gKyAnbSc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHN0eWxpemVOb0NvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHJldHVybiBzdHI7XG59XG5cblxuZnVuY3Rpb24gYXJyYXlUb0hhc2goYXJyYXkpIHtcbiAgdmFyIGhhc2ggPSB7fTtcblxuICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwgaWR4KSB7XG4gICAgaGFzaFt2YWxdID0gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGhhc2g7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XG4gIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cbiAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XG4gIGlmIChjdHguY3VzdG9tSW5zcGVjdCAmJlxuICAgICAgdmFsdWUgJiZcbiAgICAgIGlzRnVuY3Rpb24odmFsdWUuaW5zcGVjdCkgJiZcbiAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbFxuICAgICAgdmFsdWUuaW5zcGVjdCAhPT0gZXhwb3J0cy5pbnNwZWN0ICYmXG4gICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAgICEodmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZSkpIHtcbiAgICB2YXIgcmV0ID0gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMsIGN0eCk7XG4gICAgaWYgKCFpc1N0cmluZyhyZXQpKSB7XG4gICAgICByZXQgPSBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG4gIHZhciBwcmltaXRpdmUgPSBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSk7XG4gIGlmIChwcmltaXRpdmUpIHtcbiAgICByZXR1cm4gcHJpbWl0aXZlO1xuICB9XG5cbiAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgdmFyIHZpc2libGVLZXlzID0gYXJyYXlUb0hhc2goa2V5cyk7XG5cbiAgaWYgKGN0eC5zaG93SGlkZGVuKSB7XG4gICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcbiAgfVxuXG4gIC8vIElFIGRvZXNuJ3QgbWFrZSBlcnJvciBmaWVsZHMgbm9uLWVudW1lcmFibGVcbiAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2R3dzUyc2J0KHY9dnMuOTQpLmFzcHhcbiAgaWYgKGlzRXJyb3IodmFsdWUpXG4gICAgICAmJiAoa2V5cy5pbmRleE9mKCdtZXNzYWdlJykgPj0gMCB8fCBrZXlzLmluZGV4T2YoJ2Rlc2NyaXB0aW9uJykgPj0gMCkpIHtcbiAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgLy8gU29tZSB0eXBlIG9mIG9iamVjdCB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxuICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHZhciBuYW1lID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH1cbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAnZGF0ZScpO1xuICAgIH1cbiAgICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhc2UgPSAnJywgYXJyYXkgPSBmYWxzZSwgYnJhY2VzID0gWyd7JywgJ30nXTtcblxuICAvLyBNYWtlIEFycmF5IHNheSB0aGF0IHRoZXkgYXJlIEFycmF5XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGFycmF5ID0gdHJ1ZTtcbiAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xuICB9XG5cbiAgLy8gTWFrZSBmdW5jdGlvbnMgc2F5IHRoYXQgdGhleSBhcmUgZnVuY3Rpb25zXG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHZhciBuID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgYmFzZSA9ICcgW0Z1bmN0aW9uJyArIG4gKyAnXSc7XG4gIH1cblxuICAvLyBNYWtlIFJlZ0V4cHMgc2F5IHRoYXQgdGhleSBhcmUgUmVnRXhwc1xuICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcbiAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGVycm9yIHdpdGggbWVzc2FnZSBmaXJzdCBzYXkgdGhlIGVycm9yXG4gIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICBpZiAoa2V5cy5sZW5ndGggPT09IDAgJiYgKCFhcnJheSB8fCB2YWx1ZS5sZW5ndGggPT0gMCkpIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXTtcbiAgfVxuXG4gIGlmIChyZWN1cnNlVGltZXMgPCAwKSB7XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbT2JqZWN0XScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG5cbiAgY3R4LnNlZW4ucHVzaCh2YWx1ZSk7XG5cbiAgdmFyIG91dHB1dDtcbiAgaWYgKGFycmF5KSB7XG4gICAgb3V0cHV0ID0gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cyk7XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSk7XG4gICAgfSk7XG4gIH1cblxuICBjdHguc2Vlbi5wb3AoKTtcblxuICByZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKSB7XG4gIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YXIgc2ltcGxlID0gJ1xcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlwifFwiJC9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJykgKyAnXFwnJztcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoc2ltcGxlLCAnc3RyaW5nJyk7XG4gIH1cbiAgaWYgKGlzTnVtYmVyKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xuICBpZiAoaXNCb29sZWFuKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcbiAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFwib2JqZWN0XCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxuICBpZiAoaXNOdWxsKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKHZhbHVlKSB7XG4gIHJldHVybiAnWycgKyBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgKyAnXSc7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cykge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5KHZhbHVlLCBTdHJpbmcoaSkpKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIFN0cmluZyhpKSwgdHJ1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaCgnJyk7XG4gICAgfVxuICB9XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoIWtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAga2V5LCB0cnVlKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KSB7XG4gIHZhciBuYW1lLCBzdHIsIGRlc2M7XG4gIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLCBrZXkpIHx8IHsgdmFsdWU6IHZhbHVlW2tleV0gfTtcbiAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlci9TZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoIWhhc093blByb3BlcnR5KHZpc2libGVLZXlzLCBrZXkpKSB7XG4gICAgbmFtZSA9ICdbJyArIGtleSArICddJztcbiAgfVxuICBpZiAoIXN0cikge1xuICAgIGlmIChjdHguc2Vlbi5pbmRleE9mKGRlc2MudmFsdWUpIDwgMCkge1xuICAgICAgaWYgKGlzTnVsbChyZWN1cnNlVGltZXMpKSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIHJlY3Vyc2VUaW1lcyAtIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgIHN0ciA9IHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKS5zdWJzdHIoMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyID0gJ1xcbicgKyBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbQ2lyY3VsYXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzVW5kZWZpbmVkKG5hbWUpKSB7XG4gICAgaWYgKGFycmF5ICYmIGtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIG5hbWUgPSBKU09OLnN0cmluZ2lmeSgnJyArIGtleSk7XG4gICAgaWYgKG5hbWUubWF0Y2goL15cIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVwiJC8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHIoMSwgbmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnbmFtZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cInxcIiQpL2csIFwiJ1wiKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xufVxuXG5cbmZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKSB7XG4gIHZhciBudW1MaW5lc0VzdCA9IDA7XG4gIHZhciBsZW5ndGggPSBvdXRwdXQucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikge1xuICAgIG51bUxpbmVzRXN0Kys7XG4gICAgaWYgKGN1ci5pbmRleE9mKCdcXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrO1xuICAgIHJldHVybiBwcmV2ICsgY3VyLnJlcGxhY2UoL1xcdTAwMWJcXFtcXGRcXGQ/bS9nLCAnJykubGVuZ3RoICsgMTtcbiAgfSwgMCk7XG5cbiAgaWYgKGxlbmd0aCA+IDYwKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArXG4gICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcXG4gJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBvdXRwdXQuam9pbignLFxcbiAgJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBicmFjZXNbMV07XG4gIH1cblxuICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xufVxuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyKTtcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHJlKSAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGQpICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiBpc09iamVjdChlKSAmJlxuICAgICAgKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gcmVxdWlyZSgnLi9zdXBwb3J0L2lzQnVmZmVyJyk7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cblxuXG5mdW5jdGlvbiBwYWQobikge1xuICByZXR1cm4gbiA8IDEwID8gJzAnICsgbi50b1N0cmluZygxMCkgOiBuLnRvU3RyaW5nKDEwKTtcbn1cblxuXG52YXIgbW9udGhzID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsXG4gICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddO1xuXG4vLyAyNiBGZWIgMTY6MTk6MzRcbmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xuICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpO1xufVxuXG5cbi8vIGxvZyBpcyBqdXN0IGEgdGhpbiB3cmFwcGVyIHRvIGNvbnNvbGUubG9nIHRoYXQgcHJlcGVuZHMgYSB0aW1lc3RhbXBcbmV4cG9ydHMubG9nID0gZnVuY3Rpb24oKSB7XG4gIGNvbnNvbGUubG9nKCclcyAtICVzJywgdGltZXN0YW1wKCksIGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cykpO1xufTtcblxuXG4vKipcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlci5cbiAqXG4gKiBUaGUgRnVuY3Rpb24ucHJvdG90eXBlLmluaGVyaXRzIGZyb20gbGFuZy5qcyByZXdyaXR0ZW4gYXMgYSBzdGFuZGFsb25lXG4gKiBmdW5jdGlvbiAobm90IG9uIEZ1bmN0aW9uLnByb3RvdHlwZSkuIE5PVEU6IElmIHRoaXMgZmlsZSBpcyB0byBiZSBsb2FkZWRcbiAqIGR1cmluZyBib290c3RyYXBwaW5nIHRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgcmV3cml0dGVuIHVzaW5nIHNvbWUgbmF0aXZlXG4gKiBmdW5jdGlvbnMgYXMgcHJvdG90eXBlIHNldHVwIHVzaW5nIG5vcm1hbCBKYXZhU2NyaXB0IGRvZXMgbm90IHdvcmsgYXNcbiAqIGV4cGVjdGVkIGR1cmluZyBib290c3RyYXBwaW5nIChzZWUgbWlycm9yLmpzIGluIHIxMTQ5MDMpLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gd2hpY2ggbmVlZHMgdG8gaW5oZXJpdCB0aGVcbiAqICAgICBwcm90b3R5cGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gdG8gaW5oZXJpdCBwcm90b3R5cGUgZnJvbS5cbiAqL1xuZXhwb3J0cy5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmV4cG9ydHMuX2V4dGVuZCA9IGZ1bmN0aW9uKG9yaWdpbiwgYWRkKSB7XG4gIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIGFkZCBpc24ndCBhbiBvYmplY3RcbiAgaWYgKCFhZGQgfHwgIWlzT2JqZWN0KGFkZCkpIHJldHVybiBvcmlnaW47XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dO1xuICB9XG4gIHJldHVybiBvcmlnaW47XG59O1xuXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuIiwiLy8gKGMpIERlYW4gTWNOYW1lZSA8ZGVhbkBnbWFpbC5jb20+LCAyMDEyLlxuLy9cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kZWFubS9jc3MtY29sb3ItcGFyc2VyLWpzXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG9cbi8vIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlXG4vLyByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Jcbi8vIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbi8vIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1Ncbi8vIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1jb2xvci9cbnZhciBrQ1NTQ29sb3JUYWJsZSA9IHtcbiAgXCJ0cmFuc3BhcmVudFwiOiBbMCwwLDAsMF0sIFwiYWxpY2VibHVlXCI6IFsyNDAsMjQ4LDI1NSwxXSxcbiAgXCJhbnRpcXVld2hpdGVcIjogWzI1MCwyMzUsMjE1LDFdLCBcImFxdWFcIjogWzAsMjU1LDI1NSwxXSxcbiAgXCJhcXVhbWFyaW5lXCI6IFsxMjcsMjU1LDIxMiwxXSwgXCJhenVyZVwiOiBbMjQwLDI1NSwyNTUsMV0sXG4gIFwiYmVpZ2VcIjogWzI0NSwyNDUsMjIwLDFdLCBcImJpc3F1ZVwiOiBbMjU1LDIyOCwxOTYsMV0sXG4gIFwiYmxhY2tcIjogWzAsMCwwLDFdLCBcImJsYW5jaGVkYWxtb25kXCI6IFsyNTUsMjM1LDIwNSwxXSxcbiAgXCJibHVlXCI6IFswLDAsMjU1LDFdLCBcImJsdWV2aW9sZXRcIjogWzEzOCw0MywyMjYsMV0sXG4gIFwiYnJvd25cIjogWzE2NSw0Miw0MiwxXSwgXCJidXJseXdvb2RcIjogWzIyMiwxODQsMTM1LDFdLFxuICBcImNhZGV0Ymx1ZVwiOiBbOTUsMTU4LDE2MCwxXSwgXCJjaGFydHJldXNlXCI6IFsxMjcsMjU1LDAsMV0sXG4gIFwiY2hvY29sYXRlXCI6IFsyMTAsMTA1LDMwLDFdLCBcImNvcmFsXCI6IFsyNTUsMTI3LDgwLDFdLFxuICBcImNvcm5mbG93ZXJibHVlXCI6IFsxMDAsMTQ5LDIzNywxXSwgXCJjb3Juc2lsa1wiOiBbMjU1LDI0OCwyMjAsMV0sXG4gIFwiY3JpbXNvblwiOiBbMjIwLDIwLDYwLDFdLCBcImN5YW5cIjogWzAsMjU1LDI1NSwxXSxcbiAgXCJkYXJrYmx1ZVwiOiBbMCwwLDEzOSwxXSwgXCJkYXJrY3lhblwiOiBbMCwxMzksMTM5LDFdLFxuICBcImRhcmtnb2xkZW5yb2RcIjogWzE4NCwxMzQsMTEsMV0sIFwiZGFya2dyYXlcIjogWzE2OSwxNjksMTY5LDFdLFxuICBcImRhcmtncmVlblwiOiBbMCwxMDAsMCwxXSwgXCJkYXJrZ3JleVwiOiBbMTY5LDE2OSwxNjksMV0sXG4gIFwiZGFya2toYWtpXCI6IFsxODksMTgzLDEwNywxXSwgXCJkYXJrbWFnZW50YVwiOiBbMTM5LDAsMTM5LDFdLFxuICBcImRhcmtvbGl2ZWdyZWVuXCI6IFs4NSwxMDcsNDcsMV0sIFwiZGFya29yYW5nZVwiOiBbMjU1LDE0MCwwLDFdLFxuICBcImRhcmtvcmNoaWRcIjogWzE1Myw1MCwyMDQsMV0sIFwiZGFya3JlZFwiOiBbMTM5LDAsMCwxXSxcbiAgXCJkYXJrc2FsbW9uXCI6IFsyMzMsMTUwLDEyMiwxXSwgXCJkYXJrc2VhZ3JlZW5cIjogWzE0MywxODgsMTQzLDFdLFxuICBcImRhcmtzbGF0ZWJsdWVcIjogWzcyLDYxLDEzOSwxXSwgXCJkYXJrc2xhdGVncmF5XCI6IFs0Nyw3OSw3OSwxXSxcbiAgXCJkYXJrc2xhdGVncmV5XCI6IFs0Nyw3OSw3OSwxXSwgXCJkYXJrdHVycXVvaXNlXCI6IFswLDIwNiwyMDksMV0sXG4gIFwiZGFya3Zpb2xldFwiOiBbMTQ4LDAsMjExLDFdLCBcImRlZXBwaW5rXCI6IFsyNTUsMjAsMTQ3LDFdLFxuICBcImRlZXBza3libHVlXCI6IFswLDE5MSwyNTUsMV0sIFwiZGltZ3JheVwiOiBbMTA1LDEwNSwxMDUsMV0sXG4gIFwiZGltZ3JleVwiOiBbMTA1LDEwNSwxMDUsMV0sIFwiZG9kZ2VyYmx1ZVwiOiBbMzAsMTQ0LDI1NSwxXSxcbiAgXCJmaXJlYnJpY2tcIjogWzE3OCwzNCwzNCwxXSwgXCJmbG9yYWx3aGl0ZVwiOiBbMjU1LDI1MCwyNDAsMV0sXG4gIFwiZm9yZXN0Z3JlZW5cIjogWzM0LDEzOSwzNCwxXSwgXCJmdWNoc2lhXCI6IFsyNTUsMCwyNTUsMV0sXG4gIFwiZ2FpbnNib3JvXCI6IFsyMjAsMjIwLDIyMCwxXSwgXCJnaG9zdHdoaXRlXCI6IFsyNDgsMjQ4LDI1NSwxXSxcbiAgXCJnb2xkXCI6IFsyNTUsMjE1LDAsMV0sIFwiZ29sZGVucm9kXCI6IFsyMTgsMTY1LDMyLDFdLFxuICBcImdyYXlcIjogWzEyOCwxMjgsMTI4LDFdLCBcImdyZWVuXCI6IFswLDEyOCwwLDFdLFxuICBcImdyZWVueWVsbG93XCI6IFsxNzMsMjU1LDQ3LDFdLCBcImdyZXlcIjogWzEyOCwxMjgsMTI4LDFdLFxuICBcImhvbmV5ZGV3XCI6IFsyNDAsMjU1LDI0MCwxXSwgXCJob3RwaW5rXCI6IFsyNTUsMTA1LDE4MCwxXSxcbiAgXCJpbmRpYW5yZWRcIjogWzIwNSw5Miw5MiwxXSwgXCJpbmRpZ29cIjogWzc1LDAsMTMwLDFdLFxuICBcIml2b3J5XCI6IFsyNTUsMjU1LDI0MCwxXSwgXCJraGFraVwiOiBbMjQwLDIzMCwxNDAsMV0sXG4gIFwibGF2ZW5kZXJcIjogWzIzMCwyMzAsMjUwLDFdLCBcImxhdmVuZGVyYmx1c2hcIjogWzI1NSwyNDAsMjQ1LDFdLFxuICBcImxhd25ncmVlblwiOiBbMTI0LDI1MiwwLDFdLCBcImxlbW9uY2hpZmZvblwiOiBbMjU1LDI1MCwyMDUsMV0sXG4gIFwibGlnaHRibHVlXCI6IFsxNzMsMjE2LDIzMCwxXSwgXCJsaWdodGNvcmFsXCI6IFsyNDAsMTI4LDEyOCwxXSxcbiAgXCJsaWdodGN5YW5cIjogWzIyNCwyNTUsMjU1LDFdLCBcImxpZ2h0Z29sZGVucm9keWVsbG93XCI6IFsyNTAsMjUwLDIxMCwxXSxcbiAgXCJsaWdodGdyYXlcIjogWzIxMSwyMTEsMjExLDFdLCBcImxpZ2h0Z3JlZW5cIjogWzE0NCwyMzgsMTQ0LDFdLFxuICBcImxpZ2h0Z3JleVwiOiBbMjExLDIxMSwyMTEsMV0sIFwibGlnaHRwaW5rXCI6IFsyNTUsMTgyLDE5MywxXSxcbiAgXCJsaWdodHNhbG1vblwiOiBbMjU1LDE2MCwxMjIsMV0sIFwibGlnaHRzZWFncmVlblwiOiBbMzIsMTc4LDE3MCwxXSxcbiAgXCJsaWdodHNreWJsdWVcIjogWzEzNSwyMDYsMjUwLDFdLCBcImxpZ2h0c2xhdGVncmF5XCI6IFsxMTksMTM2LDE1MywxXSxcbiAgXCJsaWdodHNsYXRlZ3JleVwiOiBbMTE5LDEzNiwxNTMsMV0sIFwibGlnaHRzdGVlbGJsdWVcIjogWzE3NiwxOTYsMjIyLDFdLFxuICBcImxpZ2h0eWVsbG93XCI6IFsyNTUsMjU1LDIyNCwxXSwgXCJsaW1lXCI6IFswLDI1NSwwLDFdLFxuICBcImxpbWVncmVlblwiOiBbNTAsMjA1LDUwLDFdLCBcImxpbmVuXCI6IFsyNTAsMjQwLDIzMCwxXSxcbiAgXCJtYWdlbnRhXCI6IFsyNTUsMCwyNTUsMV0sIFwibWFyb29uXCI6IFsxMjgsMCwwLDFdLFxuICBcIm1lZGl1bWFxdWFtYXJpbmVcIjogWzEwMiwyMDUsMTcwLDFdLCBcIm1lZGl1bWJsdWVcIjogWzAsMCwyMDUsMV0sXG4gIFwibWVkaXVtb3JjaGlkXCI6IFsxODYsODUsMjExLDFdLCBcIm1lZGl1bXB1cnBsZVwiOiBbMTQ3LDExMiwyMTksMV0sXG4gIFwibWVkaXVtc2VhZ3JlZW5cIjogWzYwLDE3OSwxMTMsMV0sIFwibWVkaXVtc2xhdGVibHVlXCI6IFsxMjMsMTA0LDIzOCwxXSxcbiAgXCJtZWRpdW1zcHJpbmdncmVlblwiOiBbMCwyNTAsMTU0LDFdLCBcIm1lZGl1bXR1cnF1b2lzZVwiOiBbNzIsMjA5LDIwNCwxXSxcbiAgXCJtZWRpdW12aW9sZXRyZWRcIjogWzE5OSwyMSwxMzMsMV0sIFwibWlkbmlnaHRibHVlXCI6IFsyNSwyNSwxMTIsMV0sXG4gIFwibWludGNyZWFtXCI6IFsyNDUsMjU1LDI1MCwxXSwgXCJtaXN0eXJvc2VcIjogWzI1NSwyMjgsMjI1LDFdLFxuICBcIm1vY2Nhc2luXCI6IFsyNTUsMjI4LDE4MSwxXSwgXCJuYXZham93aGl0ZVwiOiBbMjU1LDIyMiwxNzMsMV0sXG4gIFwibmF2eVwiOiBbMCwwLDEyOCwxXSwgXCJvbGRsYWNlXCI6IFsyNTMsMjQ1LDIzMCwxXSxcbiAgXCJvbGl2ZVwiOiBbMTI4LDEyOCwwLDFdLCBcIm9saXZlZHJhYlwiOiBbMTA3LDE0MiwzNSwxXSxcbiAgXCJvcmFuZ2VcIjogWzI1NSwxNjUsMCwxXSwgXCJvcmFuZ2VyZWRcIjogWzI1NSw2OSwwLDFdLFxuICBcIm9yY2hpZFwiOiBbMjE4LDExMiwyMTQsMV0sIFwicGFsZWdvbGRlbnJvZFwiOiBbMjM4LDIzMiwxNzAsMV0sXG4gIFwicGFsZWdyZWVuXCI6IFsxNTIsMjUxLDE1MiwxXSwgXCJwYWxldHVycXVvaXNlXCI6IFsxNzUsMjM4LDIzOCwxXSxcbiAgXCJwYWxldmlvbGV0cmVkXCI6IFsyMTksMTEyLDE0NywxXSwgXCJwYXBheWF3aGlwXCI6IFsyNTUsMjM5LDIxMywxXSxcbiAgXCJwZWFjaHB1ZmZcIjogWzI1NSwyMTgsMTg1LDFdLCBcInBlcnVcIjogWzIwNSwxMzMsNjMsMV0sXG4gIFwicGlua1wiOiBbMjU1LDE5MiwyMDMsMV0sIFwicGx1bVwiOiBbMjIxLDE2MCwyMjEsMV0sXG4gIFwicG93ZGVyYmx1ZVwiOiBbMTc2LDIyNCwyMzAsMV0sIFwicHVycGxlXCI6IFsxMjgsMCwxMjgsMV0sXG4gIFwicmVkXCI6IFsyNTUsMCwwLDFdLCBcInJvc3licm93blwiOiBbMTg4LDE0MywxNDMsMV0sXG4gIFwicm95YWxibHVlXCI6IFs2NSwxMDUsMjI1LDFdLCBcInNhZGRsZWJyb3duXCI6IFsxMzksNjksMTksMV0sXG4gIFwic2FsbW9uXCI6IFsyNTAsMTI4LDExNCwxXSwgXCJzYW5keWJyb3duXCI6IFsyNDQsMTY0LDk2LDFdLFxuICBcInNlYWdyZWVuXCI6IFs0NiwxMzksODcsMV0sIFwic2Vhc2hlbGxcIjogWzI1NSwyNDUsMjM4LDFdLFxuICBcInNpZW5uYVwiOiBbMTYwLDgyLDQ1LDFdLCBcInNpbHZlclwiOiBbMTkyLDE5MiwxOTIsMV0sXG4gIFwic2t5Ymx1ZVwiOiBbMTM1LDIwNiwyMzUsMV0sIFwic2xhdGVibHVlXCI6IFsxMDYsOTAsMjA1LDFdLFxuICBcInNsYXRlZ3JheVwiOiBbMTEyLDEyOCwxNDQsMV0sIFwic2xhdGVncmV5XCI6IFsxMTIsMTI4LDE0NCwxXSxcbiAgXCJzbm93XCI6IFsyNTUsMjUwLDI1MCwxXSwgXCJzcHJpbmdncmVlblwiOiBbMCwyNTUsMTI3LDFdLFxuICBcInN0ZWVsYmx1ZVwiOiBbNzAsMTMwLDE4MCwxXSwgXCJ0YW5cIjogWzIxMCwxODAsMTQwLDFdLFxuICBcInRlYWxcIjogWzAsMTI4LDEyOCwxXSwgXCJ0aGlzdGxlXCI6IFsyMTYsMTkxLDIxNiwxXSxcbiAgXCJ0b21hdG9cIjogWzI1NSw5OSw3MSwxXSwgXCJ0dXJxdW9pc2VcIjogWzY0LDIyNCwyMDgsMV0sXG4gIFwidmlvbGV0XCI6IFsyMzgsMTMwLDIzOCwxXSwgXCJ3aGVhdFwiOiBbMjQ1LDIyMiwxNzksMV0sXG4gIFwid2hpdGVcIjogWzI1NSwyNTUsMjU1LDFdLCBcIndoaXRlc21va2VcIjogWzI0NSwyNDUsMjQ1LDFdLFxuICBcInllbGxvd1wiOiBbMjU1LDI1NSwwLDFdLCBcInllbGxvd2dyZWVuXCI6IFsxNTQsMjA1LDUwLDFdfVxuXG5mdW5jdGlvbiBjbGFtcF9jc3NfYnl0ZShpKSB7ICAvLyBDbGFtcCB0byBpbnRlZ2VyIDAgLi4gMjU1LlxuICBpID0gTWF0aC5yb3VuZChpKTsgIC8vIFNlZW1zIHRvIGJlIHdoYXQgQ2hyb21lIGRvZXMgKHZzIHRydW5jYXRpb24pLlxuICByZXR1cm4gaSA8IDAgPyAwIDogaSA+IDI1NSA/IDI1NSA6IGk7XG59XG5cbmZ1bmN0aW9uIGNsYW1wX2Nzc19mbG9hdChmKSB7ICAvLyBDbGFtcCB0byBmbG9hdCAwLjAgLi4gMS4wLlxuICByZXR1cm4gZiA8IDAgPyAwIDogZiA+IDEgPyAxIDogZjtcbn1cblxuZnVuY3Rpb24gcGFyc2VfY3NzX2ludChzdHIpIHsgIC8vIGludCBvciBwZXJjZW50YWdlLlxuICBpZiAoc3RyW3N0ci5sZW5ndGggLSAxXSA9PT0gJyUnKVxuICAgIHJldHVybiBjbGFtcF9jc3NfYnl0ZShwYXJzZUZsb2F0KHN0cikgLyAxMDAgKiAyNTUpO1xuICByZXR1cm4gY2xhbXBfY3NzX2J5dGUocGFyc2VJbnQoc3RyKSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlX2Nzc19mbG9hdChzdHIpIHsgIC8vIGZsb2F0IG9yIHBlcmNlbnRhZ2UuXG4gIGlmIChzdHJbc3RyLmxlbmd0aCAtIDFdID09PSAnJScpXG4gICAgcmV0dXJuIGNsYW1wX2Nzc19mbG9hdChwYXJzZUZsb2F0KHN0cikgLyAxMDApO1xuICByZXR1cm4gY2xhbXBfY3NzX2Zsb2F0KHBhcnNlRmxvYXQoc3RyKSk7XG59XG5cbmZ1bmN0aW9uIGNzc19odWVfdG9fcmdiKG0xLCBtMiwgaCkge1xuICBpZiAoaCA8IDApIGggKz0gMTtcbiAgZWxzZSBpZiAoaCA+IDEpIGggLT0gMTtcblxuICBpZiAoaCAqIDYgPCAxKSByZXR1cm4gbTEgKyAobTIgLSBtMSkgKiBoICogNjtcbiAgaWYgKGggKiAyIDwgMSkgcmV0dXJuIG0yO1xuICBpZiAoaCAqIDMgPCAyKSByZXR1cm4gbTEgKyAobTIgLSBtMSkgKiAoMi8zIC0gaCkgKiA2O1xuICByZXR1cm4gbTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlQ1NTQ29sb3IoY3NzX3N0cikge1xuICAvLyBSZW1vdmUgYWxsIHdoaXRlc3BhY2UsIG5vdCBjb21wbGlhbnQsIGJ1dCBzaG91bGQganVzdCBiZSBtb3JlIGFjY2VwdGluZy5cbiAgdmFyIHN0ciA9IGNzc19zdHIucmVwbGFjZSgvIC9nLCAnJykudG9Mb3dlckNhc2UoKTtcblxuICAvLyBDb2xvciBrZXl3b3JkcyAoYW5kIHRyYW5zcGFyZW50KSBsb29rdXAuXG4gIGlmIChzdHIgaW4ga0NTU0NvbG9yVGFibGUpIHJldHVybiBrQ1NTQ29sb3JUYWJsZVtzdHJdLnNsaWNlKCk7ICAvLyBkdXAuXG5cbiAgLy8gI2FiYyBhbmQgI2FiYzEyMyBzeW50YXguXG4gIGlmIChzdHJbMF0gPT09ICcjJykge1xuICAgIGlmIChzdHIubGVuZ3RoID09PSA0KSB7XG4gICAgICB2YXIgaXYgPSBwYXJzZUludChzdHIuc3Vic3RyKDEpLCAxNik7ICAvLyBUT0RPKGRlYW5tKTogU3RyaWN0ZXIgcGFyc2luZy5cbiAgICAgIGlmICghKGl2ID49IDAgJiYgaXYgPD0gMHhmZmYpKSByZXR1cm4gbnVsbDsgIC8vIENvdmVycyBOYU4uXG4gICAgICByZXR1cm4gWygoaXYgJiAweGYwMCkgPj4gNCkgfCAoKGl2ICYgMHhmMDApID4+IDgpLFxuICAgICAgICAgICAgICAoaXYgJiAweGYwKSB8ICgoaXYgJiAweGYwKSA+PiA0KSxcbiAgICAgICAgICAgICAgKGl2ICYgMHhmKSB8ICgoaXYgJiAweGYpIDw8IDQpLFxuICAgICAgICAgICAgICAxXTtcbiAgICB9IGVsc2UgaWYgKHN0ci5sZW5ndGggPT09IDcpIHtcbiAgICAgIHZhciBpdiA9IHBhcnNlSW50KHN0ci5zdWJzdHIoMSksIDE2KTsgIC8vIFRPRE8oZGVhbm0pOiBTdHJpY3RlciBwYXJzaW5nLlxuICAgICAgaWYgKCEoaXYgPj0gMCAmJiBpdiA8PSAweGZmZmZmZikpIHJldHVybiBudWxsOyAgLy8gQ292ZXJzIE5hTi5cbiAgICAgIHJldHVybiBbKGl2ICYgMHhmZjAwMDApID4+IDE2LFxuICAgICAgICAgICAgICAoaXYgJiAweGZmMDApID4+IDgsXG4gICAgICAgICAgICAgIGl2ICYgMHhmZixcbiAgICAgICAgICAgICAgMV07XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgb3AgPSBzdHIuaW5kZXhPZignKCcpLCBlcCA9IHN0ci5pbmRleE9mKCcpJyk7XG4gIGlmIChvcCAhPT0gLTEgJiYgZXAgKyAxID09PSBzdHIubGVuZ3RoKSB7XG4gICAgdmFyIGZuYW1lID0gc3RyLnN1YnN0cigwLCBvcCk7XG4gICAgdmFyIHBhcmFtcyA9IHN0ci5zdWJzdHIob3ArMSwgZXAtKG9wKzEpKS5zcGxpdCgnLCcpO1xuICAgIHZhciBhbHBoYSA9IDE7ICAvLyBUbyBhbGxvdyBjYXNlIGZhbGx0aHJvdWdoLlxuICAgIHN3aXRjaCAoZm5hbWUpIHtcbiAgICAgIGNhc2UgJ3JnYmEnOlxuICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gNCkgcmV0dXJuIG51bGw7XG4gICAgICAgIGFscGhhID0gcGFyc2VfY3NzX2Zsb2F0KHBhcmFtcy5wb3AoKSk7XG4gICAgICAgIC8vIEZhbGwgdGhyb3VnaC5cbiAgICAgIGNhc2UgJ3JnYic6XG4gICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSAzKSByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIFtwYXJzZV9jc3NfaW50KHBhcmFtc1swXSksXG4gICAgICAgICAgICAgICAgcGFyc2VfY3NzX2ludChwYXJhbXNbMV0pLFxuICAgICAgICAgICAgICAgIHBhcnNlX2Nzc19pbnQocGFyYW1zWzJdKSxcbiAgICAgICAgICAgICAgICBhbHBoYV07XG4gICAgICBjYXNlICdoc2xhJzpcbiAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IDQpIHJldHVybiBudWxsO1xuICAgICAgICBhbHBoYSA9IHBhcnNlX2Nzc19mbG9hdChwYXJhbXMucG9wKCkpO1xuICAgICAgICAvLyBGYWxsIHRocm91Z2guXG4gICAgICBjYXNlICdoc2wnOlxuICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gMykgcmV0dXJuIG51bGw7XG4gICAgICAgIHZhciBoID0gKCgocGFyc2VGbG9hdChwYXJhbXNbMF0pICUgMzYwKSArIDM2MCkgJSAzNjApIC8gMzYwOyAgLy8gMCAuLiAxXG4gICAgICAgIC8vIE5PVEUoZGVhbm0pOiBBY2NvcmRpbmcgdG8gdGhlIENTUyBzcGVjIHMvbCBzaG91bGQgb25seSBiZVxuICAgICAgICAvLyBwZXJjZW50YWdlcywgYnV0IHdlIGRvbid0IGJvdGhlciBhbmQgbGV0IGZsb2F0IG9yIHBlcmNlbnRhZ2UuXG4gICAgICAgIHZhciBzID0gcGFyc2VfY3NzX2Zsb2F0KHBhcmFtc1sxXSk7XG4gICAgICAgIHZhciBsID0gcGFyc2VfY3NzX2Zsb2F0KHBhcmFtc1syXSk7XG4gICAgICAgIHZhciBtMiA9IGwgPD0gMC41ID8gbCAqIChzICsgMSkgOiBsICsgcyAtIGwgKiBzO1xuICAgICAgICB2YXIgbTEgPSBsICogMiAtIG0yO1xuICAgICAgICByZXR1cm4gW2NsYW1wX2Nzc19ieXRlKGNzc19odWVfdG9fcmdiKG0xLCBtMiwgaCsxLzMpICogMjU1KSxcbiAgICAgICAgICAgICAgICBjbGFtcF9jc3NfYnl0ZShjc3NfaHVlX3RvX3JnYihtMSwgbTIsIGgpICogMjU1KSxcbiAgICAgICAgICAgICAgICBjbGFtcF9jc3NfYnl0ZShjc3NfaHVlX3RvX3JnYihtMSwgbTIsIGgtMS8zKSAqIDI1NSksXG4gICAgICAgICAgICAgICAgYWxwaGFdO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnRyeSB7IGV4cG9ydHMucGFyc2VDU1NDb2xvciA9IHBhcnNlQ1NTQ29sb3IgfSBjYXRjaChlKSB7IH1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFZlY3RvclRpbGVGZWF0dXJlVHlwZXMgPSBbJ1Vua25vd24nLCAnUG9pbnQnLCAnTGluZVN0cmluZycsICdQb2x5Z29uJ107XG5cbmZ1bmN0aW9uIGluZml4KG9wZXJhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKF8sIGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gJyR0eXBlJykge1xuICAgICAgICAgICAgcmV0dXJuICd0JyArIG9wZXJhdG9yICsgVmVjdG9yVGlsZUZlYXR1cmVUeXBlcy5pbmRleE9mKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAncFsnICsgSlNPTi5zdHJpbmdpZnkoa2V5KSArICddJyArIG9wZXJhdG9yICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gc3RyaWN0SW5maXgob3BlcmF0b3IpIHtcbiAgICB2YXIgbm9uc3RyaWN0SW5maXggPSBpbmZpeChvcGVyYXRvcik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKF8sIGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gJyR0eXBlJykge1xuICAgICAgICAgICAgcmV0dXJuIG5vbnN0cmljdEluZml4KF8sIGtleSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICd0eXBlb2YocFsnICsgSlNPTi5zdHJpbmdpZnkoa2V5KSArICddKSA9PT0gdHlwZW9mKCcgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkgKyAnKSAmJiAnICtcbiAgICAgICAgICAgICAgICBub25zdHJpY3RJbmZpeChfLCBrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbnZhciBvcGVyYXRvcnMgPSB7XG4gICAgJz09JzogaW5maXgoJz09PScpLFxuICAgICchPSc6IGluZml4KCchPT0nKSxcbiAgICAnPic6IHN0cmljdEluZml4KCc+JyksXG4gICAgJzwnOiBzdHJpY3RJbmZpeCgnPCcpLFxuICAgICc8PSc6IHN0cmljdEluZml4KCc8PScpLFxuICAgICc+PSc6IHN0cmljdEluZml4KCc+PScpLFxuICAgICdpbic6IGZ1bmN0aW9uKF8sIGtleSkge1xuICAgICAgICByZXR1cm4gJyhmdW5jdGlvbigpeycgKyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpLm1hcChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuICdpZiAoJyArIG9wZXJhdG9yc1snPT0nXShfLCBrZXksIHZhbHVlKSArICcpIHJldHVybiB0cnVlOyc7XG4gICAgICAgIH0pLmpvaW4oJycpICsgJ3JldHVybiBmYWxzZTt9KSgpJztcbiAgICB9LFxuICAgICchaW4nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICchKCcgKyBvcGVyYXRvcnMuaW4uYXBwbHkodGhpcywgYXJndW1lbnRzKSArICcpJztcbiAgICB9LFxuICAgICdhbnknOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkubWFwKGZ1bmN0aW9uKGZpbHRlcikge1xuICAgICAgICAgICAgcmV0dXJuICcoJyArIGNvbXBpbGUoZmlsdGVyKSArICcpJztcbiAgICAgICAgfSkuam9pbignfHwnKSB8fCAnZmFsc2UnO1xuICAgIH0sXG4gICAgJ2FsbCc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKS5tYXAoZnVuY3Rpb24oZmlsdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gJygnICsgY29tcGlsZShmaWx0ZXIpICsgJyknO1xuICAgICAgICB9KS5qb2luKCcmJicpIHx8ICd0cnVlJztcbiAgICB9LFxuICAgICdub25lJzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAnISgnICsgb3BlcmF0b3JzLmFueS5hcHBseSh0aGlzLCBhcmd1bWVudHMpICsgJyknO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIGNvbXBpbGUoZmlsdGVyKSB7XG4gICAgcmV0dXJuIG9wZXJhdG9yc1tmaWx0ZXJbMF1dLmFwcGx5KGZpbHRlciwgZmlsdGVyKTtcbn1cblxuZnVuY3Rpb24gdHJ1dGgoKSB7XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogR2l2ZW4gYSBmaWx0ZXIgZXhwcmVzc2VkIGFzIG5lc3RlZCBhcnJheXMsIHJldHVybiBhIG5ldyBmdW5jdGlvblxuICogdGhhdCBldmFsdWF0ZXMgd2hldGhlciBhIGdpdmVuIGZlYXR1cmUgKHdpdGggYSAucHJvcGVydGllcyBvciAudGFncyBwcm9wZXJ0eSlcbiAqIHBhc3NlcyBpdHMgdGVzdC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBmaWx0ZXIgbWFwYm94IGdsIGZpbHRlclxuICogQHJldHVybnMge0Z1bmN0aW9ufSBmaWx0ZXItZXZhbHVhdGluZyBmdW5jdGlvblxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmaWx0ZXIpIHtcbiAgICBpZiAoIWZpbHRlcikgcmV0dXJuIHRydXRoO1xuICAgIHZhciBmaWx0ZXJTdHIgPSAndmFyIHAgPSBmLnByb3BlcnRpZXMgfHwgZi50YWdzIHx8IHt9LCB0ID0gZi50eXBlOyByZXR1cm4gJyArIGNvbXBpbGUoZmlsdGVyKSArICc7JztcbiAgICAvLyBqc2hpbnQgZXZpbDogdHJ1ZVxuICAgIHJldHVybiBuZXcgRnVuY3Rpb24oJ2YnLCBmaWx0ZXJTdHIpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBjbGlwO1xuXG4vKiBjbGlwIGZlYXR1cmVzIGJldHdlZW4gdHdvIGF4aXMtcGFyYWxsZWwgbGluZXM6XG4gKiAgICAgfCAgICAgICAgfFxuICogIF9fX3xfX18gICAgIHwgICAgIC9cbiAqIC8gICB8ICAgXFxfX19ffF9fX18vXG4gKiAgICAgfCAgICAgICAgfFxuICovXG5cbmZ1bmN0aW9uIGNsaXAoZmVhdHVyZXMsIHNjYWxlLCBrMSwgazIsIGF4aXMsIGludGVyc2VjdCwgbWluQWxsLCBtYXhBbGwpIHtcblxuICAgIGsxIC89IHNjYWxlO1xuICAgIGsyIC89IHNjYWxlO1xuXG4gICAgaWYgKG1pbkFsbCA+PSBrMSAmJiBtYXhBbGwgPD0gazIpIHJldHVybiBmZWF0dXJlczsgLy8gdHJpdmlhbCBhY2NlcHRcbiAgICBlbHNlIGlmIChtaW5BbGwgPiBrMiB8fCBtYXhBbGwgPCBrMSkgcmV0dXJuIG51bGw7IC8vIHRyaXZpYWwgcmVqZWN0XG5cbiAgICB2YXIgY2xpcHBlZCA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuXG4gICAgICAgIHZhciBmZWF0dXJlID0gZmVhdHVyZXNbaV0sXG4gICAgICAgICAgICBnZW9tZXRyeSA9IGZlYXR1cmUuZ2VvbWV0cnksXG4gICAgICAgICAgICB0eXBlID0gZmVhdHVyZS50eXBlLFxuICAgICAgICAgICAgbWluLCBtYXg7XG5cbiAgICAgICAgbWluID0gZmVhdHVyZS5taW5bYXhpc107XG4gICAgICAgIG1heCA9IGZlYXR1cmUubWF4W2F4aXNdO1xuXG4gICAgICAgIGlmIChtaW4gPj0gazEgJiYgbWF4IDw9IGsyKSB7IC8vIHRyaXZpYWwgYWNjZXB0XG4gICAgICAgICAgICBjbGlwcGVkLnB1c2goZmVhdHVyZSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIGlmIChtaW4gPiBrMiB8fCBtYXggPCBrMSkgY29udGludWU7IC8vIHRyaXZpYWwgcmVqZWN0XG5cbiAgICAgICAgdmFyIHNsaWNlcyA9IHR5cGUgPT09IDEgP1xuICAgICAgICAgICAgICAgIGNsaXBQb2ludHMoZ2VvbWV0cnksIGsxLCBrMiwgYXhpcykgOlxuICAgICAgICAgICAgICAgIGNsaXBHZW9tZXRyeShnZW9tZXRyeSwgazEsIGsyLCBheGlzLCBpbnRlcnNlY3QsIHR5cGUgPT09IDMpO1xuXG4gICAgICAgIGlmIChzbGljZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBpZiBhIGZlYXR1cmUgZ290IGNsaXBwZWQsIGl0IHdpbGwgbGlrZWx5IGdldCBjbGlwcGVkIG9uIHRoZSBuZXh0IHpvb20gbGV2ZWwgYXMgd2VsbCxcbiAgICAgICAgICAgIC8vIHNvIHRoZXJlJ3Mgbm8gbmVlZCB0byByZWNhbGN1bGF0ZSBiYm94ZXNcbiAgICAgICAgICAgIGNsaXBwZWQucHVzaCh7XG4gICAgICAgICAgICAgICAgZ2VvbWV0cnk6IHNsaWNlcyxcbiAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICAgIHRhZ3M6IGZlYXR1cmVzW2ldLnRhZ3MgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICBtaW46IGZlYXR1cmUubWluLFxuICAgICAgICAgICAgICAgIG1heDogZmVhdHVyZS5tYXhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsaXBwZWQubGVuZ3RoID8gY2xpcHBlZCA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGNsaXBQb2ludHMoZ2VvbWV0cnksIGsxLCBrMiwgYXhpcykge1xuICAgIHZhciBzbGljZSA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnZW9tZXRyeS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYSA9IGdlb21ldHJ5W2ldLFxuICAgICAgICAgICAgYWsgPSBhW2F4aXNdO1xuXG4gICAgICAgIGlmIChhayA+PSBrMSAmJiBhayA8PSBrMikgc2xpY2UucHVzaChhKTtcbiAgICB9XG4gICAgcmV0dXJuIHNsaWNlO1xufVxuXG5mdW5jdGlvbiBjbGlwR2VvbWV0cnkoZ2VvbWV0cnksIGsxLCBrMiwgYXhpcywgaW50ZXJzZWN0LCBjbG9zZWQpIHtcblxuICAgIHZhciBzbGljZXMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2VvbWV0cnkubGVuZ3RoOyBpKyspIHtcblxuICAgICAgICB2YXIgYWsgPSAwLFxuICAgICAgICAgICAgYmsgPSAwLFxuICAgICAgICAgICAgYiA9IG51bGwsXG4gICAgICAgICAgICBwb2ludHMgPSBnZW9tZXRyeVtpXSxcbiAgICAgICAgICAgIGFyZWEgPSBwb2ludHMuYXJlYSxcbiAgICAgICAgICAgIGRpc3QgPSBwb2ludHMuZGlzdCxcbiAgICAgICAgICAgIGxlbiA9IHBvaW50cy5sZW5ndGgsXG4gICAgICAgICAgICBhLCBqLCBsYXN0O1xuXG4gICAgICAgIHZhciBzbGljZSA9IFtdO1xuXG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBsZW4gLSAxOyBqKyspIHtcbiAgICAgICAgICAgIGEgPSBiIHx8IHBvaW50c1tqXTtcbiAgICAgICAgICAgIGIgPSBwb2ludHNbaiArIDFdO1xuICAgICAgICAgICAgYWsgPSBiayB8fCBhW2F4aXNdO1xuICAgICAgICAgICAgYmsgPSBiW2F4aXNdO1xuXG4gICAgICAgICAgICBpZiAoYWsgPCBrMSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKChiayA+IGsyKSkgeyAvLyAtLS18LS0tLS18LS0+XG4gICAgICAgICAgICAgICAgICAgIHNsaWNlLnB1c2goaW50ZXJzZWN0KGEsIGIsIGsxKSwgaW50ZXJzZWN0KGEsIGIsIGsyKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2xvc2VkKSBzbGljZSA9IG5ld1NsaWNlKHNsaWNlcywgc2xpY2UsIGFyZWEsIGRpc3QpO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChiayA+PSBrMSkgc2xpY2UucHVzaChpbnRlcnNlY3QoYSwgYiwgazEpKTsgLy8gLS0tfC0tPiAgfFxuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFrID4gazIpIHtcblxuICAgICAgICAgICAgICAgIGlmICgoYmsgPCBrMSkpIHsgLy8gPC0tfC0tLS0tfC0tLVxuICAgICAgICAgICAgICAgICAgICBzbGljZS5wdXNoKGludGVyc2VjdChhLCBiLCBrMiksIGludGVyc2VjdChhLCBiLCBrMSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNsb3NlZCkgc2xpY2UgPSBuZXdTbGljZShzbGljZXMsIHNsaWNlLCBhcmVhLCBkaXN0KTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYmsgPD0gazIpIHNsaWNlLnB1c2goaW50ZXJzZWN0KGEsIGIsIGsyKSk7IC8vIHwgIDwtLXwtLS1cblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHNsaWNlLnB1c2goYSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoYmsgPCBrMSkgeyAvLyA8LS18LS0tICB8XG4gICAgICAgICAgICAgICAgICAgIHNsaWNlLnB1c2goaW50ZXJzZWN0KGEsIGIsIGsxKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2xvc2VkKSBzbGljZSA9IG5ld1NsaWNlKHNsaWNlcywgc2xpY2UsIGFyZWEsIGRpc3QpO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChiayA+IGsyKSB7IC8vIHwgIC0tLXwtLT5cbiAgICAgICAgICAgICAgICAgICAgc2xpY2UucHVzaChpbnRlcnNlY3QoYSwgYiwgazIpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjbG9zZWQpIHNsaWNlID0gbmV3U2xpY2Uoc2xpY2VzLCBzbGljZSwgYXJlYSwgZGlzdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHwgLS0+IHxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCB0aGUgbGFzdCBwb2ludFxuICAgICAgICBhID0gcG9pbnRzW2xlbiAtIDFdO1xuICAgICAgICBhayA9IGFbYXhpc107XG4gICAgICAgIGlmIChhayA+PSBrMSAmJiBhayA8PSBrMikgc2xpY2UucHVzaChhKTtcblxuICAgICAgICAvLyBjbG9zZSB0aGUgcG9seWdvbiBpZiBpdHMgZW5kcG9pbnRzIGFyZSBub3QgdGhlIHNhbWUgYWZ0ZXIgY2xpcHBpbmdcblxuICAgICAgICBsYXN0ID0gc2xpY2Vbc2xpY2UubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChjbG9zZWQgJiYgbGFzdCAmJiAoc2xpY2VbMF1bMF0gIT09IGxhc3RbMF0gfHwgc2xpY2VbMF1bMV0gIT09IGxhc3RbMV0pKSBzbGljZS5wdXNoKHNsaWNlWzBdKTtcblxuICAgICAgICAvLyBhZGQgdGhlIGZpbmFsIHNsaWNlXG4gICAgICAgIG5ld1NsaWNlKHNsaWNlcywgc2xpY2UsIGFyZWEsIGRpc3QpO1xuICAgIH1cblxuICAgIHJldHVybiBzbGljZXM7XG59XG5cbmZ1bmN0aW9uIG5ld1NsaWNlKHNsaWNlcywgc2xpY2UsIGFyZWEsIGRpc3QpIHtcbiAgICBpZiAoc2xpY2UubGVuZ3RoKSB7XG4gICAgICAgIC8vIHdlIGRvbid0IHJlY2FsY3VsYXRlIHRoZSBhcmVhL2xlbmd0aCBvZiB0aGUgdW5jbGlwcGVkIGdlb21ldHJ5IGJlY2F1c2UgdGhlIGNhc2Ugd2hlcmUgaXQgZ29lc1xuICAgICAgICAvLyBiZWxvdyB0aGUgdmlzaWJpbGl0eSB0aHJlc2hvbGQgYXMgYSByZXN1bHQgb2YgY2xpcHBpbmcgaXMgcmFyZSwgc28gd2UgYXZvaWQgZG9pbmcgdW5uZWNlc3Nhcnkgd29ya1xuICAgICAgICBzbGljZS5hcmVhID0gYXJlYTtcbiAgICAgICAgc2xpY2UuZGlzdCA9IGRpc3Q7XG5cbiAgICAgICAgc2xpY2VzLnB1c2goc2xpY2UpO1xuICAgIH1cbiAgICByZXR1cm4gW107XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gY29udmVydDtcblxudmFyIHNpbXBsaWZ5ID0gcmVxdWlyZSgnLi9zaW1wbGlmeScpO1xuXG4vLyBjb252ZXJ0cyBHZW9KU09OIGZlYXR1cmUgaW50byBhbiBpbnRlcm1lZGlhdGUgcHJvamVjdGVkIEpTT04gdmVjdG9yIGZvcm1hdCB3aXRoIHNpbXBsaWZpY2F0aW9uIGRhdGFcblxuZnVuY3Rpb24gY29udmVydChkYXRhLCB0b2xlcmFuY2UpIHtcbiAgICB2YXIgZmVhdHVyZXMgPSBbXTtcblxuICAgIGlmIChkYXRhLnR5cGUgPT09ICdGZWF0dXJlQ29sbGVjdGlvbicpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb252ZXJ0RmVhdHVyZShmZWF0dXJlcywgZGF0YS5mZWF0dXJlc1tpXSwgdG9sZXJhbmNlKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZGF0YS50eXBlID09PSAnRmVhdHVyZScpIHtcbiAgICAgICAgY29udmVydEZlYXR1cmUoZmVhdHVyZXMsIGRhdGEsIHRvbGVyYW5jZSk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBzaW5nbGUgZ2VvbWV0cnkgb3IgYSBnZW9tZXRyeSBjb2xsZWN0aW9uXG4gICAgICAgIGNvbnZlcnRGZWF0dXJlKGZlYXR1cmVzLCB7Z2VvbWV0cnk6IGRhdGF9LCB0b2xlcmFuY2UpO1xuICAgIH1cbiAgICByZXR1cm4gZmVhdHVyZXM7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRGZWF0dXJlKGZlYXR1cmVzLCBmZWF0dXJlLCB0b2xlcmFuY2UpIHtcbiAgICB2YXIgZ2VvbSA9IGZlYXR1cmUuZ2VvbWV0cnksXG4gICAgICAgIHR5cGUgPSBnZW9tLnR5cGUsXG4gICAgICAgIGNvb3JkcyA9IGdlb20uY29vcmRpbmF0ZXMsXG4gICAgICAgIHRhZ3MgPSBmZWF0dXJlLnByb3BlcnRpZXMsXG4gICAgICAgIGksIGosIHJpbmdzO1xuXG4gICAgaWYgKHR5cGUgPT09ICdQb2ludCcpIHtcbiAgICAgICAgZmVhdHVyZXMucHVzaChjcmVhdGUodGFncywgMSwgW3Byb2plY3RQb2ludChjb29yZHMpXSkpO1xuXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnTXVsdGlQb2ludCcpIHtcbiAgICAgICAgZmVhdHVyZXMucHVzaChjcmVhdGUodGFncywgMSwgcHJvamVjdChjb29yZHMpKSk7XG5cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdMaW5lU3RyaW5nJykge1xuICAgICAgICBmZWF0dXJlcy5wdXNoKGNyZWF0ZSh0YWdzLCAyLCBbcHJvamVjdChjb29yZHMsIHRvbGVyYW5jZSldKSk7XG5cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdNdWx0aUxpbmVTdHJpbmcnIHx8IHR5cGUgPT09ICdQb2x5Z29uJykge1xuICAgICAgICByaW5ncyA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29vcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByaW5ncy5wdXNoKHByb2plY3QoY29vcmRzW2ldLCB0b2xlcmFuY2UpKTtcbiAgICAgICAgfVxuICAgICAgICBmZWF0dXJlcy5wdXNoKGNyZWF0ZSh0YWdzLCB0eXBlID09PSAnUG9seWdvbicgPyAzIDogMiwgcmluZ3MpKTtcblxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ011bHRpUG9seWdvbicpIHtcbiAgICAgICAgcmluZ3MgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGNvb3Jkc1tpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHJpbmdzLnB1c2gocHJvamVjdChjb29yZHNbaV1bal0sIHRvbGVyYW5jZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZlYXR1cmVzLnB1c2goY3JlYXRlKHRhZ3MsIDMsIHJpbmdzKSk7XG5cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdHZW9tZXRyeUNvbGxlY3Rpb24nKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBnZW9tLmdlb21ldHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnZlcnRGZWF0dXJlKGZlYXR1cmVzLCB7XG4gICAgICAgICAgICAgICAgZ2VvbWV0cnk6IGdlb20uZ2VvbWV0cmllc1tpXSxcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiB0YWdzXG4gICAgICAgICAgICB9LCB0b2xlcmFuY2UpO1xuICAgICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IGRhdGEgaXMgbm90IGEgdmFsaWQgR2VvSlNPTiBvYmplY3QuJyk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGUodGFncywgdHlwZSwgZ2VvbWV0cnkpIHtcbiAgICB2YXIgZmVhdHVyZSA9IHtcbiAgICAgICAgZ2VvbWV0cnk6IGdlb21ldHJ5LFxuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICB0YWdzOiB0YWdzIHx8IG51bGwsXG4gICAgICAgIG1pbjogWzIsIDFdLCAvLyBpbml0aWFsIGJib3ggdmFsdWVzO1xuICAgICAgICBtYXg6IFstMSwgMF0gIC8vIG5vdGUgdGhhdCBjb29yZHMgYXJlIHVzdWFsbHkgaW4gWzAuLjFdIHJhbmdlXG4gICAgfTtcbiAgICBjYWxjQkJveChmZWF0dXJlKTtcbiAgICByZXR1cm4gZmVhdHVyZTtcbn1cblxuZnVuY3Rpb24gcHJvamVjdChsb25sYXRzLCB0b2xlcmFuY2UpIHtcbiAgICB2YXIgcHJvamVjdGVkID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb25sYXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHByb2plY3RlZC5wdXNoKHByb2plY3RQb2ludChsb25sYXRzW2ldKSk7XG4gICAgfVxuICAgIGlmICh0b2xlcmFuY2UpIHtcbiAgICAgICAgc2ltcGxpZnkocHJvamVjdGVkLCB0b2xlcmFuY2UpO1xuICAgICAgICBjYWxjU2l6ZShwcm9qZWN0ZWQpO1xuICAgIH1cbiAgICByZXR1cm4gcHJvamVjdGVkO1xufVxuXG5mdW5jdGlvbiBwcm9qZWN0UG9pbnQocCkge1xuICAgIHZhciBzaW4gPSBNYXRoLnNpbihwWzFdICogTWF0aC5QSSAvIDE4MCksXG4gICAgICAgIHggPSAocFswXSAvIDM2MCArIDAuNSksXG4gICAgICAgIHkgPSAoMC41IC0gMC4yNSAqIE1hdGgubG9nKCgxICsgc2luKSAvICgxIC0gc2luKSkgLyBNYXRoLlBJKTtcblxuICAgIHkgPSB5IDwgLTEgPyAtMSA6XG4gICAgICAgIHkgPiAxID8gMSA6IHk7XG5cbiAgICByZXR1cm4gW3gsIHksIDBdO1xufVxuXG4vLyBjYWxjdWxhdGUgYXJlYSBhbmQgbGVuZ3RoIG9mIHRoZSBwb2x5XG5mdW5jdGlvbiBjYWxjU2l6ZShwb2ludHMpIHtcbiAgICB2YXIgYXJlYSA9IDAsXG4gICAgICAgIGRpc3QgPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGEsIGI7IGkgPCBwb2ludHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIGEgPSBiIHx8IHBvaW50c1tpXTtcbiAgICAgICAgYiA9IHBvaW50c1tpICsgMV07XG5cbiAgICAgICAgYXJlYSArPSBhWzBdICogYlsxXSAtIGJbMF0gKiBhWzFdO1xuXG4gICAgICAgIC8vIHVzZSBNYW5oYXR0YW4gZGlzdGFuY2UgaW5zdGVhZCBvZiBFdWNsaWRpYW4gb25lIHRvIGF2b2lkIGV4cGVuc2l2ZSBzcXVhcmUgcm9vdCBjb21wdXRhdGlvblxuICAgICAgICBkaXN0ICs9IE1hdGguYWJzKGJbMF0gLSBhWzBdKSArIE1hdGguYWJzKGJbMV0gLSBhWzFdKTtcbiAgICB9XG4gICAgcG9pbnRzLmFyZWEgPSBNYXRoLmFicyhhcmVhIC8gMik7XG4gICAgcG9pbnRzLmRpc3QgPSBkaXN0O1xufVxuXG4vLyBjYWxjdWxhdGUgdGhlIGZlYXR1cmUgYm91bmRpbmcgYm94IGZvciBmYXN0ZXIgY2xpcHBpbmcgbGF0ZXJcbmZ1bmN0aW9uIGNhbGNCQm94KGZlYXR1cmUpIHtcbiAgICB2YXIgZ2VvbWV0cnkgPSBmZWF0dXJlLmdlb21ldHJ5LFxuICAgICAgICBtaW4gPSBmZWF0dXJlLm1pbixcbiAgICAgICAgbWF4ID0gZmVhdHVyZS5tYXg7XG5cbiAgICBpZiAoZmVhdHVyZS50eXBlID09PSAxKSBjYWxjUmluZ0JCb3gobWluLCBtYXgsIGdlb21ldHJ5KTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSAwOyBpIDwgZ2VvbWV0cnkubGVuZ3RoOyBpKyspIGNhbGNSaW5nQkJveChtaW4sIG1heCwgZ2VvbWV0cnlbaV0pO1xuXG4gICAgcmV0dXJuIGZlYXR1cmU7XG59XG5cbmZ1bmN0aW9uIGNhbGNSaW5nQkJveChtaW4sIG1heCwgcG9pbnRzKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIHA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcCA9IHBvaW50c1tpXTtcbiAgICAgICAgbWluWzBdID0gTWF0aC5taW4ocFswXSwgbWluWzBdKTtcbiAgICAgICAgbWF4WzBdID0gTWF0aC5tYXgocFswXSwgbWF4WzBdKTtcbiAgICAgICAgbWluWzFdID0gTWF0aC5taW4ocFsxXSwgbWluWzFdKTtcbiAgICAgICAgbWF4WzFdID0gTWF0aC5tYXgocFsxXSwgbWF4WzFdKTtcbiAgICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2VvanNvbnZ0O1xuXG52YXIgY29udmVydCA9IHJlcXVpcmUoJy4vY29udmVydCcpLCAgICAgLy8gR2VvSlNPTiBjb252ZXJzaW9uIGFuZCBwcmVwcm9jZXNzaW5nXG4gICAgdHJhbnNmb3JtID0gcmVxdWlyZSgnLi90cmFuc2Zvcm0nKSwgLy8gY29vcmRpbmF0ZSB0cmFuc2Zvcm1hdGlvblxuICAgIGNsaXAgPSByZXF1aXJlKCcuL2NsaXAnKSwgICAgICAgICAgIC8vIHN0cmlwZSBjbGlwcGluZyBhbGdvcml0aG1cbiAgICB3cmFwID0gcmVxdWlyZSgnLi93cmFwJyksICAgICAgICAgICAvLyBkYXRlIGxpbmUgcHJvY2Vzc2luZ1xuICAgIGNyZWF0ZVRpbGUgPSByZXF1aXJlKCcuL3RpbGUnKTsgICAgIC8vIGZpbmFsIHNpbXBsaWZpZWQgdGlsZSBnZW5lcmF0aW9uXG5cblxuZnVuY3Rpb24gZ2VvanNvbnZ0KGRhdGEsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IEdlb0pTT05WVChkYXRhLCBvcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gR2VvSlNPTlZUKGRhdGEsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zID0gZXh0ZW5kKE9iamVjdC5jcmVhdGUodGhpcy5vcHRpb25zKSwgb3B0aW9ucyk7XG5cbiAgICB2YXIgZGVidWcgPSBvcHRpb25zLmRlYnVnO1xuXG4gICAgaWYgKGRlYnVnKSBjb25zb2xlLnRpbWUoJ3ByZXByb2Nlc3MgZGF0YScpO1xuXG4gICAgdmFyIHoyID0gMSA8PCBvcHRpb25zLm1heFpvb20sIC8vIDJeelxuICAgICAgICBmZWF0dXJlcyA9IGNvbnZlcnQoZGF0YSwgb3B0aW9ucy50b2xlcmFuY2UgLyAoejIgKiBvcHRpb25zLmV4dGVudCkpO1xuXG4gICAgdGhpcy50aWxlcyA9IHt9O1xuICAgIHRoaXMudGlsZUNvb3JkcyA9IFtdO1xuXG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICAgIGNvbnNvbGUudGltZUVuZCgncHJlcHJvY2VzcyBkYXRhJyk7XG4gICAgICAgIGNvbnNvbGUubG9nKCdpbmRleDogbWF4Wm9vbTogJWQsIG1heFBvaW50czogJWQnLCBvcHRpb25zLmluZGV4TWF4Wm9vbSwgb3B0aW9ucy5pbmRleE1heFBvaW50cyk7XG4gICAgICAgIGNvbnNvbGUudGltZSgnZ2VuZXJhdGUgdGlsZXMnKTtcbiAgICAgICAgdGhpcy5zdGF0cyA9IHt9O1xuICAgICAgICB0aGlzLnRvdGFsID0gMDtcbiAgICB9XG5cbiAgICBmZWF0dXJlcyA9IHdyYXAoZmVhdHVyZXMsIG9wdGlvbnMuYnVmZmVyIC8gb3B0aW9ucy5leHRlbnQsIGludGVyc2VjdFgpO1xuXG4gICAgLy8gc3RhcnQgc2xpY2luZyBmcm9tIHRoZSB0b3AgdGlsZSBkb3duXG4gICAgaWYgKGZlYXR1cmVzLmxlbmd0aCkgdGhpcy5zcGxpdFRpbGUoZmVhdHVyZXMsIDAsIDAsIDApO1xuXG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICAgIGlmIChmZWF0dXJlcy5sZW5ndGgpIGNvbnNvbGUubG9nKCdmZWF0dXJlczogJWQsIHBvaW50czogJWQnLCB0aGlzLnRpbGVzWzBdLm51bUZlYXR1cmVzLCB0aGlzLnRpbGVzWzBdLm51bVBvaW50cyk7XG4gICAgICAgIGNvbnNvbGUudGltZUVuZCgnZ2VuZXJhdGUgdGlsZXMnKTtcbiAgICAgICAgY29uc29sZS5sb2coJ3RpbGVzIGdlbmVyYXRlZDonLCB0aGlzLnRvdGFsLCBKU09OLnN0cmluZ2lmeSh0aGlzLnN0YXRzKSk7XG4gICAgfVxufVxuXG5HZW9KU09OVlQucHJvdG90eXBlLm9wdGlvbnMgPSB7XG4gICAgbWF4Wm9vbTogMTQsICAgICAgICAgICAgLy8gbWF4IHpvb20gdG8gcHJlc2VydmUgZGV0YWlsIG9uXG4gICAgaW5kZXhNYXhab29tOiA1LCAgICAgICAgLy8gbWF4IHpvb20gaW4gdGhlIHRpbGUgaW5kZXhcbiAgICBpbmRleE1heFBvaW50czogMTAwMDAwLCAvLyBtYXggbnVtYmVyIG9mIHBvaW50cyBwZXIgdGlsZSBpbiB0aGUgdGlsZSBpbmRleFxuICAgIHNvbGlkQ2hpbGRyZW46IGZhbHNlLCAgIC8vIHdoZXRoZXIgdG8gdGlsZSBzb2xpZCBzcXVhcmUgdGlsZXMgZnVydGhlclxuICAgIHRvbGVyYW5jZTogMywgICAgICAgICAgIC8vIHNpbXBsaWZpY2F0aW9uIHRvbGVyYW5jZSAoaGlnaGVyIG1lYW5zIHNpbXBsZXIpXG4gICAgZXh0ZW50OiA0MDk2LCAgICAgICAgICAgLy8gdGlsZSBleHRlbnRcbiAgICBidWZmZXI6IDY0LCAgICAgICAgICAgICAvLyB0aWxlIGJ1ZmZlciBvbiBlYWNoIHNpZGVcbiAgICBkZWJ1ZzogMCAgICAgICAgICAgICAgICAvLyBsb2dnaW5nIGxldmVsICgwLCAxIG9yIDIpXG59O1xuXG5HZW9KU09OVlQucHJvdG90eXBlLnNwbGl0VGlsZSA9IGZ1bmN0aW9uIChmZWF0dXJlcywgeiwgeCwgeSwgY3osIGN4LCBjeSkge1xuXG4gICAgdmFyIHN0YWNrID0gW2ZlYXR1cmVzLCB6LCB4LCB5XSxcbiAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgZGVidWcgPSBvcHRpb25zLmRlYnVnLFxuICAgICAgICBzb2xpZCA9IG51bGw7XG5cbiAgICAvLyBhdm9pZCByZWN1cnNpb24gYnkgdXNpbmcgYSBwcm9jZXNzaW5nIHF1ZXVlXG4gICAgd2hpbGUgKHN0YWNrLmxlbmd0aCkge1xuICAgICAgICB5ID0gc3RhY2sucG9wKCk7XG4gICAgICAgIHggPSBzdGFjay5wb3AoKTtcbiAgICAgICAgeiA9IHN0YWNrLnBvcCgpO1xuICAgICAgICBmZWF0dXJlcyA9IHN0YWNrLnBvcCgpO1xuXG4gICAgICAgIHZhciB6MiA9IDEgPDwgeixcbiAgICAgICAgICAgIGlkID0gdG9JRCh6LCB4LCB5KSxcbiAgICAgICAgICAgIHRpbGUgPSB0aGlzLnRpbGVzW2lkXSxcbiAgICAgICAgICAgIHRpbGVUb2xlcmFuY2UgPSB6ID09PSBvcHRpb25zLm1heFpvb20gPyAwIDogb3B0aW9ucy50b2xlcmFuY2UgLyAoejIgKiBvcHRpb25zLmV4dGVudCk7XG5cbiAgICAgICAgaWYgKCF0aWxlKSB7XG4gICAgICAgICAgICBpZiAoZGVidWcgPiAxKSBjb25zb2xlLnRpbWUoJ2NyZWF0aW9uJyk7XG5cbiAgICAgICAgICAgIHRpbGUgPSB0aGlzLnRpbGVzW2lkXSA9IGNyZWF0ZVRpbGUoZmVhdHVyZXMsIHoyLCB4LCB5LCB0aWxlVG9sZXJhbmNlLCB6ID09PSBvcHRpb25zLm1heFpvb20pO1xuICAgICAgICAgICAgdGhpcy50aWxlQ29vcmRzLnB1c2goe3o6IHosIHg6IHgsIHk6IHl9KTtcblxuICAgICAgICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlYnVnID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygndGlsZSB6JWQtJWQtJWQgKGZlYXR1cmVzOiAlZCwgcG9pbnRzOiAlZCwgc2ltcGxpZmllZDogJWQpJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHosIHgsIHksIHRpbGUubnVtRmVhdHVyZXMsIHRpbGUubnVtUG9pbnRzLCB0aWxlLm51bVNpbXBsaWZpZWQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLnRpbWVFbmQoJ2NyZWF0aW9uJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBrZXkgPSAneicgKyB6O1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdHNba2V5XSA9ICh0aGlzLnN0YXRzW2tleV0gfHwgMCkgKyAxO1xuICAgICAgICAgICAgICAgIHRoaXMudG90YWwrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNhdmUgcmVmZXJlbmNlIHRvIG9yaWdpbmFsIGdlb21ldHJ5IGluIHRpbGUgc28gdGhhdCB3ZSBjYW4gZHJpbGwgZG93biBsYXRlciBpZiB3ZSBzdG9wIG5vd1xuICAgICAgICB0aWxlLnNvdXJjZSA9IGZlYXR1cmVzO1xuXG4gICAgICAgIC8vIGlmIGl0J3MgdGhlIGZpcnN0LXBhc3MgdGlsaW5nXG4gICAgICAgIGlmICghY3opIHtcbiAgICAgICAgICAgIC8vIHN0b3AgdGlsaW5nIGlmIHdlIHJlYWNoZWQgbWF4IHpvb20sIG9yIGlmIHRoZSB0aWxlIGlzIHRvbyBzaW1wbGVcbiAgICAgICAgICAgIGlmICh6ID09PSBvcHRpb25zLmluZGV4TWF4Wm9vbSB8fCB0aWxlLm51bVBvaW50cyA8PSBvcHRpb25zLmluZGV4TWF4UG9pbnRzKSBjb250aW51ZTtcblxuICAgICAgICAvLyBpZiBhIGRyaWxsZG93biB0byBhIHNwZWNpZmljIHRpbGVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHN0b3AgdGlsaW5nIGlmIHdlIHJlYWNoZWQgYmFzZSB6b29tIG9yIG91ciB0YXJnZXQgdGlsZSB6b29tXG4gICAgICAgICAgICBpZiAoeiA9PT0gb3B0aW9ucy5tYXhab29tIHx8IHogPT09IGN6KSBjb250aW51ZTtcblxuICAgICAgICAgICAgLy8gc3RvcCB0aWxpbmcgaWYgaXQncyBub3QgYW4gYW5jZXN0b3Igb2YgdGhlIHRhcmdldCB0aWxlXG4gICAgICAgICAgICB2YXIgbSA9IDEgPDwgKGN6IC0geik7XG4gICAgICAgICAgICBpZiAoeCAhPT0gTWF0aC5mbG9vcihjeCAvIG0pIHx8IHkgIT09IE1hdGguZmxvb3IoY3kgLyBtKSkgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzdG9wIHRpbGluZyBpZiB0aGUgdGlsZSBpcyBzb2xpZCBjbGlwcGVkIHNxdWFyZVxuICAgICAgICBpZiAoIW9wdGlvbnMuc29saWRDaGlsZHJlbiAmJiBpc0NsaXBwZWRTcXVhcmUodGlsZSwgb3B0aW9ucy5leHRlbnQsIG9wdGlvbnMuYnVmZmVyKSkge1xuICAgICAgICAgICAgaWYgKGN6KSBzb2xpZCA9IHo7IC8vIGFuZCByZW1lbWJlciB0aGUgem9vbSBpZiB3ZSdyZSBkcmlsbGluZyBkb3duXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHdlIHNsaWNlIGZ1cnRoZXIgZG93biwgbm8gbmVlZCB0byBrZWVwIHNvdXJjZSBnZW9tZXRyeVxuICAgICAgICB0aWxlLnNvdXJjZSA9IG51bGw7XG5cbiAgICAgICAgaWYgKGRlYnVnID4gMSkgY29uc29sZS50aW1lKCdjbGlwcGluZycpO1xuXG4gICAgICAgIC8vIHZhbHVlcyB3ZSdsbCB1c2UgZm9yIGNsaXBwaW5nXG4gICAgICAgIHZhciBrMSA9IDAuNSAqIG9wdGlvbnMuYnVmZmVyIC8gb3B0aW9ucy5leHRlbnQsXG4gICAgICAgICAgICBrMiA9IDAuNSAtIGsxLFxuICAgICAgICAgICAgazMgPSAwLjUgKyBrMSxcbiAgICAgICAgICAgIGs0ID0gMSArIGsxLFxuICAgICAgICAgICAgdGwsIGJsLCB0ciwgYnIsIGxlZnQsIHJpZ2h0O1xuXG4gICAgICAgIHRsID0gYmwgPSB0ciA9IGJyID0gbnVsbDtcblxuICAgICAgICBsZWZ0ICA9IGNsaXAoZmVhdHVyZXMsIHoyLCB4IC0gazEsIHggKyBrMywgMCwgaW50ZXJzZWN0WCwgdGlsZS5taW5bMF0sIHRpbGUubWF4WzBdKTtcbiAgICAgICAgcmlnaHQgPSBjbGlwKGZlYXR1cmVzLCB6MiwgeCArIGsyLCB4ICsgazQsIDAsIGludGVyc2VjdFgsIHRpbGUubWluWzBdLCB0aWxlLm1heFswXSk7XG5cbiAgICAgICAgaWYgKGxlZnQpIHtcbiAgICAgICAgICAgIHRsID0gY2xpcChsZWZ0LCB6MiwgeSAtIGsxLCB5ICsgazMsIDEsIGludGVyc2VjdFksIHRpbGUubWluWzFdLCB0aWxlLm1heFsxXSk7XG4gICAgICAgICAgICBibCA9IGNsaXAobGVmdCwgejIsIHkgKyBrMiwgeSArIGs0LCAxLCBpbnRlcnNlY3RZLCB0aWxlLm1pblsxXSwgdGlsZS5tYXhbMV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJpZ2h0KSB7XG4gICAgICAgICAgICB0ciA9IGNsaXAocmlnaHQsIHoyLCB5IC0gazEsIHkgKyBrMywgMSwgaW50ZXJzZWN0WSwgdGlsZS5taW5bMV0sIHRpbGUubWF4WzFdKTtcbiAgICAgICAgICAgIGJyID0gY2xpcChyaWdodCwgejIsIHkgKyBrMiwgeSArIGs0LCAxLCBpbnRlcnNlY3RZLCB0aWxlLm1pblsxXSwgdGlsZS5tYXhbMV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlYnVnID4gMSkgY29uc29sZS50aW1lRW5kKCdjbGlwcGluZycpO1xuXG4gICAgICAgIGlmICh0bCkgc3RhY2sucHVzaCh0bCwgeiArIDEsIHggKiAyLCAgICAgeSAqIDIpO1xuICAgICAgICBpZiAoYmwpIHN0YWNrLnB1c2goYmwsIHogKyAxLCB4ICogMiwgICAgIHkgKiAyICsgMSk7XG4gICAgICAgIGlmICh0cikgc3RhY2sucHVzaCh0ciwgeiArIDEsIHggKiAyICsgMSwgeSAqIDIpO1xuICAgICAgICBpZiAoYnIpIHN0YWNrLnB1c2goYnIsIHogKyAxLCB4ICogMiArIDEsIHkgKiAyICsgMSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNvbGlkO1xufTtcblxuR2VvSlNPTlZULnByb3RvdHlwZS5nZXRUaWxlID0gZnVuY3Rpb24gKHosIHgsIHkpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgZXh0ZW50ID0gb3B0aW9ucy5leHRlbnQsXG4gICAgICAgIGRlYnVnID0gb3B0aW9ucy5kZWJ1ZztcblxuICAgIHZhciB6MiA9IDEgPDwgejtcbiAgICB4ID0gKCh4ICUgejIpICsgejIpICUgejI7IC8vIHdyYXAgdGlsZSB4IGNvb3JkaW5hdGVcblxuICAgIHZhciBpZCA9IHRvSUQoeiwgeCwgeSk7XG4gICAgaWYgKHRoaXMudGlsZXNbaWRdKSByZXR1cm4gdHJhbnNmb3JtLnRpbGUodGhpcy50aWxlc1tpZF0sIGV4dGVudCk7XG5cbiAgICBpZiAoZGVidWcgPiAxKSBjb25zb2xlLmxvZygnZHJpbGxpbmcgZG93biB0byB6JWQtJWQtJWQnLCB6LCB4LCB5KTtcblxuICAgIHZhciB6MCA9IHosXG4gICAgICAgIHgwID0geCxcbiAgICAgICAgeTAgPSB5LFxuICAgICAgICBwYXJlbnQ7XG5cbiAgICB3aGlsZSAoIXBhcmVudCAmJiB6MCA+IDApIHtcbiAgICAgICAgejAtLTtcbiAgICAgICAgeDAgPSBNYXRoLmZsb29yKHgwIC8gMik7XG4gICAgICAgIHkwID0gTWF0aC5mbG9vcih5MCAvIDIpO1xuICAgICAgICBwYXJlbnQgPSB0aGlzLnRpbGVzW3RvSUQoejAsIHgwLCB5MCldO1xuICAgIH1cblxuICAgIGlmICghcGFyZW50IHx8ICFwYXJlbnQuc291cmNlKSByZXR1cm4gbnVsbDtcblxuICAgIC8vIGlmIHdlIGZvdW5kIGEgcGFyZW50IHRpbGUgY29udGFpbmluZyB0aGUgb3JpZ2luYWwgZ2VvbWV0cnksIHdlIGNhbiBkcmlsbCBkb3duIGZyb20gaXRcbiAgICBpZiAoZGVidWcgPiAxKSBjb25zb2xlLmxvZygnZm91bmQgcGFyZW50IHRpbGUgeiVkLSVkLSVkJywgejAsIHgwLCB5MCk7XG5cbiAgICAvLyBpdCBwYXJlbnQgdGlsZSBpcyBhIHNvbGlkIGNsaXBwZWQgc3F1YXJlLCByZXR1cm4gaXQgaW5zdGVhZCBzaW5jZSBpdCdzIGlkZW50aWNhbFxuICAgIGlmIChpc0NsaXBwZWRTcXVhcmUocGFyZW50LCBleHRlbnQsIG9wdGlvbnMuYnVmZmVyKSkgcmV0dXJuIHRyYW5zZm9ybS50aWxlKHBhcmVudCwgZXh0ZW50KTtcblxuICAgIGlmIChkZWJ1ZyA+IDEpIGNvbnNvbGUudGltZSgnZHJpbGxpbmcgZG93bicpO1xuICAgIHZhciBzb2xpZCA9IHRoaXMuc3BsaXRUaWxlKHBhcmVudC5zb3VyY2UsIHowLCB4MCwgeTAsIHosIHgsIHkpO1xuICAgIGlmIChkZWJ1ZyA+IDEpIGNvbnNvbGUudGltZUVuZCgnZHJpbGxpbmcgZG93bicpO1xuXG4gICAgLy8gb25lIG9mIHRoZSBwYXJlbnQgdGlsZXMgd2FzIGEgc29saWQgY2xpcHBlZCBzcXVhcmVcbiAgICBpZiAoc29saWQgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIG0gPSAxIDw8ICh6IC0gc29saWQpO1xuICAgICAgICBpZCA9IHRvSUQoc29saWQsIE1hdGguZmxvb3IoeCAvIG0pLCBNYXRoLmZsb29yKHkgLyBtKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMudGlsZXNbaWRdID8gdHJhbnNmb3JtLnRpbGUodGhpcy50aWxlc1tpZF0sIGV4dGVudCkgOiBudWxsO1xufTtcblxuZnVuY3Rpb24gdG9JRCh6LCB4LCB5KSB7XG4gICAgcmV0dXJuICgoKDEgPDwgeikgKiB5ICsgeCkgKiAzMikgKyB6O1xufVxuXG5mdW5jdGlvbiBpbnRlcnNlY3RYKGEsIGIsIHgpIHtcbiAgICByZXR1cm4gW3gsICh4IC0gYVswXSkgKiAoYlsxXSAtIGFbMV0pIC8gKGJbMF0gLSBhWzBdKSArIGFbMV0sIDFdO1xufVxuZnVuY3Rpb24gaW50ZXJzZWN0WShhLCBiLCB5KSB7XG4gICAgcmV0dXJuIFsoeSAtIGFbMV0pICogKGJbMF0gLSBhWzBdKSAvIChiWzFdIC0gYVsxXSkgKyBhWzBdLCB5LCAxXTtcbn1cblxuZnVuY3Rpb24gZXh0ZW5kKGRlc3QsIHNyYykge1xuICAgIGZvciAodmFyIGkgaW4gc3JjKSBkZXN0W2ldID0gc3JjW2ldO1xuICAgIHJldHVybiBkZXN0O1xufVxuXG4vLyBjaGVja3Mgd2hldGhlciBhIHRpbGUgaXMgYSB3aG9sZS1hcmVhIGZpbGwgYWZ0ZXIgY2xpcHBpbmc7IGlmIGl0IGlzLCB0aGVyZSdzIG5vIHNlbnNlIHNsaWNpbmcgaXQgZnVydGhlclxuZnVuY3Rpb24gaXNDbGlwcGVkU3F1YXJlKHRpbGUsIGV4dGVudCwgYnVmZmVyKSB7XG5cbiAgICB2YXIgZmVhdHVyZXMgPSB0aWxlLnNvdXJjZTtcbiAgICBpZiAoZmVhdHVyZXMubGVuZ3RoICE9PSAxKSByZXR1cm4gZmFsc2U7XG5cbiAgICB2YXIgZmVhdHVyZSA9IGZlYXR1cmVzWzBdO1xuICAgIGlmIChmZWF0dXJlLnR5cGUgIT09IDMgfHwgZmVhdHVyZS5nZW9tZXRyeS5sZW5ndGggPiAxKSByZXR1cm4gZmFsc2U7XG5cbiAgICB2YXIgbGVuID0gZmVhdHVyZS5nZW9tZXRyeVswXS5sZW5ndGg7XG4gICAgaWYgKGxlbiAhPT0gNSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgcCA9IHRyYW5zZm9ybS5wb2ludChmZWF0dXJlLmdlb21ldHJ5WzBdW2ldLCBleHRlbnQsIHRpbGUuejIsIHRpbGUueCwgdGlsZS55KTtcbiAgICAgICAgaWYgKChwWzBdICE9PSAtYnVmZmVyICYmIHBbMF0gIT09IGV4dGVudCArIGJ1ZmZlcikgfHxcbiAgICAgICAgICAgIChwWzFdICE9PSAtYnVmZmVyICYmIHBbMV0gIT09IGV4dGVudCArIGJ1ZmZlcikpIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBzaW1wbGlmeTtcblxuLy8gY2FsY3VsYXRlIHNpbXBsaWZpY2F0aW9uIGRhdGEgdXNpbmcgb3B0aW1pemVkIERvdWdsYXMtUGV1Y2tlciBhbGdvcml0aG1cblxuZnVuY3Rpb24gc2ltcGxpZnkocG9pbnRzLCB0b2xlcmFuY2UpIHtcblxuICAgIHZhciBzcVRvbGVyYW5jZSA9IHRvbGVyYW5jZSAqIHRvbGVyYW5jZSxcbiAgICAgICAgbGVuID0gcG9pbnRzLmxlbmd0aCxcbiAgICAgICAgZmlyc3QgPSAwLFxuICAgICAgICBsYXN0ID0gbGVuIC0gMSxcbiAgICAgICAgc3RhY2sgPSBbXSxcbiAgICAgICAgaSwgbWF4U3FEaXN0LCBzcURpc3QsIGluZGV4O1xuXG4gICAgLy8gYWx3YXlzIHJldGFpbiB0aGUgZW5kcG9pbnRzICgxIGlzIHRoZSBtYXggdmFsdWUpXG4gICAgcG9pbnRzW2ZpcnN0XVsyXSA9IDE7XG4gICAgcG9pbnRzW2xhc3RdWzJdID0gMTtcblxuICAgIC8vIGF2b2lkIHJlY3Vyc2lvbiBieSB1c2luZyBhIHN0YWNrXG4gICAgd2hpbGUgKGxhc3QpIHtcblxuICAgICAgICBtYXhTcURpc3QgPSAwO1xuXG4gICAgICAgIGZvciAoaSA9IGZpcnN0ICsgMTsgaSA8IGxhc3Q7IGkrKykge1xuICAgICAgICAgICAgc3FEaXN0ID0gZ2V0U3FTZWdEaXN0KHBvaW50c1tpXSwgcG9pbnRzW2ZpcnN0XSwgcG9pbnRzW2xhc3RdKTtcblxuICAgICAgICAgICAgaWYgKHNxRGlzdCA+IG1heFNxRGlzdCkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICBtYXhTcURpc3QgPSBzcURpc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF4U3FEaXN0ID4gc3FUb2xlcmFuY2UpIHtcbiAgICAgICAgICAgIHBvaW50c1tpbmRleF1bMl0gPSBtYXhTcURpc3Q7IC8vIHNhdmUgdGhlIHBvaW50IGltcG9ydGFuY2UgaW4gc3F1YXJlZCBwaXhlbHMgYXMgYSB6IGNvb3JkaW5hdGVcbiAgICAgICAgICAgIHN0YWNrLnB1c2goZmlyc3QpO1xuICAgICAgICAgICAgc3RhY2sucHVzaChpbmRleCk7XG4gICAgICAgICAgICBmaXJzdCA9IGluZGV4O1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsYXN0ID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBmaXJzdCA9IHN0YWNrLnBvcCgpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBzcXVhcmUgZGlzdGFuY2UgZnJvbSBhIHBvaW50IHRvIGEgc2VnbWVudFxuZnVuY3Rpb24gZ2V0U3FTZWdEaXN0KHAsIGEsIGIpIHtcblxuICAgIHZhciB4ID0gYVswXSwgeSA9IGFbMV0sXG4gICAgICAgIGJ4ID0gYlswXSwgYnkgPSBiWzFdLFxuICAgICAgICBweCA9IHBbMF0sIHB5ID0gcFsxXSxcbiAgICAgICAgZHggPSBieCAtIHgsXG4gICAgICAgIGR5ID0gYnkgLSB5O1xuXG4gICAgaWYgKGR4ICE9PSAwIHx8IGR5ICE9PSAwKSB7XG5cbiAgICAgICAgdmFyIHQgPSAoKHB4IC0geCkgKiBkeCArIChweSAtIHkpICogZHkpIC8gKGR4ICogZHggKyBkeSAqIGR5KTtcblxuICAgICAgICBpZiAodCA+IDEpIHtcbiAgICAgICAgICAgIHggPSBieDtcbiAgICAgICAgICAgIHkgPSBieTtcblxuICAgICAgICB9IGVsc2UgaWYgKHQgPiAwKSB7XG4gICAgICAgICAgICB4ICs9IGR4ICogdDtcbiAgICAgICAgICAgIHkgKz0gZHkgKiB0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZHggPSBweCAtIHg7XG4gICAgZHkgPSBweSAtIHk7XG5cbiAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlVGlsZTtcblxuZnVuY3Rpb24gY3JlYXRlVGlsZShmZWF0dXJlcywgejIsIHR4LCB0eSwgdG9sZXJhbmNlLCBub1NpbXBsaWZ5KSB7XG4gICAgdmFyIHRpbGUgPSB7XG4gICAgICAgIGZlYXR1cmVzOiBbXSxcbiAgICAgICAgbnVtUG9pbnRzOiAwLFxuICAgICAgICBudW1TaW1wbGlmaWVkOiAwLFxuICAgICAgICBudW1GZWF0dXJlczogMCxcbiAgICAgICAgc291cmNlOiBudWxsLFxuICAgICAgICB4OiB0eCxcbiAgICAgICAgeTogdHksXG4gICAgICAgIHoyOiB6MixcbiAgICAgICAgdHJhbnNmb3JtZWQ6IGZhbHNlLFxuICAgICAgICBtaW46IFsyLCAxXSxcbiAgICAgICAgbWF4OiBbLTEsIDBdXG4gICAgfTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRpbGUubnVtRmVhdHVyZXMrKztcbiAgICAgICAgYWRkRmVhdHVyZSh0aWxlLCBmZWF0dXJlc1tpXSwgdG9sZXJhbmNlLCBub1NpbXBsaWZ5KTtcblxuICAgICAgICB2YXIgbWluID0gZmVhdHVyZXNbaV0ubWluLFxuICAgICAgICAgICAgbWF4ID0gZmVhdHVyZXNbaV0ubWF4O1xuXG4gICAgICAgIGlmIChtaW5bMF0gPCB0aWxlLm1pblswXSkgdGlsZS5taW5bMF0gPSBtaW5bMF07XG4gICAgICAgIGlmIChtaW5bMV0gPCB0aWxlLm1pblsxXSkgdGlsZS5taW5bMV0gPSBtaW5bMV07XG4gICAgICAgIGlmIChtYXhbMF0gPiB0aWxlLm1heFswXSkgdGlsZS5tYXhbMF0gPSBtYXhbMF07XG4gICAgICAgIGlmIChtYXhbMV0gPiB0aWxlLm1heFsxXSkgdGlsZS5tYXhbMV0gPSBtYXhbMV07XG4gICAgfVxuICAgIHJldHVybiB0aWxlO1xufVxuXG5mdW5jdGlvbiBhZGRGZWF0dXJlKHRpbGUsIGZlYXR1cmUsIHRvbGVyYW5jZSwgbm9TaW1wbGlmeSkge1xuXG4gICAgdmFyIGdlb20gPSBmZWF0dXJlLmdlb21ldHJ5LFxuICAgICAgICB0eXBlID0gZmVhdHVyZS50eXBlLFxuICAgICAgICBzaW1wbGlmaWVkID0gW10sXG4gICAgICAgIHNxVG9sZXJhbmNlID0gdG9sZXJhbmNlICogdG9sZXJhbmNlLFxuICAgICAgICBpLCBqLCByaW5nLCBwO1xuXG4gICAgaWYgKHR5cGUgPT09IDEpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGdlb20ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHNpbXBsaWZpZWQucHVzaChnZW9tW2ldKTtcbiAgICAgICAgICAgIHRpbGUubnVtUG9pbnRzKys7XG4gICAgICAgICAgICB0aWxlLm51bVNpbXBsaWZpZWQrKztcbiAgICAgICAgfVxuXG4gICAgfSBlbHNlIHtcblxuICAgICAgICAvLyBzaW1wbGlmeSBhbmQgdHJhbnNmb3JtIHByb2plY3RlZCBjb29yZGluYXRlcyBmb3IgdGlsZSBnZW9tZXRyeVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZ2VvbS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmluZyA9IGdlb21baV07XG5cbiAgICAgICAgICAgIC8vIGZpbHRlciBvdXQgdGlueSBwb2x5bGluZXMgJiBwb2x5Z29uc1xuICAgICAgICAgICAgaWYgKCFub1NpbXBsaWZ5ICYmICgodHlwZSA9PT0gMiAmJiByaW5nLmRpc3QgPCB0b2xlcmFuY2UpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0eXBlID09PSAzICYmIHJpbmcuYXJlYSA8IHNxVG9sZXJhbmNlKSkpIHtcbiAgICAgICAgICAgICAgICB0aWxlLm51bVBvaW50cyArPSByaW5nLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHNpbXBsaWZpZWRSaW5nID0gW107XG5cbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCByaW5nLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgcCA9IHJpbmdbal07XG4gICAgICAgICAgICAgICAgLy8ga2VlcCBwb2ludHMgd2l0aCBpbXBvcnRhbmNlID4gdG9sZXJhbmNlXG4gICAgICAgICAgICAgICAgaWYgKG5vU2ltcGxpZnkgfHwgcFsyXSA+IHNxVG9sZXJhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpbXBsaWZpZWRSaW5nLnB1c2gocCk7XG4gICAgICAgICAgICAgICAgICAgIHRpbGUubnVtU2ltcGxpZmllZCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aWxlLm51bVBvaW50cysrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzaW1wbGlmaWVkLnB1c2goc2ltcGxpZmllZFJpbmcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNpbXBsaWZpZWQubGVuZ3RoKSB7XG4gICAgICAgIHRpbGUuZmVhdHVyZXMucHVzaCh7XG4gICAgICAgICAgICBnZW9tZXRyeTogc2ltcGxpZmllZCxcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICB0YWdzOiBmZWF0dXJlLnRhZ3MgfHwgbnVsbFxuICAgICAgICB9KTtcbiAgICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMudGlsZSA9IHRyYW5zZm9ybVRpbGU7XG5leHBvcnRzLnBvaW50ID0gdHJhbnNmb3JtUG9pbnQ7XG5cbi8vIFRyYW5zZm9ybXMgdGhlIGNvb3JkaW5hdGVzIG9mIGVhY2ggZmVhdHVyZSBpbiB0aGUgZ2l2ZW4gdGlsZSBmcm9tXG4vLyBtZXJjYXRvci1wcm9qZWN0ZWQgc3BhY2UgaW50byAoZXh0ZW50IHggZXh0ZW50KSB0aWxlIHNwYWNlLlxuZnVuY3Rpb24gdHJhbnNmb3JtVGlsZSh0aWxlLCBleHRlbnQpIHtcbiAgICBpZiAodGlsZS50cmFuc2Zvcm1lZCkgcmV0dXJuIHRpbGU7XG5cbiAgICB2YXIgejIgPSB0aWxlLnoyLFxuICAgICAgICB0eCA9IHRpbGUueCxcbiAgICAgICAgdHkgPSB0aWxlLnksXG4gICAgICAgIGksIGosIGs7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdGlsZS5mZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZmVhdHVyZSA9IHRpbGUuZmVhdHVyZXNbaV0sXG4gICAgICAgICAgICBnZW9tID0gZmVhdHVyZS5nZW9tZXRyeSxcbiAgICAgICAgICAgIHR5cGUgPSBmZWF0dXJlLnR5cGU7XG5cbiAgICAgICAgaWYgKHR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBnZW9tLmxlbmd0aDsgaisrKSBnZW9tW2pdID0gdHJhbnNmb3JtUG9pbnQoZ2VvbVtqXSwgZXh0ZW50LCB6MiwgdHgsIHR5KTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGdlb20ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcmluZyA9IGdlb21bal07XG4gICAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IHJpbmcubGVuZ3RoOyBrKyspIHJpbmdba10gPSB0cmFuc2Zvcm1Qb2ludChyaW5nW2tdLCBleHRlbnQsIHoyLCB0eCwgdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGlsZS50cmFuc2Zvcm1lZCA9IHRydWU7XG5cbiAgICByZXR1cm4gdGlsZTtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtUG9pbnQocCwgZXh0ZW50LCB6MiwgdHgsIHR5KSB7XG4gICAgdmFyIHggPSBNYXRoLnJvdW5kKGV4dGVudCAqIChwWzBdICogejIgLSB0eCkpLFxuICAgICAgICB5ID0gTWF0aC5yb3VuZChleHRlbnQgKiAocFsxXSAqIHoyIC0gdHkpKTtcbiAgICByZXR1cm4gW3gsIHldO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2xpcCA9IHJlcXVpcmUoJy4vY2xpcCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHdyYXA7XG5cbmZ1bmN0aW9uIHdyYXAoZmVhdHVyZXMsIGJ1ZmZlciwgaW50ZXJzZWN0WCkge1xuICAgIHZhciBtZXJnZWQgPSBmZWF0dXJlcyxcbiAgICAgICAgbGVmdCAgPSBjbGlwKGZlYXR1cmVzLCAxLCAtMSAtIGJ1ZmZlciwgYnVmZmVyLCAgICAgMCwgaW50ZXJzZWN0WCwgLTEsIDIpLCAvLyBsZWZ0IHdvcmxkIGNvcHlcbiAgICAgICAgcmlnaHQgPSBjbGlwKGZlYXR1cmVzLCAxLCAgMSAtIGJ1ZmZlciwgMiArIGJ1ZmZlciwgMCwgaW50ZXJzZWN0WCwgLTEsIDIpOyAvLyByaWdodCB3b3JsZCBjb3B5XG5cbiAgICBpZiAobGVmdCB8fCByaWdodCkge1xuICAgICAgICBtZXJnZWQgPSBjbGlwKGZlYXR1cmVzLCAxLCAtYnVmZmVyLCAxICsgYnVmZmVyLCAwLCBpbnRlcnNlY3RYLCAtMSwgMik7IC8vIGNlbnRlciB3b3JsZCBjb3B5XG5cbiAgICAgICAgaWYgKGxlZnQpIG1lcmdlZCA9IHNoaWZ0RmVhdHVyZUNvb3JkcyhsZWZ0LCAxKS5jb25jYXQobWVyZ2VkKTsgLy8gbWVyZ2UgbGVmdCBpbnRvIGNlbnRlclxuICAgICAgICBpZiAocmlnaHQpIG1lcmdlZCA9IG1lcmdlZC5jb25jYXQoc2hpZnRGZWF0dXJlQ29vcmRzKHJpZ2h0LCAtMSkpOyAvLyBtZXJnZSByaWdodCBpbnRvIGNlbnRlclxuICAgIH1cblxuICAgIHJldHVybiBtZXJnZWQ7XG59XG5cbmZ1bmN0aW9uIHNoaWZ0RmVhdHVyZUNvb3JkcyhmZWF0dXJlcywgb2Zmc2V0KSB7XG4gICAgdmFyIG5ld0ZlYXR1cmVzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBmZWF0dXJlID0gZmVhdHVyZXNbaV0sXG4gICAgICAgICAgICB0eXBlID0gZmVhdHVyZS50eXBlO1xuXG4gICAgICAgIHZhciBuZXdHZW9tZXRyeTtcblxuICAgICAgICBpZiAodHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgbmV3R2VvbWV0cnkgPSBzaGlmdENvb3JkcyhmZWF0dXJlLmdlb21ldHJ5LCBvZmZzZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3R2VvbWV0cnkgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZmVhdHVyZS5nZW9tZXRyeS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIG5ld0dlb21ldHJ5LnB1c2goc2hpZnRDb29yZHMoZmVhdHVyZS5nZW9tZXRyeVtqXSwgb2Zmc2V0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBuZXdGZWF0dXJlcy5wdXNoKHtcbiAgICAgICAgICAgIGdlb21ldHJ5OiBuZXdHZW9tZXRyeSxcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICB0YWdzOiBmZWF0dXJlLnRhZ3MsXG4gICAgICAgICAgICBtaW46IFtmZWF0dXJlLm1pblswXSArIG9mZnNldCwgZmVhdHVyZS5taW5bMV1dLFxuICAgICAgICAgICAgbWF4OiBbZmVhdHVyZS5tYXhbMF0gKyBvZmZzZXQsIGZlYXR1cmUubWF4WzFdXVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3RmVhdHVyZXM7XG59XG5cbmZ1bmN0aW9uIHNoaWZ0Q29vcmRzKHBvaW50cywgb2Zmc2V0KSB7XG4gICAgdmFyIG5ld1BvaW50cyA9IFtdO1xuICAgIG5ld1BvaW50cy5hcmVhID0gcG9pbnRzLmFyZWE7XG4gICAgbmV3UG9pbnRzLmRpc3QgPSBwb2ludHMuZGlzdDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5ld1BvaW50cy5wdXNoKFtwb2ludHNbaV1bMF0gKyBvZmZzZXQsIHBvaW50c1tpXVsxXSwgcG9pbnRzW2ldWzJdXSk7XG4gICAgfVxuICAgIHJldHVybiBuZXdQb2ludHM7XG59XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgZ2wtbWF0cml4IC0gSGlnaCBwZXJmb3JtYW5jZSBtYXRyaXggYW5kIHZlY3RvciBvcGVyYXRpb25zXG4gKiBAYXV0aG9yIEJyYW5kb24gSm9uZXNcbiAqIEBhdXRob3IgQ29saW4gTWFjS2VuemllIElWXG4gKiBAdmVyc2lvbiAyLjMuMFxuICovXG5cbi8qIENvcHlyaWdodCAoYykgMjAxNSwgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuICovXG4vLyBFTkQgSEVBREVSXG5cbmV4cG9ydHMuZ2xNYXRyaXggPSByZXF1aXJlKFwiLi9nbC1tYXRyaXgvY29tbW9uLmpzXCIpO1xuZXhwb3J0cy5tYXQyID0gcmVxdWlyZShcIi4vZ2wtbWF0cml4L21hdDIuanNcIik7XG5leHBvcnRzLm1hdDJkID0gcmVxdWlyZShcIi4vZ2wtbWF0cml4L21hdDJkLmpzXCIpO1xuZXhwb3J0cy5tYXQzID0gcmVxdWlyZShcIi4vZ2wtbWF0cml4L21hdDMuanNcIik7XG5leHBvcnRzLm1hdDQgPSByZXF1aXJlKFwiLi9nbC1tYXRyaXgvbWF0NC5qc1wiKTtcbmV4cG9ydHMucXVhdCA9IHJlcXVpcmUoXCIuL2dsLW1hdHJpeC9xdWF0LmpzXCIpO1xuZXhwb3J0cy52ZWMyID0gcmVxdWlyZShcIi4vZ2wtbWF0cml4L3ZlYzIuanNcIik7XG5leHBvcnRzLnZlYzMgPSByZXF1aXJlKFwiLi9nbC1tYXRyaXgvdmVjMy5qc1wiKTtcbmV4cG9ydHMudmVjNCA9IHJlcXVpcmUoXCIuL2dsLW1hdHJpeC92ZWM0LmpzXCIpOyIsIi8qIENvcHlyaWdodCAoYykgMjAxNSwgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuICovXG5cbi8qKlxuICogQGNsYXNzIENvbW1vbiB1dGlsaXRpZXNcbiAqIEBuYW1lIGdsTWF0cml4XG4gKi9cbnZhciBnbE1hdHJpeCA9IHt9O1xuXG4vLyBDb25zdGFudHNcbmdsTWF0cml4LkVQU0lMT04gPSAwLjAwMDAwMTtcbmdsTWF0cml4LkFSUkFZX1RZUEUgPSAodHlwZW9mIEZsb2F0MzJBcnJheSAhPT0gJ3VuZGVmaW5lZCcpID8gRmxvYXQzMkFycmF5IDogQXJyYXk7XG5nbE1hdHJpeC5SQU5ET00gPSBNYXRoLnJhbmRvbTtcblxuLyoqXG4gKiBTZXRzIHRoZSB0eXBlIG9mIGFycmF5IHVzZWQgd2hlbiBjcmVhdGluZyBuZXcgdmVjdG9ycyBhbmQgbWF0cmljZXNcbiAqXG4gKiBAcGFyYW0ge1R5cGV9IHR5cGUgQXJyYXkgdHlwZSwgc3VjaCBhcyBGbG9hdDMyQXJyYXkgb3IgQXJyYXlcbiAqL1xuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlID0gZnVuY3Rpb24odHlwZSkge1xuICAgIEdMTUFUX0FSUkFZX1RZUEUgPSB0eXBlO1xufVxuXG52YXIgZGVncmVlID0gTWF0aC5QSSAvIDE4MDtcblxuLyoqXG4qIENvbnZlcnQgRGVncmVlIFRvIFJhZGlhblxuKlxuKiBAcGFyYW0ge051bWJlcn0gQW5nbGUgaW4gRGVncmVlc1xuKi9cbmdsTWF0cml4LnRvUmFkaWFuID0gZnVuY3Rpb24oYSl7XG4gICAgIHJldHVybiBhICogZGVncmVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdsTWF0cml4O1xuIiwiLyogQ29weXJpZ2h0IChjKSAyMDE1LCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblRIRSBTT0ZUV0FSRS4gKi9cblxudmFyIGdsTWF0cml4ID0gcmVxdWlyZShcIi4vY29tbW9uLmpzXCIpO1xuXG4vKipcbiAqIEBjbGFzcyAyeDIgTWF0cml4XG4gKiBAbmFtZSBtYXQyXG4gKi9cbnZhciBtYXQyID0ge307XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBtYXQyXG4gKlxuICogQHJldHVybnMge21hdDJ9IGEgbmV3IDJ4MiBtYXRyaXhcbiAqL1xubWF0Mi5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNCk7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG1hdDIgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IGEgbWF0cml4IHRvIGNsb25lXG4gKiBAcmV0dXJucyB7bWF0Mn0gYSBuZXcgMngyIG1hdHJpeFxuICovXG5tYXQyLmNsb25lID0gZnVuY3Rpb24oYSkge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSBtYXQyIHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbm1hdDIuY29weSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2V0IGEgbWF0MiB0byB0aGUgaWRlbnRpdHkgbWF0cml4XG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xubWF0Mi5pZGVudGl0eSA9IGZ1bmN0aW9uKG91dCkge1xuICAgIG91dFswXSA9IDE7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNwb3NlIHRoZSB2YWx1ZXMgb2YgYSBtYXQyXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5tYXQyLnRyYW5zcG9zZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIC8vIElmIHdlIGFyZSB0cmFuc3Bvc2luZyBvdXJzZWx2ZXMgd2UgY2FuIHNraXAgYSBmZXcgc3RlcHMgYnV0IGhhdmUgdG8gY2FjaGUgc29tZSB2YWx1ZXNcbiAgICBpZiAob3V0ID09PSBhKSB7XG4gICAgICAgIHZhciBhMSA9IGFbMV07XG4gICAgICAgIG91dFsxXSA9IGFbMl07XG4gICAgICAgIG91dFsyXSA9IGExO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG91dFswXSA9IGFbMF07XG4gICAgICAgIG91dFsxXSA9IGFbMl07XG4gICAgICAgIG91dFsyXSA9IGFbMV07XG4gICAgICAgIG91dFszXSA9IGFbM107XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEludmVydHMgYSBtYXQyXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5tYXQyLmludmVydCA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM10sXG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuICAgICAgICBkZXQgPSBhMCAqIGEzIC0gYTIgKiBhMTtcblxuICAgIGlmICghZGV0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBkZXQgPSAxLjAgLyBkZXQ7XG4gICAgXG4gICAgb3V0WzBdID0gIGEzICogZGV0O1xuICAgIG91dFsxXSA9IC1hMSAqIGRldDtcbiAgICBvdXRbMl0gPSAtYTIgKiBkZXQ7XG4gICAgb3V0WzNdID0gIGEwICogZGV0O1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgYWRqdWdhdGUgb2YgYSBtYXQyXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5tYXQyLmFkam9pbnQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICAvLyBDYWNoaW5nIHRoaXMgdmFsdWUgaXMgbmVzc2VjYXJ5IGlmIG91dCA9PSBhXG4gICAgdmFyIGEwID0gYVswXTtcbiAgICBvdXRbMF0gPSAgYVszXTtcbiAgICBvdXRbMV0gPSAtYVsxXTtcbiAgICBvdXRbMl0gPSAtYVsyXTtcbiAgICBvdXRbM10gPSAgYTA7XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkZXRlcm1pbmFudCBvZiBhIG1hdDJcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRldGVybWluYW50IG9mIGFcbiAqL1xubWF0Mi5kZXRlcm1pbmFudCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuIGFbMF0gKiBhWzNdIC0gYVsyXSAqIGFbMV07XG59O1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIG1hdDInc1xuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0Mn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xubWF0Mi5tdWx0aXBseSA9IGZ1bmN0aW9uIChvdXQsIGEsIGIpIHtcbiAgICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdO1xuICAgIHZhciBiMCA9IGJbMF0sIGIxID0gYlsxXSwgYjIgPSBiWzJdLCBiMyA9IGJbM107XG4gICAgb3V0WzBdID0gYTAgKiBiMCArIGEyICogYjE7XG4gICAgb3V0WzFdID0gYTEgKiBiMCArIGEzICogYjE7XG4gICAgb3V0WzJdID0gYTAgKiBiMiArIGEyICogYjM7XG4gICAgb3V0WzNdID0gYTEgKiBiMiArIGEzICogYjM7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBtYXQyLm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cbm1hdDIubXVsID0gbWF0Mi5tdWx0aXBseTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0MiBieSB0aGUgZ2l2ZW4gYW5nbGVcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5tYXQyLnJvdGF0ZSA9IGZ1bmN0aW9uIChvdXQsIGEsIHJhZCkge1xuICAgIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM10sXG4gICAgICAgIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgICBjID0gTWF0aC5jb3MocmFkKTtcbiAgICBvdXRbMF0gPSBhMCAqICBjICsgYTIgKiBzO1xuICAgIG91dFsxXSA9IGExICogIGMgKyBhMyAqIHM7XG4gICAgb3V0WzJdID0gYTAgKiAtcyArIGEyICogYztcbiAgICBvdXRbM10gPSBhMSAqIC1zICsgYTMgKiBjO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNjYWxlcyB0aGUgbWF0MiBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7dmVjMn0gdiB0aGUgdmVjMiB0byBzY2FsZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKiovXG5tYXQyLnNjYWxlID0gZnVuY3Rpb24ob3V0LCBhLCB2KSB7XG4gICAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXSxcbiAgICAgICAgdjAgPSB2WzBdLCB2MSA9IHZbMV07XG4gICAgb3V0WzBdID0gYTAgKiB2MDtcbiAgICBvdXRbMV0gPSBhMSAqIHYwO1xuICAgIG91dFsyXSA9IGEyICogdjE7XG4gICAgb3V0WzNdID0gYTMgKiB2MTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBnaXZlbiBhbmdsZVxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDIuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0Mi5yb3RhdGUoZGVzdCwgZGVzdCwgcmFkKTtcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCBtYXQyIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5tYXQyLmZyb21Sb3RhdGlvbiA9IGZ1bmN0aW9uKG91dCwgcmFkKSB7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgICBjID0gTWF0aC5jb3MocmFkKTtcbiAgICBvdXRbMF0gPSBjO1xuICAgIG91dFsxXSA9IHM7XG4gICAgb3V0WzJdID0gLXM7XG4gICAgb3V0WzNdID0gYztcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciBzY2FsaW5nXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0Mi5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQyLnNjYWxlKGRlc3QsIGRlc3QsIHZlYyk7XG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgbWF0MiByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHt2ZWMyfSB2IFNjYWxpbmcgdmVjdG9yXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbm1hdDIuZnJvbVNjYWxpbmcgPSBmdW5jdGlvbihvdXQsIHYpIHtcbiAgICBvdXRbMF0gPSB2WzBdO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSB2WzFdO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIG1hdDJcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG1hdCBtYXRyaXggdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hdHJpeFxuICovXG5tYXQyLnN0ciA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuICdtYXQyKCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnLCAnICsgYVsyXSArICcsICcgKyBhWzNdICsgJyknO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIEZyb2Jlbml1cyBub3JtIG9mIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgbWF0cml4IHRvIGNhbGN1bGF0ZSBGcm9iZW5pdXMgbm9ybSBvZlxuICogQHJldHVybnMge051bWJlcn0gRnJvYmVuaXVzIG5vcm1cbiAqL1xubWF0Mi5mcm9iID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4oTWF0aC5zcXJ0KE1hdGgucG93KGFbMF0sIDIpICsgTWF0aC5wb3coYVsxXSwgMikgKyBNYXRoLnBvdyhhWzJdLCAyKSArIE1hdGgucG93KGFbM10sIDIpKSlcbn07XG5cbi8qKlxuICogUmV0dXJucyBMLCBEIGFuZCBVIG1hdHJpY2VzIChMb3dlciB0cmlhbmd1bGFyLCBEaWFnb25hbCBhbmQgVXBwZXIgdHJpYW5ndWxhcikgYnkgZmFjdG9yaXppbmcgdGhlIGlucHV0IG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBMIHRoZSBsb3dlciB0cmlhbmd1bGFyIG1hdHJpeCBcbiAqIEBwYXJhbSB7bWF0Mn0gRCB0aGUgZGlhZ29uYWwgbWF0cml4IFxuICogQHBhcmFtIHttYXQyfSBVIHRoZSB1cHBlciB0cmlhbmd1bGFyIG1hdHJpeCBcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgaW5wdXQgbWF0cml4IHRvIGZhY3Rvcml6ZVxuICovXG5cbm1hdDIuTERVID0gZnVuY3Rpb24gKEwsIEQsIFUsIGEpIHsgXG4gICAgTFsyXSA9IGFbMl0vYVswXTsgXG4gICAgVVswXSA9IGFbMF07IFxuICAgIFVbMV0gPSBhWzFdOyBcbiAgICBVWzNdID0gYVszXSAtIExbMl0gKiBVWzFdOyBcbiAgICByZXR1cm4gW0wsIEQsIFVdOyAgICAgICBcbn07IFxuXG5cbm1vZHVsZS5leHBvcnRzID0gbWF0MjtcbiIsIi8qIENvcHlyaWdodCAoYykgMjAxNSwgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuICovXG5cbnZhciBnbE1hdHJpeCA9IHJlcXVpcmUoXCIuL2NvbW1vbi5qc1wiKTtcblxuLyoqXG4gKiBAY2xhc3MgMngzIE1hdHJpeFxuICogQG5hbWUgbWF0MmRcbiAqIFxuICogQGRlc2NyaXB0aW9uIFxuICogQSBtYXQyZCBjb250YWlucyBzaXggZWxlbWVudHMgZGVmaW5lZCBhczpcbiAqIDxwcmU+XG4gKiBbYSwgYywgdHgsXG4gKiAgYiwgZCwgdHldXG4gKiA8L3ByZT5cbiAqIFRoaXMgaXMgYSBzaG9ydCBmb3JtIGZvciB0aGUgM3gzIG1hdHJpeDpcbiAqIDxwcmU+XG4gKiBbYSwgYywgdHgsXG4gKiAgYiwgZCwgdHksXG4gKiAgMCwgMCwgMV1cbiAqIDwvcHJlPlxuICogVGhlIGxhc3Qgcm93IGlzIGlnbm9yZWQgc28gdGhlIGFycmF5IGlzIHNob3J0ZXIgYW5kIG9wZXJhdGlvbnMgYXJlIGZhc3Rlci5cbiAqL1xudmFyIG1hdDJkID0ge307XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBtYXQyZFxuICpcbiAqIEByZXR1cm5zIHttYXQyZH0gYSBuZXcgMngzIG1hdHJpeFxuICovXG5tYXQyZC5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNik7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMTtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IDA7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBtYXQyZCBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IGEgbWF0cml4IHRvIGNsb25lXG4gKiBAcmV0dXJucyB7bWF0MmR9IGEgbmV3IDJ4MyBtYXRyaXhcbiAqL1xubWF0MmQuY2xvbmUgPSBmdW5jdGlvbihhKSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDYpO1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgb3V0WzRdID0gYVs0XTtcbiAgICBvdXRbNV0gPSBhWzVdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSBtYXQyZCB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICovXG5tYXQyZC5jb3B5ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICBvdXRbNF0gPSBhWzRdO1xuICAgIG91dFs1XSA9IGFbNV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2V0IGEgbWF0MmQgdG8gdGhlIGlkZW50aXR5IG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xubWF0MmQuaWRlbnRpdHkgPSBmdW5jdGlvbihvdXQpIHtcbiAgICBvdXRbMF0gPSAxO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAxO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gMDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBJbnZlcnRzIGEgbWF0MmRcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKi9cbm1hdDJkLmludmVydCA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIHZhciBhYSA9IGFbMF0sIGFiID0gYVsxXSwgYWMgPSBhWzJdLCBhZCA9IGFbM10sXG4gICAgICAgIGF0eCA9IGFbNF0sIGF0eSA9IGFbNV07XG5cbiAgICB2YXIgZGV0ID0gYWEgKiBhZCAtIGFiICogYWM7XG4gICAgaWYoIWRldCl7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBkZXQgPSAxLjAgLyBkZXQ7XG5cbiAgICBvdXRbMF0gPSBhZCAqIGRldDtcbiAgICBvdXRbMV0gPSAtYWIgKiBkZXQ7XG4gICAgb3V0WzJdID0gLWFjICogZGV0O1xuICAgIG91dFszXSA9IGFhICogZGV0O1xuICAgIG91dFs0XSA9IChhYyAqIGF0eSAtIGFkICogYXR4KSAqIGRldDtcbiAgICBvdXRbNV0gPSAoYWIgKiBhdHggLSBhYSAqIGF0eSkgKiBkZXQ7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXQyZFxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRldGVybWluYW50IG9mIGFcbiAqL1xubWF0MmQuZGV0ZXJtaW5hbnQgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiBhWzBdICogYVszXSAtIGFbMV0gKiBhWzJdO1xufTtcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byBtYXQyZCdzXG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDJkfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xubWF0MmQubXVsdGlwbHkgPSBmdW5jdGlvbiAob3V0LCBhLCBiKSB7XG4gICAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXSwgYTQgPSBhWzRdLCBhNSA9IGFbNV0sXG4gICAgICAgIGIwID0gYlswXSwgYjEgPSBiWzFdLCBiMiA9IGJbMl0sIGIzID0gYlszXSwgYjQgPSBiWzRdLCBiNSA9IGJbNV07XG4gICAgb3V0WzBdID0gYTAgKiBiMCArIGEyICogYjE7XG4gICAgb3V0WzFdID0gYTEgKiBiMCArIGEzICogYjE7XG4gICAgb3V0WzJdID0gYTAgKiBiMiArIGEyICogYjM7XG4gICAgb3V0WzNdID0gYTEgKiBiMiArIGEzICogYjM7XG4gICAgb3V0WzRdID0gYTAgKiBiNCArIGEyICogYjUgKyBhNDtcbiAgICBvdXRbNV0gPSBhMSAqIGI0ICsgYTMgKiBiNSArIGE1O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0MmQubXVsdGlwbHl9XG4gKiBAZnVuY3Rpb25cbiAqL1xubWF0MmQubXVsID0gbWF0MmQubXVsdGlwbHk7XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdDJkIGJ5IHRoZSBnaXZlbiBhbmdsZVxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKi9cbm1hdDJkLnJvdGF0ZSA9IGZ1bmN0aW9uIChvdXQsIGEsIHJhZCkge1xuICAgIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM10sIGE0ID0gYVs0XSwgYTUgPSBhWzVdLFxuICAgICAgICBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgICAgYyA9IE1hdGguY29zKHJhZCk7XG4gICAgb3V0WzBdID0gYTAgKiAgYyArIGEyICogcztcbiAgICBvdXRbMV0gPSBhMSAqICBjICsgYTMgKiBzO1xuICAgIG91dFsyXSA9IGEwICogLXMgKyBhMiAqIGM7XG4gICAgb3V0WzNdID0gYTEgKiAtcyArIGEzICogYztcbiAgICBvdXRbNF0gPSBhNDtcbiAgICBvdXRbNV0gPSBhNTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTY2FsZXMgdGhlIG1hdDJkIGJ5IHRoZSBkaW1lbnNpb25zIGluIHRoZSBnaXZlbiB2ZWMyXG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBtYXRyaXggdG8gdHJhbnNsYXRlXG4gKiBAcGFyYW0ge3ZlYzJ9IHYgdGhlIHZlYzIgdG8gc2NhbGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqKi9cbm1hdDJkLnNjYWxlID0gZnVuY3Rpb24ob3V0LCBhLCB2KSB7XG4gICAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXSwgYTQgPSBhWzRdLCBhNSA9IGFbNV0sXG4gICAgICAgIHYwID0gdlswXSwgdjEgPSB2WzFdO1xuICAgIG91dFswXSA9IGEwICogdjA7XG4gICAgb3V0WzFdID0gYTEgKiB2MDtcbiAgICBvdXRbMl0gPSBhMiAqIHYxO1xuICAgIG91dFszXSA9IGEzICogdjE7XG4gICAgb3V0WzRdID0gYTQ7XG4gICAgb3V0WzVdID0gYTU7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNsYXRlcyB0aGUgbWF0MmQgYnkgdGhlIGRpbWVuc2lvbnMgaW4gdGhlIGdpdmVuIHZlYzJcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIG1hdHJpeCB0byB0cmFuc2xhdGVcbiAqIEBwYXJhbSB7dmVjMn0gdiB0aGUgdmVjMiB0byB0cmFuc2xhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqKi9cbm1hdDJkLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uKG91dCwgYSwgdikge1xuICAgIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM10sIGE0ID0gYVs0XSwgYTUgPSBhWzVdLFxuICAgICAgICB2MCA9IHZbMF0sIHYxID0gdlsxXTtcbiAgICBvdXRbMF0gPSBhMDtcbiAgICBvdXRbMV0gPSBhMTtcbiAgICBvdXRbMl0gPSBhMjtcbiAgICBvdXRbM10gPSBhMztcbiAgICBvdXRbNF0gPSBhMCAqIHYwICsgYTIgKiB2MSArIGE0O1xuICAgIG91dFs1XSA9IGExICogdjAgKyBhMyAqIHYxICsgYTU7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgZ2l2ZW4gYW5nbGVcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQyZC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQyZC5yb3RhdGUoZGVzdCwgZGVzdCwgcmFkKTtcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgbWF0MmQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICovXG5tYXQyZC5mcm9tUm90YXRpb24gPSBmdW5jdGlvbihvdXQsIHJhZCkge1xuICAgIHZhciBzID0gTWF0aC5zaW4ocmFkKSwgYyA9IE1hdGguY29zKHJhZCk7XG4gICAgb3V0WzBdID0gYztcbiAgICBvdXRbMV0gPSBzO1xuICAgIG91dFsyXSA9IC1zO1xuICAgIG91dFszXSA9IGM7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSAwO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgdmVjdG9yIHNjYWxpbmdcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQyZC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQyZC5zY2FsZShkZXN0LCBkZXN0LCB2ZWMpO1xuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCBtYXQyZCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHt2ZWMyfSB2IFNjYWxpbmcgdmVjdG9yXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICovXG5tYXQyZC5mcm9tU2NhbGluZyA9IGZ1bmN0aW9uKG91dCwgdikge1xuICAgIG91dFswXSA9IHZbMF07XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IHZbMV07XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSAwO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgdmVjdG9yIHRyYW5zbGF0aW9uXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0MmQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0MmQudHJhbnNsYXRlKGRlc3QsIGRlc3QsIHZlYyk7XG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IG1hdDJkIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3ZlYzJ9IHYgVHJhbnNsYXRpb24gdmVjdG9yXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICovXG5tYXQyZC5mcm9tVHJhbnNsYXRpb24gPSBmdW5jdGlvbihvdXQsIHYpIHtcbiAgICBvdXRbMF0gPSAxO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAxO1xuICAgIG91dFs0XSA9IHZbMF07XG4gICAgb3V0WzVdID0gdlsxXTtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBtYXQyZFxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IGEgbWF0cml4IHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcbiAqL1xubWF0MmQuc3RyID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gJ21hdDJkKCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnLCAnICsgYVsyXSArICcsICcgKyBcbiAgICAgICAgICAgICAgICAgICAgYVszXSArICcsICcgKyBhWzRdICsgJywgJyArIGFbNV0gKyAnKSc7XG59O1xuXG4vKipcbiAqIFJldHVybnMgRnJvYmVuaXVzIG5vcm0gb2YgYSBtYXQyZFxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIG1hdHJpeCB0byBjYWxjdWxhdGUgRnJvYmVuaXVzIG5vcm0gb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IEZyb2Jlbml1cyBub3JtXG4gKi9cbm1hdDJkLmZyb2IgPSBmdW5jdGlvbiAoYSkgeyBcbiAgICByZXR1cm4oTWF0aC5zcXJ0KE1hdGgucG93KGFbMF0sIDIpICsgTWF0aC5wb3coYVsxXSwgMikgKyBNYXRoLnBvdyhhWzJdLCAyKSArIE1hdGgucG93KGFbM10sIDIpICsgTWF0aC5wb3coYVs0XSwgMikgKyBNYXRoLnBvdyhhWzVdLCAyKSArIDEpKVxufTsgXG5cbm1vZHVsZS5leHBvcnRzID0gbWF0MmQ7XG4iLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTUsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLiAqL1xuXG52YXIgZ2xNYXRyaXggPSByZXF1aXJlKFwiLi9jb21tb24uanNcIik7XG5cbi8qKlxuICogQGNsYXNzIDN4MyBNYXRyaXhcbiAqIEBuYW1lIG1hdDNcbiAqL1xudmFyIG1hdDMgPSB7fTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IG1hdDNcbiAqXG4gKiBAcmV0dXJucyB7bWF0M30gYSBuZXcgM3gzIG1hdHJpeFxuICovXG5tYXQzLmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg5KTtcbiAgICBvdXRbMF0gPSAxO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDE7XG4gICAgb3V0WzVdID0gMDtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDb3BpZXMgdGhlIHVwcGVyLWxlZnQgM3gzIHZhbHVlcyBpbnRvIHRoZSBnaXZlbiBtYXQzLlxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgM3gzIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhICAgdGhlIHNvdXJjZSA0eDQgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMuZnJvbU1hdDQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzRdO1xuICAgIG91dFs0XSA9IGFbNV07XG4gICAgb3V0WzVdID0gYVs2XTtcbiAgICBvdXRbNl0gPSBhWzhdO1xuICAgIG91dFs3XSA9IGFbOV07XG4gICAgb3V0WzhdID0gYVsxMF07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBtYXQzIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgbWF0cml4XG4gKlxuICogQHBhcmFtIHttYXQzfSBhIG1hdHJpeCB0byBjbG9uZVxuICogQHJldHVybnMge21hdDN9IGEgbmV3IDN4MyBtYXRyaXhcbiAqL1xubWF0My5jbG9uZSA9IGZ1bmN0aW9uKGEpIHtcbiAgICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoOSk7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICBvdXRbNF0gPSBhWzRdO1xuICAgIG91dFs1XSA9IGFbNV07XG4gICAgb3V0WzZdID0gYVs2XTtcbiAgICBvdXRbN10gPSBhWzddO1xuICAgIG91dFs4XSA9IGFbOF07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIG1hdDMgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My5jb3B5ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICBvdXRbNF0gPSBhWzRdO1xuICAgIG91dFs1XSA9IGFbNV07XG4gICAgb3V0WzZdID0gYVs2XTtcbiAgICBvdXRbN10gPSBhWzddO1xuICAgIG91dFs4XSA9IGFbOF07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2V0IGEgbWF0MyB0byB0aGUgaWRlbnRpdHkgbWF0cml4XG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My5pZGVudGl0eSA9IGZ1bmN0aW9uKG91dCkge1xuICAgIG91dFswXSA9IDE7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMTtcbiAgICBvdXRbNV0gPSAwO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zcG9zZSB0aGUgdmFsdWVzIG9mIGEgbWF0M1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My50cmFuc3Bvc2UgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICAvLyBJZiB3ZSBhcmUgdHJhbnNwb3Npbmcgb3Vyc2VsdmVzIHdlIGNhbiBza2lwIGEgZmV3IHN0ZXBzIGJ1dCBoYXZlIHRvIGNhY2hlIHNvbWUgdmFsdWVzXG4gICAgaWYgKG91dCA9PT0gYSkge1xuICAgICAgICB2YXIgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTEyID0gYVs1XTtcbiAgICAgICAgb3V0WzFdID0gYVszXTtcbiAgICAgICAgb3V0WzJdID0gYVs2XTtcbiAgICAgICAgb3V0WzNdID0gYTAxO1xuICAgICAgICBvdXRbNV0gPSBhWzddO1xuICAgICAgICBvdXRbNl0gPSBhMDI7XG4gICAgICAgIG91dFs3XSA9IGExMjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvdXRbMF0gPSBhWzBdO1xuICAgICAgICBvdXRbMV0gPSBhWzNdO1xuICAgICAgICBvdXRbMl0gPSBhWzZdO1xuICAgICAgICBvdXRbM10gPSBhWzFdO1xuICAgICAgICBvdXRbNF0gPSBhWzRdO1xuICAgICAgICBvdXRbNV0gPSBhWzddO1xuICAgICAgICBvdXRbNl0gPSBhWzJdO1xuICAgICAgICBvdXRbN10gPSBhWzVdO1xuICAgICAgICBvdXRbOF0gPSBhWzhdO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBJbnZlcnRzIGEgbWF0M1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My5pbnZlcnQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSxcbiAgICAgICAgYTEwID0gYVszXSwgYTExID0gYVs0XSwgYTEyID0gYVs1XSxcbiAgICAgICAgYTIwID0gYVs2XSwgYTIxID0gYVs3XSwgYTIyID0gYVs4XSxcblxuICAgICAgICBiMDEgPSBhMjIgKiBhMTEgLSBhMTIgKiBhMjEsXG4gICAgICAgIGIxMSA9IC1hMjIgKiBhMTAgKyBhMTIgKiBhMjAsXG4gICAgICAgIGIyMSA9IGEyMSAqIGExMCAtIGExMSAqIGEyMCxcblxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG4gICAgICAgIGRldCA9IGEwMCAqIGIwMSArIGEwMSAqIGIxMSArIGEwMiAqIGIyMTtcblxuICAgIGlmICghZGV0KSB7IFxuICAgICAgICByZXR1cm4gbnVsbDsgXG4gICAgfVxuICAgIGRldCA9IDEuMCAvIGRldDtcblxuICAgIG91dFswXSA9IGIwMSAqIGRldDtcbiAgICBvdXRbMV0gPSAoLWEyMiAqIGEwMSArIGEwMiAqIGEyMSkgKiBkZXQ7XG4gICAgb3V0WzJdID0gKGExMiAqIGEwMSAtIGEwMiAqIGExMSkgKiBkZXQ7XG4gICAgb3V0WzNdID0gYjExICogZGV0O1xuICAgIG91dFs0XSA9IChhMjIgKiBhMDAgLSBhMDIgKiBhMjApICogZGV0O1xuICAgIG91dFs1XSA9ICgtYTEyICogYTAwICsgYTAyICogYTEwKSAqIGRldDtcbiAgICBvdXRbNl0gPSBiMjEgKiBkZXQ7XG4gICAgb3V0WzddID0gKC1hMjEgKiBhMDAgKyBhMDEgKiBhMjApICogZGV0O1xuICAgIG91dFs4XSA9IChhMTEgKiBhMDAgLSBhMDEgKiBhMTApICogZGV0O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGFkanVnYXRlIG9mIGEgbWF0M1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My5hZGpvaW50ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sXG4gICAgICAgIGExMCA9IGFbM10sIGExMSA9IGFbNF0sIGExMiA9IGFbNV0sXG4gICAgICAgIGEyMCA9IGFbNl0sIGEyMSA9IGFbN10sIGEyMiA9IGFbOF07XG5cbiAgICBvdXRbMF0gPSAoYTExICogYTIyIC0gYTEyICogYTIxKTtcbiAgICBvdXRbMV0gPSAoYTAyICogYTIxIC0gYTAxICogYTIyKTtcbiAgICBvdXRbMl0gPSAoYTAxICogYTEyIC0gYTAyICogYTExKTtcbiAgICBvdXRbM10gPSAoYTEyICogYTIwIC0gYTEwICogYTIyKTtcbiAgICBvdXRbNF0gPSAoYTAwICogYTIyIC0gYTAyICogYTIwKTtcbiAgICBvdXRbNV0gPSAoYTAyICogYTEwIC0gYTAwICogYTEyKTtcbiAgICBvdXRbNl0gPSAoYTEwICogYTIxIC0gYTExICogYTIwKTtcbiAgICBvdXRbN10gPSAoYTAxICogYTIwIC0gYTAwICogYTIxKTtcbiAgICBvdXRbOF0gPSAoYTAwICogYTExIC0gYTAxICogYTEwKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkZXRlcm1pbmFudCBvZiBhIG1hdDNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRldGVybWluYW50IG9mIGFcbiAqL1xubWF0My5kZXRlcm1pbmFudCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sXG4gICAgICAgIGExMCA9IGFbM10sIGExMSA9IGFbNF0sIGExMiA9IGFbNV0sXG4gICAgICAgIGEyMCA9IGFbNl0sIGEyMSA9IGFbN10sIGEyMiA9IGFbOF07XG5cbiAgICByZXR1cm4gYTAwICogKGEyMiAqIGExMSAtIGExMiAqIGEyMSkgKyBhMDEgKiAoLWEyMiAqIGExMCArIGExMiAqIGEyMCkgKyBhMDIgKiAoYTIxICogYTEwIC0gYTExICogYTIwKTtcbn07XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gbWF0MydzXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5tYXQzLm11bHRpcGx5ID0gZnVuY3Rpb24gKG91dCwgYSwgYikge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLFxuICAgICAgICBhMTAgPSBhWzNdLCBhMTEgPSBhWzRdLCBhMTIgPSBhWzVdLFxuICAgICAgICBhMjAgPSBhWzZdLCBhMjEgPSBhWzddLCBhMjIgPSBhWzhdLFxuXG4gICAgICAgIGIwMCA9IGJbMF0sIGIwMSA9IGJbMV0sIGIwMiA9IGJbMl0sXG4gICAgICAgIGIxMCA9IGJbM10sIGIxMSA9IGJbNF0sIGIxMiA9IGJbNV0sXG4gICAgICAgIGIyMCA9IGJbNl0sIGIyMSA9IGJbN10sIGIyMiA9IGJbOF07XG5cbiAgICBvdXRbMF0gPSBiMDAgKiBhMDAgKyBiMDEgKiBhMTAgKyBiMDIgKiBhMjA7XG4gICAgb3V0WzFdID0gYjAwICogYTAxICsgYjAxICogYTExICsgYjAyICogYTIxO1xuICAgIG91dFsyXSA9IGIwMCAqIGEwMiArIGIwMSAqIGExMiArIGIwMiAqIGEyMjtcblxuICAgIG91dFszXSA9IGIxMCAqIGEwMCArIGIxMSAqIGExMCArIGIxMiAqIGEyMDtcbiAgICBvdXRbNF0gPSBiMTAgKiBhMDEgKyBiMTEgKiBhMTEgKyBiMTIgKiBhMjE7XG4gICAgb3V0WzVdID0gYjEwICogYTAyICsgYjExICogYTEyICsgYjEyICogYTIyO1xuXG4gICAgb3V0WzZdID0gYjIwICogYTAwICsgYjIxICogYTEwICsgYjIyICogYTIwO1xuICAgIG91dFs3XSA9IGIyMCAqIGEwMSArIGIyMSAqIGExMSArIGIyMiAqIGEyMTtcbiAgICBvdXRbOF0gPSBiMjAgKiBhMDIgKyBiMjEgKiBhMTIgKyBiMjIgKiBhMjI7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBtYXQzLm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cbm1hdDMubXVsID0gbWF0My5tdWx0aXBseTtcblxuLyoqXG4gKiBUcmFuc2xhdGUgYSBtYXQzIGJ5IHRoZSBnaXZlbiB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBtYXRyaXggdG8gdHJhbnNsYXRlXG4gKiBAcGFyYW0ge3ZlYzJ9IHYgdmVjdG9yIHRvIHRyYW5zbGF0ZSBieVxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5tYXQzLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uKG91dCwgYSwgdikge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLFxuICAgICAgICBhMTAgPSBhWzNdLCBhMTEgPSBhWzRdLCBhMTIgPSBhWzVdLFxuICAgICAgICBhMjAgPSBhWzZdLCBhMjEgPSBhWzddLCBhMjIgPSBhWzhdLFxuICAgICAgICB4ID0gdlswXSwgeSA9IHZbMV07XG5cbiAgICBvdXRbMF0gPSBhMDA7XG4gICAgb3V0WzFdID0gYTAxO1xuICAgIG91dFsyXSA9IGEwMjtcblxuICAgIG91dFszXSA9IGExMDtcbiAgICBvdXRbNF0gPSBhMTE7XG4gICAgb3V0WzVdID0gYTEyO1xuXG4gICAgb3V0WzZdID0geCAqIGEwMCArIHkgKiBhMTAgKyBhMjA7XG4gICAgb3V0WzddID0geCAqIGEwMSArIHkgKiBhMTEgKyBhMjE7XG4gICAgb3V0WzhdID0geCAqIGEwMiArIHkgKiBhMTIgKyBhMjI7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdDMgYnkgdGhlIGdpdmVuIGFuZ2xlXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My5yb3RhdGUgPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSxcbiAgICAgICAgYTEwID0gYVszXSwgYTExID0gYVs0XSwgYTEyID0gYVs1XSxcbiAgICAgICAgYTIwID0gYVs2XSwgYTIxID0gYVs3XSwgYTIyID0gYVs4XSxcblxuICAgICAgICBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgICAgYyA9IE1hdGguY29zKHJhZCk7XG5cbiAgICBvdXRbMF0gPSBjICogYTAwICsgcyAqIGExMDtcbiAgICBvdXRbMV0gPSBjICogYTAxICsgcyAqIGExMTtcbiAgICBvdXRbMl0gPSBjICogYTAyICsgcyAqIGExMjtcblxuICAgIG91dFszXSA9IGMgKiBhMTAgLSBzICogYTAwO1xuICAgIG91dFs0XSA9IGMgKiBhMTEgLSBzICogYTAxO1xuICAgIG91dFs1XSA9IGMgKiBhMTIgLSBzICogYTAyO1xuXG4gICAgb3V0WzZdID0gYTIwO1xuICAgIG91dFs3XSA9IGEyMTtcbiAgICBvdXRbOF0gPSBhMjI7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2NhbGVzIHRoZSBtYXQzIGJ5IHRoZSBkaW1lbnNpb25zIGluIHRoZSBnaXZlbiB2ZWMyXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHt2ZWMyfSB2IHRoZSB2ZWMyIHRvIHNjYWxlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqKi9cbm1hdDMuc2NhbGUgPSBmdW5jdGlvbihvdXQsIGEsIHYpIHtcbiAgICB2YXIgeCA9IHZbMF0sIHkgPSB2WzFdO1xuXG4gICAgb3V0WzBdID0geCAqIGFbMF07XG4gICAgb3V0WzFdID0geCAqIGFbMV07XG4gICAgb3V0WzJdID0geCAqIGFbMl07XG5cbiAgICBvdXRbM10gPSB5ICogYVszXTtcbiAgICBvdXRbNF0gPSB5ICogYVs0XTtcbiAgICBvdXRbNV0gPSB5ICogYVs1XTtcblxuICAgIG91dFs2XSA9IGFbNl07XG4gICAgb3V0WzddID0gYVs3XTtcbiAgICBvdXRbOF0gPSBhWzhdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciB0cmFuc2xhdGlvblxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDMuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0My50cmFuc2xhdGUoZGVzdCwgZGVzdCwgdmVjKTtcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCBtYXQzIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3ZlYzJ9IHYgVHJhbnNsYXRpb24gdmVjdG9yXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMuZnJvbVRyYW5zbGF0aW9uID0gZnVuY3Rpb24ob3V0LCB2KSB7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAxO1xuICAgIG91dFs1XSA9IDA7XG4gICAgb3V0WzZdID0gdlswXTtcbiAgICBvdXRbN10gPSB2WzFdO1xuICAgIG91dFs4XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBnaXZlbiBhbmdsZVxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDMuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0My5yb3RhdGUoZGVzdCwgZGVzdCwgcmFkKTtcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCBtYXQzIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5tYXQzLmZyb21Sb3RhdGlvbiA9IGZ1bmN0aW9uKG91dCwgcmFkKSB7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpLCBjID0gTWF0aC5jb3MocmFkKTtcblxuICAgIG91dFswXSA9IGM7XG4gICAgb3V0WzFdID0gcztcbiAgICBvdXRbMl0gPSAwO1xuXG4gICAgb3V0WzNdID0gLXM7XG4gICAgb3V0WzRdID0gYztcbiAgICBvdXRbNV0gPSAwO1xuXG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSB2ZWN0b3Igc2NhbGluZ1xuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDMuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0My5zY2FsZShkZXN0LCBkZXN0LCB2ZWMpO1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IG1hdDMgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7dmVjMn0gdiBTY2FsaW5nIHZlY3RvclxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5tYXQzLmZyb21TY2FsaW5nID0gZnVuY3Rpb24ob3V0LCB2KSB7XG4gICAgb3V0WzBdID0gdlswXTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG5cbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IHZbMV07XG4gICAgb3V0WzVdID0gMDtcblxuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ29waWVzIHRoZSB2YWx1ZXMgZnJvbSBhIG1hdDJkIGludG8gYSBtYXQzXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIG1hdHJpeCB0byBjb3B5XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKiovXG5tYXQzLmZyb21NYXQyZCA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSAwO1xuXG4gICAgb3V0WzNdID0gYVsyXTtcbiAgICBvdXRbNF0gPSBhWzNdO1xuICAgIG91dFs1XSA9IDA7XG5cbiAgICBvdXRbNl0gPSBhWzRdO1xuICAgIG91dFs3XSA9IGFbNV07XG4gICAgb3V0WzhdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4qIENhbGN1bGF0ZXMgYSAzeDMgbWF0cml4IGZyb20gdGhlIGdpdmVuIHF1YXRlcm5pb25cbipcbiogQHBhcmFtIHttYXQzfSBvdXQgbWF0MyByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuKiBAcGFyYW0ge3F1YXR9IHEgUXVhdGVybmlvbiB0byBjcmVhdGUgbWF0cml4IGZyb21cbipcbiogQHJldHVybnMge21hdDN9IG91dFxuKi9cbm1hdDMuZnJvbVF1YXQgPSBmdW5jdGlvbiAob3V0LCBxKSB7XG4gICAgdmFyIHggPSBxWzBdLCB5ID0gcVsxXSwgeiA9IHFbMl0sIHcgPSBxWzNdLFxuICAgICAgICB4MiA9IHggKyB4LFxuICAgICAgICB5MiA9IHkgKyB5LFxuICAgICAgICB6MiA9IHogKyB6LFxuXG4gICAgICAgIHh4ID0geCAqIHgyLFxuICAgICAgICB5eCA9IHkgKiB4MixcbiAgICAgICAgeXkgPSB5ICogeTIsXG4gICAgICAgIHp4ID0geiAqIHgyLFxuICAgICAgICB6eSA9IHogKiB5MixcbiAgICAgICAgenogPSB6ICogejIsXG4gICAgICAgIHd4ID0gdyAqIHgyLFxuICAgICAgICB3eSA9IHcgKiB5MixcbiAgICAgICAgd3ogPSB3ICogejI7XG5cbiAgICBvdXRbMF0gPSAxIC0geXkgLSB6ejtcbiAgICBvdXRbM10gPSB5eCAtIHd6O1xuICAgIG91dFs2XSA9IHp4ICsgd3k7XG5cbiAgICBvdXRbMV0gPSB5eCArIHd6O1xuICAgIG91dFs0XSA9IDEgLSB4eCAtIHp6O1xuICAgIG91dFs3XSA9IHp5IC0gd3g7XG5cbiAgICBvdXRbMl0gPSB6eCAtIHd5O1xuICAgIG91dFs1XSA9IHp5ICsgd3g7XG4gICAgb3V0WzhdID0gMSAtIHh4IC0geXk7XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4qIENhbGN1bGF0ZXMgYSAzeDMgbm9ybWFsIG1hdHJpeCAodHJhbnNwb3NlIGludmVyc2UpIGZyb20gdGhlIDR4NCBtYXRyaXhcbipcbiogQHBhcmFtIHttYXQzfSBvdXQgbWF0MyByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuKiBAcGFyYW0ge21hdDR9IGEgTWF0NCB0byBkZXJpdmUgdGhlIG5vcm1hbCBtYXRyaXggZnJvbVxuKlxuKiBAcmV0dXJucyB7bWF0M30gb3V0XG4qL1xubWF0My5ub3JtYWxGcm9tTWF0NCA9IGZ1bmN0aW9uIChvdXQsIGEpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTAzID0gYVszXSxcbiAgICAgICAgYTEwID0gYVs0XSwgYTExID0gYVs1XSwgYTEyID0gYVs2XSwgYTEzID0gYVs3XSxcbiAgICAgICAgYTIwID0gYVs4XSwgYTIxID0gYVs5XSwgYTIyID0gYVsxMF0sIGEyMyA9IGFbMTFdLFxuICAgICAgICBhMzAgPSBhWzEyXSwgYTMxID0gYVsxM10sIGEzMiA9IGFbMTRdLCBhMzMgPSBhWzE1XSxcblxuICAgICAgICBiMDAgPSBhMDAgKiBhMTEgLSBhMDEgKiBhMTAsXG4gICAgICAgIGIwMSA9IGEwMCAqIGExMiAtIGEwMiAqIGExMCxcbiAgICAgICAgYjAyID0gYTAwICogYTEzIC0gYTAzICogYTEwLFxuICAgICAgICBiMDMgPSBhMDEgKiBhMTIgLSBhMDIgKiBhMTEsXG4gICAgICAgIGIwNCA9IGEwMSAqIGExMyAtIGEwMyAqIGExMSxcbiAgICAgICAgYjA1ID0gYTAyICogYTEzIC0gYTAzICogYTEyLFxuICAgICAgICBiMDYgPSBhMjAgKiBhMzEgLSBhMjEgKiBhMzAsXG4gICAgICAgIGIwNyA9IGEyMCAqIGEzMiAtIGEyMiAqIGEzMCxcbiAgICAgICAgYjA4ID0gYTIwICogYTMzIC0gYTIzICogYTMwLFxuICAgICAgICBiMDkgPSBhMjEgKiBhMzIgLSBhMjIgKiBhMzEsXG4gICAgICAgIGIxMCA9IGEyMSAqIGEzMyAtIGEyMyAqIGEzMSxcbiAgICAgICAgYjExID0gYTIyICogYTMzIC0gYTIzICogYTMyLFxuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcbiAgICAgICAgZGV0ID0gYjAwICogYjExIC0gYjAxICogYjEwICsgYjAyICogYjA5ICsgYjAzICogYjA4IC0gYjA0ICogYjA3ICsgYjA1ICogYjA2O1xuXG4gICAgaWYgKCFkZXQpIHsgXG4gICAgICAgIHJldHVybiBudWxsOyBcbiAgICB9XG4gICAgZGV0ID0gMS4wIC8gZGV0O1xuXG4gICAgb3V0WzBdID0gKGExMSAqIGIxMSAtIGExMiAqIGIxMCArIGExMyAqIGIwOSkgKiBkZXQ7XG4gICAgb3V0WzFdID0gKGExMiAqIGIwOCAtIGExMCAqIGIxMSAtIGExMyAqIGIwNykgKiBkZXQ7XG4gICAgb3V0WzJdID0gKGExMCAqIGIxMCAtIGExMSAqIGIwOCArIGExMyAqIGIwNikgKiBkZXQ7XG5cbiAgICBvdXRbM10gPSAoYTAyICogYjEwIC0gYTAxICogYjExIC0gYTAzICogYjA5KSAqIGRldDtcbiAgICBvdXRbNF0gPSAoYTAwICogYjExIC0gYTAyICogYjA4ICsgYTAzICogYjA3KSAqIGRldDtcbiAgICBvdXRbNV0gPSAoYTAxICogYjA4IC0gYTAwICogYjEwIC0gYTAzICogYjA2KSAqIGRldDtcblxuICAgIG91dFs2XSA9IChhMzEgKiBiMDUgLSBhMzIgKiBiMDQgKyBhMzMgKiBiMDMpICogZGV0O1xuICAgIG91dFs3XSA9IChhMzIgKiBiMDIgLSBhMzAgKiBiMDUgLSBhMzMgKiBiMDEpICogZGV0O1xuICAgIG91dFs4XSA9IChhMzAgKiBiMDQgLSBhMzEgKiBiMDIgKyBhMzMgKiBiMDApICogZGV0O1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIG1hdDNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG1hdCBtYXRyaXggdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hdHJpeFxuICovXG5tYXQzLnN0ciA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuICdtYXQzKCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnLCAnICsgYVsyXSArICcsICcgKyBcbiAgICAgICAgICAgICAgICAgICAgYVszXSArICcsICcgKyBhWzRdICsgJywgJyArIGFbNV0gKyAnLCAnICsgXG4gICAgICAgICAgICAgICAgICAgIGFbNl0gKyAnLCAnICsgYVs3XSArICcsICcgKyBhWzhdICsgJyknO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIEZyb2Jlbml1cyBub3JtIG9mIGEgbWF0M1xuICpcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgbWF0cml4IHRvIGNhbGN1bGF0ZSBGcm9iZW5pdXMgbm9ybSBvZlxuICogQHJldHVybnMge051bWJlcn0gRnJvYmVuaXVzIG5vcm1cbiAqL1xubWF0My5mcm9iID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4oTWF0aC5zcXJ0KE1hdGgucG93KGFbMF0sIDIpICsgTWF0aC5wb3coYVsxXSwgMikgKyBNYXRoLnBvdyhhWzJdLCAyKSArIE1hdGgucG93KGFbM10sIDIpICsgTWF0aC5wb3coYVs0XSwgMikgKyBNYXRoLnBvdyhhWzVdLCAyKSArIE1hdGgucG93KGFbNl0sIDIpICsgTWF0aC5wb3coYVs3XSwgMikgKyBNYXRoLnBvdyhhWzhdLCAyKSkpXG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gbWF0MztcbiIsIi8qIENvcHlyaWdodCAoYykgMjAxNSwgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuICovXG5cbnZhciBnbE1hdHJpeCA9IHJlcXVpcmUoXCIuL2NvbW1vbi5qc1wiKTtcblxuLyoqXG4gKiBAY2xhc3MgNHg0IE1hdHJpeFxuICogQG5hbWUgbWF0NFxuICovXG52YXIgbWF0NCA9IHt9O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgbWF0NFxuICpcbiAqIEByZXR1cm5zIHttYXQ0fSBhIG5ldyA0eDQgbWF0cml4XG4gKi9cbm1hdDQuY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDE2KTtcbiAgICBvdXRbMF0gPSAxO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gMTtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMDtcbiAgICBvdXRbOV0gPSAwO1xuICAgIG91dFsxMF0gPSAxO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAwO1xuICAgIG91dFsxNV0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbWF0NCBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gYSBtYXRyaXggdG8gY2xvbmVcbiAqIEByZXR1cm5zIHttYXQ0fSBhIG5ldyA0eDQgbWF0cml4XG4gKi9cbm1hdDQuY2xvbmUgPSBmdW5jdGlvbihhKSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDE2KTtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIG91dFs0XSA9IGFbNF07XG4gICAgb3V0WzVdID0gYVs1XTtcbiAgICBvdXRbNl0gPSBhWzZdO1xuICAgIG91dFs3XSA9IGFbN107XG4gICAgb3V0WzhdID0gYVs4XTtcbiAgICBvdXRbOV0gPSBhWzldO1xuICAgIG91dFsxMF0gPSBhWzEwXTtcbiAgICBvdXRbMTFdID0gYVsxMV07XG4gICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSBtYXQ0IHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuY29weSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgb3V0WzRdID0gYVs0XTtcbiAgICBvdXRbNV0gPSBhWzVdO1xuICAgIG91dFs2XSA9IGFbNl07XG4gICAgb3V0WzddID0gYVs3XTtcbiAgICBvdXRbOF0gPSBhWzhdO1xuICAgIG91dFs5XSA9IGFbOV07XG4gICAgb3V0WzEwXSA9IGFbMTBdO1xuICAgIG91dFsxMV0gPSBhWzExXTtcbiAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2V0IGEgbWF0NCB0byB0aGUgaWRlbnRpdHkgbWF0cml4XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5pZGVudGl0eSA9IGZ1bmN0aW9uKG91dCkge1xuICAgIG91dFswXSA9IDE7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSAxO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAwO1xuICAgIG91dFs5XSA9IDA7XG4gICAgb3V0WzEwXSA9IDE7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IDA7XG4gICAgb3V0WzEzXSA9IDA7XG4gICAgb3V0WzE0XSA9IDA7XG4gICAgb3V0WzE1XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNwb3NlIHRoZSB2YWx1ZXMgb2YgYSBtYXQ0XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LnRyYW5zcG9zZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIC8vIElmIHdlIGFyZSB0cmFuc3Bvc2luZyBvdXJzZWx2ZXMgd2UgY2FuIHNraXAgYSBmZXcgc3RlcHMgYnV0IGhhdmUgdG8gY2FjaGUgc29tZSB2YWx1ZXNcbiAgICBpZiAob3V0ID09PSBhKSB7XG4gICAgICAgIHZhciBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLCBhMDMgPSBhWzNdLFxuICAgICAgICAgICAgYTEyID0gYVs2XSwgYTEzID0gYVs3XSxcbiAgICAgICAgICAgIGEyMyA9IGFbMTFdO1xuXG4gICAgICAgIG91dFsxXSA9IGFbNF07XG4gICAgICAgIG91dFsyXSA9IGFbOF07XG4gICAgICAgIG91dFszXSA9IGFbMTJdO1xuICAgICAgICBvdXRbNF0gPSBhMDE7XG4gICAgICAgIG91dFs2XSA9IGFbOV07XG4gICAgICAgIG91dFs3XSA9IGFbMTNdO1xuICAgICAgICBvdXRbOF0gPSBhMDI7XG4gICAgICAgIG91dFs5XSA9IGExMjtcbiAgICAgICAgb3V0WzExXSA9IGFbMTRdO1xuICAgICAgICBvdXRbMTJdID0gYTAzO1xuICAgICAgICBvdXRbMTNdID0gYTEzO1xuICAgICAgICBvdXRbMTRdID0gYTIzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG91dFswXSA9IGFbMF07XG4gICAgICAgIG91dFsxXSA9IGFbNF07XG4gICAgICAgIG91dFsyXSA9IGFbOF07XG4gICAgICAgIG91dFszXSA9IGFbMTJdO1xuICAgICAgICBvdXRbNF0gPSBhWzFdO1xuICAgICAgICBvdXRbNV0gPSBhWzVdO1xuICAgICAgICBvdXRbNl0gPSBhWzldO1xuICAgICAgICBvdXRbN10gPSBhWzEzXTtcbiAgICAgICAgb3V0WzhdID0gYVsyXTtcbiAgICAgICAgb3V0WzldID0gYVs2XTtcbiAgICAgICAgb3V0WzEwXSA9IGFbMTBdO1xuICAgICAgICBvdXRbMTFdID0gYVsxNF07XG4gICAgICAgIG91dFsxMl0gPSBhWzNdO1xuICAgICAgICBvdXRbMTNdID0gYVs3XTtcbiAgICAgICAgb3V0WzE0XSA9IGFbMTFdO1xuICAgICAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEludmVydHMgYSBtYXQ0XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LmludmVydCA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLCBhMDMgPSBhWzNdLFxuICAgICAgICBhMTAgPSBhWzRdLCBhMTEgPSBhWzVdLCBhMTIgPSBhWzZdLCBhMTMgPSBhWzddLFxuICAgICAgICBhMjAgPSBhWzhdLCBhMjEgPSBhWzldLCBhMjIgPSBhWzEwXSwgYTIzID0gYVsxMV0sXG4gICAgICAgIGEzMCA9IGFbMTJdLCBhMzEgPSBhWzEzXSwgYTMyID0gYVsxNF0sIGEzMyA9IGFbMTVdLFxuXG4gICAgICAgIGIwMCA9IGEwMCAqIGExMSAtIGEwMSAqIGExMCxcbiAgICAgICAgYjAxID0gYTAwICogYTEyIC0gYTAyICogYTEwLFxuICAgICAgICBiMDIgPSBhMDAgKiBhMTMgLSBhMDMgKiBhMTAsXG4gICAgICAgIGIwMyA9IGEwMSAqIGExMiAtIGEwMiAqIGExMSxcbiAgICAgICAgYjA0ID0gYTAxICogYTEzIC0gYTAzICogYTExLFxuICAgICAgICBiMDUgPSBhMDIgKiBhMTMgLSBhMDMgKiBhMTIsXG4gICAgICAgIGIwNiA9IGEyMCAqIGEzMSAtIGEyMSAqIGEzMCxcbiAgICAgICAgYjA3ID0gYTIwICogYTMyIC0gYTIyICogYTMwLFxuICAgICAgICBiMDggPSBhMjAgKiBhMzMgLSBhMjMgKiBhMzAsXG4gICAgICAgIGIwOSA9IGEyMSAqIGEzMiAtIGEyMiAqIGEzMSxcbiAgICAgICAgYjEwID0gYTIxICogYTMzIC0gYTIzICogYTMxLFxuICAgICAgICBiMTEgPSBhMjIgKiBhMzMgLSBhMjMgKiBhMzIsXG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuICAgICAgICBkZXQgPSBiMDAgKiBiMTEgLSBiMDEgKiBiMTAgKyBiMDIgKiBiMDkgKyBiMDMgKiBiMDggLSBiMDQgKiBiMDcgKyBiMDUgKiBiMDY7XG5cbiAgICBpZiAoIWRldCkgeyBcbiAgICAgICAgcmV0dXJuIG51bGw7IFxuICAgIH1cbiAgICBkZXQgPSAxLjAgLyBkZXQ7XG5cbiAgICBvdXRbMF0gPSAoYTExICogYjExIC0gYTEyICogYjEwICsgYTEzICogYjA5KSAqIGRldDtcbiAgICBvdXRbMV0gPSAoYTAyICogYjEwIC0gYTAxICogYjExIC0gYTAzICogYjA5KSAqIGRldDtcbiAgICBvdXRbMl0gPSAoYTMxICogYjA1IC0gYTMyICogYjA0ICsgYTMzICogYjAzKSAqIGRldDtcbiAgICBvdXRbM10gPSAoYTIyICogYjA0IC0gYTIxICogYjA1IC0gYTIzICogYjAzKSAqIGRldDtcbiAgICBvdXRbNF0gPSAoYTEyICogYjA4IC0gYTEwICogYjExIC0gYTEzICogYjA3KSAqIGRldDtcbiAgICBvdXRbNV0gPSAoYTAwICogYjExIC0gYTAyICogYjA4ICsgYTAzICogYjA3KSAqIGRldDtcbiAgICBvdXRbNl0gPSAoYTMyICogYjAyIC0gYTMwICogYjA1IC0gYTMzICogYjAxKSAqIGRldDtcbiAgICBvdXRbN10gPSAoYTIwICogYjA1IC0gYTIyICogYjAyICsgYTIzICogYjAxKSAqIGRldDtcbiAgICBvdXRbOF0gPSAoYTEwICogYjEwIC0gYTExICogYjA4ICsgYTEzICogYjA2KSAqIGRldDtcbiAgICBvdXRbOV0gPSAoYTAxICogYjA4IC0gYTAwICogYjEwIC0gYTAzICogYjA2KSAqIGRldDtcbiAgICBvdXRbMTBdID0gKGEzMCAqIGIwNCAtIGEzMSAqIGIwMiArIGEzMyAqIGIwMCkgKiBkZXQ7XG4gICAgb3V0WzExXSA9IChhMjEgKiBiMDIgLSBhMjAgKiBiMDQgLSBhMjMgKiBiMDApICogZGV0O1xuICAgIG91dFsxMl0gPSAoYTExICogYjA3IC0gYTEwICogYjA5IC0gYTEyICogYjA2KSAqIGRldDtcbiAgICBvdXRbMTNdID0gKGEwMCAqIGIwOSAtIGEwMSAqIGIwNyArIGEwMiAqIGIwNikgKiBkZXQ7XG4gICAgb3V0WzE0XSA9IChhMzEgKiBiMDEgLSBhMzAgKiBiMDMgLSBhMzIgKiBiMDApICogZGV0O1xuICAgIG91dFsxNV0gPSAoYTIwICogYjAzIC0gYTIxICogYjAxICsgYTIyICogYjAwKSAqIGRldDtcblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGFkanVnYXRlIG9mIGEgbWF0NFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5hZGpvaW50ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM10sXG4gICAgICAgIGExMCA9IGFbNF0sIGExMSA9IGFbNV0sIGExMiA9IGFbNl0sIGExMyA9IGFbN10sXG4gICAgICAgIGEyMCA9IGFbOF0sIGEyMSA9IGFbOV0sIGEyMiA9IGFbMTBdLCBhMjMgPSBhWzExXSxcbiAgICAgICAgYTMwID0gYVsxMl0sIGEzMSA9IGFbMTNdLCBhMzIgPSBhWzE0XSwgYTMzID0gYVsxNV07XG5cbiAgICBvdXRbMF0gID0gIChhMTEgKiAoYTIyICogYTMzIC0gYTIzICogYTMyKSAtIGEyMSAqIChhMTIgKiBhMzMgLSBhMTMgKiBhMzIpICsgYTMxICogKGExMiAqIGEyMyAtIGExMyAqIGEyMikpO1xuICAgIG91dFsxXSAgPSAtKGEwMSAqIChhMjIgKiBhMzMgLSBhMjMgKiBhMzIpIC0gYTIxICogKGEwMiAqIGEzMyAtIGEwMyAqIGEzMikgKyBhMzEgKiAoYTAyICogYTIzIC0gYTAzICogYTIyKSk7XG4gICAgb3V0WzJdICA9ICAoYTAxICogKGExMiAqIGEzMyAtIGExMyAqIGEzMikgLSBhMTEgKiAoYTAyICogYTMzIC0gYTAzICogYTMyKSArIGEzMSAqIChhMDIgKiBhMTMgLSBhMDMgKiBhMTIpKTtcbiAgICBvdXRbM10gID0gLShhMDEgKiAoYTEyICogYTIzIC0gYTEzICogYTIyKSAtIGExMSAqIChhMDIgKiBhMjMgLSBhMDMgKiBhMjIpICsgYTIxICogKGEwMiAqIGExMyAtIGEwMyAqIGExMikpO1xuICAgIG91dFs0XSAgPSAtKGExMCAqIChhMjIgKiBhMzMgLSBhMjMgKiBhMzIpIC0gYTIwICogKGExMiAqIGEzMyAtIGExMyAqIGEzMikgKyBhMzAgKiAoYTEyICogYTIzIC0gYTEzICogYTIyKSk7XG4gICAgb3V0WzVdICA9ICAoYTAwICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjAgKiAoYTAyICogYTMzIC0gYTAzICogYTMyKSArIGEzMCAqIChhMDIgKiBhMjMgLSBhMDMgKiBhMjIpKTtcbiAgICBvdXRbNl0gID0gLShhMDAgKiAoYTEyICogYTMzIC0gYTEzICogYTMyKSAtIGExMCAqIChhMDIgKiBhMzMgLSBhMDMgKiBhMzIpICsgYTMwICogKGEwMiAqIGExMyAtIGEwMyAqIGExMikpO1xuICAgIG91dFs3XSAgPSAgKGEwMCAqIChhMTIgKiBhMjMgLSBhMTMgKiBhMjIpIC0gYTEwICogKGEwMiAqIGEyMyAtIGEwMyAqIGEyMikgKyBhMjAgKiAoYTAyICogYTEzIC0gYTAzICogYTEyKSk7XG4gICAgb3V0WzhdICA9ICAoYTEwICogKGEyMSAqIGEzMyAtIGEyMyAqIGEzMSkgLSBhMjAgKiAoYTExICogYTMzIC0gYTEzICogYTMxKSArIGEzMCAqIChhMTEgKiBhMjMgLSBhMTMgKiBhMjEpKTtcbiAgICBvdXRbOV0gID0gLShhMDAgKiAoYTIxICogYTMzIC0gYTIzICogYTMxKSAtIGEyMCAqIChhMDEgKiBhMzMgLSBhMDMgKiBhMzEpICsgYTMwICogKGEwMSAqIGEyMyAtIGEwMyAqIGEyMSkpO1xuICAgIG91dFsxMF0gPSAgKGEwMCAqIChhMTEgKiBhMzMgLSBhMTMgKiBhMzEpIC0gYTEwICogKGEwMSAqIGEzMyAtIGEwMyAqIGEzMSkgKyBhMzAgKiAoYTAxICogYTEzIC0gYTAzICogYTExKSk7XG4gICAgb3V0WzExXSA9IC0oYTAwICogKGExMSAqIGEyMyAtIGExMyAqIGEyMSkgLSBhMTAgKiAoYTAxICogYTIzIC0gYTAzICogYTIxKSArIGEyMCAqIChhMDEgKiBhMTMgLSBhMDMgKiBhMTEpKTtcbiAgICBvdXRbMTJdID0gLShhMTAgKiAoYTIxICogYTMyIC0gYTIyICogYTMxKSAtIGEyMCAqIChhMTEgKiBhMzIgLSBhMTIgKiBhMzEpICsgYTMwICogKGExMSAqIGEyMiAtIGExMiAqIGEyMSkpO1xuICAgIG91dFsxM10gPSAgKGEwMCAqIChhMjEgKiBhMzIgLSBhMjIgKiBhMzEpIC0gYTIwICogKGEwMSAqIGEzMiAtIGEwMiAqIGEzMSkgKyBhMzAgKiAoYTAxICogYTIyIC0gYTAyICogYTIxKSk7XG4gICAgb3V0WzE0XSA9IC0oYTAwICogKGExMSAqIGEzMiAtIGExMiAqIGEzMSkgLSBhMTAgKiAoYTAxICogYTMyIC0gYTAyICogYTMxKSArIGEzMCAqIChhMDEgKiBhMTIgLSBhMDIgKiBhMTEpKTtcbiAgICBvdXRbMTVdID0gIChhMDAgKiAoYTExICogYTIyIC0gYTEyICogYTIxKSAtIGExMCAqIChhMDEgKiBhMjIgLSBhMDIgKiBhMjEpICsgYTIwICogKGEwMSAqIGExMiAtIGEwMiAqIGExMSkpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRldGVybWluYW50IG9mIGEgbWF0NFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge051bWJlcn0gZGV0ZXJtaW5hbnQgb2YgYVxuICovXG5tYXQ0LmRldGVybWluYW50ID0gZnVuY3Rpb24gKGEpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTAzID0gYVszXSxcbiAgICAgICAgYTEwID0gYVs0XSwgYTExID0gYVs1XSwgYTEyID0gYVs2XSwgYTEzID0gYVs3XSxcbiAgICAgICAgYTIwID0gYVs4XSwgYTIxID0gYVs5XSwgYTIyID0gYVsxMF0sIGEyMyA9IGFbMTFdLFxuICAgICAgICBhMzAgPSBhWzEyXSwgYTMxID0gYVsxM10sIGEzMiA9IGFbMTRdLCBhMzMgPSBhWzE1XSxcblxuICAgICAgICBiMDAgPSBhMDAgKiBhMTEgLSBhMDEgKiBhMTAsXG4gICAgICAgIGIwMSA9IGEwMCAqIGExMiAtIGEwMiAqIGExMCxcbiAgICAgICAgYjAyID0gYTAwICogYTEzIC0gYTAzICogYTEwLFxuICAgICAgICBiMDMgPSBhMDEgKiBhMTIgLSBhMDIgKiBhMTEsXG4gICAgICAgIGIwNCA9IGEwMSAqIGExMyAtIGEwMyAqIGExMSxcbiAgICAgICAgYjA1ID0gYTAyICogYTEzIC0gYTAzICogYTEyLFxuICAgICAgICBiMDYgPSBhMjAgKiBhMzEgLSBhMjEgKiBhMzAsXG4gICAgICAgIGIwNyA9IGEyMCAqIGEzMiAtIGEyMiAqIGEzMCxcbiAgICAgICAgYjA4ID0gYTIwICogYTMzIC0gYTIzICogYTMwLFxuICAgICAgICBiMDkgPSBhMjEgKiBhMzIgLSBhMjIgKiBhMzEsXG4gICAgICAgIGIxMCA9IGEyMSAqIGEzMyAtIGEyMyAqIGEzMSxcbiAgICAgICAgYjExID0gYTIyICogYTMzIC0gYTIzICogYTMyO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuICAgIHJldHVybiBiMDAgKiBiMTEgLSBiMDEgKiBiMTAgKyBiMDIgKiBiMDkgKyBiMDMgKiBiMDggLSBiMDQgKiBiMDcgKyBiMDUgKiBiMDY7XG59O1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIG1hdDQnc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0NH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5tdWx0aXBseSA9IGZ1bmN0aW9uIChvdXQsIGEsIGIpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTAzID0gYVszXSxcbiAgICAgICAgYTEwID0gYVs0XSwgYTExID0gYVs1XSwgYTEyID0gYVs2XSwgYTEzID0gYVs3XSxcbiAgICAgICAgYTIwID0gYVs4XSwgYTIxID0gYVs5XSwgYTIyID0gYVsxMF0sIGEyMyA9IGFbMTFdLFxuICAgICAgICBhMzAgPSBhWzEyXSwgYTMxID0gYVsxM10sIGEzMiA9IGFbMTRdLCBhMzMgPSBhWzE1XTtcblxuICAgIC8vIENhY2hlIG9ubHkgdGhlIGN1cnJlbnQgbGluZSBvZiB0aGUgc2Vjb25kIG1hdHJpeFxuICAgIHZhciBiMCAgPSBiWzBdLCBiMSA9IGJbMV0sIGIyID0gYlsyXSwgYjMgPSBiWzNdOyAgXG4gICAgb3V0WzBdID0gYjAqYTAwICsgYjEqYTEwICsgYjIqYTIwICsgYjMqYTMwO1xuICAgIG91dFsxXSA9IGIwKmEwMSArIGIxKmExMSArIGIyKmEyMSArIGIzKmEzMTtcbiAgICBvdXRbMl0gPSBiMCphMDIgKyBiMSphMTIgKyBiMiphMjIgKyBiMyphMzI7XG4gICAgb3V0WzNdID0gYjAqYTAzICsgYjEqYTEzICsgYjIqYTIzICsgYjMqYTMzO1xuXG4gICAgYjAgPSBiWzRdOyBiMSA9IGJbNV07IGIyID0gYls2XTsgYjMgPSBiWzddO1xuICAgIG91dFs0XSA9IGIwKmEwMCArIGIxKmExMCArIGIyKmEyMCArIGIzKmEzMDtcbiAgICBvdXRbNV0gPSBiMCphMDEgKyBiMSphMTEgKyBiMiphMjEgKyBiMyphMzE7XG4gICAgb3V0WzZdID0gYjAqYTAyICsgYjEqYTEyICsgYjIqYTIyICsgYjMqYTMyO1xuICAgIG91dFs3XSA9IGIwKmEwMyArIGIxKmExMyArIGIyKmEyMyArIGIzKmEzMztcblxuICAgIGIwID0gYls4XTsgYjEgPSBiWzldOyBiMiA9IGJbMTBdOyBiMyA9IGJbMTFdO1xuICAgIG91dFs4XSA9IGIwKmEwMCArIGIxKmExMCArIGIyKmEyMCArIGIzKmEzMDtcbiAgICBvdXRbOV0gPSBiMCphMDEgKyBiMSphMTEgKyBiMiphMjEgKyBiMyphMzE7XG4gICAgb3V0WzEwXSA9IGIwKmEwMiArIGIxKmExMiArIGIyKmEyMiArIGIzKmEzMjtcbiAgICBvdXRbMTFdID0gYjAqYTAzICsgYjEqYTEzICsgYjIqYTIzICsgYjMqYTMzO1xuXG4gICAgYjAgPSBiWzEyXTsgYjEgPSBiWzEzXTsgYjIgPSBiWzE0XTsgYjMgPSBiWzE1XTtcbiAgICBvdXRbMTJdID0gYjAqYTAwICsgYjEqYTEwICsgYjIqYTIwICsgYjMqYTMwO1xuICAgIG91dFsxM10gPSBiMCphMDEgKyBiMSphMTEgKyBiMiphMjEgKyBiMyphMzE7XG4gICAgb3V0WzE0XSA9IGIwKmEwMiArIGIxKmExMiArIGIyKmEyMiArIGIzKmEzMjtcbiAgICBvdXRbMTVdID0gYjAqYTAzICsgYjEqYTEzICsgYjIqYTIzICsgYjMqYTMzO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0NC5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG5tYXQ0Lm11bCA9IG1hdDQubXVsdGlwbHk7XG5cbi8qKlxuICogVHJhbnNsYXRlIGEgbWF0NCBieSB0aGUgZ2l2ZW4gdmVjdG9yXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHRyYW5zbGF0ZVxuICogQHBhcmFtIHt2ZWMzfSB2IHZlY3RvciB0byB0cmFuc2xhdGUgYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC50cmFuc2xhdGUgPSBmdW5jdGlvbiAob3V0LCBhLCB2KSB7XG4gICAgdmFyIHggPSB2WzBdLCB5ID0gdlsxXSwgeiA9IHZbMl0sXG4gICAgICAgIGEwMCwgYTAxLCBhMDIsIGEwMyxcbiAgICAgICAgYTEwLCBhMTEsIGExMiwgYTEzLFxuICAgICAgICBhMjAsIGEyMSwgYTIyLCBhMjM7XG5cbiAgICBpZiAoYSA9PT0gb3V0KSB7XG4gICAgICAgIG91dFsxMl0gPSBhWzBdICogeCArIGFbNF0gKiB5ICsgYVs4XSAqIHogKyBhWzEyXTtcbiAgICAgICAgb3V0WzEzXSA9IGFbMV0gKiB4ICsgYVs1XSAqIHkgKyBhWzldICogeiArIGFbMTNdO1xuICAgICAgICBvdXRbMTRdID0gYVsyXSAqIHggKyBhWzZdICogeSArIGFbMTBdICogeiArIGFbMTRdO1xuICAgICAgICBvdXRbMTVdID0gYVszXSAqIHggKyBhWzddICogeSArIGFbMTFdICogeiArIGFbMTVdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGEwMCA9IGFbMF07IGEwMSA9IGFbMV07IGEwMiA9IGFbMl07IGEwMyA9IGFbM107XG4gICAgICAgIGExMCA9IGFbNF07IGExMSA9IGFbNV07IGExMiA9IGFbNl07IGExMyA9IGFbN107XG4gICAgICAgIGEyMCA9IGFbOF07IGEyMSA9IGFbOV07IGEyMiA9IGFbMTBdOyBhMjMgPSBhWzExXTtcblxuICAgICAgICBvdXRbMF0gPSBhMDA7IG91dFsxXSA9IGEwMTsgb3V0WzJdID0gYTAyOyBvdXRbM10gPSBhMDM7XG4gICAgICAgIG91dFs0XSA9IGExMDsgb3V0WzVdID0gYTExOyBvdXRbNl0gPSBhMTI7IG91dFs3XSA9IGExMztcbiAgICAgICAgb3V0WzhdID0gYTIwOyBvdXRbOV0gPSBhMjE7IG91dFsxMF0gPSBhMjI7IG91dFsxMV0gPSBhMjM7XG5cbiAgICAgICAgb3V0WzEyXSA9IGEwMCAqIHggKyBhMTAgKiB5ICsgYTIwICogeiArIGFbMTJdO1xuICAgICAgICBvdXRbMTNdID0gYTAxICogeCArIGExMSAqIHkgKyBhMjEgKiB6ICsgYVsxM107XG4gICAgICAgIG91dFsxNF0gPSBhMDIgKiB4ICsgYTEyICogeSArIGEyMiAqIHogKyBhWzE0XTtcbiAgICAgICAgb3V0WzE1XSA9IGEwMyAqIHggKyBhMTMgKiB5ICsgYTIzICogeiArIGFbMTVdO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNjYWxlcyB0aGUgbWF0NCBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjM1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byBzY2FsZVxuICogQHBhcmFtIHt2ZWMzfSB2IHRoZSB2ZWMzIHRvIHNjYWxlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqKi9cbm1hdDQuc2NhbGUgPSBmdW5jdGlvbihvdXQsIGEsIHYpIHtcbiAgICB2YXIgeCA9IHZbMF0sIHkgPSB2WzFdLCB6ID0gdlsyXTtcblxuICAgIG91dFswXSA9IGFbMF0gKiB4O1xuICAgIG91dFsxXSA9IGFbMV0gKiB4O1xuICAgIG91dFsyXSA9IGFbMl0gKiB4O1xuICAgIG91dFszXSA9IGFbM10gKiB4O1xuICAgIG91dFs0XSA9IGFbNF0gKiB5O1xuICAgIG91dFs1XSA9IGFbNV0gKiB5O1xuICAgIG91dFs2XSA9IGFbNl0gKiB5O1xuICAgIG91dFs3XSA9IGFbN10gKiB5O1xuICAgIG91dFs4XSA9IGFbOF0gKiB6O1xuICAgIG91dFs5XSA9IGFbOV0gKiB6O1xuICAgIG91dFsxMF0gPSBhWzEwXSAqIHo7XG4gICAgb3V0WzExXSA9IGFbMTFdICogejtcbiAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdDQgYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgZ2l2ZW4gYXhpc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcGFyYW0ge3ZlYzN9IGF4aXMgdGhlIGF4aXMgdG8gcm90YXRlIGFyb3VuZFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LnJvdGF0ZSA9IGZ1bmN0aW9uIChvdXQsIGEsIHJhZCwgYXhpcykge1xuICAgIHZhciB4ID0gYXhpc1swXSwgeSA9IGF4aXNbMV0sIHogPSBheGlzWzJdLFxuICAgICAgICBsZW4gPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSArIHogKiB6KSxcbiAgICAgICAgcywgYywgdCxcbiAgICAgICAgYTAwLCBhMDEsIGEwMiwgYTAzLFxuICAgICAgICBhMTAsIGExMSwgYTEyLCBhMTMsXG4gICAgICAgIGEyMCwgYTIxLCBhMjIsIGEyMyxcbiAgICAgICAgYjAwLCBiMDEsIGIwMixcbiAgICAgICAgYjEwLCBiMTEsIGIxMixcbiAgICAgICAgYjIwLCBiMjEsIGIyMjtcblxuICAgIGlmIChNYXRoLmFicyhsZW4pIDwgZ2xNYXRyaXguRVBTSUxPTikgeyByZXR1cm4gbnVsbDsgfVxuICAgIFxuICAgIGxlbiA9IDEgLyBsZW47XG4gICAgeCAqPSBsZW47XG4gICAgeSAqPSBsZW47XG4gICAgeiAqPSBsZW47XG5cbiAgICBzID0gTWF0aC5zaW4ocmFkKTtcbiAgICBjID0gTWF0aC5jb3MocmFkKTtcbiAgICB0ID0gMSAtIGM7XG5cbiAgICBhMDAgPSBhWzBdOyBhMDEgPSBhWzFdOyBhMDIgPSBhWzJdOyBhMDMgPSBhWzNdO1xuICAgIGExMCA9IGFbNF07IGExMSA9IGFbNV07IGExMiA9IGFbNl07IGExMyA9IGFbN107XG4gICAgYTIwID0gYVs4XTsgYTIxID0gYVs5XTsgYTIyID0gYVsxMF07IGEyMyA9IGFbMTFdO1xuXG4gICAgLy8gQ29uc3RydWN0IHRoZSBlbGVtZW50cyBvZiB0aGUgcm90YXRpb24gbWF0cml4XG4gICAgYjAwID0geCAqIHggKiB0ICsgYzsgYjAxID0geSAqIHggKiB0ICsgeiAqIHM7IGIwMiA9IHogKiB4ICogdCAtIHkgKiBzO1xuICAgIGIxMCA9IHggKiB5ICogdCAtIHogKiBzOyBiMTEgPSB5ICogeSAqIHQgKyBjOyBiMTIgPSB6ICogeSAqIHQgKyB4ICogcztcbiAgICBiMjAgPSB4ICogeiAqIHQgKyB5ICogczsgYjIxID0geSAqIHogKiB0IC0geCAqIHM7IGIyMiA9IHogKiB6ICogdCArIGM7XG5cbiAgICAvLyBQZXJmb3JtIHJvdGF0aW9uLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgIG91dFswXSA9IGEwMCAqIGIwMCArIGExMCAqIGIwMSArIGEyMCAqIGIwMjtcbiAgICBvdXRbMV0gPSBhMDEgKiBiMDAgKyBhMTEgKiBiMDEgKyBhMjEgKiBiMDI7XG4gICAgb3V0WzJdID0gYTAyICogYjAwICsgYTEyICogYjAxICsgYTIyICogYjAyO1xuICAgIG91dFszXSA9IGEwMyAqIGIwMCArIGExMyAqIGIwMSArIGEyMyAqIGIwMjtcbiAgICBvdXRbNF0gPSBhMDAgKiBiMTAgKyBhMTAgKiBiMTEgKyBhMjAgKiBiMTI7XG4gICAgb3V0WzVdID0gYTAxICogYjEwICsgYTExICogYjExICsgYTIxICogYjEyO1xuICAgIG91dFs2XSA9IGEwMiAqIGIxMCArIGExMiAqIGIxMSArIGEyMiAqIGIxMjtcbiAgICBvdXRbN10gPSBhMDMgKiBiMTAgKyBhMTMgKiBiMTEgKyBhMjMgKiBiMTI7XG4gICAgb3V0WzhdID0gYTAwICogYjIwICsgYTEwICogYjIxICsgYTIwICogYjIyO1xuICAgIG91dFs5XSA9IGEwMSAqIGIyMCArIGExMSAqIGIyMSArIGEyMSAqIGIyMjtcbiAgICBvdXRbMTBdID0gYTAyICogYjIwICsgYTEyICogYjIxICsgYTIyICogYjIyO1xuICAgIG91dFsxMV0gPSBhMDMgKiBiMjAgKyBhMTMgKiBiMjEgKyBhMjMgKiBiMjI7XG5cbiAgICBpZiAoYSAhPT0gb3V0KSB7IC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIGxhc3Qgcm93XG4gICAgICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICAgICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgICAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdHJpeCBieSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBYIGF4aXNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LnJvdGF0ZVggPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcbiAgICB2YXIgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICAgIGMgPSBNYXRoLmNvcyhyYWQpLFxuICAgICAgICBhMTAgPSBhWzRdLFxuICAgICAgICBhMTEgPSBhWzVdLFxuICAgICAgICBhMTIgPSBhWzZdLFxuICAgICAgICBhMTMgPSBhWzddLFxuICAgICAgICBhMjAgPSBhWzhdLFxuICAgICAgICBhMjEgPSBhWzldLFxuICAgICAgICBhMjIgPSBhWzEwXSxcbiAgICAgICAgYTIzID0gYVsxMV07XG5cbiAgICBpZiAoYSAhPT0gb3V0KSB7IC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIHJvd3NcbiAgICAgICAgb3V0WzBdICA9IGFbMF07XG4gICAgICAgIG91dFsxXSAgPSBhWzFdO1xuICAgICAgICBvdXRbMl0gID0gYVsyXTtcbiAgICAgICAgb3V0WzNdICA9IGFbM107XG4gICAgICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICAgICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgICAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICB9XG5cbiAgICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAgb3V0WzRdID0gYTEwICogYyArIGEyMCAqIHM7XG4gICAgb3V0WzVdID0gYTExICogYyArIGEyMSAqIHM7XG4gICAgb3V0WzZdID0gYTEyICogYyArIGEyMiAqIHM7XG4gICAgb3V0WzddID0gYTEzICogYyArIGEyMyAqIHM7XG4gICAgb3V0WzhdID0gYTIwICogYyAtIGExMCAqIHM7XG4gICAgb3V0WzldID0gYTIxICogYyAtIGExMSAqIHM7XG4gICAgb3V0WzEwXSA9IGEyMiAqIGMgLSBhMTIgKiBzO1xuICAgIG91dFsxMV0gPSBhMjMgKiBjIC0gYTEzICogcztcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0cml4IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFkgYXhpc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQucm90YXRlWSA9IGZ1bmN0aW9uIChvdXQsIGEsIHJhZCkge1xuICAgIHZhciBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgICAgYyA9IE1hdGguY29zKHJhZCksXG4gICAgICAgIGEwMCA9IGFbMF0sXG4gICAgICAgIGEwMSA9IGFbMV0sXG4gICAgICAgIGEwMiA9IGFbMl0sXG4gICAgICAgIGEwMyA9IGFbM10sXG4gICAgICAgIGEyMCA9IGFbOF0sXG4gICAgICAgIGEyMSA9IGFbOV0sXG4gICAgICAgIGEyMiA9IGFbMTBdLFxuICAgICAgICBhMjMgPSBhWzExXTtcblxuICAgIGlmIChhICE9PSBvdXQpIHsgLy8gSWYgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZGlmZmVyLCBjb3B5IHRoZSB1bmNoYW5nZWQgcm93c1xuICAgICAgICBvdXRbNF0gID0gYVs0XTtcbiAgICAgICAgb3V0WzVdICA9IGFbNV07XG4gICAgICAgIG91dFs2XSAgPSBhWzZdO1xuICAgICAgICBvdXRbN10gID0gYVs3XTtcbiAgICAgICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgICAgICBvdXRbMTNdID0gYVsxM107XG4gICAgICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICAgICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIH1cblxuICAgIC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgICBvdXRbMF0gPSBhMDAgKiBjIC0gYTIwICogcztcbiAgICBvdXRbMV0gPSBhMDEgKiBjIC0gYTIxICogcztcbiAgICBvdXRbMl0gPSBhMDIgKiBjIC0gYTIyICogcztcbiAgICBvdXRbM10gPSBhMDMgKiBjIC0gYTIzICogcztcbiAgICBvdXRbOF0gPSBhMDAgKiBzICsgYTIwICogYztcbiAgICBvdXRbOV0gPSBhMDEgKiBzICsgYTIxICogYztcbiAgICBvdXRbMTBdID0gYTAyICogcyArIGEyMiAqIGM7XG4gICAgb3V0WzExXSA9IGEwMyAqIHMgKyBhMjMgKiBjO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXRyaXggYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWiBheGlzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5yb3RhdGVaID0gZnVuY3Rpb24gKG91dCwgYSwgcmFkKSB7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgICBjID0gTWF0aC5jb3MocmFkKSxcbiAgICAgICAgYTAwID0gYVswXSxcbiAgICAgICAgYTAxID0gYVsxXSxcbiAgICAgICAgYTAyID0gYVsyXSxcbiAgICAgICAgYTAzID0gYVszXSxcbiAgICAgICAgYTEwID0gYVs0XSxcbiAgICAgICAgYTExID0gYVs1XSxcbiAgICAgICAgYTEyID0gYVs2XSxcbiAgICAgICAgYTEzID0gYVs3XTtcblxuICAgIGlmIChhICE9PSBvdXQpIHsgLy8gSWYgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZGlmZmVyLCBjb3B5IHRoZSB1bmNoYW5nZWQgbGFzdCByb3dcbiAgICAgICAgb3V0WzhdICA9IGFbOF07XG4gICAgICAgIG91dFs5XSAgPSBhWzldO1xuICAgICAgICBvdXRbMTBdID0gYVsxMF07XG4gICAgICAgIG91dFsxMV0gPSBhWzExXTtcbiAgICAgICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgICAgICBvdXRbMTNdID0gYVsxM107XG4gICAgICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICAgICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIH1cblxuICAgIC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgICBvdXRbMF0gPSBhMDAgKiBjICsgYTEwICogcztcbiAgICBvdXRbMV0gPSBhMDEgKiBjICsgYTExICogcztcbiAgICBvdXRbMl0gPSBhMDIgKiBjICsgYTEyICogcztcbiAgICBvdXRbM10gPSBhMDMgKiBjICsgYTEzICogcztcbiAgICBvdXRbNF0gPSBhMTAgKiBjIC0gYTAwICogcztcbiAgICBvdXRbNV0gPSBhMTEgKiBjIC0gYTAxICogcztcbiAgICBvdXRbNl0gPSBhMTIgKiBjIC0gYTAyICogcztcbiAgICBvdXRbN10gPSBhMTMgKiBjIC0gYTAzICogcztcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSB2ZWN0b3IgdHJhbnNsYXRpb25cbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIGRlc3QsIHZlYyk7XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHt2ZWMzfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LmZyb21UcmFuc2xhdGlvbiA9IGZ1bmN0aW9uKG91dCwgdikge1xuICAgIG91dFswXSA9IDE7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSAxO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAwO1xuICAgIG91dFs5XSA9IDA7XG4gICAgb3V0WzEwXSA9IDE7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IHZbMF07XG4gICAgb3V0WzEzXSA9IHZbMV07XG4gICAgb3V0WzE0XSA9IHZbMl07XG4gICAgb3V0WzE1XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSB2ZWN0b3Igc2NhbGluZ1xuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0NC5zY2FsZShkZXN0LCBkZXN0LCB2ZWMpO1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7dmVjM30gdiBTY2FsaW5nIHZlY3RvclxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LmZyb21TY2FsaW5nID0gZnVuY3Rpb24ob3V0LCB2KSB7XG4gICAgb3V0WzBdID0gdlswXTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IHZbMV07XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDA7XG4gICAgb3V0WzldID0gMDtcbiAgICBvdXRbMTBdID0gdlsyXTtcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gMDtcbiAgICBvdXRbMTVdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIGdpdmVuIGFuZ2xlIGFyb3VuZCBhIGdpdmVuIGF4aXNcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDQucm90YXRlKGRlc3QsIGRlc3QsIHJhZCwgYXhpcyk7XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEBwYXJhbSB7dmVjM30gYXhpcyB0aGUgYXhpcyB0byByb3RhdGUgYXJvdW5kXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuZnJvbVJvdGF0aW9uID0gZnVuY3Rpb24ob3V0LCByYWQsIGF4aXMpIHtcbiAgICB2YXIgeCA9IGF4aXNbMF0sIHkgPSBheGlzWzFdLCB6ID0gYXhpc1syXSxcbiAgICAgICAgbGVuID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkgKyB6ICogeiksXG4gICAgICAgIHMsIGMsIHQ7XG4gICAgXG4gICAgaWYgKE1hdGguYWJzKGxlbikgPCBnbE1hdHJpeC5FUFNJTE9OKSB7IHJldHVybiBudWxsOyB9XG4gICAgXG4gICAgbGVuID0gMSAvIGxlbjtcbiAgICB4ICo9IGxlbjtcbiAgICB5ICo9IGxlbjtcbiAgICB6ICo9IGxlbjtcbiAgICBcbiAgICBzID0gTWF0aC5zaW4ocmFkKTtcbiAgICBjID0gTWF0aC5jb3MocmFkKTtcbiAgICB0ID0gMSAtIGM7XG4gICAgXG4gICAgLy8gUGVyZm9ybSByb3RhdGlvbi1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgICBvdXRbMF0gPSB4ICogeCAqIHQgKyBjO1xuICAgIG91dFsxXSA9IHkgKiB4ICogdCArIHogKiBzO1xuICAgIG91dFsyXSA9IHogKiB4ICogdCAtIHkgKiBzO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0geCAqIHkgKiB0IC0geiAqIHM7XG4gICAgb3V0WzVdID0geSAqIHkgKiB0ICsgYztcbiAgICBvdXRbNl0gPSB6ICogeSAqIHQgKyB4ICogcztcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IHggKiB6ICogdCArIHkgKiBzO1xuICAgIG91dFs5XSA9IHkgKiB6ICogdCAtIHggKiBzO1xuICAgIG91dFsxMF0gPSB6ICogeiAqIHQgKyBjO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAwO1xuICAgIG91dFsxNV0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFggYXhpc1xuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0NC5yb3RhdGVYKGRlc3QsIGRlc3QsIHJhZCk7XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5mcm9tWFJvdGF0aW9uID0gZnVuY3Rpb24ob3V0LCByYWQpIHtcbiAgICB2YXIgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICAgIGMgPSBNYXRoLmNvcyhyYWQpO1xuICAgIFxuICAgIC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgICBvdXRbMF0gID0gMTtcbiAgICBvdXRbMV0gID0gMDtcbiAgICBvdXRbMl0gID0gMDtcbiAgICBvdXRbM10gID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IGM7XG4gICAgb3V0WzZdID0gcztcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDA7XG4gICAgb3V0WzldID0gLXM7XG4gICAgb3V0WzEwXSA9IGM7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IDA7XG4gICAgb3V0WzEzXSA9IDA7XG4gICAgb3V0WzE0XSA9IDA7XG4gICAgb3V0WzE1XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWSBheGlzXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnJvdGF0ZVkoZGVzdCwgZGVzdCwgcmFkKTtcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LmZyb21ZUm90YXRpb24gPSBmdW5jdGlvbihvdXQsIHJhZCkge1xuICAgIHZhciBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgICAgYyA9IE1hdGguY29zKHJhZCk7XG4gICAgXG4gICAgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgIG91dFswXSAgPSBjO1xuICAgIG91dFsxXSAgPSAwO1xuICAgIG91dFsyXSAgPSAtcztcbiAgICBvdXRbM10gID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IDE7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IHM7XG4gICAgb3V0WzldID0gMDtcbiAgICBvdXRbMTBdID0gYztcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gMDtcbiAgICBvdXRbMTVdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBaIGF4aXNcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDQucm90YXRlWihkZXN0LCBkZXN0LCByYWQpO1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuZnJvbVpSb3RhdGlvbiA9IGZ1bmN0aW9uKG91dCwgcmFkKSB7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgICBjID0gTWF0aC5jb3MocmFkKTtcbiAgICBcbiAgICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAgb3V0WzBdICA9IGM7XG4gICAgb3V0WzFdICA9IHM7XG4gICAgb3V0WzJdICA9IDA7XG4gICAgb3V0WzNdICA9IDA7XG4gICAgb3V0WzRdID0gLXM7XG4gICAgb3V0WzVdID0gYztcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMDtcbiAgICBvdXRbOV0gPSAwO1xuICAgIG91dFsxMF0gPSAxO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAwO1xuICAgIG91dFsxNV0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgcXVhdGVybmlvbiByb3RhdGlvbiBhbmQgdmVjdG9yIHRyYW5zbGF0aW9uXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCB2ZWMpO1xuICogICAgIHZhciBxdWF0TWF0ID0gbWF0NC5jcmVhdGUoKTtcbiAqICAgICBxdWF0NC50b01hdDQocXVhdCwgcXVhdE1hdCk7XG4gKiAgICAgbWF0NC5tdWx0aXBseShkZXN0LCBxdWF0TWF0KTtcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3F1YXQ0fSBxIFJvdGF0aW9uIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7dmVjM30gdiBUcmFuc2xhdGlvbiB2ZWN0b3JcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5mcm9tUm90YXRpb25UcmFuc2xhdGlvbiA9IGZ1bmN0aW9uIChvdXQsIHEsIHYpIHtcbiAgICAvLyBRdWF0ZXJuaW9uIG1hdGhcbiAgICB2YXIgeCA9IHFbMF0sIHkgPSBxWzFdLCB6ID0gcVsyXSwgdyA9IHFbM10sXG4gICAgICAgIHgyID0geCArIHgsXG4gICAgICAgIHkyID0geSArIHksXG4gICAgICAgIHoyID0geiArIHosXG5cbiAgICAgICAgeHggPSB4ICogeDIsXG4gICAgICAgIHh5ID0geCAqIHkyLFxuICAgICAgICB4eiA9IHggKiB6MixcbiAgICAgICAgeXkgPSB5ICogeTIsXG4gICAgICAgIHl6ID0geSAqIHoyLFxuICAgICAgICB6eiA9IHogKiB6MixcbiAgICAgICAgd3ggPSB3ICogeDIsXG4gICAgICAgIHd5ID0gdyAqIHkyLFxuICAgICAgICB3eiA9IHcgKiB6MjtcblxuICAgIG91dFswXSA9IDEgLSAoeXkgKyB6eik7XG4gICAgb3V0WzFdID0geHkgKyB3ejtcbiAgICBvdXRbMl0gPSB4eiAtIHd5O1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0geHkgLSB3ejtcbiAgICBvdXRbNV0gPSAxIC0gKHh4ICsgenopO1xuICAgIG91dFs2XSA9IHl6ICsgd3g7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSB4eiArIHd5O1xuICAgIG91dFs5XSA9IHl6IC0gd3g7XG4gICAgb3V0WzEwXSA9IDEgLSAoeHggKyB5eSk7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IHZbMF07XG4gICAgb3V0WzEzXSA9IHZbMV07XG4gICAgb3V0WzE0XSA9IHZbMl07XG4gICAgb3V0WzE1XSA9IDE7XG4gICAgXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgcXVhdGVybmlvbiByb3RhdGlvbiwgdmVjdG9yIHRyYW5zbGF0aW9uIGFuZCB2ZWN0b3Igc2NhbGVcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIHZlYyk7XG4gKiAgICAgdmFyIHF1YXRNYXQgPSBtYXQ0LmNyZWF0ZSgpO1xuICogICAgIHF1YXQ0LnRvTWF0NChxdWF0LCBxdWF0TWF0KTtcbiAqICAgICBtYXQ0Lm11bHRpcGx5KGRlc3QsIHF1YXRNYXQpO1xuICogICAgIG1hdDQuc2NhbGUoZGVzdCwgc2NhbGUpXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtxdWF0NH0gcSBSb3RhdGlvbiBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3ZlYzN9IHYgVHJhbnNsYXRpb24gdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IHMgU2NhbGluZyB2ZWN0b3JcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5mcm9tUm90YXRpb25UcmFuc2xhdGlvblNjYWxlID0gZnVuY3Rpb24gKG91dCwgcSwgdiwgcykge1xuICAgIC8vIFF1YXRlcm5pb24gbWF0aFxuICAgIHZhciB4ID0gcVswXSwgeSA9IHFbMV0sIHogPSBxWzJdLCB3ID0gcVszXSxcbiAgICAgICAgeDIgPSB4ICsgeCxcbiAgICAgICAgeTIgPSB5ICsgeSxcbiAgICAgICAgejIgPSB6ICsgeixcblxuICAgICAgICB4eCA9IHggKiB4MixcbiAgICAgICAgeHkgPSB4ICogeTIsXG4gICAgICAgIHh6ID0geCAqIHoyLFxuICAgICAgICB5eSA9IHkgKiB5MixcbiAgICAgICAgeXogPSB5ICogejIsXG4gICAgICAgIHp6ID0geiAqIHoyLFxuICAgICAgICB3eCA9IHcgKiB4MixcbiAgICAgICAgd3kgPSB3ICogeTIsXG4gICAgICAgIHd6ID0gdyAqIHoyLFxuICAgICAgICBzeCA9IHNbMF0sXG4gICAgICAgIHN5ID0gc1sxXSxcbiAgICAgICAgc3ogPSBzWzJdO1xuXG4gICAgb3V0WzBdID0gKDEgLSAoeXkgKyB6eikpICogc3g7XG4gICAgb3V0WzFdID0gKHh5ICsgd3opICogc3g7XG4gICAgb3V0WzJdID0gKHh6IC0gd3kpICogc3g7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAoeHkgLSB3eikgKiBzeTtcbiAgICBvdXRbNV0gPSAoMSAtICh4eCArIHp6KSkgKiBzeTtcbiAgICBvdXRbNl0gPSAoeXogKyB3eCkgKiBzeTtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9ICh4eiArIHd5KSAqIHN6O1xuICAgIG91dFs5XSA9ICh5eiAtIHd4KSAqIHN6O1xuICAgIG91dFsxMF0gPSAoMSAtICh4eCArIHl5KSkgKiBzejtcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gdlswXTtcbiAgICBvdXRbMTNdID0gdlsxXTtcbiAgICBvdXRbMTRdID0gdlsyXTtcbiAgICBvdXRbMTVdID0gMTtcbiAgICBcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBxdWF0ZXJuaW9uIHJvdGF0aW9uLCB2ZWN0b3IgdHJhbnNsYXRpb24gYW5kIHZlY3RvciBzY2FsZSwgcm90YXRpbmcgYW5kIHNjYWxpbmcgYXJvdW5kIHRoZSBnaXZlbiBvcmlnaW5cbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIHZlYyk7XG4gKiAgICAgbWF0NC50cmFuc2xhdGUoZGVzdCwgb3JpZ2luKTtcbiAqICAgICB2YXIgcXVhdE1hdCA9IG1hdDQuY3JlYXRlKCk7XG4gKiAgICAgcXVhdDQudG9NYXQ0KHF1YXQsIHF1YXRNYXQpO1xuICogICAgIG1hdDQubXVsdGlwbHkoZGVzdCwgcXVhdE1hdCk7XG4gKiAgICAgbWF0NC5zY2FsZShkZXN0LCBzY2FsZSlcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCBuZWdhdGl2ZU9yaWdpbik7XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtxdWF0NH0gcSBSb3RhdGlvbiBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3ZlYzN9IHYgVHJhbnNsYXRpb24gdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IHMgU2NhbGluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gbyBUaGUgb3JpZ2luIHZlY3RvciBhcm91bmQgd2hpY2ggdG8gc2NhbGUgYW5kIHJvdGF0ZVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LmZyb21Sb3RhdGlvblRyYW5zbGF0aW9uU2NhbGVPcmlnaW4gPSBmdW5jdGlvbiAob3V0LCBxLCB2LCBzLCBvKSB7XG4gIC8vIFF1YXRlcm5pb24gbWF0aFxuICB2YXIgeCA9IHFbMF0sIHkgPSBxWzFdLCB6ID0gcVsyXSwgdyA9IHFbM10sXG4gICAgICB4MiA9IHggKyB4LFxuICAgICAgeTIgPSB5ICsgeSxcbiAgICAgIHoyID0geiArIHosXG5cbiAgICAgIHh4ID0geCAqIHgyLFxuICAgICAgeHkgPSB4ICogeTIsXG4gICAgICB4eiA9IHggKiB6MixcbiAgICAgIHl5ID0geSAqIHkyLFxuICAgICAgeXogPSB5ICogejIsXG4gICAgICB6eiA9IHogKiB6MixcbiAgICAgIHd4ID0gdyAqIHgyLFxuICAgICAgd3kgPSB3ICogeTIsXG4gICAgICB3eiA9IHcgKiB6MixcbiAgICAgIFxuICAgICAgc3ggPSBzWzBdLFxuICAgICAgc3kgPSBzWzFdLFxuICAgICAgc3ogPSBzWzJdLFxuXG4gICAgICBveCA9IG9bMF0sXG4gICAgICBveSA9IG9bMV0sXG4gICAgICBveiA9IG9bMl07XG4gICAgICBcbiAgb3V0WzBdID0gKDEgLSAoeXkgKyB6eikpICogc3g7XG4gIG91dFsxXSA9ICh4eSArIHd6KSAqIHN4O1xuICBvdXRbMl0gPSAoeHogLSB3eSkgKiBzeDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gKHh5IC0gd3opICogc3k7XG4gIG91dFs1XSA9ICgxIC0gKHh4ICsgenopKSAqIHN5O1xuICBvdXRbNl0gPSAoeXogKyB3eCkgKiBzeTtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gKHh6ICsgd3kpICogc3o7XG4gIG91dFs5XSA9ICh5eiAtIHd4KSAqIHN6O1xuICBvdXRbMTBdID0gKDEgLSAoeHggKyB5eSkpICogc3o7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gdlswXSArIG94IC0gKG91dFswXSAqIG94ICsgb3V0WzRdICogb3kgKyBvdXRbOF0gKiBveik7XG4gIG91dFsxM10gPSB2WzFdICsgb3kgLSAob3V0WzFdICogb3ggKyBvdXRbNV0gKiBveSArIG91dFs5XSAqIG96KTtcbiAgb3V0WzE0XSA9IHZbMl0gKyBveiAtIChvdXRbMl0gKiBveCArIG91dFs2XSAqIG95ICsgb3V0WzEwXSAqIG96KTtcbiAgb3V0WzE1XSA9IDE7XG4gICAgICAgIFxuICByZXR1cm4gb3V0O1xufTtcblxubWF0NC5mcm9tUXVhdCA9IGZ1bmN0aW9uIChvdXQsIHEpIHtcbiAgICB2YXIgeCA9IHFbMF0sIHkgPSBxWzFdLCB6ID0gcVsyXSwgdyA9IHFbM10sXG4gICAgICAgIHgyID0geCArIHgsXG4gICAgICAgIHkyID0geSArIHksXG4gICAgICAgIHoyID0geiArIHosXG5cbiAgICAgICAgeHggPSB4ICogeDIsXG4gICAgICAgIHl4ID0geSAqIHgyLFxuICAgICAgICB5eSA9IHkgKiB5MixcbiAgICAgICAgenggPSB6ICogeDIsXG4gICAgICAgIHp5ID0geiAqIHkyLFxuICAgICAgICB6eiA9IHogKiB6MixcbiAgICAgICAgd3ggPSB3ICogeDIsXG4gICAgICAgIHd5ID0gdyAqIHkyLFxuICAgICAgICB3eiA9IHcgKiB6MjtcblxuICAgIG91dFswXSA9IDEgLSB5eSAtIHp6O1xuICAgIG91dFsxXSA9IHl4ICsgd3o7XG4gICAgb3V0WzJdID0genggLSB3eTtcbiAgICBvdXRbM10gPSAwO1xuXG4gICAgb3V0WzRdID0geXggLSB3ejtcbiAgICBvdXRbNV0gPSAxIC0geHggLSB6ejtcbiAgICBvdXRbNl0gPSB6eSArIHd4O1xuICAgIG91dFs3XSA9IDA7XG5cbiAgICBvdXRbOF0gPSB6eCArIHd5O1xuICAgIG91dFs5XSA9IHp5IC0gd3g7XG4gICAgb3V0WzEwXSA9IDEgLSB4eCAtIHl5O1xuICAgIG91dFsxMV0gPSAwO1xuXG4gICAgb3V0WzEyXSA9IDA7XG4gICAgb3V0WzEzXSA9IDA7XG4gICAgb3V0WzE0XSA9IDA7XG4gICAgb3V0WzE1XSA9IDE7XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBmcnVzdHVtIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBib3VuZHNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge051bWJlcn0gbGVmdCBMZWZ0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge051bWJlcn0gcmlnaHQgUmlnaHQgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7TnVtYmVyfSBib3R0b20gQm90dG9tIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge051bWJlcn0gdG9wIFRvcCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtOdW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtOdW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5mcnVzdHVtID0gZnVuY3Rpb24gKG91dCwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIpIHtcbiAgICB2YXIgcmwgPSAxIC8gKHJpZ2h0IC0gbGVmdCksXG4gICAgICAgIHRiID0gMSAvICh0b3AgLSBib3R0b20pLFxuICAgICAgICBuZiA9IDEgLyAobmVhciAtIGZhcik7XG4gICAgb3V0WzBdID0gKG5lYXIgKiAyKSAqIHJsO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gKG5lYXIgKiAyKSAqIHRiO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAocmlnaHQgKyBsZWZ0KSAqIHJsO1xuICAgIG91dFs5XSA9ICh0b3AgKyBib3R0b20pICogdGI7XG4gICAgb3V0WzEwXSA9IChmYXIgKyBuZWFyKSAqIG5mO1xuICAgIG91dFsxMV0gPSAtMTtcbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gKGZhciAqIG5lYXIgKiAyKSAqIG5mO1xuICAgIG91dFsxNV0gPSAwO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHBlcnNwZWN0aXZlIHByb2plY3Rpb24gbWF0cml4IHdpdGggdGhlIGdpdmVuIGJvdW5kc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cbiAqIEBwYXJhbSB7bnVtYmVyfSBmb3Z5IFZlcnRpY2FsIGZpZWxkIG9mIHZpZXcgaW4gcmFkaWFuc1xuICogQHBhcmFtIHtudW1iZXJ9IGFzcGVjdCBBc3BlY3QgcmF0aW8uIHR5cGljYWxseSB2aWV3cG9ydCB3aWR0aC9oZWlnaHRcbiAqIEBwYXJhbSB7bnVtYmVyfSBuZWFyIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBmYXIgRmFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQucGVyc3BlY3RpdmUgPSBmdW5jdGlvbiAob3V0LCBmb3Z5LCBhc3BlY3QsIG5lYXIsIGZhcikge1xuICAgIHZhciBmID0gMS4wIC8gTWF0aC50YW4oZm92eSAvIDIpLFxuICAgICAgICBuZiA9IDEgLyAobmVhciAtIGZhcik7XG4gICAgb3V0WzBdID0gZiAvIGFzcGVjdDtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IGY7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDA7XG4gICAgb3V0WzldID0gMDtcbiAgICBvdXRbMTBdID0gKGZhciArIG5lYXIpICogbmY7XG4gICAgb3V0WzExXSA9IC0xO1xuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAoMiAqIGZhciAqIG5lYXIpICogbmY7XG4gICAgb3V0WzE1XSA9IDA7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcGVyc3BlY3RpdmUgcHJvamVjdGlvbiBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gZmllbGQgb2Ygdmlldy5cbiAqIFRoaXMgaXMgcHJpbWFyaWx5IHVzZWZ1bCBmb3IgZ2VuZXJhdGluZyBwcm9qZWN0aW9uIG1hdHJpY2VzIHRvIGJlIHVzZWRcbiAqIHdpdGggdGhlIHN0aWxsIGV4cGVyaWVtZW50YWwgV2ViVlIgQVBJLlxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cbiAqIEBwYXJhbSB7bnVtYmVyfSBmb3YgT2JqZWN0IGNvbnRhaW5pbmcgdGhlIGZvbGxvd2luZyB2YWx1ZXM6IHVwRGVncmVlcywgZG93bkRlZ3JlZXMsIGxlZnREZWdyZWVzLCByaWdodERlZ3JlZXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBuZWFyIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBmYXIgRmFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQucGVyc3BlY3RpdmVGcm9tRmllbGRPZlZpZXcgPSBmdW5jdGlvbiAob3V0LCBmb3YsIG5lYXIsIGZhcikge1xuICAgIHZhciB1cFRhbiA9IE1hdGgudGFuKGZvdi51cERlZ3JlZXMgKiBNYXRoLlBJLzE4MC4wKSxcbiAgICAgICAgZG93blRhbiA9IE1hdGgudGFuKGZvdi5kb3duRGVncmVlcyAqIE1hdGguUEkvMTgwLjApLFxuICAgICAgICBsZWZ0VGFuID0gTWF0aC50YW4oZm92LmxlZnREZWdyZWVzICogTWF0aC5QSS8xODAuMCksXG4gICAgICAgIHJpZ2h0VGFuID0gTWF0aC50YW4oZm92LnJpZ2h0RGVncmVlcyAqIE1hdGguUEkvMTgwLjApLFxuICAgICAgICB4U2NhbGUgPSAyLjAgLyAobGVmdFRhbiArIHJpZ2h0VGFuKSxcbiAgICAgICAgeVNjYWxlID0gMi4wIC8gKHVwVGFuICsgZG93blRhbik7XG5cbiAgICBvdXRbMF0gPSB4U2NhbGU7XG4gICAgb3V0WzFdID0gMC4wO1xuICAgIG91dFsyXSA9IDAuMDtcbiAgICBvdXRbM10gPSAwLjA7XG4gICAgb3V0WzRdID0gMC4wO1xuICAgIG91dFs1XSA9IHlTY2FsZTtcbiAgICBvdXRbNl0gPSAwLjA7XG4gICAgb3V0WzddID0gMC4wO1xuICAgIG91dFs4XSA9IC0oKGxlZnRUYW4gLSByaWdodFRhbikgKiB4U2NhbGUgKiAwLjUpO1xuICAgIG91dFs5XSA9ICgodXBUYW4gLSBkb3duVGFuKSAqIHlTY2FsZSAqIDAuNSk7XG4gICAgb3V0WzEwXSA9IGZhciAvIChuZWFyIC0gZmFyKTtcbiAgICBvdXRbMTFdID0gLTEuMDtcbiAgICBvdXRbMTJdID0gMC4wO1xuICAgIG91dFsxM10gPSAwLjA7XG4gICAgb3V0WzE0XSA9IChmYXIgKiBuZWFyKSAvIChuZWFyIC0gZmFyKTtcbiAgICBvdXRbMTVdID0gMC4wO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgb3J0aG9nb25hbCBwcm9qZWN0aW9uIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBib3VuZHNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge251bWJlcn0gbGVmdCBMZWZ0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gcmlnaHQgUmlnaHQgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBib3R0b20gQm90dG9tIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gdG9wIFRvcCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5vcnRobyA9IGZ1bmN0aW9uIChvdXQsIGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyKSB7XG4gICAgdmFyIGxyID0gMSAvIChsZWZ0IC0gcmlnaHQpLFxuICAgICAgICBidCA9IDEgLyAoYm90dG9tIC0gdG9wKSxcbiAgICAgICAgbmYgPSAxIC8gKG5lYXIgLSBmYXIpO1xuICAgIG91dFswXSA9IC0yICogbHI7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSAtMiAqIGJ0O1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAwO1xuICAgIG91dFs5XSA9IDA7XG4gICAgb3V0WzEwXSA9IDIgKiBuZjtcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gKGxlZnQgKyByaWdodCkgKiBscjtcbiAgICBvdXRbMTNdID0gKHRvcCArIGJvdHRvbSkgKiBidDtcbiAgICBvdXRbMTRdID0gKGZhciArIG5lYXIpICogbmY7XG4gICAgb3V0WzE1XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgbG9vay1hdCBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gZXllIHBvc2l0aW9uLCBmb2NhbCBwb2ludCwgYW5kIHVwIGF4aXNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge3ZlYzN9IGV5ZSBQb3NpdGlvbiBvZiB0aGUgdmlld2VyXG4gKiBAcGFyYW0ge3ZlYzN9IGNlbnRlciBQb2ludCB0aGUgdmlld2VyIGlzIGxvb2tpbmcgYXRcbiAqIEBwYXJhbSB7dmVjM30gdXAgdmVjMyBwb2ludGluZyB1cFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0Lmxvb2tBdCA9IGZ1bmN0aW9uIChvdXQsIGV5ZSwgY2VudGVyLCB1cCkge1xuICAgIHZhciB4MCwgeDEsIHgyLCB5MCwgeTEsIHkyLCB6MCwgejEsIHoyLCBsZW4sXG4gICAgICAgIGV5ZXggPSBleWVbMF0sXG4gICAgICAgIGV5ZXkgPSBleWVbMV0sXG4gICAgICAgIGV5ZXogPSBleWVbMl0sXG4gICAgICAgIHVweCA9IHVwWzBdLFxuICAgICAgICB1cHkgPSB1cFsxXSxcbiAgICAgICAgdXB6ID0gdXBbMl0sXG4gICAgICAgIGNlbnRlcnggPSBjZW50ZXJbMF0sXG4gICAgICAgIGNlbnRlcnkgPSBjZW50ZXJbMV0sXG4gICAgICAgIGNlbnRlcnogPSBjZW50ZXJbMl07XG5cbiAgICBpZiAoTWF0aC5hYnMoZXlleCAtIGNlbnRlcngpIDwgZ2xNYXRyaXguRVBTSUxPTiAmJlxuICAgICAgICBNYXRoLmFicyhleWV5IC0gY2VudGVyeSkgPCBnbE1hdHJpeC5FUFNJTE9OICYmXG4gICAgICAgIE1hdGguYWJzKGV5ZXogLSBjZW50ZXJ6KSA8IGdsTWF0cml4LkVQU0lMT04pIHtcbiAgICAgICAgcmV0dXJuIG1hdDQuaWRlbnRpdHkob3V0KTtcbiAgICB9XG5cbiAgICB6MCA9IGV5ZXggLSBjZW50ZXJ4O1xuICAgIHoxID0gZXlleSAtIGNlbnRlcnk7XG4gICAgejIgPSBleWV6IC0gY2VudGVyejtcblxuICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQoejAgKiB6MCArIHoxICogejEgKyB6MiAqIHoyKTtcbiAgICB6MCAqPSBsZW47XG4gICAgejEgKj0gbGVuO1xuICAgIHoyICo9IGxlbjtcblxuICAgIHgwID0gdXB5ICogejIgLSB1cHogKiB6MTtcbiAgICB4MSA9IHVweiAqIHowIC0gdXB4ICogejI7XG4gICAgeDIgPSB1cHggKiB6MSAtIHVweSAqIHowO1xuICAgIGxlbiA9IE1hdGguc3FydCh4MCAqIHgwICsgeDEgKiB4MSArIHgyICogeDIpO1xuICAgIGlmICghbGVuKSB7XG4gICAgICAgIHgwID0gMDtcbiAgICAgICAgeDEgPSAwO1xuICAgICAgICB4MiA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGVuID0gMSAvIGxlbjtcbiAgICAgICAgeDAgKj0gbGVuO1xuICAgICAgICB4MSAqPSBsZW47XG4gICAgICAgIHgyICo9IGxlbjtcbiAgICB9XG5cbiAgICB5MCA9IHoxICogeDIgLSB6MiAqIHgxO1xuICAgIHkxID0gejIgKiB4MCAtIHowICogeDI7XG4gICAgeTIgPSB6MCAqIHgxIC0gejEgKiB4MDtcblxuICAgIGxlbiA9IE1hdGguc3FydCh5MCAqIHkwICsgeTEgKiB5MSArIHkyICogeTIpO1xuICAgIGlmICghbGVuKSB7XG4gICAgICAgIHkwID0gMDtcbiAgICAgICAgeTEgPSAwO1xuICAgICAgICB5MiA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGVuID0gMSAvIGxlbjtcbiAgICAgICAgeTAgKj0gbGVuO1xuICAgICAgICB5MSAqPSBsZW47XG4gICAgICAgIHkyICo9IGxlbjtcbiAgICB9XG5cbiAgICBvdXRbMF0gPSB4MDtcbiAgICBvdXRbMV0gPSB5MDtcbiAgICBvdXRbMl0gPSB6MDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IHgxO1xuICAgIG91dFs1XSA9IHkxO1xuICAgIG91dFs2XSA9IHoxO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0geDI7XG4gICAgb3V0WzldID0geTI7XG4gICAgb3V0WzEwXSA9IHoyO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSAtKHgwICogZXlleCArIHgxICogZXlleSArIHgyICogZXlleik7XG4gICAgb3V0WzEzXSA9IC0oeTAgKiBleWV4ICsgeTEgKiBleWV5ICsgeTIgKiBleWV6KTtcbiAgICBvdXRbMTRdID0gLSh6MCAqIGV5ZXggKyB6MSAqIGV5ZXkgKyB6MiAqIGV5ZXopO1xuICAgIG91dFsxNV0gPSAxO1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIG1hdDRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG1hdCBtYXRyaXggdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hdHJpeFxuICovXG5tYXQ0LnN0ciA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuICdtYXQ0KCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnLCAnICsgYVsyXSArICcsICcgKyBhWzNdICsgJywgJyArXG4gICAgICAgICAgICAgICAgICAgIGFbNF0gKyAnLCAnICsgYVs1XSArICcsICcgKyBhWzZdICsgJywgJyArIGFbN10gKyAnLCAnICtcbiAgICAgICAgICAgICAgICAgICAgYVs4XSArICcsICcgKyBhWzldICsgJywgJyArIGFbMTBdICsgJywgJyArIGFbMTFdICsgJywgJyArIFxuICAgICAgICAgICAgICAgICAgICBhWzEyXSArICcsICcgKyBhWzEzXSArICcsICcgKyBhWzE0XSArICcsICcgKyBhWzE1XSArICcpJztcbn07XG5cbi8qKlxuICogUmV0dXJucyBGcm9iZW5pdXMgbm9ybSBvZiBhIG1hdDRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byBjYWxjdWxhdGUgRnJvYmVuaXVzIG5vcm0gb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IEZyb2Jlbml1cyBub3JtXG4gKi9cbm1hdDQuZnJvYiA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuKE1hdGguc3FydChNYXRoLnBvdyhhWzBdLCAyKSArIE1hdGgucG93KGFbMV0sIDIpICsgTWF0aC5wb3coYVsyXSwgMikgKyBNYXRoLnBvdyhhWzNdLCAyKSArIE1hdGgucG93KGFbNF0sIDIpICsgTWF0aC5wb3coYVs1XSwgMikgKyBNYXRoLnBvdyhhWzZdLCAyKSArIE1hdGgucG93KGFbN10sIDIpICsgTWF0aC5wb3coYVs4XSwgMikgKyBNYXRoLnBvdyhhWzldLCAyKSArIE1hdGgucG93KGFbMTBdLCAyKSArIE1hdGgucG93KGFbMTFdLCAyKSArIE1hdGgucG93KGFbMTJdLCAyKSArIE1hdGgucG93KGFbMTNdLCAyKSArIE1hdGgucG93KGFbMTRdLCAyKSArIE1hdGgucG93KGFbMTVdLCAyKSApKVxufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hdDQ7XG4iLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTUsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLiAqL1xuXG52YXIgZ2xNYXRyaXggPSByZXF1aXJlKFwiLi9jb21tb24uanNcIik7XG52YXIgbWF0MyA9IHJlcXVpcmUoXCIuL21hdDMuanNcIik7XG52YXIgdmVjMyA9IHJlcXVpcmUoXCIuL3ZlYzMuanNcIik7XG52YXIgdmVjNCA9IHJlcXVpcmUoXCIuL3ZlYzQuanNcIik7XG5cbi8qKlxuICogQGNsYXNzIFF1YXRlcm5pb25cbiAqIEBuYW1lIHF1YXRcbiAqL1xudmFyIHF1YXQgPSB7fTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IHF1YXRcbiAqXG4gKiBAcmV0dXJucyB7cXVhdH0gYSBuZXcgcXVhdGVybmlvblxuICovXG5xdWF0LmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtcbiAgICBvdXRbMF0gPSAwO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNldHMgYSBxdWF0ZXJuaW9uIHRvIHJlcHJlc2VudCB0aGUgc2hvcnRlc3Qgcm90YXRpb24gZnJvbSBvbmVcbiAqIHZlY3RvciB0byBhbm90aGVyLlxuICpcbiAqIEJvdGggdmVjdG9ycyBhcmUgYXNzdW1lZCB0byBiZSB1bml0IGxlbmd0aC5cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb24uXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGluaXRpYWwgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIGRlc3RpbmF0aW9uIHZlY3RvclxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LnJvdGF0aW9uVG8gPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRtcHZlYzMgPSB2ZWMzLmNyZWF0ZSgpO1xuICAgIHZhciB4VW5pdFZlYzMgPSB2ZWMzLmZyb21WYWx1ZXMoMSwwLDApO1xuICAgIHZhciB5VW5pdFZlYzMgPSB2ZWMzLmZyb21WYWx1ZXMoMCwxLDApO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgICAgICB2YXIgZG90ID0gdmVjMy5kb3QoYSwgYik7XG4gICAgICAgIGlmIChkb3QgPCAtMC45OTk5OTkpIHtcbiAgICAgICAgICAgIHZlYzMuY3Jvc3ModG1wdmVjMywgeFVuaXRWZWMzLCBhKTtcbiAgICAgICAgICAgIGlmICh2ZWMzLmxlbmd0aCh0bXB2ZWMzKSA8IDAuMDAwMDAxKVxuICAgICAgICAgICAgICAgIHZlYzMuY3Jvc3ModG1wdmVjMywgeVVuaXRWZWMzLCBhKTtcbiAgICAgICAgICAgIHZlYzMubm9ybWFsaXplKHRtcHZlYzMsIHRtcHZlYzMpO1xuICAgICAgICAgICAgcXVhdC5zZXRBeGlzQW5nbGUob3V0LCB0bXB2ZWMzLCBNYXRoLlBJKTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0gZWxzZSBpZiAoZG90ID4gMC45OTk5OTkpIHtcbiAgICAgICAgICAgIG91dFswXSA9IDA7XG4gICAgICAgICAgICBvdXRbMV0gPSAwO1xuICAgICAgICAgICAgb3V0WzJdID0gMDtcbiAgICAgICAgICAgIG91dFszXSA9IDE7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmVjMy5jcm9zcyh0bXB2ZWMzLCBhLCBiKTtcbiAgICAgICAgICAgIG91dFswXSA9IHRtcHZlYzNbMF07XG4gICAgICAgICAgICBvdXRbMV0gPSB0bXB2ZWMzWzFdO1xuICAgICAgICAgICAgb3V0WzJdID0gdG1wdmVjM1syXTtcbiAgICAgICAgICAgIG91dFszXSA9IDEgKyBkb3Q7XG4gICAgICAgICAgICByZXR1cm4gcXVhdC5ub3JtYWxpemUob3V0LCBvdXQpO1xuICAgICAgICB9XG4gICAgfTtcbn0pKCk7XG5cbi8qKlxuICogU2V0cyB0aGUgc3BlY2lmaWVkIHF1YXRlcm5pb24gd2l0aCB2YWx1ZXMgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW5cbiAqIGF4ZXMuIEVhY2ggYXhpcyBpcyBhIHZlYzMgYW5kIGlzIGV4cGVjdGVkIHRvIGJlIHVuaXQgbGVuZ3RoIGFuZFxuICogcGVycGVuZGljdWxhciB0byBhbGwgb3RoZXIgc3BlY2lmaWVkIGF4ZXMuXG4gKlxuICogQHBhcmFtIHt2ZWMzfSB2aWV3ICB0aGUgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgdmlld2luZyBkaXJlY3Rpb25cbiAqIEBwYXJhbSB7dmVjM30gcmlnaHQgdGhlIHZlY3RvciByZXByZXNlbnRpbmcgdGhlIGxvY2FsIFwicmlnaHRcIiBkaXJlY3Rpb25cbiAqIEBwYXJhbSB7dmVjM30gdXAgICAgdGhlIHZlY3RvciByZXByZXNlbnRpbmcgdGhlIGxvY2FsIFwidXBcIiBkaXJlY3Rpb25cbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xucXVhdC5zZXRBeGVzID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciBtYXRyID0gbWF0My5jcmVhdGUoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbihvdXQsIHZpZXcsIHJpZ2h0LCB1cCkge1xuICAgICAgICBtYXRyWzBdID0gcmlnaHRbMF07XG4gICAgICAgIG1hdHJbM10gPSByaWdodFsxXTtcbiAgICAgICAgbWF0cls2XSA9IHJpZ2h0WzJdO1xuXG4gICAgICAgIG1hdHJbMV0gPSB1cFswXTtcbiAgICAgICAgbWF0cls0XSA9IHVwWzFdO1xuICAgICAgICBtYXRyWzddID0gdXBbMl07XG5cbiAgICAgICAgbWF0clsyXSA9IC12aWV3WzBdO1xuICAgICAgICBtYXRyWzVdID0gLXZpZXdbMV07XG4gICAgICAgIG1hdHJbOF0gPSAtdmlld1syXTtcblxuICAgICAgICByZXR1cm4gcXVhdC5ub3JtYWxpemUob3V0LCBxdWF0LmZyb21NYXQzKG91dCwgbWF0cikpO1xuICAgIH07XG59KSgpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgcXVhdCBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIHF1YXRlcm5pb25cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdGVybmlvbiB0byBjbG9uZVxuICogQHJldHVybnMge3F1YXR9IGEgbmV3IHF1YXRlcm5pb25cbiAqIEBmdW5jdGlvblxuICovXG5xdWF0LmNsb25lID0gdmVjNC5jbG9uZTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHF1YXQgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHcgVyBjb21wb25lbnRcbiAqIEByZXR1cm5zIHtxdWF0fSBhIG5ldyBxdWF0ZXJuaW9uXG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5mcm9tVmFsdWVzID0gdmVjNC5mcm9tVmFsdWVzO1xuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSBxdWF0IHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSB0aGUgc291cmNlIHF1YXRlcm5pb25cbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqIEBmdW5jdGlvblxuICovXG5xdWF0LmNvcHkgPSB2ZWM0LmNvcHk7XG5cbi8qKlxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgcXVhdCB0byB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0gdyBXIGNvbXBvbmVudFxuICogQHJldHVybnMge3F1YXR9IG91dFxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQuc2V0ID0gdmVjNC5zZXQ7XG5cbi8qKlxuICogU2V0IGEgcXVhdCB0byB0aGUgaWRlbnRpdHkgcXVhdGVybmlvblxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LmlkZW50aXR5ID0gZnVuY3Rpb24ob3V0KSB7XG4gICAgb3V0WzBdID0gMDtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTZXRzIGEgcXVhdCBmcm9tIHRoZSBnaXZlbiBhbmdsZSBhbmQgcm90YXRpb24gYXhpcyxcbiAqIHRoZW4gcmV0dXJucyBpdC5cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7dmVjM30gYXhpcyB0aGUgYXhpcyBhcm91bmQgd2hpY2ggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSBpbiByYWRpYW5zXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiovXG5xdWF0LnNldEF4aXNBbmdsZSA9IGZ1bmN0aW9uKG91dCwgYXhpcywgcmFkKSB7XG4gICAgcmFkID0gcmFkICogMC41O1xuICAgIHZhciBzID0gTWF0aC5zaW4ocmFkKTtcbiAgICBvdXRbMF0gPSBzICogYXhpc1swXTtcbiAgICBvdXRbMV0gPSBzICogYXhpc1sxXTtcbiAgICBvdXRbMl0gPSBzICogYXhpc1syXTtcbiAgICBvdXRbM10gPSBNYXRoLmNvcyhyYWQpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFkZHMgdHdvIHF1YXQnc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3F1YXR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5hZGQgPSB2ZWM0LmFkZDtcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byBxdWF0J3NcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtxdWF0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0Lm11bHRpcGx5ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgdmFyIGF4ID0gYVswXSwgYXkgPSBhWzFdLCBheiA9IGFbMl0sIGF3ID0gYVszXSxcbiAgICAgICAgYnggPSBiWzBdLCBieSA9IGJbMV0sIGJ6ID0gYlsyXSwgYncgPSBiWzNdO1xuXG4gICAgb3V0WzBdID0gYXggKiBidyArIGF3ICogYnggKyBheSAqIGJ6IC0gYXogKiBieTtcbiAgICBvdXRbMV0gPSBheSAqIGJ3ICsgYXcgKiBieSArIGF6ICogYnggLSBheCAqIGJ6O1xuICAgIG91dFsyXSA9IGF6ICogYncgKyBhdyAqIGJ6ICsgYXggKiBieSAtIGF5ICogYng7XG4gICAgb3V0WzNdID0gYXcgKiBidyAtIGF4ICogYnggLSBheSAqIGJ5IC0gYXogKiBiejtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHF1YXQubXVsdGlwbHl9XG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5tdWwgPSBxdWF0Lm11bHRpcGx5O1xuXG4vKipcbiAqIFNjYWxlcyBhIHF1YXQgYnkgYSBzY2FsYXIgbnVtYmVyXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7cXVhdH0gYSB0aGUgdmVjdG9yIHRvIHNjYWxlXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIHZlY3RvciBieVxuICogQHJldHVybnMge3F1YXR9IG91dFxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQuc2NhbGUgPSB2ZWM0LnNjYWxlO1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBxdWF0ZXJuaW9uIGJ5IHRoZSBnaXZlbiBhbmdsZSBhYm91dCB0aGUgWCBheGlzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgcXVhdCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkIGFuZ2xlIChpbiByYWRpYW5zKSB0byByb3RhdGVcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xucXVhdC5yb3RhdGVYID0gZnVuY3Rpb24gKG91dCwgYSwgcmFkKSB7XG4gICAgcmFkICo9IDAuNTsgXG5cbiAgICB2YXIgYXggPSBhWzBdLCBheSA9IGFbMV0sIGF6ID0gYVsyXSwgYXcgPSBhWzNdLFxuICAgICAgICBieCA9IE1hdGguc2luKHJhZCksIGJ3ID0gTWF0aC5jb3MocmFkKTtcblxuICAgIG91dFswXSA9IGF4ICogYncgKyBhdyAqIGJ4O1xuICAgIG91dFsxXSA9IGF5ICogYncgKyBheiAqIGJ4O1xuICAgIG91dFsyXSA9IGF6ICogYncgLSBheSAqIGJ4O1xuICAgIG91dFszXSA9IGF3ICogYncgLSBheCAqIGJ4O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBxdWF0ZXJuaW9uIGJ5IHRoZSBnaXZlbiBhbmdsZSBhYm91dCB0aGUgWSBheGlzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgcXVhdCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkIGFuZ2xlIChpbiByYWRpYW5zKSB0byByb3RhdGVcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xucXVhdC5yb3RhdGVZID0gZnVuY3Rpb24gKG91dCwgYSwgcmFkKSB7XG4gICAgcmFkICo9IDAuNTsgXG5cbiAgICB2YXIgYXggPSBhWzBdLCBheSA9IGFbMV0sIGF6ID0gYVsyXSwgYXcgPSBhWzNdLFxuICAgICAgICBieSA9IE1hdGguc2luKHJhZCksIGJ3ID0gTWF0aC5jb3MocmFkKTtcblxuICAgIG91dFswXSA9IGF4ICogYncgLSBheiAqIGJ5O1xuICAgIG91dFsxXSA9IGF5ICogYncgKyBhdyAqIGJ5O1xuICAgIG91dFsyXSA9IGF6ICogYncgKyBheCAqIGJ5O1xuICAgIG91dFszXSA9IGF3ICogYncgLSBheSAqIGJ5O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBxdWF0ZXJuaW9uIGJ5IHRoZSBnaXZlbiBhbmdsZSBhYm91dCB0aGUgWiBheGlzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgcXVhdCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkIGFuZ2xlIChpbiByYWRpYW5zKSB0byByb3RhdGVcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xucXVhdC5yb3RhdGVaID0gZnVuY3Rpb24gKG91dCwgYSwgcmFkKSB7XG4gICAgcmFkICo9IDAuNTsgXG5cbiAgICB2YXIgYXggPSBhWzBdLCBheSA9IGFbMV0sIGF6ID0gYVsyXSwgYXcgPSBhWzNdLFxuICAgICAgICBieiA9IE1hdGguc2luKHJhZCksIGJ3ID0gTWF0aC5jb3MocmFkKTtcblxuICAgIG91dFswXSA9IGF4ICogYncgKyBheSAqIGJ6O1xuICAgIG91dFsxXSA9IGF5ICogYncgLSBheCAqIGJ6O1xuICAgIG91dFsyXSA9IGF6ICogYncgKyBhdyAqIGJ6O1xuICAgIG91dFszXSA9IGF3ICogYncgLSBheiAqIGJ6O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIFcgY29tcG9uZW50IG9mIGEgcXVhdCBmcm9tIHRoZSBYLCBZLCBhbmQgWiBjb21wb25lbnRzLlxuICogQXNzdW1lcyB0aGF0IHF1YXRlcm5pb24gaXMgMSB1bml0IGluIGxlbmd0aC5cbiAqIEFueSBleGlzdGluZyBXIGNvbXBvbmVudCB3aWxsIGJlIGlnbm9yZWQuXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdCB0byBjYWxjdWxhdGUgVyBjb21wb25lbnQgb2ZcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xucXVhdC5jYWxjdWxhdGVXID0gZnVuY3Rpb24gKG91dCwgYSkge1xuICAgIHZhciB4ID0gYVswXSwgeSA9IGFbMV0sIHogPSBhWzJdO1xuXG4gICAgb3V0WzBdID0geDtcbiAgICBvdXRbMV0gPSB5O1xuICAgIG91dFsyXSA9IHo7XG4gICAgb3V0WzNdID0gTWF0aC5zcXJ0KE1hdGguYWJzKDEuMCAtIHggKiB4IC0geSAqIHkgLSB6ICogeikpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byBxdWF0J3NcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7cXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcbiAqIEBmdW5jdGlvblxuICovXG5xdWF0LmRvdCA9IHZlYzQuZG90O1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gcXVhdCdzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7cXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50IGJldHdlZW4gdGhlIHR3byBpbnB1dHNcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqIEBmdW5jdGlvblxuICovXG5xdWF0LmxlcnAgPSB2ZWM0LmxlcnA7XG5cbi8qKlxuICogUGVyZm9ybXMgYSBzcGhlcmljYWwgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gcXVhdFxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3F1YXR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQuc2xlcnAgPSBmdW5jdGlvbiAob3V0LCBhLCBiLCB0KSB7XG4gICAgLy8gYmVuY2htYXJrczpcbiAgICAvLyAgICBodHRwOi8vanNwZXJmLmNvbS9xdWF0ZXJuaW9uLXNsZXJwLWltcGxlbWVudGF0aW9uc1xuXG4gICAgdmFyIGF4ID0gYVswXSwgYXkgPSBhWzFdLCBheiA9IGFbMl0sIGF3ID0gYVszXSxcbiAgICAgICAgYnggPSBiWzBdLCBieSA9IGJbMV0sIGJ6ID0gYlsyXSwgYncgPSBiWzNdO1xuXG4gICAgdmFyICAgICAgICBvbWVnYSwgY29zb20sIHNpbm9tLCBzY2FsZTAsIHNjYWxlMTtcblxuICAgIC8vIGNhbGMgY29zaW5lXG4gICAgY29zb20gPSBheCAqIGJ4ICsgYXkgKiBieSArIGF6ICogYnogKyBhdyAqIGJ3O1xuICAgIC8vIGFkanVzdCBzaWducyAoaWYgbmVjZXNzYXJ5KVxuICAgIGlmICggY29zb20gPCAwLjAgKSB7XG4gICAgICAgIGNvc29tID0gLWNvc29tO1xuICAgICAgICBieCA9IC0gYng7XG4gICAgICAgIGJ5ID0gLSBieTtcbiAgICAgICAgYnogPSAtIGJ6O1xuICAgICAgICBidyA9IC0gYnc7XG4gICAgfVxuICAgIC8vIGNhbGN1bGF0ZSBjb2VmZmljaWVudHNcbiAgICBpZiAoICgxLjAgLSBjb3NvbSkgPiAwLjAwMDAwMSApIHtcbiAgICAgICAgLy8gc3RhbmRhcmQgY2FzZSAoc2xlcnApXG4gICAgICAgIG9tZWdhICA9IE1hdGguYWNvcyhjb3NvbSk7XG4gICAgICAgIHNpbm9tICA9IE1hdGguc2luKG9tZWdhKTtcbiAgICAgICAgc2NhbGUwID0gTWF0aC5zaW4oKDEuMCAtIHQpICogb21lZ2EpIC8gc2lub207XG4gICAgICAgIHNjYWxlMSA9IE1hdGguc2luKHQgKiBvbWVnYSkgLyBzaW5vbTtcbiAgICB9IGVsc2UgeyAgICAgICAgXG4gICAgICAgIC8vIFwiZnJvbVwiIGFuZCBcInRvXCIgcXVhdGVybmlvbnMgYXJlIHZlcnkgY2xvc2UgXG4gICAgICAgIC8vICAuLi4gc28gd2UgY2FuIGRvIGEgbGluZWFyIGludGVycG9sYXRpb25cbiAgICAgICAgc2NhbGUwID0gMS4wIC0gdDtcbiAgICAgICAgc2NhbGUxID0gdDtcbiAgICB9XG4gICAgLy8gY2FsY3VsYXRlIGZpbmFsIHZhbHVlc1xuICAgIG91dFswXSA9IHNjYWxlMCAqIGF4ICsgc2NhbGUxICogYng7XG4gICAgb3V0WzFdID0gc2NhbGUwICogYXkgKyBzY2FsZTEgKiBieTtcbiAgICBvdXRbMl0gPSBzY2FsZTAgKiBheiArIHNjYWxlMSAqIGJ6O1xuICAgIG91dFszXSA9IHNjYWxlMCAqIGF3ICsgc2NhbGUxICogYnc7XG4gICAgXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUGVyZm9ybXMgYSBzcGhlcmljYWwgbGluZWFyIGludGVycG9sYXRpb24gd2l0aCB0d28gY29udHJvbCBwb2ludHNcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtxdWF0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtxdWF0fSBjIHRoZSB0aGlyZCBvcGVyYW5kXG4gKiBAcGFyYW0ge3F1YXR9IGQgdGhlIGZvdXJ0aCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudFxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LnNxbGVycCA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciB0ZW1wMSA9IHF1YXQuY3JlYXRlKCk7XG4gIHZhciB0ZW1wMiA9IHF1YXQuY3JlYXRlKCk7XG4gIFxuICByZXR1cm4gZnVuY3Rpb24gKG91dCwgYSwgYiwgYywgZCwgdCkge1xuICAgIHF1YXQuc2xlcnAodGVtcDEsIGEsIGQsIHQpO1xuICAgIHF1YXQuc2xlcnAodGVtcDIsIGIsIGMsIHQpO1xuICAgIHF1YXQuc2xlcnAob3V0LCB0ZW1wMSwgdGVtcDIsIDIgKiB0ICogKDEgLSB0KSk7XG4gICAgXG4gICAgcmV0dXJuIG91dDtcbiAgfTtcbn0oKSk7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgaW52ZXJzZSBvZiBhIHF1YXRcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0IHRvIGNhbGN1bGF0ZSBpbnZlcnNlIG9mXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQuaW52ZXJ0ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXSxcbiAgICAgICAgZG90ID0gYTAqYTAgKyBhMSphMSArIGEyKmEyICsgYTMqYTMsXG4gICAgICAgIGludkRvdCA9IGRvdCA/IDEuMC9kb3QgOiAwO1xuICAgIFxuICAgIC8vIFRPRE86IFdvdWxkIGJlIGZhc3RlciB0byByZXR1cm4gWzAsMCwwLDBdIGltbWVkaWF0ZWx5IGlmIGRvdCA9PSAwXG5cbiAgICBvdXRbMF0gPSAtYTAqaW52RG90O1xuICAgIG91dFsxXSA9IC1hMSppbnZEb3Q7XG4gICAgb3V0WzJdID0gLWEyKmludkRvdDtcbiAgICBvdXRbM10gPSBhMyppbnZEb3Q7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgY29uanVnYXRlIG9mIGEgcXVhdFxuICogSWYgdGhlIHF1YXRlcm5pb24gaXMgbm9ybWFsaXplZCwgdGhpcyBmdW5jdGlvbiBpcyBmYXN0ZXIgdGhhbiBxdWF0LmludmVyc2UgYW5kIHByb2R1Y2VzIHRoZSBzYW1lIHJlc3VsdC5cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0IHRvIGNhbGN1bGF0ZSBjb25qdWdhdGUgb2ZcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xucXVhdC5jb25qdWdhdGUgPSBmdW5jdGlvbiAob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gLWFbMF07XG4gICAgb3V0WzFdID0gLWFbMV07XG4gICAgb3V0WzJdID0gLWFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgYSBxdWF0XG4gKlxuICogQHBhcmFtIHtxdWF0fSBhIHZlY3RvciB0byBjYWxjdWxhdGUgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBsZW5ndGggb2YgYVxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQubGVuZ3RoID0gdmVjNC5sZW5ndGg7XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBxdWF0Lmxlbmd0aH1cbiAqIEBmdW5jdGlvblxuICovXG5xdWF0LmxlbiA9IHF1YXQubGVuZ3RoO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIGEgcXVhdFxuICpcbiAqIEBwYXJhbSB7cXVhdH0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIHNxdWFyZWQgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGxlbmd0aCBvZiBhXG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5zcXVhcmVkTGVuZ3RoID0gdmVjNC5zcXVhcmVkTGVuZ3RoO1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgcXVhdC5zcXVhcmVkTGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQuc3FyTGVuID0gcXVhdC5zcXVhcmVkTGVuZ3RoO1xuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIHF1YXRcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0ZXJuaW9uIHRvIG5vcm1hbGl6ZVxuICogQHJldHVybnMge3F1YXR9IG91dFxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQubm9ybWFsaXplID0gdmVjNC5ub3JtYWxpemU7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHF1YXRlcm5pb24gZnJvbSB0aGUgZ2l2ZW4gM3gzIHJvdGF0aW9uIG1hdHJpeC5cbiAqXG4gKiBOT1RFOiBUaGUgcmVzdWx0YW50IHF1YXRlcm5pb24gaXMgbm90IG5vcm1hbGl6ZWQsIHNvIHlvdSBzaG91bGQgYmUgc3VyZVxuICogdG8gcmVub3JtYWxpemUgdGhlIHF1YXRlcm5pb24geW91cnNlbGYgd2hlcmUgbmVjZXNzYXJ5LlxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHttYXQzfSBtIHJvdGF0aW9uIG1hdHJpeFxuICogQHJldHVybnMge3F1YXR9IG91dFxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQuZnJvbU1hdDMgPSBmdW5jdGlvbihvdXQsIG0pIHtcbiAgICAvLyBBbGdvcml0aG0gaW4gS2VuIFNob2VtYWtlJ3MgYXJ0aWNsZSBpbiAxOTg3IFNJR0dSQVBIIGNvdXJzZSBub3Rlc1xuICAgIC8vIGFydGljbGUgXCJRdWF0ZXJuaW9uIENhbGN1bHVzIGFuZCBGYXN0IEFuaW1hdGlvblwiLlxuICAgIHZhciBmVHJhY2UgPSBtWzBdICsgbVs0XSArIG1bOF07XG4gICAgdmFyIGZSb290O1xuXG4gICAgaWYgKCBmVHJhY2UgPiAwLjAgKSB7XG4gICAgICAgIC8vIHx3fCA+IDEvMiwgbWF5IGFzIHdlbGwgY2hvb3NlIHcgPiAxLzJcbiAgICAgICAgZlJvb3QgPSBNYXRoLnNxcnQoZlRyYWNlICsgMS4wKTsgIC8vIDJ3XG4gICAgICAgIG91dFszXSA9IDAuNSAqIGZSb290O1xuICAgICAgICBmUm9vdCA9IDAuNS9mUm9vdDsgIC8vIDEvKDR3KVxuICAgICAgICBvdXRbMF0gPSAobVs1XS1tWzddKSpmUm9vdDtcbiAgICAgICAgb3V0WzFdID0gKG1bNl0tbVsyXSkqZlJvb3Q7XG4gICAgICAgIG91dFsyXSA9IChtWzFdLW1bM10pKmZSb290O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHx3fCA8PSAxLzJcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICBpZiAoIG1bNF0gPiBtWzBdIClcbiAgICAgICAgICBpID0gMTtcbiAgICAgICAgaWYgKCBtWzhdID4gbVtpKjMraV0gKVxuICAgICAgICAgIGkgPSAyO1xuICAgICAgICB2YXIgaiA9IChpKzEpJTM7XG4gICAgICAgIHZhciBrID0gKGkrMiklMztcbiAgICAgICAgXG4gICAgICAgIGZSb290ID0gTWF0aC5zcXJ0KG1baSozK2ldLW1baiozK2pdLW1bayozK2tdICsgMS4wKTtcbiAgICAgICAgb3V0W2ldID0gMC41ICogZlJvb3Q7XG4gICAgICAgIGZSb290ID0gMC41IC8gZlJvb3Q7XG4gICAgICAgIG91dFszXSA9IChtW2oqMytrXSAtIG1bayozK2pdKSAqIGZSb290O1xuICAgICAgICBvdXRbal0gPSAobVtqKjMraV0gKyBtW2kqMytqXSkgKiBmUm9vdDtcbiAgICAgICAgb3V0W2tdID0gKG1bayozK2ldICsgbVtpKjMra10pICogZlJvb3Q7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBxdWF0ZW5pb25cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IHZlYyB2ZWN0b3IgdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxuICovXG5xdWF0LnN0ciA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuICdxdWF0KCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnLCAnICsgYVsyXSArICcsICcgKyBhWzNdICsgJyknO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBxdWF0O1xuIiwiLyogQ29weXJpZ2h0IChjKSAyMDE1LCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblRIRSBTT0ZUV0FSRS4gKi9cblxudmFyIGdsTWF0cml4ID0gcmVxdWlyZShcIi4vY29tbW9uLmpzXCIpO1xuXG4vKipcbiAqIEBjbGFzcyAyIERpbWVuc2lvbmFsIFZlY3RvclxuICogQG5hbWUgdmVjMlxuICovXG52YXIgdmVjMiA9IHt9O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcsIGVtcHR5IHZlYzJcbiAqXG4gKiBAcmV0dXJucyB7dmVjMn0gYSBuZXcgMkQgdmVjdG9yXG4gKi9cbnZlYzIuY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDIpO1xuICAgIG91dFswXSA9IDA7XG4gICAgb3V0WzFdID0gMDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzIgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIGNsb25lXG4gKiBAcmV0dXJucyB7dmVjMn0gYSBuZXcgMkQgdmVjdG9yXG4gKi9cbnZlYzIuY2xvbmUgPSBmdW5jdGlvbihhKSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDIpO1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzIgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcmV0dXJucyB7dmVjMn0gYSBuZXcgMkQgdmVjdG9yXG4gKi9cbnZlYzIuZnJvbVZhbHVlcyA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMik7XG4gICAgb3V0WzBdID0geDtcbiAgICBvdXRbMV0gPSB5O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSB2ZWMyIHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBzb3VyY2UgdmVjdG9yXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIuY29weSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyIHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIuc2V0ID0gZnVuY3Rpb24ob3V0LCB4LCB5KSB7XG4gICAgb3V0WzBdID0geDtcbiAgICBvdXRbMV0gPSB5O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5hZGQgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTdWJ0cmFjdHMgdmVjdG9yIGIgZnJvbSB2ZWN0b3IgYVxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5zdWJ0cmFjdCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5zdWJ0cmFjdH1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMyLnN1YiA9IHZlYzIuc3VidHJhY3Q7XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLm11bHRpcGx5ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAqIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSAqIGJbMV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzIubXVsID0gdmVjMi5tdWx0aXBseTtcblxuLyoqXG4gKiBEaXZpZGVzIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIuZGl2aWRlID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAvIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSAvIGJbMV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLmRpdmlkZX1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMyLmRpdiA9IHZlYzIuZGl2aWRlO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG1pbmltdW0gb2YgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5taW4gPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBNYXRoLm1pbihhWzBdLCBiWzBdKTtcbiAgICBvdXRbMV0gPSBNYXRoLm1pbihhWzFdLCBiWzFdKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtYXhpbXVtIG9mIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIubWF4ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gTWF0aC5tYXgoYVswXSwgYlswXSk7XG4gICAgb3V0WzFdID0gTWF0aC5tYXgoYVsxXSwgYlsxXSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2NhbGVzIGEgdmVjMiBieSBhIHNjYWxhciBudW1iZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgdmVjdG9yIGJ5XG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIuc2NhbGUgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICogYjtcbiAgICBvdXRbMV0gPSBhWzFdICogYjtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBZGRzIHR3byB2ZWMyJ3MgYWZ0ZXIgc2NhbGluZyB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWVcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiIGJ5IGJlZm9yZSBhZGRpbmdcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5zY2FsZUFuZEFkZCA9IGZ1bmN0aW9uKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgKGJbMF0gKiBzY2FsZSk7XG4gICAgb3V0WzFdID0gYVsxXSArIChiWzFdICogc2NhbGUpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG52ZWMyLmRpc3RhbmNlID0gZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciB4ID0gYlswXSAtIGFbMF0sXG4gICAgICAgIHkgPSBiWzFdIC0gYVsxXTtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSk7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5kaXN0YW5jZX1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMyLmRpc3QgPSB2ZWMyLmRpc3RhbmNlO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xudmVjMi5zcXVhcmVkRGlzdGFuY2UgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHggPSBiWzBdIC0gYVswXSxcbiAgICAgICAgeSA9IGJbMV0gLSBhWzFdO1xuICAgIHJldHVybiB4KnggKyB5Knk7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5zcXVhcmVkRGlzdGFuY2V9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMi5zcXJEaXN0ID0gdmVjMi5zcXVhcmVkRGlzdGFuY2U7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gbGVuZ3RoIG9mIGFcbiAqL1xudmVjMi5sZW5ndGggPSBmdW5jdGlvbiAoYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV07XG4gICAgcmV0dXJuIE1hdGguc3FydCh4KnggKyB5KnkpO1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIubGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzIubGVuID0gdmVjMi5sZW5ndGg7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBsZW5ndGggb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgc3F1YXJlZCBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgbGVuZ3RoIG9mIGFcbiAqL1xudmVjMi5zcXVhcmVkTGVuZ3RoID0gZnVuY3Rpb24gKGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdO1xuICAgIHJldHVybiB4KnggKyB5Knk7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5zcXVhcmVkTGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzIuc3FyTGVuID0gdmVjMi5zcXVhcmVkTGVuZ3RoO1xuXG4vKipcbiAqIE5lZ2F0ZXMgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gbmVnYXRlXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIubmVnYXRlID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gLWFbMF07XG4gICAgb3V0WzFdID0gLWFbMV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgaW52ZXJzZSBvZiB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBpbnZlcnRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5pbnZlcnNlID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gIG91dFswXSA9IDEuMCAvIGFbMF07XG4gIG91dFsxXSA9IDEuMCAvIGFbMV07XG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBub3JtYWxpemVcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5ub3JtYWxpemUgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdO1xuICAgIHZhciBsZW4gPSB4KnggKyB5Knk7XG4gICAgaWYgKGxlbiA+IDApIHtcbiAgICAgICAgLy9UT0RPOiBldmFsdWF0ZSB1c2Ugb2YgZ2xtX2ludnNxcnQgaGVyZT9cbiAgICAgICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pO1xuICAgICAgICBvdXRbMF0gPSBhWzBdICogbGVuO1xuICAgICAgICBvdXRbMV0gPSBhWzFdICogbGVuO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkb3QgcHJvZHVjdCBvZiBhIGFuZCBiXG4gKi9cbnZlYzIuZG90ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdHdvIHZlYzInc1xuICogTm90ZSB0aGF0IHRoZSBjcm9zcyBwcm9kdWN0IG11c3QgYnkgZGVmaW5pdGlvbiBwcm9kdWNlIGEgM0QgdmVjdG9yXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMyLmNyb3NzID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgdmFyIHogPSBhWzBdICogYlsxXSAtIGFbMV0gKiBiWzBdO1xuICAgIG91dFswXSA9IG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gejtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50IGJldHdlZW4gdGhlIHR3byBpbnB1dHNcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5sZXJwID0gZnVuY3Rpb24gKG91dCwgYSwgYiwgdCkge1xuICAgIHZhciBheCA9IGFbMF0sXG4gICAgICAgIGF5ID0gYVsxXTtcbiAgICBvdXRbMF0gPSBheCArIHQgKiAoYlswXSAtIGF4KTtcbiAgICBvdXRbMV0gPSBheSArIHQgKiAoYlsxXSAtIGF5KTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gdmVjdG9yIHdpdGggdGhlIGdpdmVuIHNjYWxlXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGVdIExlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIHZlY3Rvci4gSWYgb21taXR0ZWQsIGEgdW5pdCB2ZWN0b3Igd2lsbCBiZSByZXR1cm5lZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLnJhbmRvbSA9IGZ1bmN0aW9uIChvdXQsIHNjYWxlKSB7XG4gICAgc2NhbGUgPSBzY2FsZSB8fCAxLjA7XG4gICAgdmFyIHIgPSBnbE1hdHJpeC5SQU5ET00oKSAqIDIuMCAqIE1hdGguUEk7XG4gICAgb3V0WzBdID0gTWF0aC5jb3MocikgKiBzY2FsZTtcbiAgICBvdXRbMV0gPSBNYXRoLnNpbihyKSAqIHNjYWxlO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzIgd2l0aCBhIG1hdDJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDJ9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIudHJhbnNmb3JtTWF0MiA9IGZ1bmN0aW9uKG91dCwgYSwgbSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV07XG4gICAgb3V0WzBdID0gbVswXSAqIHggKyBtWzJdICogeTtcbiAgICBvdXRbMV0gPSBtWzFdICogeCArIG1bM10gKiB5O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzIgd2l0aCBhIG1hdDJkXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQyZH0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi50cmFuc2Zvcm1NYXQyZCA9IGZ1bmN0aW9uKG91dCwgYSwgbSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV07XG4gICAgb3V0WzBdID0gbVswXSAqIHggKyBtWzJdICogeSArIG1bNF07XG4gICAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzNdICogeSArIG1bNV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0M1xuICogM3JkIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMSdcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDN9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIudHJhbnNmb3JtTWF0MyA9IGZ1bmN0aW9uKG91dCwgYSwgbSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV07XG4gICAgb3V0WzBdID0gbVswXSAqIHggKyBtWzNdICogeSArIG1bNl07XG4gICAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzRdICogeSArIG1bN107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0NFxuICogM3JkIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMCdcbiAqIDR0aCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzEnXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQ0fSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLnRyYW5zZm9ybU1hdDQgPSBmdW5jdGlvbihvdXQsIGEsIG0pIHtcbiAgICB2YXIgeCA9IGFbMF0sIFxuICAgICAgICB5ID0gYVsxXTtcbiAgICBvdXRbMF0gPSBtWzBdICogeCArIG1bNF0gKiB5ICsgbVsxMl07XG4gICAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzVdICogeSArIG1bMTNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFBlcmZvcm0gc29tZSBvcGVyYXRpb24gb3ZlciBhbiBhcnJheSBvZiB2ZWMycy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBhcnJheSBvZiB2ZWN0b3JzIHRvIGl0ZXJhdGUgb3ZlclxuICogQHBhcmFtIHtOdW1iZXJ9IHN0cmlkZSBOdW1iZXIgb2YgZWxlbWVudHMgYmV0d2VlbiB0aGUgc3RhcnQgb2YgZWFjaCB2ZWMyLiBJZiAwIGFzc3VtZXMgdGlnaHRseSBwYWNrZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgTnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNraXAgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCBOdW1iZXIgb2YgdmVjMnMgdG8gaXRlcmF0ZSBvdmVyLiBJZiAwIGl0ZXJhdGVzIG92ZXIgZW50aXJlIGFycmF5XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIHZlY3RvciBpbiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbYXJnXSBhZGRpdGlvbmFsIGFyZ3VtZW50IHRvIHBhc3MgdG8gZm5cbiAqIEByZXR1cm5zIHtBcnJheX0gYVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzIuZm9yRWFjaCA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgdmVjID0gdmVjMi5jcmVhdGUoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbihhLCBzdHJpZGUsIG9mZnNldCwgY291bnQsIGZuLCBhcmcpIHtcbiAgICAgICAgdmFyIGksIGw7XG4gICAgICAgIGlmKCFzdHJpZGUpIHtcbiAgICAgICAgICAgIHN0cmlkZSA9IDI7XG4gICAgICAgIH1cblxuICAgICAgICBpZighb2Zmc2V0KSB7XG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZihjb3VudCkge1xuICAgICAgICAgICAgbCA9IE1hdGgubWluKChjb3VudCAqIHN0cmlkZSkgKyBvZmZzZXQsIGEubGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGwgPSBhLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcihpID0gb2Zmc2V0OyBpIDwgbDsgaSArPSBzdHJpZGUpIHtcbiAgICAgICAgICAgIHZlY1swXSA9IGFbaV07IHZlY1sxXSA9IGFbaSsxXTtcbiAgICAgICAgICAgIGZuKHZlYywgdmVjLCBhcmcpO1xuICAgICAgICAgICAgYVtpXSA9IHZlY1swXTsgYVtpKzFdID0gdmVjWzFdO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gYTtcbiAgICB9O1xufSkoKTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgdmVjdG9yXG4gKlxuICogQHBhcmFtIHt2ZWMyfSB2ZWMgdmVjdG9yIHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2ZWN0b3JcbiAqL1xudmVjMi5zdHIgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiAndmVjMignICsgYVswXSArICcsICcgKyBhWzFdICsgJyknO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB2ZWMyO1xuIiwiLyogQ29weXJpZ2h0IChjKSAyMDE1LCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblRIRSBTT0ZUV0FSRS4gKi9cblxudmFyIGdsTWF0cml4ID0gcmVxdWlyZShcIi4vY29tbW9uLmpzXCIpO1xuXG4vKipcbiAqIEBjbGFzcyAzIERpbWVuc2lvbmFsIFZlY3RvclxuICogQG5hbWUgdmVjM1xuICovXG52YXIgdmVjMyA9IHt9O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcsIGVtcHR5IHZlYzNcbiAqXG4gKiBAcmV0dXJucyB7dmVjM30gYSBuZXcgM0QgdmVjdG9yXG4gKi9cbnZlYzMuY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDMpO1xuICAgIG91dFswXSA9IDA7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMyBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gY2xvbmVcbiAqIEByZXR1cm5zIHt2ZWMzfSBhIG5ldyAzRCB2ZWN0b3JcbiAqL1xudmVjMy5jbG9uZSA9IGZ1bmN0aW9uKGEpIHtcbiAgICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMyk7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMzIGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWMzfSBhIG5ldyAzRCB2ZWN0b3JcbiAqL1xudmVjMy5mcm9tVmFsdWVzID0gZnVuY3Rpb24oeCwgeSwgeikge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgzKTtcbiAgICBvdXRbMF0gPSB4O1xuICAgIG91dFsxXSA9IHk7XG4gICAgb3V0WzJdID0gejtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgdmVjMyB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgc291cmNlIHZlY3RvclxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLmNvcHkgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzIHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLnNldCA9IGZ1bmN0aW9uKG91dCwgeCwgeSwgeikge1xuICAgIG91dFswXSA9IHg7XG4gICAgb3V0WzFdID0geTtcbiAgICBvdXRbMl0gPSB6O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5hZGQgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgICBvdXRbMl0gPSBhWzJdICsgYlsyXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTdWJ0cmFjdHMgdmVjdG9yIGIgZnJvbSB2ZWN0b3IgYVxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5zdWJ0cmFjdCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICAgIG91dFsyXSA9IGFbMl0gLSBiWzJdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5zdWJ0cmFjdH1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMzLnN1YiA9IHZlYzMuc3VidHJhY3Q7XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLm11bHRpcGx5ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAqIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSAqIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSAqIGJbMl07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzMubXVsID0gdmVjMy5tdWx0aXBseTtcblxuLyoqXG4gKiBEaXZpZGVzIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMuZGl2aWRlID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAvIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSAvIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSAvIGJbMl07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLmRpdmlkZX1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMzLmRpdiA9IHZlYzMuZGl2aWRlO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG1pbmltdW0gb2YgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5taW4gPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBNYXRoLm1pbihhWzBdLCBiWzBdKTtcbiAgICBvdXRbMV0gPSBNYXRoLm1pbihhWzFdLCBiWzFdKTtcbiAgICBvdXRbMl0gPSBNYXRoLm1pbihhWzJdLCBiWzJdKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtYXhpbXVtIG9mIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMubWF4ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gTWF0aC5tYXgoYVswXSwgYlswXSk7XG4gICAgb3V0WzFdID0gTWF0aC5tYXgoYVsxXSwgYlsxXSk7XG4gICAgb3V0WzJdID0gTWF0aC5tYXgoYVsyXSwgYlsyXSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2NhbGVzIGEgdmVjMyBieSBhIHNjYWxhciBudW1iZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgdmVjdG9yIGJ5XG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMuc2NhbGUgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICogYjtcbiAgICBvdXRbMV0gPSBhWzFdICogYjtcbiAgICBvdXRbMl0gPSBhWzJdICogYjtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBZGRzIHR3byB2ZWMzJ3MgYWZ0ZXIgc2NhbGluZyB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWVcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiIGJ5IGJlZm9yZSBhZGRpbmdcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5zY2FsZUFuZEFkZCA9IGZ1bmN0aW9uKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgKGJbMF0gKiBzY2FsZSk7XG4gICAgb3V0WzFdID0gYVsxXSArIChiWzFdICogc2NhbGUpO1xuICAgIG91dFsyXSA9IGFbMl0gKyAoYlsyXSAqIHNjYWxlKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xudmVjMy5kaXN0YW5jZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgICB5ID0gYlsxXSAtIGFbMV0sXG4gICAgICAgIHogPSBiWzJdIC0gYVsyXTtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSArIHoqeik7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5kaXN0YW5jZX1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMzLmRpc3QgPSB2ZWMzLmRpc3RhbmNlO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xudmVjMy5zcXVhcmVkRGlzdGFuY2UgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHggPSBiWzBdIC0gYVswXSxcbiAgICAgICAgeSA9IGJbMV0gLSBhWzFdLFxuICAgICAgICB6ID0gYlsyXSAtIGFbMl07XG4gICAgcmV0dXJuIHgqeCArIHkqeSArIHoqejtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLnNxdWFyZWREaXN0YW5jZX1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMzLnNxckRpc3QgPSB2ZWMzLnNxdWFyZWREaXN0YW5jZTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBsZW5ndGggb2YgYVxuICovXG52ZWMzLmxlbmd0aCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXSxcbiAgICAgICAgeiA9IGFbMl07XG4gICAgcmV0dXJuIE1hdGguc3FydCh4KnggKyB5KnkgKyB6KnopO1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMubGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzMubGVuID0gdmVjMy5sZW5ndGg7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBsZW5ndGggb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgc3F1YXJlZCBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgbGVuZ3RoIG9mIGFcbiAqL1xudmVjMy5zcXVhcmVkTGVuZ3RoID0gZnVuY3Rpb24gKGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdLFxuICAgICAgICB6ID0gYVsyXTtcbiAgICByZXR1cm4geCp4ICsgeSp5ICsgeip6O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMuc3F1YXJlZExlbmd0aH1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMzLnNxckxlbiA9IHZlYzMuc3F1YXJlZExlbmd0aDtcblxuLyoqXG4gKiBOZWdhdGVzIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIG5lZ2F0ZVxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLm5lZ2F0ZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IC1hWzBdO1xuICAgIG91dFsxXSA9IC1hWzFdO1xuICAgIG91dFsyXSA9IC1hWzJdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGludmVyc2Ugb2YgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gaW52ZXJ0XG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMuaW52ZXJzZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICBvdXRbMF0gPSAxLjAgLyBhWzBdO1xuICBvdXRbMV0gPSAxLjAgLyBhWzFdO1xuICBvdXRbMl0gPSAxLjAgLyBhWzJdO1xuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBOb3JtYWxpemUgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gbm9ybWFsaXplXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMubm9ybWFsaXplID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXSxcbiAgICAgICAgeiA9IGFbMl07XG4gICAgdmFyIGxlbiA9IHgqeCArIHkqeSArIHoqejtcbiAgICBpZiAobGVuID4gMCkge1xuICAgICAgICAvL1RPRE86IGV2YWx1YXRlIHVzZSBvZiBnbG1faW52c3FydCBoZXJlP1xuICAgICAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gICAgICAgIG91dFswXSA9IGFbMF0gKiBsZW47XG4gICAgICAgIG91dFsxXSA9IGFbMV0gKiBsZW47XG4gICAgICAgIG91dFsyXSA9IGFbMl0gKiBsZW47XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcbiAqL1xudmVjMy5kb3QgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhWzBdICogYlswXSArIGFbMV0gKiBiWzFdICsgYVsyXSAqIGJbMl07XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMuY3Jvc3MgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICB2YXIgYXggPSBhWzBdLCBheSA9IGFbMV0sIGF6ID0gYVsyXSxcbiAgICAgICAgYnggPSBiWzBdLCBieSA9IGJbMV0sIGJ6ID0gYlsyXTtcblxuICAgIG91dFswXSA9IGF5ICogYnogLSBheiAqIGJ5O1xuICAgIG91dFsxXSA9IGF6ICogYnggLSBheCAqIGJ6O1xuICAgIG91dFsyXSA9IGF4ICogYnkgLSBheSAqIGJ4O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLmxlcnAgPSBmdW5jdGlvbiAob3V0LCBhLCBiLCB0KSB7XG4gICAgdmFyIGF4ID0gYVswXSxcbiAgICAgICAgYXkgPSBhWzFdLFxuICAgICAgICBheiA9IGFbMl07XG4gICAgb3V0WzBdID0gYXggKyB0ICogKGJbMF0gLSBheCk7XG4gICAgb3V0WzFdID0gYXkgKyB0ICogKGJbMV0gLSBheSk7XG4gICAgb3V0WzJdID0gYXogKyB0ICogKGJbMl0gLSBheik7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUGVyZm9ybXMgYSBoZXJtaXRlIGludGVycG9sYXRpb24gd2l0aCB0d28gY29udHJvbCBwb2ludHNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGMgdGhlIHRoaXJkIG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gZCB0aGUgZm91cnRoIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50IGJldHdlZW4gdGhlIHR3byBpbnB1dHNcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5oZXJtaXRlID0gZnVuY3Rpb24gKG91dCwgYSwgYiwgYywgZCwgdCkge1xuICB2YXIgZmFjdG9yVGltZXMyID0gdCAqIHQsXG4gICAgICBmYWN0b3IxID0gZmFjdG9yVGltZXMyICogKDIgKiB0IC0gMykgKyAxLFxuICAgICAgZmFjdG9yMiA9IGZhY3RvclRpbWVzMiAqICh0IC0gMikgKyB0LFxuICAgICAgZmFjdG9yMyA9IGZhY3RvclRpbWVzMiAqICh0IC0gMSksXG4gICAgICBmYWN0b3I0ID0gZmFjdG9yVGltZXMyICogKDMgLSAyICogdCk7XG4gIFxuICBvdXRbMF0gPSBhWzBdICogZmFjdG9yMSArIGJbMF0gKiBmYWN0b3IyICsgY1swXSAqIGZhY3RvcjMgKyBkWzBdICogZmFjdG9yNDtcbiAgb3V0WzFdID0gYVsxXSAqIGZhY3RvcjEgKyBiWzFdICogZmFjdG9yMiArIGNbMV0gKiBmYWN0b3IzICsgZFsxXSAqIGZhY3RvcjQ7XG4gIG91dFsyXSA9IGFbMl0gKiBmYWN0b3IxICsgYlsyXSAqIGZhY3RvcjIgKyBjWzJdICogZmFjdG9yMyArIGRbMl0gKiBmYWN0b3I0O1xuICBcbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUGVyZm9ybXMgYSBiZXppZXIgaW50ZXJwb2xhdGlvbiB3aXRoIHR3byBjb250cm9sIHBvaW50c1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYyB0aGUgdGhpcmQgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBkIHRoZSBmb3VydGggb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLmJlemllciA9IGZ1bmN0aW9uIChvdXQsIGEsIGIsIGMsIGQsIHQpIHtcbiAgdmFyIGludmVyc2VGYWN0b3IgPSAxIC0gdCxcbiAgICAgIGludmVyc2VGYWN0b3JUaW1lc1R3byA9IGludmVyc2VGYWN0b3IgKiBpbnZlcnNlRmFjdG9yLFxuICAgICAgZmFjdG9yVGltZXMyID0gdCAqIHQsXG4gICAgICBmYWN0b3IxID0gaW52ZXJzZUZhY3RvclRpbWVzVHdvICogaW52ZXJzZUZhY3RvcixcbiAgICAgIGZhY3RvcjIgPSAzICogdCAqIGludmVyc2VGYWN0b3JUaW1lc1R3byxcbiAgICAgIGZhY3RvcjMgPSAzICogZmFjdG9yVGltZXMyICogaW52ZXJzZUZhY3RvcixcbiAgICAgIGZhY3RvcjQgPSBmYWN0b3JUaW1lczIgKiB0O1xuICBcbiAgb3V0WzBdID0gYVswXSAqIGZhY3RvcjEgKyBiWzBdICogZmFjdG9yMiArIGNbMF0gKiBmYWN0b3IzICsgZFswXSAqIGZhY3RvcjQ7XG4gIG91dFsxXSA9IGFbMV0gKiBmYWN0b3IxICsgYlsxXSAqIGZhY3RvcjIgKyBjWzFdICogZmFjdG9yMyArIGRbMV0gKiBmYWN0b3I0O1xuICBvdXRbMl0gPSBhWzJdICogZmFjdG9yMSArIGJbMl0gKiBmYWN0b3IyICsgY1syXSAqIGZhY3RvcjMgKyBkWzJdICogZmFjdG9yNDtcbiAgXG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gc2NhbGVcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IFtzY2FsZV0gTGVuZ3RoIG9mIHRoZSByZXN1bHRpbmcgdmVjdG9yLiBJZiBvbW1pdHRlZCwgYSB1bml0IHZlY3RvciB3aWxsIGJlIHJldHVybmVkXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMucmFuZG9tID0gZnVuY3Rpb24gKG91dCwgc2NhbGUpIHtcbiAgICBzY2FsZSA9IHNjYWxlIHx8IDEuMDtcblxuICAgIHZhciByID0gZ2xNYXRyaXguUkFORE9NKCkgKiAyLjAgKiBNYXRoLlBJO1xuICAgIHZhciB6ID0gKGdsTWF0cml4LlJBTkRPTSgpICogMi4wKSAtIDEuMDtcbiAgICB2YXIgelNjYWxlID0gTWF0aC5zcXJ0KDEuMC16KnopICogc2NhbGU7XG5cbiAgICBvdXRbMF0gPSBNYXRoLmNvcyhyKSAqIHpTY2FsZTtcbiAgICBvdXRbMV0gPSBNYXRoLnNpbihyKSAqIHpTY2FsZTtcbiAgICBvdXRbMl0gPSB6ICogc2NhbGU7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgbWF0NC5cbiAqIDR0aCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzEnXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQ0fSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLnRyYW5zZm9ybU1hdDQgPSBmdW5jdGlvbihvdXQsIGEsIG0pIHtcbiAgICB2YXIgeCA9IGFbMF0sIHkgPSBhWzFdLCB6ID0gYVsyXSxcbiAgICAgICAgdyA9IG1bM10gKiB4ICsgbVs3XSAqIHkgKyBtWzExXSAqIHogKyBtWzE1XTtcbiAgICB3ID0gdyB8fCAxLjA7XG4gICAgb3V0WzBdID0gKG1bMF0gKiB4ICsgbVs0XSAqIHkgKyBtWzhdICogeiArIG1bMTJdKSAvIHc7XG4gICAgb3V0WzFdID0gKG1bMV0gKiB4ICsgbVs1XSAqIHkgKyBtWzldICogeiArIG1bMTNdKSAvIHc7XG4gICAgb3V0WzJdID0gKG1bMl0gKiB4ICsgbVs2XSAqIHkgKyBtWzEwXSAqIHogKyBtWzE0XSkgLyB3O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzMgd2l0aCBhIG1hdDMuXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQ0fSBtIHRoZSAzeDMgbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMudHJhbnNmb3JtTWF0MyA9IGZ1bmN0aW9uKG91dCwgYSwgbSkge1xuICAgIHZhciB4ID0gYVswXSwgeSA9IGFbMV0sIHogPSBhWzJdO1xuICAgIG91dFswXSA9IHggKiBtWzBdICsgeSAqIG1bM10gKyB6ICogbVs2XTtcbiAgICBvdXRbMV0gPSB4ICogbVsxXSArIHkgKiBtWzRdICsgeiAqIG1bN107XG4gICAgb3V0WzJdID0geCAqIG1bMl0gKyB5ICogbVs1XSArIHogKiBtWzhdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzMgd2l0aCBhIHF1YXRcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge3F1YXR9IHEgcXVhdGVybmlvbiB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLnRyYW5zZm9ybVF1YXQgPSBmdW5jdGlvbihvdXQsIGEsIHEpIHtcbiAgICAvLyBiZW5jaG1hcmtzOiBodHRwOi8vanNwZXJmLmNvbS9xdWF0ZXJuaW9uLXRyYW5zZm9ybS12ZWMzLWltcGxlbWVudGF0aW9uc1xuXG4gICAgdmFyIHggPSBhWzBdLCB5ID0gYVsxXSwgeiA9IGFbMl0sXG4gICAgICAgIHF4ID0gcVswXSwgcXkgPSBxWzFdLCBxeiA9IHFbMl0sIHF3ID0gcVszXSxcblxuICAgICAgICAvLyBjYWxjdWxhdGUgcXVhdCAqIHZlY1xuICAgICAgICBpeCA9IHF3ICogeCArIHF5ICogeiAtIHF6ICogeSxcbiAgICAgICAgaXkgPSBxdyAqIHkgKyBxeiAqIHggLSBxeCAqIHosXG4gICAgICAgIGl6ID0gcXcgKiB6ICsgcXggKiB5IC0gcXkgKiB4LFxuICAgICAgICBpdyA9IC1xeCAqIHggLSBxeSAqIHkgLSBxeiAqIHo7XG5cbiAgICAvLyBjYWxjdWxhdGUgcmVzdWx0ICogaW52ZXJzZSBxdWF0XG4gICAgb3V0WzBdID0gaXggKiBxdyArIGl3ICogLXF4ICsgaXkgKiAtcXogLSBpeiAqIC1xeTtcbiAgICBvdXRbMV0gPSBpeSAqIHF3ICsgaXcgKiAtcXkgKyBpeiAqIC1xeCAtIGl4ICogLXF6O1xuICAgIG91dFsyXSA9IGl6ICogcXcgKyBpdyAqIC1xeiArIGl4ICogLXF5IC0gaXkgKiAtcXg7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUm90YXRlIGEgM0QgdmVjdG9yIGFyb3VuZCB0aGUgeC1heGlzXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCBUaGUgcmVjZWl2aW5nIHZlYzNcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjMyBwb2ludCB0byByb3RhdGVcbiAqIEBwYXJhbSB7dmVjM30gYiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IGMgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMucm90YXRlWCA9IGZ1bmN0aW9uKG91dCwgYSwgYiwgYyl7XG4gICB2YXIgcCA9IFtdLCByPVtdO1xuXHQgIC8vVHJhbnNsYXRlIHBvaW50IHRvIHRoZSBvcmlnaW5cblx0ICBwWzBdID0gYVswXSAtIGJbMF07XG5cdCAgcFsxXSA9IGFbMV0gLSBiWzFdO1xuICBcdHBbMl0gPSBhWzJdIC0gYlsyXTtcblxuXHQgIC8vcGVyZm9ybSByb3RhdGlvblxuXHQgIHJbMF0gPSBwWzBdO1xuXHQgIHJbMV0gPSBwWzFdKk1hdGguY29zKGMpIC0gcFsyXSpNYXRoLnNpbihjKTtcblx0ICByWzJdID0gcFsxXSpNYXRoLnNpbihjKSArIHBbMl0qTWF0aC5jb3MoYyk7XG5cblx0ICAvL3RyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG5cdCAgb3V0WzBdID0gclswXSArIGJbMF07XG5cdCAgb3V0WzFdID0gclsxXSArIGJbMV07XG5cdCAgb3V0WzJdID0gclsyXSArIGJbMl07XG5cbiAgXHRyZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB5LWF4aXNcbiAqIEBwYXJhbSB7dmVjM30gb3V0IFRoZSByZWNlaXZpbmcgdmVjM1xuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWMzIHBvaW50IHRvIHJvdGF0ZVxuICogQHBhcmFtIHt2ZWMzfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gYyBUaGUgYW5nbGUgb2Ygcm90YXRpb25cbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5yb3RhdGVZID0gZnVuY3Rpb24ob3V0LCBhLCBiLCBjKXtcbiAgXHR2YXIgcCA9IFtdLCByPVtdO1xuICBcdC8vVHJhbnNsYXRlIHBvaW50IHRvIHRoZSBvcmlnaW5cbiAgXHRwWzBdID0gYVswXSAtIGJbMF07XG4gIFx0cFsxXSA9IGFbMV0gLSBiWzFdO1xuICBcdHBbMl0gPSBhWzJdIC0gYlsyXTtcbiAgXG4gIFx0Ly9wZXJmb3JtIHJvdGF0aW9uXG4gIFx0clswXSA9IHBbMl0qTWF0aC5zaW4oYykgKyBwWzBdKk1hdGguY29zKGMpO1xuICBcdHJbMV0gPSBwWzFdO1xuICBcdHJbMl0gPSBwWzJdKk1hdGguY29zKGMpIC0gcFswXSpNYXRoLnNpbihjKTtcbiAgXG4gIFx0Ly90cmFuc2xhdGUgdG8gY29ycmVjdCBwb3NpdGlvblxuICBcdG91dFswXSA9IHJbMF0gKyBiWzBdO1xuICBcdG91dFsxXSA9IHJbMV0gKyBiWzFdO1xuICBcdG91dFsyXSA9IHJbMl0gKyBiWzJdO1xuICBcbiAgXHRyZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB6LWF4aXNcbiAqIEBwYXJhbSB7dmVjM30gb3V0IFRoZSByZWNlaXZpbmcgdmVjM1xuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWMzIHBvaW50IHRvIHJvdGF0ZVxuICogQHBhcmFtIHt2ZWMzfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gYyBUaGUgYW5nbGUgb2Ygcm90YXRpb25cbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5yb3RhdGVaID0gZnVuY3Rpb24ob3V0LCBhLCBiLCBjKXtcbiAgXHR2YXIgcCA9IFtdLCByPVtdO1xuICBcdC8vVHJhbnNsYXRlIHBvaW50IHRvIHRoZSBvcmlnaW5cbiAgXHRwWzBdID0gYVswXSAtIGJbMF07XG4gIFx0cFsxXSA9IGFbMV0gLSBiWzFdO1xuICBcdHBbMl0gPSBhWzJdIC0gYlsyXTtcbiAgXG4gIFx0Ly9wZXJmb3JtIHJvdGF0aW9uXG4gIFx0clswXSA9IHBbMF0qTWF0aC5jb3MoYykgLSBwWzFdKk1hdGguc2luKGMpO1xuICBcdHJbMV0gPSBwWzBdKk1hdGguc2luKGMpICsgcFsxXSpNYXRoLmNvcyhjKTtcbiAgXHRyWzJdID0gcFsyXTtcbiAgXG4gIFx0Ly90cmFuc2xhdGUgdG8gY29ycmVjdCBwb3NpdGlvblxuICBcdG91dFswXSA9IHJbMF0gKyBiWzBdO1xuICBcdG91dFsxXSA9IHJbMV0gKyBiWzFdO1xuICBcdG91dFsyXSA9IHJbMl0gKyBiWzJdO1xuICBcbiAgXHRyZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBQZXJmb3JtIHNvbWUgb3BlcmF0aW9uIG92ZXIgYW4gYXJyYXkgb2YgdmVjM3MuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgYXJyYXkgb2YgdmVjdG9ycyB0byBpdGVyYXRlIG92ZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdHJpZGUgTnVtYmVyIG9mIGVsZW1lbnRzIGJldHdlZW4gdGhlIHN0YXJ0IG9mIGVhY2ggdmVjMy4gSWYgMCBhc3N1bWVzIHRpZ2h0bHkgcGFja2VkXG4gKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IE51bWJlciBvZiBlbGVtZW50cyB0byBza2lwIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5XG4gKiBAcGFyYW0ge051bWJlcn0gY291bnQgTnVtYmVyIG9mIHZlYzNzIHRvIGl0ZXJhdGUgb3Zlci4gSWYgMCBpdGVyYXRlcyBvdmVyIGVudGlyZSBhcnJheVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCB2ZWN0b3IgaW4gdGhlIGFycmF5XG4gKiBAcGFyYW0ge09iamVjdH0gW2FyZ10gYWRkaXRpb25hbCBhcmd1bWVudCB0byBwYXNzIHRvIGZuXG4gKiBAcmV0dXJucyB7QXJyYXl9IGFcbiAqIEBmdW5jdGlvblxuICovXG52ZWMzLmZvckVhY2ggPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZlYyA9IHZlYzMuY3JlYXRlKCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oYSwgc3RyaWRlLCBvZmZzZXQsIGNvdW50LCBmbiwgYXJnKSB7XG4gICAgICAgIHZhciBpLCBsO1xuICAgICAgICBpZighc3RyaWRlKSB7XG4gICAgICAgICAgICBzdHJpZGUgPSAzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIW9mZnNldCkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYoY291bnQpIHtcbiAgICAgICAgICAgIGwgPSBNYXRoLm1pbigoY291bnQgKiBzdHJpZGUpICsgb2Zmc2V0LCBhLmxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsID0gYS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IoaSA9IG9mZnNldDsgaSA8IGw7IGkgKz0gc3RyaWRlKSB7XG4gICAgICAgICAgICB2ZWNbMF0gPSBhW2ldOyB2ZWNbMV0gPSBhW2krMV07IHZlY1syXSA9IGFbaSsyXTtcbiAgICAgICAgICAgIGZuKHZlYywgdmVjLCBhcmcpO1xuICAgICAgICAgICAgYVtpXSA9IHZlY1swXTsgYVtpKzFdID0gdmVjWzFdOyBhW2krMl0gPSB2ZWNbMl07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBhO1xuICAgIH07XG59KSgpO1xuXG4vKipcbiAqIEdldCB0aGUgYW5nbGUgYmV0d2VlbiB0d28gM0QgdmVjdG9yc1xuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYW5nbGUgaW4gcmFkaWFuc1xuICovXG52ZWMzLmFuZ2xlID0gZnVuY3Rpb24oYSwgYikge1xuICAgXG4gICAgdmFyIHRlbXBBID0gdmVjMy5mcm9tVmFsdWVzKGFbMF0sIGFbMV0sIGFbMl0pO1xuICAgIHZhciB0ZW1wQiA9IHZlYzMuZnJvbVZhbHVlcyhiWzBdLCBiWzFdLCBiWzJdKTtcbiBcbiAgICB2ZWMzLm5vcm1hbGl6ZSh0ZW1wQSwgdGVtcEEpO1xuICAgIHZlYzMubm9ybWFsaXplKHRlbXBCLCB0ZW1wQik7XG4gXG4gICAgdmFyIGNvc2luZSA9IHZlYzMuZG90KHRlbXBBLCB0ZW1wQik7XG5cbiAgICBpZihjb3NpbmUgPiAxLjApe1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gTWF0aC5hY29zKGNvc2luZSk7XG4gICAgfSAgICAgXG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IHZlYyB2ZWN0b3IgdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxuICovXG52ZWMzLnN0ciA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuICd2ZWMzKCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnLCAnICsgYVsyXSArICcpJztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gdmVjMztcbiIsIi8qIENvcHlyaWdodCAoYykgMjAxNSwgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuICovXG5cbnZhciBnbE1hdHJpeCA9IHJlcXVpcmUoXCIuL2NvbW1vbi5qc1wiKTtcblxuLyoqXG4gKiBAY2xhc3MgNCBEaW1lbnNpb25hbCBWZWN0b3JcbiAqIEBuYW1lIHZlYzRcbiAqL1xudmFyIHZlYzQgPSB7fTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3LCBlbXB0eSB2ZWM0XG4gKlxuICogQHJldHVybnMge3ZlYzR9IGEgbmV3IDREIHZlY3RvclxuICovXG52ZWM0LmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtcbiAgICBvdXRbMF0gPSAwO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjNCBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjNH0gYSB2ZWN0b3IgdG8gY2xvbmVcbiAqIEByZXR1cm5zIHt2ZWM0fSBhIG5ldyA0RCB2ZWN0b3JcbiAqL1xudmVjNC5jbG9uZSA9IGZ1bmN0aW9uKGEpIHtcbiAgICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNCk7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzQgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHcgVyBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWM0fSBhIG5ldyA0RCB2ZWN0b3JcbiAqL1xudmVjNC5mcm9tVmFsdWVzID0gZnVuY3Rpb24oeCwgeSwgeiwgdykge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtcbiAgICBvdXRbMF0gPSB4O1xuICAgIG91dFsxXSA9IHk7XG4gICAgb3V0WzJdID0gejtcbiAgICBvdXRbM10gPSB3O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSB2ZWM0IHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBzb3VyY2UgdmVjdG9yXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQuY29weSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjNCB0byB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB3IFcgY29tcG9uZW50XG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQuc2V0ID0gZnVuY3Rpb24ob3V0LCB4LCB5LCB6LCB3KSB7XG4gICAgb3V0WzBdID0geDtcbiAgICBvdXRbMV0gPSB5O1xuICAgIG91dFsyXSA9IHo7XG4gICAgb3V0WzNdID0gdztcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBZGRzIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQuYWRkID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSArIGJbMl07XG4gICAgb3V0WzNdID0gYVszXSArIGJbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU3VidHJhY3RzIHZlY3RvciBiIGZyb20gdmVjdG9yIGFcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQuc3VidHJhY3QgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgICBvdXRbMl0gPSBhWzJdIC0gYlsyXTtcbiAgICBvdXRbM10gPSBhWzNdIC0gYlszXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQuc3VidHJhY3R9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjNC5zdWIgPSB2ZWM0LnN1YnRyYWN0O1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5tdWx0aXBseSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKiBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gKiBiWzFdO1xuICAgIG91dFsyXSA9IGFbMl0gKiBiWzJdO1xuICAgIG91dFszXSA9IGFbM10gKiBiWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG52ZWM0Lm11bCA9IHZlYzQubXVsdGlwbHk7XG5cbi8qKlxuICogRGl2aWRlcyB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LmRpdmlkZSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gLyBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gLyBiWzFdO1xuICAgIG91dFsyXSA9IGFbMl0gLyBiWzJdO1xuICAgIG91dFszXSA9IGFbM10gLyBiWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5kaXZpZGV9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjNC5kaXYgPSB2ZWM0LmRpdmlkZTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtaW5pbXVtIG9mIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQubWluID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gTWF0aC5taW4oYVswXSwgYlswXSk7XG4gICAgb3V0WzFdID0gTWF0aC5taW4oYVsxXSwgYlsxXSk7XG4gICAgb3V0WzJdID0gTWF0aC5taW4oYVsyXSwgYlsyXSk7XG4gICAgb3V0WzNdID0gTWF0aC5taW4oYVszXSwgYlszXSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWF4aW11bSBvZiB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0Lm1heCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IE1hdGgubWF4KGFbMF0sIGJbMF0pO1xuICAgIG91dFsxXSA9IE1hdGgubWF4KGFbMV0sIGJbMV0pO1xuICAgIG91dFsyXSA9IE1hdGgubWF4KGFbMl0sIGJbMl0pO1xuICAgIG91dFszXSA9IE1hdGgubWF4KGFbM10sIGJbM10pO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNjYWxlcyBhIHZlYzQgYnkgYSBzY2FsYXIgbnVtYmVyXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgdmVjdG9yIHRvIHNjYWxlXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIHZlY3RvciBieVxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LnNjYWxlID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAqIGI7XG4gICAgb3V0WzFdID0gYVsxXSAqIGI7XG4gICAgb3V0WzJdID0gYVsyXSAqIGI7XG4gICAgb3V0WzNdID0gYVszXSAqIGI7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWRkcyB0d28gdmVjNCdzIGFmdGVyIHNjYWxpbmcgdGhlIHNlY29uZCBvcGVyYW5kIGJ5IGEgc2NhbGFyIHZhbHVlXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYiBieSBiZWZvcmUgYWRkaW5nXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQuc2NhbGVBbmRBZGQgPSBmdW5jdGlvbihvdXQsIGEsIGIsIHNjYWxlKSB7XG4gICAgb3V0WzBdID0gYVswXSArIChiWzBdICogc2NhbGUpO1xuICAgIG91dFsxXSA9IGFbMV0gKyAoYlsxXSAqIHNjYWxlKTtcbiAgICBvdXRbMl0gPSBhWzJdICsgKGJbMl0gKiBzY2FsZSk7XG4gICAgb3V0WzNdID0gYVszXSArIChiWzNdICogc2NhbGUpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG52ZWM0LmRpc3RhbmNlID0gZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciB4ID0gYlswXSAtIGFbMF0sXG4gICAgICAgIHkgPSBiWzFdIC0gYVsxXSxcbiAgICAgICAgeiA9IGJbMl0gLSBhWzJdLFxuICAgICAgICB3ID0gYlszXSAtIGFbM107XG4gICAgcmV0dXJuIE1hdGguc3FydCh4KnggKyB5KnkgKyB6KnogKyB3KncpO1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQuZGlzdGFuY2V9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjNC5kaXN0ID0gdmVjNC5kaXN0YW5jZTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gKi9cbnZlYzQuc3F1YXJlZERpc3RhbmNlID0gZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciB4ID0gYlswXSAtIGFbMF0sXG4gICAgICAgIHkgPSBiWzFdIC0gYVsxXSxcbiAgICAgICAgeiA9IGJbMl0gLSBhWzJdLFxuICAgICAgICB3ID0gYlszXSAtIGFbM107XG4gICAgcmV0dXJuIHgqeCArIHkqeSArIHoqeiArIHcqdztcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0LnNxdWFyZWREaXN0YW5jZX1cbiAqIEBmdW5jdGlvblxuICovXG52ZWM0LnNxckRpc3QgPSB2ZWM0LnNxdWFyZWREaXN0YW5jZTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgYSB2ZWM0XG4gKlxuICogQHBhcmFtIHt2ZWM0fSBhIHZlY3RvciB0byBjYWxjdWxhdGUgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBsZW5ndGggb2YgYVxuICovXG52ZWM0Lmxlbmd0aCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXSxcbiAgICAgICAgeiA9IGFbMl0sXG4gICAgICAgIHcgPSBhWzNdO1xuICAgIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5ICsgeip6ICsgdyp3KTtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0Lmxlbmd0aH1cbiAqIEBmdW5jdGlvblxuICovXG52ZWM0LmxlbiA9IHZlYzQubGVuZ3RoO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIGEgdmVjNFxuICpcbiAqIEBwYXJhbSB7dmVjNH0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIHNxdWFyZWQgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGxlbmd0aCBvZiBhXG4gKi9cbnZlYzQuc3F1YXJlZExlbmd0aCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXSxcbiAgICAgICAgeiA9IGFbMl0sXG4gICAgICAgIHcgPSBhWzNdO1xuICAgIHJldHVybiB4KnggKyB5KnkgKyB6KnogKyB3Knc7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5zcXVhcmVkTGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzQuc3FyTGVuID0gdmVjNC5zcXVhcmVkTGVuZ3RoO1xuXG4vKipcbiAqIE5lZ2F0ZXMgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWM0XG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB2ZWN0b3IgdG8gbmVnYXRlXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQubmVnYXRlID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gLWFbMF07XG4gICAgb3V0WzFdID0gLWFbMV07XG4gICAgb3V0WzJdID0gLWFbMl07XG4gICAgb3V0WzNdID0gLWFbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgaW52ZXJzZSBvZiB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzRcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHZlY3RvciB0byBpbnZlcnRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5pbnZlcnNlID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gIG91dFswXSA9IDEuMCAvIGFbMF07XG4gIG91dFsxXSA9IDEuMCAvIGFbMV07XG4gIG91dFsyXSA9IDEuMCAvIGFbMl07XG4gIG91dFszXSA9IDEuMCAvIGFbM107XG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIHZlYzRcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHZlY3RvciB0byBub3JtYWxpemVcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5ub3JtYWxpemUgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdLFxuICAgICAgICB6ID0gYVsyXSxcbiAgICAgICAgdyA9IGFbM107XG4gICAgdmFyIGxlbiA9IHgqeCArIHkqeSArIHoqeiArIHcqdztcbiAgICBpZiAobGVuID4gMCkge1xuICAgICAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gICAgICAgIG91dFswXSA9IHggKiBsZW47XG4gICAgICAgIG91dFsxXSA9IHkgKiBsZW47XG4gICAgICAgIG91dFsyXSA9IHogKiBsZW47XG4gICAgICAgIG91dFszXSA9IHcgKiBsZW47XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcbiAqL1xudmVjNC5kb3QgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhWzBdICogYlswXSArIGFbMV0gKiBiWzFdICsgYVsyXSAqIGJbMl0gKyBhWzNdICogYlszXTtcbn07XG5cbi8qKlxuICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQubGVycCA9IGZ1bmN0aW9uIChvdXQsIGEsIGIsIHQpIHtcbiAgICB2YXIgYXggPSBhWzBdLFxuICAgICAgICBheSA9IGFbMV0sXG4gICAgICAgIGF6ID0gYVsyXSxcbiAgICAgICAgYXcgPSBhWzNdO1xuICAgIG91dFswXSA9IGF4ICsgdCAqIChiWzBdIC0gYXgpO1xuICAgIG91dFsxXSA9IGF5ICsgdCAqIChiWzFdIC0gYXkpO1xuICAgIG91dFsyXSA9IGF6ICsgdCAqIChiWzJdIC0gYXopO1xuICAgIG91dFszXSA9IGF3ICsgdCAqIChiWzNdIC0gYXcpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gc2NhbGVcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IFtzY2FsZV0gTGVuZ3RoIG9mIHRoZSByZXN1bHRpbmcgdmVjdG9yLiBJZiBvbW1pdHRlZCwgYSB1bml0IHZlY3RvciB3aWxsIGJlIHJldHVybmVkXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQucmFuZG9tID0gZnVuY3Rpb24gKG91dCwgc2NhbGUpIHtcbiAgICBzY2FsZSA9IHNjYWxlIHx8IDEuMDtcblxuICAgIC8vVE9ETzogVGhpcyBpcyBhIHByZXR0eSBhd2Z1bCB3YXkgb2YgZG9pbmcgdGhpcy4gRmluZCBzb21ldGhpbmcgYmV0dGVyLlxuICAgIG91dFswXSA9IGdsTWF0cml4LlJBTkRPTSgpO1xuICAgIG91dFsxXSA9IGdsTWF0cml4LlJBTkRPTSgpO1xuICAgIG91dFsyXSA9IGdsTWF0cml4LlJBTkRPTSgpO1xuICAgIG91dFszXSA9IGdsTWF0cml4LlJBTkRPTSgpO1xuICAgIHZlYzQubm9ybWFsaXplKG91dCwgb3V0KTtcbiAgICB2ZWM0LnNjYWxlKG91dCwgb3V0LCBzY2FsZSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjNCB3aXRoIGEgbWF0NC5cbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDR9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQudHJhbnNmb3JtTWF0NCA9IGZ1bmN0aW9uKG91dCwgYSwgbSkge1xuICAgIHZhciB4ID0gYVswXSwgeSA9IGFbMV0sIHogPSBhWzJdLCB3ID0gYVszXTtcbiAgICBvdXRbMF0gPSBtWzBdICogeCArIG1bNF0gKiB5ICsgbVs4XSAqIHogKyBtWzEyXSAqIHc7XG4gICAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzVdICogeSArIG1bOV0gKiB6ICsgbVsxM10gKiB3O1xuICAgIG91dFsyXSA9IG1bMl0gKiB4ICsgbVs2XSAqIHkgKyBtWzEwXSAqIHogKyBtWzE0XSAqIHc7XG4gICAgb3V0WzNdID0gbVszXSAqIHggKyBtWzddICogeSArIG1bMTFdICogeiArIG1bMTVdICogdztcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWM0IHdpdGggYSBxdWF0XG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHtxdWF0fSBxIHF1YXRlcm5pb24gdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC50cmFuc2Zvcm1RdWF0ID0gZnVuY3Rpb24ob3V0LCBhLCBxKSB7XG4gICAgdmFyIHggPSBhWzBdLCB5ID0gYVsxXSwgeiA9IGFbMl0sXG4gICAgICAgIHF4ID0gcVswXSwgcXkgPSBxWzFdLCBxeiA9IHFbMl0sIHF3ID0gcVszXSxcblxuICAgICAgICAvLyBjYWxjdWxhdGUgcXVhdCAqIHZlY1xuICAgICAgICBpeCA9IHF3ICogeCArIHF5ICogeiAtIHF6ICogeSxcbiAgICAgICAgaXkgPSBxdyAqIHkgKyBxeiAqIHggLSBxeCAqIHosXG4gICAgICAgIGl6ID0gcXcgKiB6ICsgcXggKiB5IC0gcXkgKiB4LFxuICAgICAgICBpdyA9IC1xeCAqIHggLSBxeSAqIHkgLSBxeiAqIHo7XG5cbiAgICAvLyBjYWxjdWxhdGUgcmVzdWx0ICogaW52ZXJzZSBxdWF0XG4gICAgb3V0WzBdID0gaXggKiBxdyArIGl3ICogLXF4ICsgaXkgKiAtcXogLSBpeiAqIC1xeTtcbiAgICBvdXRbMV0gPSBpeSAqIHF3ICsgaXcgKiAtcXkgKyBpeiAqIC1xeCAtIGl4ICogLXF6O1xuICAgIG91dFsyXSA9IGl6ICogcXcgKyBpdyAqIC1xeiArIGl4ICogLXF5IC0gaXkgKiAtcXg7XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBQZXJmb3JtIHNvbWUgb3BlcmF0aW9uIG92ZXIgYW4gYXJyYXkgb2YgdmVjNHMuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgYXJyYXkgb2YgdmVjdG9ycyB0byBpdGVyYXRlIG92ZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdHJpZGUgTnVtYmVyIG9mIGVsZW1lbnRzIGJldHdlZW4gdGhlIHN0YXJ0IG9mIGVhY2ggdmVjNC4gSWYgMCBhc3N1bWVzIHRpZ2h0bHkgcGFja2VkXG4gKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IE51bWJlciBvZiBlbGVtZW50cyB0byBza2lwIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5XG4gKiBAcGFyYW0ge051bWJlcn0gY291bnQgTnVtYmVyIG9mIHZlYzRzIHRvIGl0ZXJhdGUgb3Zlci4gSWYgMCBpdGVyYXRlcyBvdmVyIGVudGlyZSBhcnJheVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCB2ZWN0b3IgaW4gdGhlIGFycmF5XG4gKiBAcGFyYW0ge09iamVjdH0gW2FyZ10gYWRkaXRpb25hbCBhcmd1bWVudCB0byBwYXNzIHRvIGZuXG4gKiBAcmV0dXJucyB7QXJyYXl9IGFcbiAqIEBmdW5jdGlvblxuICovXG52ZWM0LmZvckVhY2ggPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZlYyA9IHZlYzQuY3JlYXRlKCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oYSwgc3RyaWRlLCBvZmZzZXQsIGNvdW50LCBmbiwgYXJnKSB7XG4gICAgICAgIHZhciBpLCBsO1xuICAgICAgICBpZighc3RyaWRlKSB7XG4gICAgICAgICAgICBzdHJpZGUgPSA0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIW9mZnNldCkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYoY291bnQpIHtcbiAgICAgICAgICAgIGwgPSBNYXRoLm1pbigoY291bnQgKiBzdHJpZGUpICsgb2Zmc2V0LCBhLmxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsID0gYS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IoaSA9IG9mZnNldDsgaSA8IGw7IGkgKz0gc3RyaWRlKSB7XG4gICAgICAgICAgICB2ZWNbMF0gPSBhW2ldOyB2ZWNbMV0gPSBhW2krMV07IHZlY1syXSA9IGFbaSsyXTsgdmVjWzNdID0gYVtpKzNdO1xuICAgICAgICAgICAgZm4odmVjLCB2ZWMsIGFyZyk7XG4gICAgICAgICAgICBhW2ldID0gdmVjWzBdOyBhW2krMV0gPSB2ZWNbMV07IGFbaSsyXSA9IHZlY1syXTsgYVtpKzNdID0gdmVjWzNdO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gYTtcbiAgICB9O1xufSkoKTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgdmVjdG9yXG4gKlxuICogQHBhcmFtIHt2ZWM0fSB2ZWMgdmVjdG9yIHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2ZWN0b3JcbiAqL1xudmVjNC5zdHIgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiAndmVjNCgnICsgYVswXSArICcsICcgKyBhWzFdICsgJywgJyArIGFbMl0gKyAnLCAnICsgYVszXSArICcpJztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gdmVjNDtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gY29uc3RhbnQodmFsdWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGludGVycG9sYXRlTnVtYmVyKGEsIGIsIHQpIHtcbiAgICByZXR1cm4gKGEgKiAoMSAtIHQpKSArIChiICogdCk7XG59XG5cbmZ1bmN0aW9uIGludGVycG9sYXRlQXJyYXkoYSwgYiwgdCkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0W2ldID0gaW50ZXJwb2xhdGVOdW1iZXIoYVtpXSwgYltpXSwgdCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydHNbJ2ludGVycG9sYXRlZCddID0gZnVuY3Rpb24oZikge1xuICAgIGlmICghZi5zdG9wcykge1xuICAgICAgICByZXR1cm4gY29uc3RhbnQoZik7XG4gICAgfVxuXG4gICAgdmFyIHN0b3BzID0gZi5zdG9wcyxcbiAgICAgICAgYmFzZSA9IGYuYmFzZSB8fCAxLFxuICAgICAgICBpbnRlcnBvbGF0ZSA9IEFycmF5LmlzQXJyYXkoc3RvcHNbMF1bMV0pID8gaW50ZXJwb2xhdGVBcnJheSA6IGludGVycG9sYXRlTnVtYmVyO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKHopIHtcbiAgICAgICAgLy8gZmluZCB0aGUgdHdvIHN0b3BzIHdoaWNoIHRoZSBjdXJyZW50IHogaXMgYmV0d2VlblxuICAgICAgICB2YXIgbG93LCBoaWdoO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzdG9wID0gc3RvcHNbaV07XG5cbiAgICAgICAgICAgIGlmIChzdG9wWzBdIDw9IHopIHtcbiAgICAgICAgICAgICAgICBsb3cgPSBzdG9wO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc3RvcFswXSA+IHopIHtcbiAgICAgICAgICAgICAgICBoaWdoID0gc3RvcDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsb3cgJiYgaGlnaCkge1xuICAgICAgICAgICAgdmFyIHpvb21EaWZmID0gaGlnaFswXSAtIGxvd1swXSxcbiAgICAgICAgICAgICAgICB6b29tUHJvZ3Jlc3MgPSB6IC0gbG93WzBdLFxuXG4gICAgICAgICAgICAgICAgdCA9IGJhc2UgPT09IDEgP1xuICAgICAgICAgICAgICAgIHpvb21Qcm9ncmVzcyAvIHpvb21EaWZmIDpcbiAgICAgICAgICAgICAgICAoTWF0aC5wb3coYmFzZSwgem9vbVByb2dyZXNzKSAtIDEpIC8gKE1hdGgucG93KGJhc2UsIHpvb21EaWZmKSAtIDEpO1xuXG4gICAgICAgICAgICByZXR1cm4gaW50ZXJwb2xhdGUobG93WzFdLCBoaWdoWzFdLCB0KTtcblxuICAgICAgICB9IGVsc2UgaWYgKGxvdykge1xuICAgICAgICAgICAgcmV0dXJuIGxvd1sxXTtcblxuICAgICAgICB9IGVsc2UgaWYgKGhpZ2gpIHtcbiAgICAgICAgICAgIHJldHVybiBoaWdoWzFdO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5cbmV4cG9ydHNbJ3BpZWNld2lzZS1jb25zdGFudCddID0gZnVuY3Rpb24oZikge1xuICAgIGlmICghZi5zdG9wcykge1xuICAgICAgICByZXR1cm4gY29uc3RhbnQoZik7XG4gICAgfVxuXG4gICAgdmFyIHN0b3BzID0gZi5zdG9wcztcblxuICAgIHJldHVybiBmdW5jdGlvbih6KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChzdG9wc1tpXVswXSA+IHopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RvcHNbaSA9PT0gMCA/IDAgOiBpIC0gMV1bMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3RvcHNbc3RvcHMubGVuZ3RoIC0gMV1bMV07XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHJlZmVyZW5jZSA9IHJlcXVpcmUoJy4uLy4uL3JlZmVyZW5jZS9sYXRlc3QubWluLmpzJyk7XG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCcuL3BhcnNlZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHN0eWxlKSB7XG4gICAgcmV0dXJuIHZhbGlkYXRlKHN0eWxlLCByZWZlcmVuY2UpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHBhcnNlQ1NTQ29sb3IgPSByZXF1aXJlKCdjc3Njb2xvcnBhcnNlcicpLnBhcnNlQ1NTQ29sb3I7XG52YXIgZm9ybWF0ID0gcmVxdWlyZSgndXRpbCcpLmZvcm1hdDtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihzdHlsZSwgcmVmZXJlbmNlKSB7XG5cbiAgICB2YXIgY29uc3RhbnRzID0gc3R5bGUuY29uc3RhbnRzIHx8IHt9LFxuICAgICAgICBsYXllcnMgPSB7fSxcbiAgICAgICAgZXJyb3JzID0gW107XG5cbiAgICBmdW5jdGlvbiBlcnJvcihrZXksIHZhbCAvKiwgbWVzc2FnZSwgLi4uKi8pIHtcbiAgICAgICAgdmFyIGVyciA9IHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IChrZXkgPyBrZXkgKyAnOiAnIDogJycpICtcbiAgICAgICAgICAgIGZvcm1hdC5hcHBseShmb3JtYXQsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMikpXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHZhbCAhPT0gbnVsbCAmJiB2YWwgIT09IHVuZGVmaW5lZCAmJiB2YWwuX19saW5lX18pIHtcbiAgICAgICAgICAgIGVyci5saW5lID0gdmFsLl9fbGluZV9fO1xuICAgICAgICB9XG5cbiAgICAgICAgZXJyb3JzLnB1c2goZXJyKTtcbiAgICB9XG5cbiAgICAvLyBNYWluIHJlY3Vyc2l2ZSB2YWxpZGF0aW9uIGZ1bmN0aW9uLiBUcmFja3M6XG4gICAgLy9cbiAgICAvLyAtIGtleTogc3RyaW5nIHJlcHJlc2VudGluZyBsb2NhdGlvbiBvZiB2YWxpZGF0aW9uIGluIHN0eWxlIHRyZWUuIFVzZWQgb25seVxuICAgIC8vICAgZm9yIG1vcmUgaW5mb3JtYXRpdmUgZXJyb3IgcmVwb3J0aW5nLlxuICAgIC8vIC0gdmFsOiBjdXJyZW50IHZhbHVlIGZyb20gc3R5bGUgYmVpbmcgZXZhbHVhdGVkLiBNYXkgYmUgYW55dGhpbmcgZnJvbSBhXG4gICAgLy8gICBoaWdoIGxldmVsIG9iamVjdCB0aGF0IG5lZWRzIHRvIGJlIGRlc2NlbmRlZCBpbnRvIGRlZXBlciBvciBhIHNpbXBsZVxuICAgIC8vICAgc2NhbGFyIHZhbHVlLlxuICAgIC8vIC0gc3BlYzogY3VycmVudCBzcGVjIGJlaW5nIGV2YWx1YXRlZC4gVHJhY2tzIHZhbC5cbiAgICAvL1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKGtleSwgdmFsLCBzcGVjKSB7XG4gICAgICAgIHZhciB0eXBlID0gdHlwZW9mXyh2YWwpO1xuXG4gICAgICAgIC8vIENvbnN0YW50c1xuICAgICAgICBpZiAodHlwZSA9PT0gJ3N0cmluZycgJiYgdmFsWzBdID09PSAnQCcpIHtcblxuICAgICAgICAgICAgaWYgKHJlZmVyZW5jZS4kdmVyc2lvbiA+IDcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3Ioa2V5LCB2YWwsICdjb25zdGFudHMgaGF2ZSBiZWVuIGRlcHJlY2F0ZWQgYXMgb2YgdjgnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCEodmFsIGluIGNvbnN0YW50cykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yKGtleSwgdmFsLCAnY29uc3RhbnQgXCIlc1wiIG5vdCBmb3VuZCcsIHZhbCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFsID0gY29uc3RhbnRzW3ZhbF07XG4gICAgICAgICAgICAgICAgdHlwZSA9IHR5cGVvZl8odmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzcGVjLmZ1bmN0aW9uICYmIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsaWRhdGUuZnVuY3Rpb24oa2V5LCB2YWwsIHNwZWMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNwZWMudHlwZSkge1xuICAgICAgICAgICAgdmFyIHZhbGlkYXRvciA9IHZhbGlkYXRlW3NwZWMudHlwZV07XG4gICAgICAgICAgICBpZiAodmFsaWRhdG9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRvcihrZXksIHZhbCwgc3BlYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzcGVjID0gcmVmZXJlbmNlW3NwZWMudHlwZV07XG4gICAgICAgIH1cblxuICAgICAgICB2YWxpZGF0ZS5vYmplY3Qoa2V5LCB2YWwsIHNwZWMpO1xuICAgIH1cblxuICAgIHZhbGlkYXRlLmNvbnN0YW50cyA9IGZ1bmN0aW9uKGtleSwgdmFsKSB7XG5cbiAgICAgICAgaWYgKHJlZmVyZW5jZS4kdmVyc2lvbiA+IDcpIHtcbiAgICAgICAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3Ioa2V5LCB2YWwsICdjb25zdGFudHMgaGF2ZSBiZWVuIGRlcHJlY2F0ZWQgYXMgb2YgdjgnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gdHlwZW9mXyh2YWwpO1xuICAgICAgICAgICAgaWYgKHR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yKGtleSwgdmFsLCAnb2JqZWN0IGV4cGVjdGVkLCAlcyBmb3VuZCcsIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBrIGluIHZhbCkge1xuICAgICAgICAgICAgICAgIGlmIChrWzBdICE9PSAnQCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3Ioa2V5ICsgJy4nICsgaywgdmFsW2tdLCAnY29uc3RhbnRzIG11c3Qgc3RhcnQgd2l0aCBcIkBcIicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIHZhbGlkYXRlLnNvdXJjZSA9IGZ1bmN0aW9uKGtleSwgdmFsKSB7XG4gICAgICAgIGlmICghdmFsLnR5cGUpIHtcbiAgICAgICAgICAgIGVycm9yKGtleSwgdmFsLCAnXCJ0eXBlXCIgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0eXBlID0gdW5idW5kbGUodmFsLnR5cGUpO1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3ZlY3Rvcic6XG4gICAgICAgICAgICBjYXNlICdyYXN0ZXInOlxuICAgICAgICAgICAgICAgIHZhbGlkYXRlLm9iamVjdChrZXksIHZhbCwgcmVmZXJlbmNlLnNvdXJjZV90aWxlKTtcblxuICAgICAgICAgICAgICAgIGlmICgndXJsJyBpbiB2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiB2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChbJ3R5cGUnLCAndXJsJywgJ3RpbGVTaXplJ10uaW5kZXhPZihwcm9wKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcihrZXkgKyAnLicgKyBwcm9wLCB2YWxbcHJvcF0sICdhIHNvdXJjZSB3aXRoIGEgXCJ1cmxcIiBwcm9wZXJ0eSBtYXkgbm90IGluY2x1ZGUgYSBcIiVzXCIgcHJvcGVydHknLCBwcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZ2VvanNvbic6XG4gICAgICAgICAgICAgICAgdmFsaWRhdGUub2JqZWN0KGtleSwgdmFsLCByZWZlcmVuY2Uuc291cmNlX2dlb2pzb24pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndmlkZW8nOlxuICAgICAgICAgICAgICAgIHZhbGlkYXRlLm9iamVjdChrZXksIHZhbCwgcmVmZXJlbmNlLnNvdXJjZV92aWRlbyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpbWFnZSc6XG4gICAgICAgICAgICAgICAgdmFsaWRhdGUub2JqZWN0KGtleSwgdmFsLCByZWZlcmVuY2Uuc291cmNlX2ltYWdlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdmFsaWRhdGUuZW51bShrZXkgKyAnLnR5cGUnLCB2YWwudHlwZSwge3ZhbHVlczogWyd2ZWN0b3InLCAncmFzdGVyJywgJ2dlb2pzb24nLCAndmlkZW8nLCAnaW1hZ2UnXX0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhbGlkYXRlLmxheWVyID0gZnVuY3Rpb24oa2V5LCB2YWwpIHtcbiAgICAgICAgaWYgKCF2YWwudHlwZSAmJiAhdmFsLnJlZikge1xuICAgICAgICAgICAgZXJyb3Ioa2V5LCB2YWwsICdlaXRoZXIgXCJ0eXBlXCIgb3IgXCJyZWZcIiBpcyByZXF1aXJlZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHR5cGUgPSB1bmJ1bmRsZSh2YWwudHlwZSksXG4gICAgICAgICAgICByZWYgPSB1bmJ1bmRsZSh2YWwucmVmKTtcblxuICAgICAgICBpZiAodmFsLmlkKSB7XG4gICAgICAgICAgICBpZiAobGF5ZXJzW3ZhbC5pZF0pIHtcbiAgICAgICAgICAgICAgICBlcnJvcihrZXksIHZhbC5pZCwgJ2R1cGxpY2F0ZSBsYXllciBpZCBcIiVzXCIsIHByZXZpb3VzbHkgdXNlZCBhdCBsaW5lICVkJywgdmFsLmlkLCBsYXllcnNbdmFsLmlkXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxheWVyc1t2YWwuaWRdID0gdmFsLmlkLl9fbGluZV9fO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCdyZWYnIGluIHZhbCkge1xuICAgICAgICAgICAgWyd0eXBlJywgJ3NvdXJjZScsICdzb3VyY2UtbGF5ZXInLCAnZmlsdGVyJywgJ2xheW91dCddLmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgICAgICBpZiAocCBpbiB2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3Ioa2V5LCB2YWxbcF0sICdcIiVzXCIgaXMgcHJvaGliaXRlZCBmb3IgcmVmIGxheWVycycsIHApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgcGFyZW50O1xuXG4gICAgICAgICAgICBzdHlsZS5sYXllcnMuZm9yRWFjaChmdW5jdGlvbihsYXllcikge1xuICAgICAgICAgICAgICAgIGlmIChsYXllci5pZCA9PSByZWYpIHBhcmVudCA9IGxheWVyO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmICghcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgZXJyb3Ioa2V5LCB2YWwucmVmLCAncmVmIGxheWVyIFwiJXNcIiBub3QgZm91bmQnLCByZWYpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJlbnQucmVmKSB7XG4gICAgICAgICAgICAgICAgZXJyb3Ioa2V5LCB2YWwucmVmLCAncmVmIGNhbm5vdCByZWZlcmVuY2UgYW5vdGhlciByZWYgbGF5ZXInKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdHlwZSA9IHBhcmVudC50eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgIT09ICdiYWNrZ3JvdW5kJykge1xuICAgICAgICAgICAgaWYgKCF2YWwuc291cmNlKSB7XG4gICAgICAgICAgICAgICAgZXJyb3Ioa2V5LCB2YWwsICdtaXNzaW5nIHJlcXVpcmVkIHByb3BlcnR5IFwic291cmNlXCInKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHNvdXJjZSA9IHN0eWxlLnNvdXJjZXNbdmFsLnNvdXJjZV07XG4gICAgICAgICAgICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3Ioa2V5LCB2YWwuc291cmNlLCAnc291cmNlIFwiJXNcIiBub3QgZm91bmQnLCB2YWwuc291cmNlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZS50eXBlID09ICd2ZWN0b3InICYmIHR5cGUgPT0gJ3Jhc3RlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3Ioa2V5LCB2YWwuc291cmNlLCAnbGF5ZXIgXCIlc1wiIHJlcXVpcmVzIGEgcmFzdGVyIHNvdXJjZScsIHZhbC5pZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2UudHlwZSA9PSAncmFzdGVyJyAmJiB0eXBlICE9ICdyYXN0ZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yKGtleSwgdmFsLnNvdXJjZSwgJ2xheWVyIFwiJXNcIiByZXF1aXJlcyBhIHZlY3RvciBzb3VyY2UnLCB2YWwuaWQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlLnR5cGUgPT0gJ3ZlY3RvcicgJiYgIXZhbFsnc291cmNlLWxheWVyJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3Ioa2V5LCB2YWwsICdsYXllciBcIiVzXCIgbXVzdCBzcGVjaWZ5IGEgXCJzb3VyY2UtbGF5ZXJcIicsIHZhbC5pZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFsaWRhdGUub2JqZWN0KGtleSwgdmFsLCByZWZlcmVuY2UubGF5ZXIsIHtcbiAgICAgICAgICAgIGZpbHRlcjogdmFsaWRhdGUuZmlsdGVyLFxuICAgICAgICAgICAgbGF5b3V0OiBmdW5jdGlvbihrZXksIHZhbCkge1xuICAgICAgICAgICAgICAgIHZhciBzcGVjID0gcmVmZXJlbmNlWydsYXlvdXRfJyArIHR5cGVdO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlICYmIHNwZWMgJiYgdmFsaWRhdGUoa2V5LCB2YWwsIHNwZWMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhaW50OiBmdW5jdGlvbihrZXksIHZhbCkge1xuICAgICAgICAgICAgICAgIHZhciBzcGVjID0gcmVmZXJlbmNlWydwYWludF8nICsgdHlwZV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGUgJiYgc3BlYyAmJiB2YWxpZGF0ZShrZXksIHZhbCwgc3BlYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YWxpZGF0ZS5vYmplY3QgPSBmdW5jdGlvbiAoa2V5LCB2YWwsIHNwZWMsIHZhbGlkYXRvcnMpIHtcbiAgICAgICAgdmFsaWRhdG9ycyA9IHZhbGlkYXRvcnMgfHwge307XG5cbiAgICAgICAgdmFyIHR5cGUgPSB0eXBlb2ZfKHZhbCk7XG4gICAgICAgIGlmICh0eXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yKGtleSwgdmFsLCAnb2JqZWN0IGV4cGVjdGVkLCAlcyBmb3VuZCcsIHR5cGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgayBpbiB2YWwpIHtcbiAgICAgICAgICAgIHZhciBzcGVja2V5ID0gay5zcGxpdCgnLicpWzBdOyAvLyB0cmVhdCAncGFpbnQuKicgYXMgJ3BhaW50J1xuICAgICAgICAgICAgdmFyIGRlZiA9IHNwZWNbc3BlY2tleV0gfHwgc3BlY1snKiddO1xuICAgICAgICAgICAgdmFyIHRyYW5zaXRpb24gPSBzcGVja2V5Lm1hdGNoKC9eKC4qKS10cmFuc2l0aW9uJC8pO1xuXG4gICAgICAgICAgICBpZiAoZGVmKSB7XG4gICAgICAgICAgICAgICAgKHZhbGlkYXRvcnNbc3BlY2tleV0gfHwgdmFsaWRhdGUpKChrZXkgPyBrZXkgKyAnLicgOiBrZXkpICsgaywgdmFsW2tdLCBkZWYpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0cmFuc2l0aW9uICYmIHNwZWNbdHJhbnNpdGlvblsxXV0gJiYgc3BlY1t0cmFuc2l0aW9uWzFdXS50cmFuc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGUoKGtleSA/IGtleSArICcuJyA6IGtleSkgKyBrLCB2YWxba10sIHJlZmVyZW5jZS50cmFuc2l0aW9uKTtcbiAgICAgICAgICAgIC8vIHRvbGVyYXRlIHJvb3QtbGV2ZWwgZXh0cmEga2V5cyAmIGFyYml0cmFyeSBsYXllciBwcm9wZXJ0aWVzXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGtleSAhPT0gJycgJiYga2V5LnNwbGl0KCcuJykubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgZXJyb3Ioa2V5LCB2YWxba10sICd1bmtub3duIHByb3BlcnR5IFwiJXNcIicsIGspO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgbCBpbiBzcGVjKSB7XG4gICAgICAgICAgICBpZiAoc3BlY1tsXS5yZXF1aXJlZCAmJiBzcGVjW2xdWydkZWZhdWx0J10gPT09IHVuZGVmaW5lZCAmJiB2YWxbbF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGVycm9yKGtleSwgdmFsLCAnbWlzc2luZyByZXF1aXJlZCBwcm9wZXJ0eSBcIiVzXCInLCBsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YWxpZGF0ZS5hcnJheSA9IGZ1bmN0aW9uIChrZXksIHZhbCwgc3BlYywgdmFsaWRhdG9yKSB7XG4gICAgICAgIGlmICh0eXBlb2ZfKHZhbCkgIT09ICdhcnJheScpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcihrZXksIHZhbCwgJ2FycmF5IGV4cGVjdGVkLCAlcyBmb3VuZCcsIHR5cGVvZl8odmFsKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3BlYy5sZW5ndGggJiYgdmFsLmxlbmd0aCAhPT0gc3BlYy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcihrZXksIHZhbCwgJ2FycmF5IGxlbmd0aCAlZCBleHBlY3RlZCwgbGVuZ3RoICVkIGZvdW5kJywgc3BlYy5sZW5ndGgsIHZhbC5sZW5ndGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNwZWNbJ21pbi1sZW5ndGgnXSAmJiB2YWwubGVuZ3RoIDwgc3BlY1snbWluLWxlbmd0aCddKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3Ioa2V5LCB2YWwsICdhcnJheSBsZW5ndGggYXQgbGVhc3QgJWQgZXhwZWN0ZWQsIGxlbmd0aCAlZCBmb3VuZCcsIHNwZWNbJ21pbi1sZW5ndGgnXSwgdmFsLmxlbmd0aCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdmFsdWUgPSB7XG4gICAgICAgICAgICBcInR5cGVcIjogc3BlYy52YWx1ZVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChzdHlsZS52ZXJzaW9uIDwgNykge1xuICAgICAgICAgICAgdmFsdWUuZnVuY3Rpb24gPSBzcGVjLmZ1bmN0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZl8oc3BlYy52YWx1ZSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHNwZWMudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgKHZhbGlkYXRvciB8fCB2YWxpZGF0ZSkoa2V5ICsgJ1snICsgaSArICddJywgdmFsW2ldLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG5cbiAgICB2YWxpZGF0ZS5maWx0ZXIgPSBmdW5jdGlvbihrZXksIHZhbCkge1xuICAgICAgICB2YXIgdHlwZTtcblxuICAgICAgICBpZiAodHlwZW9mXyh2YWwpICE9PSAnYXJyYXknKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3Ioa2V5LCB2YWwsICdhcnJheSBleHBlY3RlZCwgJXMgZm91bmQnLCB0eXBlb2ZfKHZhbCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbC5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3Ioa2V5LCB2YWwsICdmaWx0ZXIgYXJyYXkgbXVzdCBoYXZlIGF0IGxlYXN0IDEgZWxlbWVudCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsaWRhdGUuZW51bShrZXkgKyAnWzBdJywgdmFsWzBdLCByZWZlcmVuY2UuZmlsdGVyX29wZXJhdG9yKTtcblxuICAgICAgICBzd2l0Y2ggKHVuYnVuZGxlKHZhbFswXSkpIHtcbiAgICAgICAgICAgIGNhc2UgJzwnOlxuICAgICAgICAgICAgY2FzZSAnPD0nOlxuICAgICAgICAgICAgY2FzZSAnPic6XG4gICAgICAgICAgICBjYXNlICc+PSc6XG4gICAgICAgICAgICAgICAgaWYgKHZhbC5sZW5ndGggPj0gMiAmJiB2YWxbMV0gPT0gJyR0eXBlJykge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcihrZXksIHZhbCwgJ1wiJHR5cGVcIiBjYW5ub3QgYmUgdXNlIHdpdGggb3BlcmF0b3IgXCIlc1wiJywgdmFsWzBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgICAgICBjYXNlICc9PSc6XG4gICAgICAgICAgICBjYXNlICchPSc6XG4gICAgICAgICAgICAgICAgaWYgKHZhbC5sZW5ndGggIT0gMykge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcihrZXksIHZhbCwgJ2ZpbHRlciBhcnJheSBmb3Igb3BlcmF0b3IgXCIlc1wiIG11c3QgaGF2ZSAzIGVsZW1lbnRzJywgdmFsWzBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgICAgICBjYXNlICdpbic6XG4gICAgICAgICAgICBjYXNlICchaW4nOlxuICAgICAgICAgICAgICAgIGlmICh2YWwubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9IHR5cGVvZl8odmFsWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcihrZXkgKyAnWzFdJywgdmFsWzFdLCAnc3RyaW5nIGV4cGVjdGVkLCAlcyBmb3VuZCcsIHR5cGUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZhbFsxXVswXSA9PT0gJ0AnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcihrZXkgKyAnWzFdJywgdmFsWzFdLCAnZmlsdGVyIGtleSBjYW5ub3QgYmUgYSBjb25zdGFudCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAyOyBpIDwgdmFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSB0eXBlb2ZfKHZhbFtpXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWxbMV0gPT0gJyR0eXBlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGUuZW51bShrZXkgKyAnWycgKyBpICsgJ10nLCB2YWxbaV0sIHJlZmVyZW5jZS5nZW9tZXRyeV90eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiB2YWxbaV1bMF0gPT09ICdAJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3Ioa2V5ICsgJ1snICsgaSArICddJywgdmFsW2ldLCAnZmlsdGVyIHZhbHVlIGNhbm5vdCBiZSBhIGNvbnN0YW50Jyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gJ3N0cmluZycgJiYgdHlwZSAhPT0gJ251bWJlcicgJiYgdHlwZSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcihrZXkgKyAnWycgKyBpICsgJ10nLCB2YWxbaV0sICdzdHJpbmcsIG51bWJlciwgb3IgYm9vbGVhbiBleHBlY3RlZCwgJXMgZm91bmQnLCB0eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnYW55JzpcbiAgICAgICAgICAgIGNhc2UgJ2FsbCc6XG4gICAgICAgICAgICBjYXNlICdub25lJzpcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDwgdmFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlLmZpbHRlcihrZXkgKyAnWycgKyBpICsgJ10nLCB2YWxbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YWxpZGF0ZS5mdW5jdGlvbiA9IGZ1bmN0aW9uKGtleSwgdmFsLCBzcGVjKSB7XG4gICAgICAgIHZhbGlkYXRlLm9iamVjdChrZXksIHZhbCwgcmVmZXJlbmNlLmZ1bmN0aW9uLCB7XG4gICAgICAgICAgICBzdG9wczogZnVuY3Rpb24gKGtleSwgdmFsLCBhcnJheVNwZWMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGFzdFN0b3AgPSAtSW5maW5pdHk7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGUuYXJyYXkoa2V5LCB2YWwsIGFycmF5U3BlYywgZnVuY3Rpb24gdmFsaWRhdGVTdG9wKGtleSwgdmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2ZfKHZhbCkgIT09ICdhcnJheScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcihrZXksIHZhbCwgJ2FycmF5IGV4cGVjdGVkLCAlcyBmb3VuZCcsIHR5cGVvZl8odmFsKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsLmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yKGtleSwgdmFsLCAnYXJyYXkgbGVuZ3RoICVkIGV4cGVjdGVkLCBsZW5ndGggJWQgZm91bmQnLCAyLCB2YWwubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlKGtleSArICdbMF0nLCB2YWxbMF0sIHt0eXBlOiAnbnVtYmVyJ30pO1xuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZShrZXkgKyAnWzFdJywgdmFsWzFdLCBzcGVjKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mXyh2YWxbMF0pID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNwZWMuZnVuY3Rpb24gPT09ICdwaWVjZXdpc2UtY29uc3RhbnQnICYmIHZhbFswXSAlIDEgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcihrZXkgKyAnWzBdJywgdmFsWzBdLCAnem9vbSBsZXZlbCBmb3IgcGllY2V3aXNlLWNvbnN0YW50IGZ1bmN0aW9ucyBtdXN0IGJlIGFuIGludGVnZXInKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbFswXSA8IGxhc3RTdG9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3Ioa2V5ICsgJ1swXScsIHZhbFswXSwgJ2FycmF5IHN0b3BzIG11c3QgYXBwZWFyIGluIGFzY2VuZGluZyBvcmRlcicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0U3RvcCA9IHZhbFswXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZl8odmFsKSA9PT0gJ2FycmF5JyAmJiB2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yKGtleSwgdmFsLCAnYXJyYXkgbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBzdG9wJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFsaWRhdGUuZW51bSA9IGZ1bmN0aW9uIChrZXksIHZhbCwgc3BlYykge1xuICAgICAgICBpZiAoc3BlYy52YWx1ZXMuaW5kZXhPZih1bmJ1bmRsZSh2YWwpKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGVycm9yKGtleSwgdmFsLCAnZXhwZWN0ZWQgb25lIG9mIFslc10sICVzIGZvdW5kJywgc3BlYy52YWx1ZXMuam9pbignLCAnKSwgdmFsKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YWxpZGF0ZS5jb2xvciA9IGZ1bmN0aW9uKGtleSwgdmFsKSB7XG4gICAgICAgIHZhciB0eXBlID0gdHlwZW9mXyh2YWwpO1xuICAgICAgICBpZiAodHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcihrZXksIHZhbCwgJ2NvbG9yIGV4cGVjdGVkLCAlcyBmb3VuZCcsIHR5cGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcnNlQ1NTQ29sb3IodmFsKSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yKGtleSwgdmFsLCAnY29sb3IgZXhwZWN0ZWQsIFwiJXNcIiBmb3VuZCcsIHZhbCk7XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBmdW5jdGlvbiB0eXBlVmFsaWRhdG9yKGV4cGVjdGVkKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihrZXksIHZhbCwgc3BlYykge1xuICAgICAgICAgICAgdmFyIGFjdHVhbCA9IHR5cGVvZl8odmFsKTtcbiAgICAgICAgICAgIGlmIChhY3R1YWwgIT09IGV4cGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgZXJyb3Ioa2V5LCB2YWwsICclcyBleHBlY3RlZCwgJXMgZm91bmQnLCBleHBlY3RlZCwgYWN0dWFsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCdtaW5pbXVtJyBpbiBzcGVjICYmIHZhbCA8IHNwZWMubWluaW11bSkge1xuICAgICAgICAgICAgICAgIGVycm9yKGtleSwgdmFsLCAnJXMgaXMgbGVzcyB0aGFuIHRoZSBtaW5pbXVtIHZhbHVlICVzJywgdmFsLCBzcGVjLm1pbmltdW0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoJ21heGltdW0nIGluIHNwZWMgJiYgdmFsID4gc3BlYy5tYXhpbXVtKSB7XG4gICAgICAgICAgICAgICAgZXJyb3Ioa2V5LCB2YWwsICclcyBpcyBncmVhdGVyIHRoYW4gdGhlIG1heGltdW0gdmFsdWUgJXMnLCB2YWwsIHNwZWMubWF4aW11bSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFsaWRhdGUubnVtYmVyID0gdHlwZVZhbGlkYXRvcignbnVtYmVyJyk7XG4gICAgdmFsaWRhdGUuc3RyaW5nID0gdHlwZVZhbGlkYXRvcignc3RyaW5nJyk7XG4gICAgdmFsaWRhdGUuYm9vbGVhbiA9IHR5cGVWYWxpZGF0b3IoJ2Jvb2xlYW4nKTtcblxuICAgIHZhbGlkYXRlWycqJ10gPSBmdW5jdGlvbigpIHt9O1xuXG4gICAgdmFsaWRhdGUoJycsIHN0eWxlLCByZWZlcmVuY2UuJHJvb3QpO1xuICAgIGlmIChyZWZlcmVuY2UuJHZlcnNpb24gPiA3ICYmIHN0eWxlLmNvbnN0YW50cykge1xuICAgICAgICB2YWxpZGF0ZS5jb25zdGFudHMoJ2NvbnN0YW50cycsIHN0eWxlLmNvbnN0YW50cyk7XG4gICAgfVxuXG4gICAgZXJyb3JzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBhLmxpbmUgLSBiLmxpbmU7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZXJyb3JzO1xufTtcblxuZnVuY3Rpb24gdHlwZW9mXyh2YWwpIHtcbiAgICBpZiAodmFsIGluc3RhbmNlb2YgTnVtYmVyKVxuICAgICAgICByZXR1cm4gJ251bWJlcic7XG4gICAgaWYgKHZhbCBpbnN0YW5jZW9mIFN0cmluZylcbiAgICAgICAgcmV0dXJuICdzdHJpbmcnO1xuICAgIGlmICh2YWwgaW5zdGFuY2VvZiBCb29sZWFuKVxuICAgICAgICByZXR1cm4gJ2Jvb2xlYW4nO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpXG4gICAgICAgIHJldHVybiAnYXJyYXknO1xuICAgIGlmICh2YWwgPT09IG51bGwpXG4gICAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWw7XG59XG5cbmZ1bmN0aW9uIHVuYnVuZGxlKF8pIHtcbiAgICBpZiAoXyBpbnN0YW5jZW9mIE51bWJlciB8fFxuICAgICAgICBfIGluc3RhbmNlb2YgU3RyaW5nIHx8XG4gICAgICAgIF8gaW5zdGFuY2VvZiBCb29sZWFuKSB7XG4gICAgICAgIHJldHVybiBfLnZhbHVlT2YoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gXztcbiAgICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vdjguanNvbicpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3Y4Lm1pbi5qc29uJyk7XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiJHZlcnNpb25cIjogOCxcbiAgXCIkcm9vdFwiOiB7XG4gICAgXCJ2ZXJzaW9uXCI6IHtcbiAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwidmFsdWVzXCI6IFs4XSxcbiAgICAgIFwiZG9jXCI6IFwiU3R5bGVzaGVldCB2ZXJzaW9uIG51bWJlci4gTXVzdCBiZSA4LlwiLFxuICAgICAgXCJleGFtcGxlXCI6IDhcbiAgICB9LFxuICAgIFwibmFtZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZG9jXCI6IFwiQSBodW1hbi1yZWFkYWJsZSBuYW1lIGZvciB0aGUgc3R5bGUuXCIsXG4gICAgICBcImV4YW1wbGVcIjogXCJCcmlnaHRcIlxuICAgIH0sXG4gICAgXCJtZXRhZGF0YVwiOiB7XG4gICAgICBcInR5cGVcIjogXCIqXCIsXG4gICAgICBcImRvY1wiOiBcIkFyYml0cmFyeSBwcm9wZXJ0aWVzIHVzZWZ1bCB0byB0cmFjayB3aXRoIHRoZSBzdHlsZXNoZWV0LCBidXQgZG8gbm90IGluZmx1ZW5jZSByZW5kZXJpbmcuIFByb3BlcnRpZXMgc2hvdWxkIGJlIHByZWZpeGVkIHRvIGF2b2lkIGNvbGxpc2lvbnMsIGxpa2UgJ21hcGJveDonLlwiXG4gICAgfSxcbiAgICBcImNlbnRlclwiOiB7XG4gICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgXCJ2YWx1ZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkb2NcIjogXCJEZWZhdWx0IG1hcCBjZW50ZXIgaW4gbG9uZ2l0dWRlIGFuZCBsYXRpdHVkZS4gIFRoZSBzdHlsZSBjZW50ZXIgd2lsbCBiZSB1c2VkIG9ubHkgaWYgdGhlIG1hcCBoYXMgbm90IGJlZW4gcG9zaXRpb25lZCBieSBvdGhlciBtZWFucyAoZS5nLiBtYXAgb3B0aW9ucyBvciB1c2VyIGludGVyYWN0aW9uKS5cIixcbiAgICAgIFwiZXhhbXBsZVwiOiBbLTczLjk3NDksIDQwLjc3MzZdXG4gICAgfSxcbiAgICBcInpvb21cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRvY1wiOiBcIkRlZmF1bHQgem9vbSBsZXZlbC4gIFRoZSBzdHlsZSB6b29tIHdpbGwgYmUgdXNlZCBvbmx5IGlmIHRoZSBtYXAgaGFzIG5vdCBiZWVuIHBvc2l0aW9uZWQgYnkgb3RoZXIgbWVhbnMgKGUuZy4gbWFwIG9wdGlvbnMgb3IgdXNlciBpbnRlcmFjdGlvbikuXCIsXG4gICAgICBcImV4YW1wbGVcIjogMTIuNVxuICAgIH0sXG4gICAgXCJiZWFyaW5nXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgICBcInBlcmlvZFwiOiAzNjAsXG4gICAgICBcInVuaXRzXCI6IFwiZGVncmVlc1wiLFxuICAgICAgXCJkb2NcIjogXCJEZWZhdWx0IGJlYXJpbmcsIGluIGRlZ3JlZXMuICBUaGUgc3R5bGUgYmVhcmluZyB3aWxsIGJlIHVzZWQgb25seSBpZiB0aGUgbWFwIGhhcyBub3QgYmVlbiBwb3NpdGlvbmVkIGJ5IG90aGVyIG1lYW5zIChlLmcuIG1hcCBvcHRpb25zIG9yIHVzZXIgaW50ZXJhY3Rpb24pLlwiLFxuICAgICAgXCJleGFtcGxlXCI6IDI5XG4gICAgfSxcbiAgICBcInBpdGNoXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgICBcInVuaXRzXCI6IFwiZGVncmVlc1wiLFxuICAgICAgXCJkb2NcIjogXCJEZWZhdWx0IHBpdGNoLCBpbiBkZWdyZWVzLiBaZXJvIGlzIHBlcnBlbmRpY3VsYXIgdG8gdGhlIHN1cmZhY2UuICBUaGUgc3R5bGUgcGl0Y2ggd2lsbCBiZSB1c2VkIG9ubHkgaWYgdGhlIG1hcCBoYXMgbm90IGJlZW4gcG9zaXRpb25lZCBieSBvdGhlciBtZWFucyAoZS5nLiBtYXAgb3B0aW9ucyBvciB1c2VyIGludGVyYWN0aW9uKS5cIixcbiAgICAgIFwiZXhhbXBsZVwiOiA1MFxuICAgIH0sXG4gICAgXCJzb3VyY2VzXCI6IHtcbiAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgIFwidHlwZVwiOiBcInNvdXJjZXNcIixcbiAgICAgIFwiZG9jXCI6IFwiRGF0YSBzb3VyY2Ugc3BlY2lmaWNhdGlvbnMuXCIsXG4gICAgICBcImV4YW1wbGVcIjoge1xuICAgICAgICBcIm1hcGJveC1zdHJlZXRzXCI6IHtcbiAgICAgICAgICBcInR5cGVcIjogXCJ2ZWN0b3JcIixcbiAgICAgICAgICBcInVybFwiOiBcIm1hcGJveDovL21hcGJveC5tYXBib3gtc3RyZWV0cy12NlwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwic3ByaXRlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJkb2NcIjogXCJBIGJhc2UgVVJMIGZvciByZXRyaWV2aW5nIHRoZSBzcHJpdGUgaW1hZ2UgYW5kIG1ldGFkYXRhLiBUaGUgZXh0ZW5zaW9ucyBgLnBuZ2AsIGAuanNvbmAgYW5kIHNjYWxlIGZhY3RvciBgQDJ4LnBuZ2Agd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGFwcGVuZGVkLlwiLFxuICAgICAgXCJleGFtcGxlXCI6IFwibWFwYm94Oi8vc3ByaXRlcy9tYXBib3gvYnJpZ2h0LXY4XCJcbiAgICB9LFxuICAgIFwiZ2x5cGhzXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJkb2NcIjogXCJBIFVSTCB0ZW1wbGF0ZSBmb3IgbG9hZGluZyBzaWduZWQtZGlzdGFuY2UtZmllbGQgZ2x5cGggc2V0cyBpbiBQQkYgZm9ybWF0LiBWYWxpZCB0b2tlbnMgYXJlIHtmb250c3RhY2t9IGFuZCB7cmFuZ2V9LlwiLFxuICAgICAgXCJleGFtcGxlXCI6IFwibWFwYm94Oi8vZm9udHMvbWFwYm94L3tmb250c3RhY2t9L3tyYW5nZX0ucGJmXCJcbiAgICB9LFxuICAgIFwidHJhbnNpdGlvblwiOiB7XG4gICAgICBcInR5cGVcIjogXCJ0cmFuc2l0aW9uXCIsXG4gICAgICBcImRvY1wiOiBcIkEgZ2xvYmFsIHRyYW5zaXRpb24gZGVmaW5pdGlvbiB0byB1c2UgYXMgYSBkZWZhdWx0IGFjcm9zcyBwcm9wZXJ0aWVzLlwiLFxuICAgICAgXCJleGFtcGxlXCI6IHtcbiAgICAgICAgXCJkdXJhdGlvblwiOiAzMDAsXG4gICAgICAgIFwiZGVsYXlcIjogMFxuICAgICAgfVxuICAgIH0sXG4gICAgXCJsYXllcnNcIjoge1xuICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgIFwidmFsdWVcIjogXCJsYXllclwiLFxuICAgICAgXCJkb2NcIjogXCJMYXllcnMgd2lsbCBiZSBkcmF3biBpbiB0aGUgb3JkZXIgb2YgdGhpcyBhcnJheS5cIixcbiAgICAgIFwiZXhhbXBsZVwiOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBcImlkXCI6IFwid2F0ZXJcIixcbiAgICAgICAgICBcInNvdXJjZVwiOiBcIm1hcGJveC1zdHJlZXRzXCIsXG4gICAgICAgICAgXCJzb3VyY2UtbGF5ZXJcIjogXCJ3YXRlclwiLFxuICAgICAgICAgIFwidHlwZVwiOiBcImZpbGxcIixcbiAgICAgICAgICBcInBhaW50XCI6IHtcbiAgICAgICAgICAgIFwiZmlsbC1jb2xvclwiOiBcIiMwMGZmZmZcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgXVxuICAgIH1cbiAgfSxcbiAgXCJzb3VyY2VzXCI6IHtcbiAgICBcIipcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic291cmNlXCIsXG4gICAgICBcImRvY1wiOiBcIlNwZWNpZmljYXRpb24gb2YgYSBkYXRhIHNvdXJjZS4gRm9yIHZlY3RvciBhbmQgcmFzdGVyIHNvdXJjZXMsIGVpdGhlciBUaWxlSlNPTiBvciBhIFVSTCB0byBhIFRpbGVKU09OIG11c3QgYmUgcHJvdmlkZWQuIEZvciBHZW9KU09OIGFuZCB2aWRlbyBzb3VyY2VzLCBhIFVSTCBtdXN0IGJlIHByb3ZpZGVkLlwiXG4gICAgfVxuICB9LFxuICBcInNvdXJjZVwiOiBbXG4gICAgXCJzb3VyY2VfdGlsZVwiLFxuICAgIFwic291cmNlX2dlb2pzb25cIixcbiAgICBcInNvdXJjZV92aWRlb1wiLFxuICAgIFwic291cmNlX2ltYWdlXCJcbiAgXSxcbiAgXCJzb3VyY2VfdGlsZVwiOiB7XG4gICAgXCJ0eXBlXCI6IHtcbiAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwidmFsdWVzXCI6IFtcbiAgICAgICAgXCJ2ZWN0b3JcIixcbiAgICAgICAgXCJyYXN0ZXJcIlxuICAgICAgXSxcbiAgICAgIFwiZG9jXCI6IFwiVGhlIGRhdGEgdHlwZSBvZiB0aGUgdGlsZSBzb3VyY2UuXCJcbiAgICB9LFxuICAgIFwidXJsXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJkb2NcIjogXCJBIFVSTCB0byBhIFRpbGVKU09OIHJlc291cmNlLiBTdXBwb3J0ZWQgcHJvdG9jb2xzIGFyZSBgaHR0cDpgLCBgaHR0cHM6YCwgYW5kIGBtYXBib3g6Ly88bWFwaWQ+YC5cIlxuICAgIH0sXG4gICAgXCJ0aWxlc1wiOiB7XG4gICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgXCJ2YWx1ZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJkb2NcIjogXCJBbiBhcnJheSBvZiBvbmUgb3IgbW9yZSB0aWxlIHNvdXJjZSBVUkxzLCBhcyBpbiB0aGUgVGlsZUpTT04gc3BlYy5cIlxuICAgIH0sXG4gICAgXCJtaW56b29tXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgICBcImRvY1wiOiBcIk1pbmltdW0gem9vbSBsZXZlbCBmb3Igd2hpY2ggdGlsZXMgYXJlIGF2YWlsYWJsZSwgYXMgaW4gdGhlIFRpbGVKU09OIHNwZWMuXCJcbiAgICB9LFxuICAgIFwibWF4em9vbVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAyMixcbiAgICAgIFwiZG9jXCI6IFwiTWF4aW11bSB6b29tIGxldmVsIGZvciB3aGljaCB0aWxlcyBhcmUgYXZhaWxhYmxlLCBhcyBpbiB0aGUgVGlsZUpTT04gc3BlYy4gRGF0YSBmcm9tIHRpbGVzIGF0IHRoZSBtYXh6b29tIGFyZSB1c2VkIHdoZW4gZGlzcGxheWluZyB0aGUgbWFwIGF0IGhpZ2hlciB6b29tIGxldmVscy5cIlxuICAgIH0sXG4gICAgXCJ0aWxlU2l6ZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiA1MTIsXG4gICAgICBcInVuaXRzXCI6IFwicGl4ZWxzXCIsXG4gICAgICBcImRvY1wiOiBcIlRoZSBtaW5pbXVtIHZpc3VhbCBzaXplIHRvIGRpc3BsYXkgdGlsZXMgZm9yIHRoaXMgbGF5ZXIuIE9ubHkgY29uZmlndXJhYmxlIGZvciByYXN0ZXIgbGF5ZXJzLlwiXG4gICAgfSxcbiAgICBcIipcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiKlwiLFxuICAgICAgXCJkb2NcIjogXCJPdGhlciBrZXlzIHRvIGNvbmZpZ3VyZSB0aGUgZGF0YSBzb3VyY2UuXCJcbiAgICB9XG4gIH0sXG4gIFwic291cmNlX2dlb2pzb25cIjoge1xuICAgIFwidHlwZVwiOiB7XG4gICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcInZhbHVlc1wiOiBbXG4gICAgICAgIFwiZ2VvanNvblwiXG4gICAgICBdLFxuICAgICAgXCJkb2NcIjogXCJUaGUgZGF0YSB0eXBlIG9mIHRoZSBHZW9KU09OIHNvdXJjZS5cIlxuICAgIH0sXG4gICAgXCJkYXRhXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIipcIixcbiAgICAgIFwiZG9jXCI6IFwiQSBVUkwgdG8gYSBHZW9KU09OIGZpbGUsIG9yIGlubGluZSBHZW9KU09OLlwiXG4gICAgfSxcbiAgICBcIm1heHpvb21cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMTQsXG4gICAgICBcImRvY1wiOiBcIk1heGltdW0gem9vbSB0byBwcmVzZXJ2ZSBkZXRhaWwgYXQuXCJcbiAgICB9LFxuICAgIFwiYnVmZmVyXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDY0LFxuICAgICAgXCJkb2NcIjogXCJUaWxlIGJ1ZmZlciBvbiBlYWNoIHNpZGUuXCJcbiAgICB9LFxuICAgIFwidG9sZXJhbmNlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDMsXG4gICAgICBcImRvY1wiOiBcIlNpbXBsaWZpY2F0aW9uIHRvbGVyYW5jZSAoaGlnaGVyIG1lYW5zIHNpbXBsZXIpLlwiXG4gICAgfVxuICB9LFxuICBcInNvdXJjZV92aWRlb1wiOiB7XG4gICAgXCJ0eXBlXCI6IHtcbiAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwidmFsdWVzXCI6IFtcbiAgICAgICAgXCJ2aWRlb1wiXG4gICAgICBdLFxuICAgICAgXCJkb2NcIjogXCJUaGUgZGF0YSB0eXBlIG9mIHRoZSB2aWRlbyBzb3VyY2UuXCJcbiAgICB9LFxuICAgIFwidXJsc1wiOiB7XG4gICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgXCJ2YWx1ZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJkb2NcIjogXCJVUkxzIHRvIHZpZGVvIGNvbnRlbnQgaW4gb3JkZXIgb2YgcHJlZmVycmVkIGZvcm1hdC5cIlxuICAgIH0sXG4gICAgXCJjb29yZGluYXRlc1wiOiB7XG4gICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICBcImRvY1wiOiBcIkNvcm5lcnMgb2YgdmlkZW8gc3BlY2lmaWVkIGluIGxvbmdpdHVkZSwgbGF0aXR1ZGUgcGFpcnMuXCIsXG4gICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgXCJsZW5ndGhcIjogNCxcbiAgICAgIFwidmFsdWVcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgICBcImxlbmd0aFwiOiAyLFxuICAgICAgICBcInZhbHVlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiZG9jXCI6IFwiQSBzaW5nbGUgbG9uZ2l0dWRlLCBsYXRpdHVkZSBwYWlyLlwiXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBcInNvdXJjZV9pbWFnZVwiOiB7XG4gICAgXCJ0eXBlXCI6IHtcbiAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwidmFsdWVzXCI6IFtcbiAgICAgICAgXCJpbWFnZVwiXG4gICAgICBdLFxuICAgICAgXCJkb2NcIjogXCJUaGUgZGF0YSB0eXBlIG9mIHRoZSBpbWFnZSBzb3VyY2UuXCJcbiAgICB9LFxuICAgIFwidXJsXCI6IHtcbiAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJkb2NcIjogXCJVUkwgdGhhdCBwb2ludHMgdG8gYW4gaW1hZ2VcIlxuICAgIH0sXG4gICAgXCJjb29yZGluYXRlc1wiOiB7XG4gICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICBcImRvY1wiOiBcIkNvcm5lcnMgb2YgaW1hZ2Ugc3BlY2lmaWVkIGluIGxvbmdpdHVkZSwgbGF0aXR1ZGUgcGFpcnMuXCIsXG4gICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgXCJsZW5ndGhcIjogNCxcbiAgICAgIFwidmFsdWVcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgICBcImxlbmd0aFwiOiAyLFxuICAgICAgICBcInZhbHVlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiZG9jXCI6IFwiQSBzaW5nbGUgbG9uZ2l0dWRlLCBsYXRpdHVkZSBwYWlyLlwiXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBcImxheWVyXCI6IHtcbiAgICBcImlkXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJkb2NcIjogXCJVbmlxdWUgbGF5ZXIgbmFtZS5cIlxuICAgIH0sXG4gICAgXCJ0eXBlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwidmFsdWVzXCI6IFtcbiAgICAgICAgXCJmaWxsXCIsXG4gICAgICAgIFwibGluZVwiLFxuICAgICAgICBcInN5bWJvbFwiLFxuICAgICAgICBcImNpcmNsZVwiLFxuICAgICAgICBcInJhc3RlclwiLFxuICAgICAgICBcImJhY2tncm91bmRcIlxuICAgICAgXSxcbiAgICAgIFwiZG9jXCI6IFwiUmVuZGVyaW5nIHR5cGUgb2YgdGhpcyBsYXllci5cIlxuICAgIH0sXG4gICAgXCJtZXRhZGF0YVwiOiB7XG4gICAgICBcInR5cGVcIjogXCIqXCIsXG4gICAgICBcImRvY1wiOiBcIkFyYml0cmFyeSBwcm9wZXJ0aWVzIHVzZWZ1bCB0byB0cmFjayB3aXRoIHRoZSBsYXllciwgYnV0IGRvIG5vdCBpbmZsdWVuY2UgcmVuZGVyaW5nLiBQcm9wZXJ0aWVzIHNob3VsZCBiZSBwcmVmaXhlZCB0byBhdm9pZCBjb2xsaXNpb25zLCBsaWtlICdtYXBib3g6Jy5cIlxuICAgIH0sXG4gICAgXCJyZWZcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImRvY1wiOiBcIlJlZmVyZW5jZXMgYW5vdGhlciBsYXllciB0byBjb3B5IGB0eXBlYCwgYHNvdXJjZWAsIGBzb3VyY2UtbGF5ZXJgLCBgbWluem9vbWAsIGBtYXh6b29tYCwgYGZpbHRlcmAsIGFuZCBgbGF5b3V0YCBwcm9wZXJ0aWVzIGZyb20uIFRoaXMgYWxsb3dzIHRoZSBsYXllcnMgdG8gc2hhcmUgcHJvY2Vzc2luZyBhbmQgYmUgbW9yZSBlZmZpY2llbnQuXCJcbiAgICB9LFxuICAgIFwic291cmNlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJkb2NcIjogXCJOYW1lIG9mIGEgc291cmNlIGRlc2NyaXB0aW9uIHRvIGJlIHVzZWQgZm9yIHRoaXMgbGF5ZXIuXCJcbiAgICB9LFxuICAgIFwic291cmNlLWxheWVyXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJkb2NcIjogXCJMYXllciB0byB1c2UgZnJvbSBhIHZlY3RvciB0aWxlIHNvdXJjZS4gUmVxdWlyZWQgaWYgdGhlIHNvdXJjZSBzdXBwb3J0cyBtdWx0aXBsZSBsYXllcnMuXCJcbiAgICB9LFxuICAgIFwibWluem9vbVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJtYXhpbXVtXCI6IDIyLFxuICAgICAgXCJkb2NcIjogXCJUaGUgbWluaW11bSB6b29tIGxldmVsIG9uIHdoaWNoIHRoZSBsYXllciBnZXRzIHBhcnNlZCBhbmQgYXBwZWFycyBvbi5cIlxuICAgIH0sXG4gICAgXCJtYXh6b29tXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcIm1heGltdW1cIjogMjIsXG4gICAgICBcImRvY1wiOiBcIlRoZSBtYXhpbXVtIHpvb20gbGV2ZWwgb24gd2hpY2ggdGhlIGxheWVyIGdldHMgcGFyc2VkIGFuZCBhcHBlYXJzIG9uLlwiXG4gICAgfSxcbiAgICBcImludGVyYWN0aXZlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgIFwiZG9jXCI6IFwiRW5hYmxlIHF1ZXJ5aW5nIG9mIGZlYXR1cmUgZGF0YSBmcm9tIHRoaXMgbGF5ZXIgZm9yIGludGVyYWN0aXZpdHkuXCIsXG4gICAgICBcImRlZmF1bHRcIjogZmFsc2VcbiAgICB9LFxuICAgIFwiZmlsdGVyXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImZpbHRlclwiLFxuICAgICAgXCJkb2NcIjogXCJBIGV4cHJlc3Npb24gc3BlY2lmeWluZyBjb25kaXRpb25zIG9uIHNvdXJjZSBmZWF0dXJlcy4gT25seSBmZWF0dXJlcyB0aGF0IG1hdGNoIHRoZSBmaWx0ZXIgYXJlIGRpc3BsYXllZC5cIlxuICAgIH0sXG4gICAgXCJsYXlvdXRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibGF5b3V0XCIsXG4gICAgICBcImRvY1wiOiBcIkxheW91dCBwcm9wZXJ0aWVzIGZvciB0aGUgbGF5ZXIuXCJcbiAgICB9LFxuICAgIFwicGFpbnRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwicGFpbnRcIixcbiAgICAgIFwiZG9jXCI6IFwiRGVmYXVsdCBwYWludCBwcm9wZXJ0aWVzIGZvciB0aGlzIGxheWVyLlwiXG4gICAgfSxcbiAgICBcInBhaW50LipcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwicGFpbnRcIixcbiAgICAgIFwiZG9jXCI6IFwiQ2xhc3Mtc3BlY2lmaWMgcGFpbnQgcHJvcGVydGllcyBmb3IgdGhpcyBsYXllci4gVGhlIGNsYXNzIG5hbWUgaXMgdGhlIHBhcnQgYWZ0ZXIgdGhlIGZpcnN0IGRvdC5cIlxuICAgIH1cbiAgfSxcbiAgXCJsYXlvdXRcIjogW1xuICAgIFwibGF5b3V0X2ZpbGxcIixcbiAgICBcImxheW91dF9saW5lXCIsXG4gICAgXCJsYXlvdXRfY2lyY2xlXCIsXG4gICAgXCJsYXlvdXRfc3ltYm9sXCIsXG4gICAgXCJsYXlvdXRfcmFzdGVyXCIsXG4gICAgXCJsYXlvdXRfYmFja2dyb3VuZFwiXG4gIF0sXG4gIFwibGF5b3V0X2JhY2tncm91bmRcIjoge1xuICAgIFwidmlzaWJpbGl0eVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcInZhbHVlc1wiOiBbXG4gICAgICAgIFwidmlzaWJsZVwiLFxuICAgICAgICBcIm5vbmVcIlxuICAgICAgXSxcbiAgICAgIFwiZGVmYXVsdFwiOiBcInZpc2libGVcIixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIGRpc3BsYXkgb2YgdGhpcyBsYXllci4gYG5vbmVgIGhpZGVzIHRoaXMgbGF5ZXIuXCJcbiAgICB9XG4gIH0sXG4gIFwibGF5b3V0X2ZpbGxcIjoge1xuICAgIFwidmlzaWJpbGl0eVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcInZhbHVlc1wiOiBbXG4gICAgICAgIFwidmlzaWJsZVwiLFxuICAgICAgICBcIm5vbmVcIlxuICAgICAgXSxcbiAgICAgIFwiZGVmYXVsdFwiOiBcInZpc2libGVcIixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIGRpc3BsYXkgb2YgdGhpcyBsYXllci4gYG5vbmVgIGhpZGVzIHRoaXMgbGF5ZXIuXCJcbiAgICB9XG4gIH0sXG4gIFwibGF5b3V0X2NpcmNsZVwiOiB7XG4gICAgXCJ2aXNpYmlsaXR5XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwidmFsdWVzXCI6IFtcbiAgICAgICAgXCJ2aXNpYmxlXCIsXG4gICAgICAgIFwibm9uZVwiXG4gICAgICBdLFxuICAgICAgXCJkZWZhdWx0XCI6IFwidmlzaWJsZVwiLFxuICAgICAgXCJkb2NcIjogXCJUaGUgZGlzcGxheSBvZiB0aGlzIGxheWVyLiBgbm9uZWAgaGlkZXMgdGhpcyBsYXllci5cIlxuICAgIH1cbiAgfSxcbiAgXCJsYXlvdXRfbGluZVwiOiB7XG4gICAgXCJsaW5lLWNhcFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcInZhbHVlc1wiOiBbXG4gICAgICAgIFwiYnV0dFwiLFxuICAgICAgICBcInJvdW5kXCIsXG4gICAgICAgIFwic3F1YXJlXCJcbiAgICAgIF0sXG4gICAgICBcImRlZmF1bHRcIjogXCJidXR0XCIsXG4gICAgICBcImRvY1wiOiBcIlRoZSBkaXNwbGF5IG9mIGxpbmUgZW5kaW5ncy5cIlxuICAgIH0sXG4gICAgXCJsaW5lLWpvaW5cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcInBpZWNld2lzZS1jb25zdGFudFwiLFxuICAgICAgXCJ2YWx1ZXNcIjogW1xuICAgICAgICBcImJldmVsXCIsXG4gICAgICAgIFwicm91bmRcIixcbiAgICAgICAgXCJtaXRlclwiXG4gICAgICBdLFxuICAgICAgXCJkZWZhdWx0XCI6IFwibWl0ZXJcIixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIGRpc3BsYXkgb2YgbGluZXMgd2hlbiBqb2luaW5nLlwiXG4gICAgfSxcbiAgICBcImxpbmUtbWl0ZXItbGltaXRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwiZG9jXCI6IFwiVXNlZCB0byBhdXRvbWF0aWNhbGx5IGNvbnZlcnQgbWl0ZXIgam9pbnMgdG8gYmV2ZWwgam9pbnMgZm9yIHNoYXJwIGFuZ2xlcy5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICB7XG4gICAgICAgICAgXCJsaW5lLWpvaW5cIjogXCJtaXRlclwiXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9LFxuICAgIFwibGluZS1yb3VuZC1saW1pdFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAxLjA1LFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJkb2NcIjogXCJVc2VkIHRvIGF1dG9tYXRpY2FsbHkgY29udmVydCByb3VuZCBqb2lucyB0byBtaXRlciBqb2lucyBmb3Igc2hhbGxvdyBhbmdsZXMuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAge1xuICAgICAgICAgIFwibGluZS1qb2luXCI6IFwicm91bmRcIlxuICAgICAgICB9XG4gICAgICBdXG4gICAgfSxcbiAgICBcInZpc2liaWxpdHlcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcInBpZWNld2lzZS1jb25zdGFudFwiLFxuICAgICAgXCJ2YWx1ZXNcIjogW1xuICAgICAgICBcInZpc2libGVcIixcbiAgICAgICAgXCJub25lXCJcbiAgICAgIF0sXG4gICAgICBcImRlZmF1bHRcIjogXCJ2aXNpYmxlXCIsXG4gICAgICBcImRvY1wiOiBcIlRoZSBkaXNwbGF5IG9mIHRoaXMgbGF5ZXIuIGBub25lYCBoaWRlcyB0aGlzIGxheWVyLlwiXG4gICAgfVxuICB9LFxuICBcImxheW91dF9zeW1ib2xcIjoge1xuICAgIFwic3ltYm9sLXBsYWNlbWVudFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcInZhbHVlc1wiOiBbXG4gICAgICAgICAgXCJwb2ludFwiLFxuICAgICAgICAgIFwibGluZVwiXG4gICAgICBdLFxuICAgICAgXCJkZWZhdWx0XCI6IFwicG9pbnRcIixcbiAgICAgIFwiZG9jXCI6IFwiTGFiZWwgcGxhY2VtZW50IHJlbGF0aXZlIHRvIGl0cyBnZW9tZXRyeS4gYGxpbmVgIGNhbiBvbmx5IGJlIHVzZWQgb24gTGluZVN0cmluZ3MgYW5kIFBvbHlnb25zLlwiXG4gICAgfSxcbiAgICBcInN5bWJvbC1zcGFjaW5nXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDI1MCxcbiAgICAgIFwibWluaW11bVwiOiAxLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ1bml0c1wiOiBcInBpeGVsc1wiLFxuICAgICAgXCJkb2NcIjogXCJEaXN0YW5jZSBiZXR3ZWVuIHR3byBzeW1ib2wgYW5jaG9ycy5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICB7XG4gICAgICAgICAgXCJzeW1ib2wtcGxhY2VtZW50XCI6IFwibGluZVwiXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9LFxuICAgIFwic3ltYm9sLWF2b2lkLWVkZ2VzXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwiZGVmYXVsdFwiOiBmYWxzZSxcbiAgICAgIFwiZG9jXCI6IFwiSWYgdHJ1ZSwgdGhlIHN5bWJvbHMgd2lsbCBub3QgY3Jvc3MgdGlsZSBlZGdlcyB0byBhdm9pZCBtdXR1YWwgY29sbGlzaW9ucy4gUmVjb21tZW5kZWQgaW4gbGF5ZXJzIHRoYXQgZG9uJ3QgaGF2ZSBlbm91Z2ggcGFkZGluZyBpbiB0aGUgdmVjdG9yIHRpbGUgdG8gcHJldmVudCBjb2xsaXNpb25zLCBvciBpZiBpdCBpcyBhIHBvaW50IHN5bWJvbCBsYXllciBwbGFjZWQgYWZ0ZXIgYSBsaW5lIHN5bWJvbCBsYXllci5cIlxuICAgIH0sXG4gICAgXCJpY29uLWFsbG93LW92ZXJsYXBcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcInBpZWNld2lzZS1jb25zdGFudFwiLFxuICAgICAgXCJkZWZhdWx0XCI6IGZhbHNlLFxuICAgICAgXCJkb2NcIjogXCJJZiB0cnVlLCB0aGUgaWNvbiB3aWxsIGJlIHZpc2libGUgZXZlbiBpZiBpdCBjb2xsaWRlcyB3aXRoIG90aGVyIHByZXZpb3VzbHkgZHJhd24gc3ltYm9scy5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcImljb24taW1hZ2VcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJpY29uLWlnbm9yZS1wbGFjZW1lbnRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcInBpZWNld2lzZS1jb25zdGFudFwiLFxuICAgICAgXCJkZWZhdWx0XCI6IGZhbHNlLFxuICAgICAgXCJkb2NcIjogXCJJZiB0cnVlLCBvdGhlciBzeW1ib2xzIGNhbiBiZSB2aXNpYmxlIGV2ZW4gaWYgdGhleSBjb2xsaWRlIHdpdGggdGhlIGljb24uXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJpY29uLWltYWdlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwiaWNvbi1vcHRpb25hbFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcImRlZmF1bHRcIjogZmFsc2UsXG4gICAgICBcImRvY1wiOiBcIklmIHRydWUsIHRleHQgd2lsbCBkaXNwbGF5IHdpdGhvdXQgdGhlaXIgY29ycmVzcG9uZGluZyBpY29ucyB3aGVuIHRoZSBpY29uIGNvbGxpZGVzIHdpdGggb3RoZXIgc3ltYm9scyBhbmQgdGhlIHRleHQgZG9lcyBub3QuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJpY29uLWltYWdlXCIsXG4gICAgICAgIFwidGV4dC1maWVsZFwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcImljb24tcm90YXRpb24tYWxpZ25tZW50XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwidmFsdWVzXCI6IFtcbiAgICAgICAgXCJtYXBcIixcbiAgICAgICAgXCJ2aWV3cG9ydFwiXG4gICAgICBdLFxuICAgICAgXCJkZWZhdWx0XCI6IFwidmlld3BvcnRcIixcbiAgICAgIFwiZG9jXCI6IFwiT3JpZW50YXRpb24gb2YgaWNvbiB3aGVuIG1hcCBpcyByb3RhdGVkLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwiaWNvbi1pbWFnZVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcImljb24tc2l6ZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAxLFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcImRvY1wiOiBcIlNjYWxlIGZhY3RvciBmb3IgaWNvbi4gMSBpcyBvcmlnaW5hbCBzaXplLCAzIHRyaXBsZXMgdGhlIHNpemUuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJpY29uLWltYWdlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwiaWNvbi1pbWFnZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwiZG9jXCI6IFwiQSBzdHJpbmcgd2l0aCB7dG9rZW5zfSByZXBsYWNlZCwgcmVmZXJlbmNpbmcgdGhlIGRhdGEgcHJvcGVydHkgdG8gcHVsbCBmcm9tLlwiLFxuICAgICAgXCJ0b2tlbnNcIjogdHJ1ZVxuICAgIH0sXG4gICAgXCJpY29uLXJvdGF0ZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgICAgXCJwZXJpb2RcIjogMzYwLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ1bml0c1wiOiBcImRlZ3JlZXNcIixcbiAgICAgIFwiZG9jXCI6IFwiUm90YXRlcyB0aGUgaWNvbiBjbG9ja3dpc2UuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJpY29uLWltYWdlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwiaWNvbi1wYWRkaW5nXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDIsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwidW5pdHNcIjogXCJwaXhlbHNcIixcbiAgICAgIFwiZG9jXCI6IFwiU2l6ZSBvZiB0aGUgYWRkaXRpb25hbCBhcmVhIGFyb3VuZCB0aGUgaWNvbiBib3VuZGluZyBib3ggdXNlZCBmb3IgZGV0ZWN0aW5nIHN5bWJvbCBjb2xsaXNpb25zLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwiaWNvbi1pbWFnZVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcImljb24ta2VlcC11cHJpZ2h0XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwiZGVmYXVsdFwiOiBmYWxzZSxcbiAgICAgIFwiZG9jXCI6IFwiSWYgdHJ1ZSwgdGhlIGljb24gbWF5IGJlIGZsaXBwZWQgdG8gcHJldmVudCBpdCBmcm9tIGJlaW5nIHJlbmRlcmVkIHVwc2lkZS1kb3duLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwiaWNvbi1pbWFnZVwiLFxuICAgICAgICB7XG4gICAgICAgICAgXCJpY29uLXJvdGF0aW9uLWFsaWdubWVudFwiOiBcIm1hcFwiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBcInN5bWJvbC1wbGFjZW1lbnRcIjogXCJsaW5lXCJcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0sXG4gICAgXCJpY29uLW9mZnNldFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgXCJ2YWx1ZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJsZW5ndGhcIjogMixcbiAgICAgIFwiZGVmYXVsdFwiOiBbXG4gICAgICAgIDAsXG4gICAgICAgIDBcbiAgICAgIF0sXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcImRvY1wiOiBcIk9mZnNldCBkaXN0YW5jZSBvZiBpY29uIGZyb20gaXRzIGFuY2hvci4gUG9zaXRpdmUgdmFsdWVzIGluZGljYXRlIHJpZ2h0IGFuZCBkb3duLCB3aGlsZSBuZWdhdGl2ZSB2YWx1ZXMgaW5kaWNhdGUgbGVmdCBhbmQgdXAuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJpY29uLWltYWdlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwidGV4dC1yb3RhdGlvbi1hbGlnbm1lbnRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcInBpZWNld2lzZS1jb25zdGFudFwiLFxuICAgICAgXCJ2YWx1ZXNcIjogW1xuICAgICAgICBcIm1hcFwiLFxuICAgICAgICBcInZpZXdwb3J0XCJcbiAgICAgIF0sXG4gICAgICBcImRlZmF1bHRcIjogXCJ2aWV3cG9ydFwiLFxuICAgICAgXCJkb2NcIjogXCJPcmllbnRhdGlvbiBvZiB0ZXh0IHdoZW4gbWFwIGlzIHJvdGF0ZWQuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJ0ZXh0LWZpZWxkXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwidGV4dC1maWVsZFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwiZGVmYXVsdFwiOiBcIlwiLFxuICAgICAgXCJ0b2tlbnNcIjogdHJ1ZSxcbiAgICAgIFwiZG9jXCI6IFwiVmFsdWUgdG8gdXNlIGZvciBhIHRleHQgbGFiZWwuIEZlYXR1cmUgcHJvcGVydGllcyBhcmUgc3BlY2lmaWVkIHVzaW5nIHRva2VucyBsaWtlIHtmaWVsZF9uYW1lfS5cIlxuICAgIH0sXG4gICAgXCJ0ZXh0LWZvbnRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgIFwidmFsdWVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwiZGVmYXVsdFwiOiBbXCJPcGVuIFNhbnMgUmVndWxhclwiLCBcIkFyaWFsIFVuaWNvZGUgTVMgUmVndWxhclwiXSxcbiAgICAgIFwiZG9jXCI6IFwiRm9udCBzdGFjayB0byB1c2UgZm9yIGRpc3BsYXlpbmcgdGV4dC5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJ0ZXh0LXNpemVcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMTYsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwidW5pdHNcIjogXCJwaXhlbHNcIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwiZG9jXCI6IFwiRm9udCBzaXplLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwidGV4dC1maWVsZFwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInRleHQtbWF4LXdpZHRoXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDEwLFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcInVuaXRzXCI6IFwiZW1cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIG1heGltdW0gbGluZSB3aWR0aCBmb3IgdGV4dCB3cmFwcGluZy5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJ0ZXh0LWxpbmUtaGVpZ2h0XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDEuMixcbiAgICAgIFwidW5pdHNcIjogXCJlbVwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJkb2NcIjogXCJUZXh0IGxlYWRpbmcgdmFsdWUgZm9yIG11bHRpLWxpbmUgdGV4dC5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJ0ZXh0LWxldHRlci1zcGFjaW5nXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgICBcInVuaXRzXCI6IFwiZW1cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwiZG9jXCI6IFwiVGV4dCB0cmFja2luZyBhbW91bnQuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJ0ZXh0LWZpZWxkXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwidGV4dC1qdXN0aWZ5XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwidmFsdWVzXCI6IFtcbiAgICAgICAgXCJsZWZ0XCIsXG4gICAgICAgIFwiY2VudGVyXCIsXG4gICAgICAgIFwicmlnaHRcIlxuICAgICAgXSxcbiAgICAgIFwiZGVmYXVsdFwiOiBcImNlbnRlclwiLFxuICAgICAgXCJkb2NcIjogXCJUZXh0IGp1c3RpZmljYXRpb24gb3B0aW9ucy5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJ0ZXh0LWFuY2hvclwiOiB7XG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcInZhbHVlc1wiOiBbXG4gICAgICAgIFwiY2VudGVyXCIsXG4gICAgICAgIFwibGVmdFwiLFxuICAgICAgICBcInJpZ2h0XCIsXG4gICAgICAgIFwidG9wXCIsXG4gICAgICAgIFwiYm90dG9tXCIsXG4gICAgICAgIFwidG9wLWxlZnRcIixcbiAgICAgICAgXCJ0b3AtcmlnaHRcIixcbiAgICAgICAgXCJib3R0b20tbGVmdFwiLFxuICAgICAgICBcImJvdHRvbS1yaWdodFwiXG4gICAgICBdLFxuICAgICAgXCJkZWZhdWx0XCI6IFwiY2VudGVyXCIsXG4gICAgICBcImRvY1wiOiBcIlBhcnQgb2YgdGhlIHRleHQgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJ0ZXh0LW1heC1hbmdsZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiA0NSxcbiAgICAgIFwidW5pdHNcIjogXCJkZWdyZWVzXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcImRvY1wiOiBcIk1heGltdW0gYW5nbGUgY2hhbmdlIGJldHdlZW4gYWRqYWNlbnQgY2hhcmFjdGVycy5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIixcbiAgICAgICAge1xuICAgICAgICAgIFwic3ltYm9sLXBsYWNlbWVudFwiOiBcImxpbmVcIlxuICAgICAgICB9XG4gICAgICBdXG4gICAgfSxcbiAgICBcInRleHQtcm90YXRlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgICBcInBlcmlvZFwiOiAzNjAsXG4gICAgICBcInVuaXRzXCI6IFwiZGVncmVlc1wiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJkb2NcIjogXCJSb3RhdGVzIHRoZSB0ZXh0IGNsb2Nrd2lzZS5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJ0ZXh0LXBhZGRpbmdcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMixcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJ1bml0c1wiOiBcInBpeGVsc1wiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJkb2NcIjogXCJTaXplIG9mIHRoZSBhZGRpdGlvbmFsIGFyZWEgYXJvdW5kIHRoZSB0ZXh0IGJvdW5kaW5nIGJveCB1c2VkIGZvciBkZXRlY3Rpbmcgc3ltYm9sIGNvbGxpc2lvbnMuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJ0ZXh0LWZpZWxkXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwidGV4dC1rZWVwLXVwcmlnaHRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcInBpZWNld2lzZS1jb25zdGFudFwiLFxuICAgICAgXCJkZWZhdWx0XCI6IHRydWUsXG4gICAgICBcImRvY1wiOiBcIklmIHRydWUsIHRoZSB0ZXh0IG1heSBiZSBmbGlwcGVkIHZlcnRpY2FsbHkgdG8gcHJldmVudCBpdCBmcm9tIGJlaW5nIHJlbmRlcmVkIHVwc2lkZS1kb3duLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwidGV4dC1maWVsZFwiLFxuICAgICAgICB7XG4gICAgICAgICAgXCJ0ZXh0LXJvdGF0aW9uLWFsaWdubWVudFwiOiBcIm1hcFwiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBcInN5bWJvbC1wbGFjZW1lbnRcIjogXCJsaW5lXCJcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0sXG4gICAgXCJ0ZXh0LXRyYW5zZm9ybVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcInZhbHVlc1wiOiBbXG4gICAgICAgIFwibm9uZVwiLFxuICAgICAgICBcInVwcGVyY2FzZVwiLFxuICAgICAgICBcImxvd2VyY2FzZVwiXG4gICAgICBdLFxuICAgICAgXCJkZWZhdWx0XCI6IFwibm9uZVwiLFxuICAgICAgXCJkb2NcIjogXCJTcGVjaWZpZXMgaG93IHRvIGNhcGl0YWxpemUgdGV4dCwgc2ltaWxhciB0byB0aGUgQ1NTIGB0ZXh0LXRyYW5zZm9ybWAgcHJvcGVydHkuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJ0ZXh0LWZpZWxkXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwidGV4dC1vZmZzZXRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgIFwiZG9jXCI6IFwiT2Zmc2V0IGRpc3RhbmNlIG9mIHRleHQgZnJvbSBpdHMgYW5jaG9yLiBQb3NpdGl2ZSB2YWx1ZXMgaW5kaWNhdGUgcmlnaHQgYW5kIGRvd24sIHdoaWxlIG5lZ2F0aXZlIHZhbHVlcyBpbmRpY2F0ZSBsZWZ0IGFuZCB1cC5cIixcbiAgICAgIFwidmFsdWVcIjogXCJudW1iZXJcIixcbiAgICAgIFwidW5pdHNcIjogXCJlbXNcIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwibGVuZ3RoXCI6IDIsXG4gICAgICBcImRlZmF1bHRcIjogW1xuICAgICAgICAwLFxuICAgICAgICAwXG4gICAgICBdLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwidGV4dC1maWVsZFwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInRleHQtYWxsb3ctb3ZlcmxhcFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcImRlZmF1bHRcIjogZmFsc2UsXG4gICAgICBcImRvY1wiOiBcIklmIHRydWUsIHRoZSB0ZXh0IHdpbGwgYmUgdmlzaWJsZSBldmVuIGlmIGl0IGNvbGxpZGVzIHdpdGggb3RoZXIgcHJldmlvdXNseSBkcmF3biBzeW1ib2xzLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwidGV4dC1maWVsZFwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInRleHQtaWdub3JlLXBsYWNlbWVudFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcImRlZmF1bHRcIjogZmFsc2UsXG4gICAgICBcImRvY1wiOiBcIklmIHRydWUsIG90aGVyIHN5bWJvbHMgY2FuIGJlIHZpc2libGUgZXZlbiBpZiB0aGV5IGNvbGxpZGUgd2l0aCB0aGUgdGV4dC5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJ0ZXh0LW9wdGlvbmFsXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwiZGVmYXVsdFwiOiBmYWxzZSxcbiAgICAgIFwiZG9jXCI6IFwiSWYgdHJ1ZSwgaWNvbnMgd2lsbCBkaXNwbGF5IHdpdGhvdXQgdGhlaXIgY29ycmVzcG9uZGluZyB0ZXh0IHdoZW4gdGhlIHRleHQgY29sbGlkZXMgd2l0aCBvdGhlciBzeW1ib2xzIGFuZCB0aGUgaWNvbiBkb2VzIG5vdC5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIixcbiAgICAgICAgXCJpY29uLWltYWdlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwidmlzaWJpbGl0eVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcInZhbHVlc1wiOiBbXG4gICAgICAgIFwidmlzaWJsZVwiLFxuICAgICAgICBcIm5vbmVcIlxuICAgICAgXSxcbiAgICAgIFwiZGVmYXVsdFwiOiBcInZpc2libGVcIixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIGRpc3BsYXkgb2YgdGhpcyBsYXllci4gYG5vbmVgIGhpZGVzIHRoaXMgbGF5ZXIuXCJcbiAgICB9XG4gIH0sXG4gIFwibGF5b3V0X3Jhc3RlclwiOiB7XG4gICAgXCJ2aXNpYmlsaXR5XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwidmFsdWVzXCI6IFtcbiAgICAgICAgXCJ2aXNpYmxlXCIsXG4gICAgICAgIFwibm9uZVwiXG4gICAgICBdLFxuICAgICAgXCJkZWZhdWx0XCI6IFwidmlzaWJsZVwiLFxuICAgICAgXCJkb2NcIjogXCJUaGUgZGlzcGxheSBvZiB0aGlzIGxheWVyLiBgbm9uZWAgaGlkZXMgdGhpcyBsYXllci5cIlxuICAgIH1cbiAgfSxcbiAgXCJmaWx0ZXJcIjoge1xuICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgXCJ2YWx1ZVwiOiBcIipcIixcbiAgICBcImRvY1wiOiBcIkEgZmlsdGVyIHNlbGVjdHMgc3BlY2lmaWMgZmVhdHVyZXMgZnJvbSBhIGxheWVyLlwiXG4gIH0sXG4gIFwiZmlsdGVyX29wZXJhdG9yXCI6IHtcbiAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgXCJ2YWx1ZXNcIjogW1xuICAgICAgXCI9PVwiLFxuICAgICAgXCIhPVwiLFxuICAgICAgXCI+XCIsXG4gICAgICBcIj49XCIsXG4gICAgICBcIjxcIixcbiAgICAgIFwiPD1cIixcbiAgICAgIFwiaW5cIixcbiAgICAgIFwiIWluXCIsXG4gICAgICBcImFsbFwiLFxuICAgICAgXCJhbnlcIixcbiAgICAgIFwibm9uZVwiXG4gICAgXSxcbiAgICBcImRvY1wiOiBcIlRoZSBmaWx0ZXIgb3BlcmF0b3IuXCJcbiAgfSxcbiAgXCJnZW9tZXRyeV90eXBlXCI6IHtcbiAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgXCJ2YWx1ZXNcIjogW1xuICAgICAgXCJQb2ludFwiLFxuICAgICAgXCJMaW5lU3RyaW5nXCIsXG4gICAgICBcIlBvbHlnb25cIlxuICAgIF0sXG4gICAgXCJkb2NcIjogXCJUaGUgZ2VvbWV0cnkgdHlwZSBmb3IgdGhlIGZpbHRlciB0byBzZWxlY3QuXCJcbiAgfSxcbiAgXCJjb2xvcl9vcGVyYXRpb25cIjoge1xuICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICBcInZhbHVlc1wiOiBbXG4gICAgICBcImxpZ2h0ZW5cIixcbiAgICAgIFwic2F0dXJhdGVcIixcbiAgICAgIFwic3BpblwiLFxuICAgICAgXCJmYWRlXCIsXG4gICAgICBcIm1peFwiXG4gICAgXSxcbiAgICBcImRvY1wiOiBcIkEgY29sb3Igb3BlcmF0aW9uIHRvIGFwcGx5LlwiXG4gIH0sXG4gIFwiZnVuY3Rpb25cIjoge1xuICAgIFwic3RvcHNcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgIFwiZG9jXCI6IFwiQW4gYXJyYXkgb2Ygc3RvcHMuXCIsXG4gICAgICBcInZhbHVlXCI6IFwiZnVuY3Rpb25fc3RvcFwiXG4gICAgfSxcbiAgICBcImJhc2VcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMSxcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJkb2NcIjogXCJUaGUgZXhwb25lbnRpYWwgYmFzZSBvZiB0aGUgaW50ZXJwb2xhdGlvbiBjdXJ2ZS4gSXQgY29udHJvbHMgdGhlIHJhdGUgYXQgd2hpY2ggdGhlIHJlc3VsdCBpbmNyZWFzZXMuIEhpZ2hlciB2YWx1ZXMgbWFrZSB0aGUgcmVzdWx0IGluY3JlYXNlIG1vcmUgdG93YXJkcyB0aGUgaGlnaCBlbmQgb2YgdGhlIHJhbmdlLiBXaXRoIGAxYCB0aGUgc3RvcHMgYXJlIGludGVycG9sYXRlZCBsaW5lYXJseS5cIlxuICAgIH1cbiAgfSxcbiAgXCJmdW5jdGlvbl9zdG9wXCI6IHtcbiAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgIFwibWluaW11bVwiOiAwLFxuICAgIFwibWF4aW11bVwiOiAyMixcbiAgICBcInZhbHVlXCI6IFtcbiAgICAgIFwibnVtYmVyXCIsXG4gICAgICBcImNvbG9yXCJcbiAgICBdLFxuICAgIFwibGVuZ3RoXCI6IDIsXG4gICAgXCJkb2NcIjogXCJab29tIGxldmVsIGFuZCB2YWx1ZSBwYWlyLlwiXG4gIH0sXG4gIFwicGFpbnRcIjogW1xuICAgIFwicGFpbnRfZmlsbFwiLFxuICAgIFwicGFpbnRfbGluZVwiLFxuICAgIFwicGFpbnRfY2lyY2xlXCIsXG4gICAgXCJwYWludF9zeW1ib2xcIixcbiAgICBcInBhaW50X3Jhc3RlclwiLFxuICAgIFwicGFpbnRfYmFja2dyb3VuZFwiXG4gIF0sXG4gIFwicGFpbnRfZmlsbFwiOiB7XG4gICAgXCJmaWxsLWFudGlhbGlhc1wiOiB7XG4gICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcImRlZmF1bHRcIjogdHJ1ZSxcbiAgICAgIFwiZG9jXCI6IFwiV2hldGhlciBvciBub3QgdGhlIGZpbGwgc2hvdWxkIGJlIGFudGlhbGlhc2VkLlwiXG4gICAgfSxcbiAgICBcImZpbGwtb3BhY2l0eVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAxLFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcIm1heGltdW1cIjogMSxcbiAgICAgIFwiZG9jXCI6IFwiVGhlIG9wYWNpdHkgZ2l2ZW4gdG8gdGhlIGZpbGwgY29sb3IuXCIsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZVxuICAgIH0sXG4gICAgXCJmaWxsLWNvbG9yXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImNvbG9yXCIsXG4gICAgICBcImRlZmF1bHRcIjogXCIjMDAwMDAwXCIsXG4gICAgICBcImRvY1wiOiBcIlRoZSBjb2xvciBvZiB0aGUgZmlsbC5cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBcIiFcIjogXCJmaWxsLXBhdHRlcm5cIlxuICAgICAgICB9XG4gICAgICBdXG4gICAgfSxcbiAgICBcImZpbGwtb3V0bGluZS1jb2xvclwiOiB7XG4gICAgICBcInR5cGVcIjogXCJjb2xvclwiLFxuICAgICAgXCJkb2NcIjogXCJUaGUgb3V0bGluZSBjb2xvciBvZiB0aGUgZmlsbC4gTWF0Y2hlcyB0aGUgdmFsdWUgb2YgYGZpbGwtY29sb3JgIGlmIHVuc3BlY2lmaWVkLlwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAge1xuICAgICAgICAgIFwiIVwiOiBcImZpbGwtcGF0dGVyblwiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBcImZpbGwtYW50aWFsaWFzXCI6IHRydWVcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0sXG4gICAgXCJmaWxsLXRyYW5zbGF0ZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgXCJ2YWx1ZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJsZW5ndGhcIjogMixcbiAgICAgIFwiZGVmYXVsdFwiOiBbXG4gICAgICAgIDAsXG4gICAgICAgIDBcbiAgICAgIF0sXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwidW5pdHNcIjogXCJwaXhlbHNcIixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIGdlb21ldHJ5J3Mgb2Zmc2V0LiBWYWx1ZXMgYXJlIFt4LCB5XSB3aGVyZSBuZWdhdGl2ZXMgaW5kaWNhdGUgbGVmdCBhbmQgdXAsIHJlc3BlY3RpdmVseS5cIlxuICAgIH0sXG4gICAgXCJmaWxsLXRyYW5zbGF0ZS1hbmNob3JcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcInBpZWNld2lzZS1jb25zdGFudFwiLFxuICAgICAgXCJ2YWx1ZXNcIjogW1xuICAgICAgICBcIm1hcFwiLFxuICAgICAgICBcInZpZXdwb3J0XCJcbiAgICAgIF0sXG4gICAgICBcImRvY1wiOiBcIkNvbnRyb2wgd2hldGhlciB0aGUgdHJhbnNsYXRpb24gaXMgcmVsYXRpdmUgdG8gdGhlIG1hcCAobm9ydGgpIG9yIHZpZXdwb3J0IChzY3JlZW4pXCIsXG4gICAgICBcImRlZmF1bHRcIjogXCJtYXBcIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcImZpbGwtdHJhbnNsYXRlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwiZmlsbC1wYXR0ZXJuXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcInBpZWNld2lzZS1jb25zdGFudFwiLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcImRvY1wiOiBcIk5hbWUgb2YgaW1hZ2UgaW4gc3ByaXRlIHRvIHVzZSBmb3IgZHJhd2luZyBpbWFnZSBmaWxscy4gRm9yIHNlYW1sZXNzIHBhdHRlcm5zLCBpbWFnZSB3aWR0aCBhbmQgaGVpZ2h0IG11c3QgYmUgYSBmYWN0b3Igb2YgdHdvICgyLCA0LCA4LCAuLi4sIDUxMikuXCJcbiAgICB9XG4gIH0sXG4gIFwicGFpbnRfbGluZVwiOiB7XG4gICAgXCJsaW5lLW9wYWNpdHlcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRvY1wiOiBcIlRoZSBvcGFjaXR5IGF0IHdoaWNoIHRoZSBsaW5lIHdpbGwgYmUgZHJhd24uXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcImRlZmF1bHRcIjogMSxcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJtYXhpbXVtXCI6IDEsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZVxuICAgIH0sXG4gICAgXCJsaW5lLWNvbG9yXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImNvbG9yXCIsXG4gICAgICBcImRvY1wiOiBcIlRoZSBjb2xvciB3aXRoIHdoaWNoIHRoZSBsaW5lIHdpbGwgYmUgZHJhd24uXCIsXG4gICAgICBcImRlZmF1bHRcIjogXCIjMDAwMDAwXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICB7XG4gICAgICAgICAgXCIhXCI6IFwibGluZS1wYXR0ZXJuXCJcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0sXG4gICAgXCJsaW5lLXRyYW5zbGF0ZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgXCJ2YWx1ZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJsZW5ndGhcIjogMixcbiAgICAgIFwiZGVmYXVsdFwiOiBbXG4gICAgICAgIDAsXG4gICAgICAgIDBcbiAgICAgIF0sXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwidW5pdHNcIjogXCJwaXhlbHNcIixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIGdlb21ldHJ5J3Mgb2Zmc2V0LiBWYWx1ZXMgYXJlIFt4LCB5XSB3aGVyZSBuZWdhdGl2ZXMgaW5kaWNhdGUgbGVmdCBhbmQgdXAsIHJlc3BlY3RpdmVseS5cIlxuICAgIH0sXG4gICAgXCJsaW5lLXRyYW5zbGF0ZS1hbmNob3JcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcInBpZWNld2lzZS1jb25zdGFudFwiLFxuICAgICAgXCJ2YWx1ZXNcIjogW1xuICAgICAgICBcIm1hcFwiLFxuICAgICAgICBcInZpZXdwb3J0XCJcbiAgICAgIF0sXG4gICAgICBcImRvY1wiOiBcIkNvbnRyb2wgd2hldGhlciB0aGUgdHJhbnNsYXRpb24gaXMgcmVsYXRpdmUgdG8gdGhlIG1hcCAobm9ydGgpIG9yIHZpZXdwb3J0IChzY3JlZW4pXCIsXG4gICAgICBcImRlZmF1bHRcIjogXCJtYXBcIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcImxpbmUtdHJhbnNsYXRlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwibGluZS13aWR0aFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAxLFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwidW5pdHNcIjogXCJwaXhlbHNcIixcbiAgICAgIFwiZG9jXCI6IFwiU3Ryb2tlIHRoaWNrbmVzcy5cIlxuICAgIH0sXG4gICAgXCJsaW5lLWdhcC13aWR0aFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcImRvY1wiOiBcIkRyYXdzIGEgbGluZSBjYXNpbmcgb3V0c2lkZSBvZiBhIGxpbmUncyBhY3R1YWwgcGF0aC4gVmFsdWUgaW5kaWNhdGVzIHRoZSB3aWR0aCBvZiB0aGUgaW5uZXIgZ2FwLlwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInVuaXRzXCI6IFwicGl4ZWxzXCJcbiAgICB9LFxuICAgIFwibGluZS1vZmZzZXRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIFwiZG9jXCI6IFwiVGhlIGxpbmUncyBvZmZzZXQgcGVycGVuZGljdWxhciB0byBpdHMgZGlyZWN0aW9uLiBWYWx1ZXMgbWF5IGJlIHBvc2l0aXZlIG9yIG5lZ2F0aXZlLCB3aGVyZSBwb3NpdGl2ZSBpbmRpY2F0ZXMgXFxcImxlZnR3YXJkc1xcXCIgKGlmIHlvdSB3ZXJlIG1vdmluZyBpbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBsaW5lKSBhbmQgbmVnYXRpdmUgaW5kaWNhdGVzIFxcXCJyaWdodHdhcmRzLlxcXCJcIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJ1bml0c1wiOiBcInBpeGVsc1wiXG4gICAgfSxcbiAgICBcImxpbmUtYmx1clwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwidW5pdHNcIjogXCJwaXhlbHNcIixcbiAgICAgIFwiZG9jXCI6IFwiQmx1ciBhcHBsaWVkIHRvIHRoZSBsaW5lLCBpbiBwaXhlbHMuXCJcbiAgICB9LFxuICAgIFwibGluZS1kYXNoYXJyYXlcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgIFwidmFsdWVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwiZG9jXCI6IFwiU3BlY2lmaWVzIHRoZSBsZW5ndGhzIG9mIHRoZSBhbHRlcm5hdGluZyBkYXNoZXMgYW5kIGdhcHMgdGhhdCBmb3JtIHRoZSBkYXNoIHBhdHRlcm4uIFRoZSBsZW5ndGhzIGFyZSBsYXRlciBzY2FsZWQgYnkgdGhlIGxpbmUgd2lkdGguIFRvIGNvbnZlcnQgYSBkYXNoIGxlbmd0aCB0byBwaXhlbHMsIG11bHRpcGx5IHRoZSBsZW5ndGggYnkgdGhlIGN1cnJlbnQgbGluZSB3aWR0aC5cIixcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInVuaXRzXCI6IFwibGluZSB3aWR0aHNcIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICB7XG4gICAgICAgICAgXCIhXCI6IFwibGluZS1wYXR0ZXJuXCJcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0sXG4gICAgXCJsaW5lLXBhdHRlcm5cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwiZG9jXCI6IFwiTmFtZSBvZiBpbWFnZSBpbiBzcHJpdGUgdG8gdXNlIGZvciBkcmF3aW5nIGltYWdlIGxpbmVzLiBGb3Igc2VhbWxlc3MgcGF0dGVybnMsIGltYWdlIHdpZHRoIG11c3QgYmUgYSBmYWN0b3Igb2YgdHdvICgyLCA0LCA4LCAuLi4sIDUxMikuXCJcbiAgICB9XG4gIH0sXG4gIFwicGFpbnRfY2lyY2xlXCI6IHtcbiAgICBcImNpcmNsZS1yYWRpdXNcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogNSxcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInVuaXRzXCI6IFwicGl4ZWxzXCIsXG4gICAgICBcImRvY1wiOiBcIkNpcmNsZSByYWRpdXMuXCJcbiAgICB9LFxuICAgIFwiY2lyY2xlLWNvbG9yXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImNvbG9yXCIsXG4gICAgICBcImRlZmF1bHRcIjogXCIjMDAwMDAwXCIsXG4gICAgICBcImRvY1wiOiBcIlRoZSBjb2xvciBvZiB0aGUgY2lyY2xlLlwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWVcbiAgICB9LFxuICAgIFwiY2lyY2xlLWJsdXJcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIFwiZG9jXCI6IFwiQW1vdW50IHRvIGJsdXIgdGhlIGNpcmNsZS4gMSBibHVycyB0aGUgY2lyY2xlIHN1Y2ggdGhhdCBvbmx5IHRoZSBjZW50ZXJwb2ludCBpcyBmdWxsIG9wYWNpdHkuXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZVxuICAgIH0sXG4gICAgXCJjaXJjbGUtb3BhY2l0eVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIG9wYWNpdHkgYXQgd2hpY2ggdGhlIGNpcmNsZSB3aWxsIGJlIGRyYXduLlwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDEsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwibWF4aW11bVwiOiAxLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWVcbiAgICB9LFxuICAgIFwiY2lyY2xlLXRyYW5zbGF0ZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgXCJ2YWx1ZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJsZW5ndGhcIjogMixcbiAgICAgIFwiZGVmYXVsdFwiOiBbMCwgMF0sXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwidW5pdHNcIjogXCJwaXhlbHNcIixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIGdlb21ldHJ5J3Mgb2Zmc2V0LiBWYWx1ZXMgYXJlIFt4LCB5XSB3aGVyZSBuZWdhdGl2ZXMgaW5kaWNhdGUgbGVmdCBhbmQgdXAsIHJlc3BlY3RpdmVseS5cIlxuICAgIH0sXG4gICAgXCJjaXJjbGUtdHJhbnNsYXRlLWFuY2hvclwiOiB7XG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcInZhbHVlc1wiOiBbXG4gICAgICAgIFwibWFwXCIsXG4gICAgICAgIFwidmlld3BvcnRcIlxuICAgICAgXSxcbiAgICAgIFwiZG9jXCI6IFwiQ29udHJvbCB3aGV0aGVyIHRoZSB0cmFuc2xhdGlvbiBpcyByZWxhdGl2ZSB0byB0aGUgbWFwIChub3J0aCkgb3Igdmlld3BvcnQgKHNjcmVlbilcIixcbiAgICAgIFwiZGVmYXVsdFwiOiBcIm1hcFwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwiY2lyY2xlLXRyYW5zbGF0ZVwiXG4gICAgICBdXG4gICAgfVxuICB9LFxuICBcInBhaW50X3N5bWJvbFwiOiB7XG4gICAgXCJpY29uLW9wYWNpdHlcIjoge1xuICAgICAgXCJkb2NcIjogXCJUaGUgb3BhY2l0eSBhdCB3aGljaCB0aGUgaWNvbiB3aWxsIGJlIGRyYXduLlwiLFxuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMSxcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJtYXhpbXVtXCI6IDEsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcImljb24taW1hZ2VcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJpY29uLWNvbG9yXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImNvbG9yXCIsXG4gICAgICBcImRlZmF1bHRcIjogXCIjMDAwMDAwXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwiZG9jXCI6IFwiVGhlIGNvbG9yIG9mIHRoZSBpY29uLiBUaGlzIGNhbiBvbmx5IGJlIHVzZWQgd2l0aCBzZGYgaWNvbnMuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJpY29uLWltYWdlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwiaWNvbi1oYWxvLWNvbG9yXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImNvbG9yXCIsXG4gICAgICBcImRlZmF1bHRcIjogXCJyZ2JhKDAsIDAsIDAsIDApXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwiZG9jXCI6IFwiVGhlIGNvbG9yIG9mIHRoZSBpY29uJ3MgaGFsby4gSWNvbiBoYWxvcyBjYW4gb25seSBiZSB1c2VkIHdpdGggc2RmIGljb25zLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwiaWNvbi1pbWFnZVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcImljb24taGFsby13aWR0aFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwidW5pdHNcIjogXCJwaXhlbHNcIixcbiAgICAgIFwiZG9jXCI6IFwiRGlzdGFuY2Ugb2YgaGFsbyB0byB0aGUgaWNvbiBvdXRsaW5lLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwiaWNvbi1pbWFnZVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcImljb24taGFsby1ibHVyXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJ1bml0c1wiOiBcInBpeGVsc1wiLFxuICAgICAgXCJkb2NcIjogXCJGYWRlIG91dCB0aGUgaGFsbyB0b3dhcmRzIHRoZSBvdXRzaWRlLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwiaWNvbi1pbWFnZVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcImljb24tdHJhbnNsYXRlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICBcInZhbHVlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImxlbmd0aFwiOiAyLFxuICAgICAgXCJkZWZhdWx0XCI6IFtcbiAgICAgICAgMCxcbiAgICAgICAgMFxuICAgICAgXSxcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJ1bml0c1wiOiBcInBpeGVsc1wiLFxuICAgICAgXCJkb2NcIjogXCJEaXN0YW5jZSB0aGF0IHRoZSBpY29uJ3MgYW5jaG9yIGlzIG1vdmVkIGZyb20gaXRzIG9yaWdpbmFsIHBsYWNlbWVudC4gUG9zaXRpdmUgdmFsdWVzIGluZGljYXRlIHJpZ2h0IGFuZCBkb3duLCB3aGlsZSBuZWdhdGl2ZSB2YWx1ZXMgaW5kaWNhdGUgbGVmdCBhbmQgdXAuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJpY29uLWltYWdlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwiaWNvbi10cmFuc2xhdGUtYW5jaG9yXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwidmFsdWVzXCI6IFtcbiAgICAgICAgXCJtYXBcIixcbiAgICAgICAgXCJ2aWV3cG9ydFwiXG4gICAgICBdLFxuICAgICAgXCJkb2NcIjogXCJDb250cm9sIHdoZXRoZXIgdGhlIHRyYW5zbGF0aW9uIGlzIHJlbGF0aXZlIHRvIHRoZSBtYXAgKG5vcnRoKSBvciB2aWV3cG9ydCAoc2NyZWVuKS5cIixcbiAgICAgIFwiZGVmYXVsdFwiOiBcIm1hcFwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwiaWNvbi1pbWFnZVwiLFxuICAgICAgICBcImljb24tdHJhbnNsYXRlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwidGV4dC1vcGFjaXR5XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkb2NcIjogXCJUaGUgb3BhY2l0eSBhdCB3aGljaCB0aGUgdGV4dCB3aWxsIGJlIGRyYXduLlwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDEsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwibWF4aW11bVwiOiAxLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJ0ZXh0LWZpZWxkXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwidGV4dC1jb2xvclwiOiB7XG4gICAgICBcInR5cGVcIjogXCJjb2xvclwiLFxuICAgICAgXCJkb2NcIjogXCJUaGUgY29sb3Igd2l0aCB3aGljaCB0aGUgdGV4dCB3aWxsIGJlIGRyYXduLlwiLFxuICAgICAgXCJkZWZhdWx0XCI6IFwiIzAwMDAwMFwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJ0ZXh0LWZpZWxkXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwidGV4dC1oYWxvLWNvbG9yXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImNvbG9yXCIsXG4gICAgICBcImRlZmF1bHRcIjogXCJyZ2JhKDAsIDAsIDAsIDApXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwiZG9jXCI6IFwiVGhlIGNvbG9yIG9mIHRoZSB0ZXh0J3MgaGFsbywgd2hpY2ggaGVscHMgaXQgc3RhbmQgb3V0IGZyb20gYmFja2dyb3VuZHMuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJ0ZXh0LWZpZWxkXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwidGV4dC1oYWxvLXdpZHRoXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJ1bml0c1wiOiBcInBpeGVsc1wiLFxuICAgICAgXCJkb2NcIjogXCJEaXN0YW5jZSBvZiBoYWxvIHRvIHRoZSBmb250IG91dGxpbmUuIE1heCB0ZXh0IGhhbG8gd2lkdGggaXMgMS80IG9mIHRoZSBmb250LXNpemUuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJ0ZXh0LWZpZWxkXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwidGV4dC1oYWxvLWJsdXJcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInVuaXRzXCI6IFwicGl4ZWxzXCIsXG4gICAgICBcImRvY1wiOiBcIlRoZSBoYWxvJ3MgZmFkZW91dCBkaXN0YW5jZSB0b3dhcmRzIHRoZSBvdXRzaWRlLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwidGV4dC1maWVsZFwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInRleHQtdHJhbnNsYXRlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICBcInZhbHVlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImxlbmd0aFwiOiAyLFxuICAgICAgXCJkZWZhdWx0XCI6IFtcbiAgICAgICAgMCxcbiAgICAgICAgMFxuICAgICAgXSxcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJ1bml0c1wiOiBcInBpeGVsc1wiLFxuICAgICAgXCJkb2NcIjogXCJEaXN0YW5jZSB0aGF0IHRoZSB0ZXh0J3MgYW5jaG9yIGlzIG1vdmVkIGZyb20gaXRzIG9yaWdpbmFsIHBsYWNlbWVudC4gUG9zaXRpdmUgdmFsdWVzIGluZGljYXRlIHJpZ2h0IGFuZCBkb3duLCB3aGlsZSBuZWdhdGl2ZSB2YWx1ZXMgaW5kaWNhdGUgbGVmdCBhbmQgdXAuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJ0ZXh0LWZpZWxkXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwidGV4dC10cmFuc2xhdGUtYW5jaG9yXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwidmFsdWVzXCI6IFtcbiAgICAgICAgXCJtYXBcIixcbiAgICAgICAgXCJ2aWV3cG9ydFwiXG4gICAgICBdLFxuICAgICAgXCJkb2NcIjogXCJDb250cm9sIHdoZXRoZXIgdGhlIHRyYW5zbGF0aW9uIGlzIHJlbGF0aXZlIHRvIHRoZSBtYXAgKG5vcnRoKSBvciB2aWV3cG9ydCAoc2NyZWVuKS5cIixcbiAgICAgIFwiZGVmYXVsdFwiOiBcIm1hcFwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwidGV4dC1maWVsZFwiLFxuICAgICAgICBcInRleHQtdHJhbnNsYXRlXCJcbiAgICAgIF1cbiAgICB9XG4gIH0sXG4gIFwicGFpbnRfcmFzdGVyXCI6IHtcbiAgICBcInJhc3Rlci1vcGFjaXR5XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkb2NcIjogXCJUaGUgb3BhY2l0eSBhdCB3aGljaCB0aGUgaW1hZ2Ugd2lsbCBiZSBkcmF3bi5cIixcbiAgICAgIFwiZGVmYXVsdFwiOiAxLFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcIm1heGltdW1cIjogMSxcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlXG4gICAgfSxcbiAgICBcInJhc3Rlci1odWUtcm90YXRlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgICBcInBlcmlvZFwiOiAzNjAsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwidW5pdHNcIjogXCJkZWdyZWVzXCIsXG4gICAgICBcImRvY1wiOiBcIlJvdGF0ZXMgaHVlcyBhcm91bmQgdGhlIGNvbG9yIHdoZWVsLlwiXG4gICAgfSxcbiAgICBcInJhc3Rlci1icmlnaHRuZXNzLW1pblwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwiZG9jXCI6IFwiSW5jcmVhc2Ugb3IgcmVkdWNlIHRoZSBicmlnaHRuZXNzIG9mIHRoZSBpbWFnZS4gVGhlIHZhbHVlIGlzIHRoZSBtaW5pbXVtIGJyaWdodG5lc3MuXCIsXG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJtYXhpbXVtXCI6IDEsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZVxuICAgIH0sXG4gICAgXCJyYXN0ZXItYnJpZ2h0bmVzcy1tYXhcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcImRvY1wiOiBcIkluY3JlYXNlIG9yIHJlZHVjZSB0aGUgYnJpZ2h0bmVzcyBvZiB0aGUgaW1hZ2UuIFRoZSB2YWx1ZSBpcyB0aGUgbWF4aW11bSBicmlnaHRuZXNzLlwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDEsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwibWF4aW11bVwiOiAxLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWVcbiAgICB9LFxuICAgIFwicmFzdGVyLXNhdHVyYXRpb25cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRvY1wiOiBcIkluY3JlYXNlIG9yIHJlZHVjZSB0aGUgc2F0dXJhdGlvbiBvZiB0aGUgaW1hZ2UuXCIsXG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIFwibWluaW11bVwiOiAtMSxcbiAgICAgIFwibWF4aW11bVwiOiAxLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWVcbiAgICB9LFxuICAgIFwicmFzdGVyLWNvbnRyYXN0XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkb2NcIjogXCJJbmNyZWFzZSBvciByZWR1Y2UgdGhlIGNvbnRyYXN0IG9mIHRoZSBpbWFnZS5cIixcbiAgICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgICAgXCJtaW5pbXVtXCI6IC0xLFxuICAgICAgXCJtYXhpbXVtXCI6IDEsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZVxuICAgIH0sXG4gICAgXCJyYXN0ZXItZmFkZS1kdXJhdGlvblwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAzMDAsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJ1bml0c1wiOiBcIm1pbGxpc2Vjb25kc1wiLFxuICAgICAgXCJkb2NcIjogXCJGYWRlIGR1cmF0aW9uIHdoZW4gYSBuZXcgdGlsZSBpcyBhZGRlZC5cIlxuICAgIH1cbiAgfSxcbiAgXCJwYWludF9iYWNrZ3JvdW5kXCI6IHtcbiAgICBcImJhY2tncm91bmQtY29sb3JcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiY29sb3JcIixcbiAgICAgIFwiZGVmYXVsdFwiOiBcIiMwMDAwMDBcIixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIGNvbG9yIHdpdGggd2hpY2ggdGhlIGJhY2tncm91bmQgd2lsbCBiZSBkcmF3bi5cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBcIiFcIjogXCJiYWNrZ3JvdW5kLXBhdHRlcm5cIlxuICAgICAgICB9XG4gICAgICBdXG4gICAgfSxcbiAgICBcImJhY2tncm91bmQtcGF0dGVyblwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJkb2NcIjogXCJOYW1lIG9mIGltYWdlIGluIHNwcml0ZSB0byB1c2UgZm9yIGRyYXdpbmcgYW4gaW1hZ2UgYmFja2dyb3VuZC4gRm9yIHNlYW1sZXNzIHBhdHRlcm5zLCBpbWFnZSB3aWR0aCBhbmQgaGVpZ2h0IG11c3QgYmUgYSBmYWN0b3Igb2YgdHdvICgyLCA0LCA4LCAuLi4sIDUxMikuXCJcbiAgICB9LFxuICAgIFwiYmFja2dyb3VuZC1vcGFjaXR5XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDEsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwibWF4aW11bVwiOiAxLFxuICAgICAgXCJkb2NcIjogXCJUaGUgb3BhY2l0eSBhdCB3aGljaCB0aGUgYmFja2dyb3VuZCB3aWxsIGJlIGRyYXduLlwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWVcbiAgICB9XG4gIH0sXG4gIFwidHJhbnNpdGlvblwiOiB7XG4gICAgXCJkdXJhdGlvblwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAzMDAsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwidW5pdHNcIjogXCJtaWxsaXNlY29uZHNcIixcbiAgICAgIFwiZG9jXCI6IFwiVGltZSBhbGxvdHRlZCBmb3IgdHJhbnNpdGlvbnMgdG8gY29tcGxldGUuXCJcbiAgICB9LFxuICAgIFwiZGVsYXlcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJ1bml0c1wiOiBcIm1pbGxpc2Vjb25kc1wiLFxuICAgICAgXCJkb2NcIjogXCJMZW5ndGggb2YgdGltZSBiZWZvcmUgYSB0cmFuc2l0aW9uIGJlZ2lucy5cIlxuICAgIH1cbiAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1wiJHZlcnNpb25cIjo4LFwiJHJvb3RcIjp7XCJ2ZXJzaW9uXCI6e1wicmVxdWlyZWRcIjp0cnVlLFwidHlwZVwiOlwiZW51bVwiLFwidmFsdWVzXCI6WzhdfSxcIm5hbWVcIjp7XCJ0eXBlXCI6XCJzdHJpbmdcIn0sXCJtZXRhZGF0YVwiOntcInR5cGVcIjpcIipcIn0sXCJjZW50ZXJcIjp7XCJ0eXBlXCI6XCJhcnJheVwiLFwidmFsdWVcIjpcIm51bWJlclwifSxcInpvb21cIjp7XCJ0eXBlXCI6XCJudW1iZXJcIn0sXCJiZWFyaW5nXCI6e1widHlwZVwiOlwibnVtYmVyXCIsXCJkZWZhdWx0XCI6MCxcInBlcmlvZFwiOjM2MCxcInVuaXRzXCI6XCJkZWdyZWVzXCJ9LFwicGl0Y2hcIjp7XCJ0eXBlXCI6XCJudW1iZXJcIixcImRlZmF1bHRcIjowLFwidW5pdHNcIjpcImRlZ3JlZXNcIn0sXCJzb3VyY2VzXCI6e1wicmVxdWlyZWRcIjp0cnVlLFwidHlwZVwiOlwic291cmNlc1wifSxcInNwcml0ZVwiOntcInR5cGVcIjpcInN0cmluZ1wifSxcImdseXBoc1wiOntcInR5cGVcIjpcInN0cmluZ1wifSxcInRyYW5zaXRpb25cIjp7XCJ0eXBlXCI6XCJ0cmFuc2l0aW9uXCJ9LFwibGF5ZXJzXCI6e1wicmVxdWlyZWRcIjp0cnVlLFwidHlwZVwiOlwiYXJyYXlcIixcInZhbHVlXCI6XCJsYXllclwifX0sXCJzb3VyY2VzXCI6e1wiKlwiOntcInR5cGVcIjpcInNvdXJjZVwifX0sXCJzb3VyY2VcIjpbXCJzb3VyY2VfdGlsZVwiLFwic291cmNlX2dlb2pzb25cIixcInNvdXJjZV92aWRlb1wiLFwic291cmNlX2ltYWdlXCJdLFwic291cmNlX3RpbGVcIjp7XCJ0eXBlXCI6e1wicmVxdWlyZWRcIjp0cnVlLFwidHlwZVwiOlwiZW51bVwiLFwidmFsdWVzXCI6W1widmVjdG9yXCIsXCJyYXN0ZXJcIl19LFwidXJsXCI6e1widHlwZVwiOlwic3RyaW5nXCJ9LFwidGlsZXNcIjp7XCJ0eXBlXCI6XCJhcnJheVwiLFwidmFsdWVcIjpcInN0cmluZ1wifSxcIm1pbnpvb21cIjp7XCJ0eXBlXCI6XCJudW1iZXJcIixcImRlZmF1bHRcIjowfSxcIm1heHpvb21cIjp7XCJ0eXBlXCI6XCJudW1iZXJcIixcImRlZmF1bHRcIjoyMn0sXCJ0aWxlU2l6ZVwiOntcInR5cGVcIjpcIm51bWJlclwiLFwiZGVmYXVsdFwiOjUxMixcInVuaXRzXCI6XCJwaXhlbHNcIn0sXCIqXCI6e1widHlwZVwiOlwiKlwifX0sXCJzb3VyY2VfZ2VvanNvblwiOntcInR5cGVcIjp7XCJyZXF1aXJlZFwiOnRydWUsXCJ0eXBlXCI6XCJlbnVtXCIsXCJ2YWx1ZXNcIjpbXCJnZW9qc29uXCJdfSxcImRhdGFcIjp7XCJ0eXBlXCI6XCIqXCJ9LFwibWF4em9vbVwiOntcInR5cGVcIjpcIm51bWJlclwiLFwiZGVmYXVsdFwiOjE0fSxcImJ1ZmZlclwiOntcInR5cGVcIjpcIm51bWJlclwiLFwiZGVmYXVsdFwiOjY0fSxcInRvbGVyYW5jZVwiOntcInR5cGVcIjpcIm51bWJlclwiLFwiZGVmYXVsdFwiOjN9fSxcInNvdXJjZV92aWRlb1wiOntcInR5cGVcIjp7XCJyZXF1aXJlZFwiOnRydWUsXCJ0eXBlXCI6XCJlbnVtXCIsXCJ2YWx1ZXNcIjpbXCJ2aWRlb1wiXX0sXCJ1cmxzXCI6e1wicmVxdWlyZWRcIjp0cnVlLFwidHlwZVwiOlwiYXJyYXlcIixcInZhbHVlXCI6XCJzdHJpbmdcIn0sXCJjb29yZGluYXRlc1wiOntcInJlcXVpcmVkXCI6dHJ1ZSxcInR5cGVcIjpcImFycmF5XCIsXCJsZW5ndGhcIjo0LFwidmFsdWVcIjp7XCJ0eXBlXCI6XCJhcnJheVwiLFwibGVuZ3RoXCI6MixcInZhbHVlXCI6XCJudW1iZXJcIn19fSxcInNvdXJjZV9pbWFnZVwiOntcInR5cGVcIjp7XCJyZXF1aXJlZFwiOnRydWUsXCJ0eXBlXCI6XCJlbnVtXCIsXCJ2YWx1ZXNcIjpbXCJpbWFnZVwiXX0sXCJ1cmxcIjp7XCJyZXF1aXJlZFwiOnRydWUsXCJ0eXBlXCI6XCJzdHJpbmdcIn0sXCJjb29yZGluYXRlc1wiOntcInJlcXVpcmVkXCI6dHJ1ZSxcInR5cGVcIjpcImFycmF5XCIsXCJsZW5ndGhcIjo0LFwidmFsdWVcIjp7XCJ0eXBlXCI6XCJhcnJheVwiLFwibGVuZ3RoXCI6MixcInZhbHVlXCI6XCJudW1iZXJcIn19fSxcImxheWVyXCI6e1wiaWRcIjp7XCJ0eXBlXCI6XCJzdHJpbmdcIn0sXCJ0eXBlXCI6e1widHlwZVwiOlwiZW51bVwiLFwidmFsdWVzXCI6W1wiZmlsbFwiLFwibGluZVwiLFwic3ltYm9sXCIsXCJjaXJjbGVcIixcInJhc3RlclwiLFwiYmFja2dyb3VuZFwiXX0sXCJtZXRhZGF0YVwiOntcInR5cGVcIjpcIipcIn0sXCJyZWZcIjp7XCJ0eXBlXCI6XCJzdHJpbmdcIn0sXCJzb3VyY2VcIjp7XCJ0eXBlXCI6XCJzdHJpbmdcIn0sXCJzb3VyY2UtbGF5ZXJcIjp7XCJ0eXBlXCI6XCJzdHJpbmdcIn0sXCJtaW56b29tXCI6e1widHlwZVwiOlwibnVtYmVyXCIsXCJtaW5pbXVtXCI6MCxcIm1heGltdW1cIjoyMn0sXCJtYXh6b29tXCI6e1widHlwZVwiOlwibnVtYmVyXCIsXCJtaW5pbXVtXCI6MCxcIm1heGltdW1cIjoyMn0sXCJpbnRlcmFjdGl2ZVwiOntcInR5cGVcIjpcImJvb2xlYW5cIixcImRlZmF1bHRcIjpmYWxzZX0sXCJmaWx0ZXJcIjp7XCJ0eXBlXCI6XCJmaWx0ZXJcIn0sXCJsYXlvdXRcIjp7XCJ0eXBlXCI6XCJsYXlvdXRcIn0sXCJwYWludFwiOntcInR5cGVcIjpcInBhaW50XCJ9LFwicGFpbnQuKlwiOntcInR5cGVcIjpcInBhaW50XCJ9fSxcImxheW91dFwiOltcImxheW91dF9maWxsXCIsXCJsYXlvdXRfbGluZVwiLFwibGF5b3V0X2NpcmNsZVwiLFwibGF5b3V0X3N5bWJvbFwiLFwibGF5b3V0X3Jhc3RlclwiLFwibGF5b3V0X2JhY2tncm91bmRcIl0sXCJsYXlvdXRfYmFja2dyb3VuZFwiOntcInZpc2liaWxpdHlcIjp7XCJ0eXBlXCI6XCJlbnVtXCIsXCJmdW5jdGlvblwiOlwicGllY2V3aXNlLWNvbnN0YW50XCIsXCJ2YWx1ZXNcIjpbXCJ2aXNpYmxlXCIsXCJub25lXCJdLFwiZGVmYXVsdFwiOlwidmlzaWJsZVwifX0sXCJsYXlvdXRfZmlsbFwiOntcInZpc2liaWxpdHlcIjp7XCJ0eXBlXCI6XCJlbnVtXCIsXCJmdW5jdGlvblwiOlwicGllY2V3aXNlLWNvbnN0YW50XCIsXCJ2YWx1ZXNcIjpbXCJ2aXNpYmxlXCIsXCJub25lXCJdLFwiZGVmYXVsdFwiOlwidmlzaWJsZVwifX0sXCJsYXlvdXRfY2lyY2xlXCI6e1widmlzaWJpbGl0eVwiOntcInR5cGVcIjpcImVudW1cIixcImZ1bmN0aW9uXCI6XCJwaWVjZXdpc2UtY29uc3RhbnRcIixcInZhbHVlc1wiOltcInZpc2libGVcIixcIm5vbmVcIl0sXCJkZWZhdWx0XCI6XCJ2aXNpYmxlXCJ9fSxcImxheW91dF9saW5lXCI6e1wibGluZS1jYXBcIjp7XCJ0eXBlXCI6XCJlbnVtXCIsXCJmdW5jdGlvblwiOlwicGllY2V3aXNlLWNvbnN0YW50XCIsXCJ2YWx1ZXNcIjpbXCJidXR0XCIsXCJyb3VuZFwiLFwic3F1YXJlXCJdLFwiZGVmYXVsdFwiOlwiYnV0dFwifSxcImxpbmUtam9pblwiOntcInR5cGVcIjpcImVudW1cIixcImZ1bmN0aW9uXCI6XCJwaWVjZXdpc2UtY29uc3RhbnRcIixcInZhbHVlc1wiOltcImJldmVsXCIsXCJyb3VuZFwiLFwibWl0ZXJcIl0sXCJkZWZhdWx0XCI6XCJtaXRlclwifSxcImxpbmUtbWl0ZXItbGltaXRcIjp7XCJ0eXBlXCI6XCJudW1iZXJcIixcImRlZmF1bHRcIjoyLFwiZnVuY3Rpb25cIjpcImludGVycG9sYXRlZFwiLFwicmVxdWlyZXNcIjpbe1wibGluZS1qb2luXCI6XCJtaXRlclwifV19LFwibGluZS1yb3VuZC1saW1pdFwiOntcInR5cGVcIjpcIm51bWJlclwiLFwiZGVmYXVsdFwiOjEuMDUsXCJmdW5jdGlvblwiOlwiaW50ZXJwb2xhdGVkXCIsXCJyZXF1aXJlc1wiOlt7XCJsaW5lLWpvaW5cIjpcInJvdW5kXCJ9XX0sXCJ2aXNpYmlsaXR5XCI6e1widHlwZVwiOlwiZW51bVwiLFwiZnVuY3Rpb25cIjpcInBpZWNld2lzZS1jb25zdGFudFwiLFwidmFsdWVzXCI6W1widmlzaWJsZVwiLFwibm9uZVwiXSxcImRlZmF1bHRcIjpcInZpc2libGVcIn19LFwibGF5b3V0X3N5bWJvbFwiOntcInN5bWJvbC1wbGFjZW1lbnRcIjp7XCJ0eXBlXCI6XCJlbnVtXCIsXCJmdW5jdGlvblwiOlwicGllY2V3aXNlLWNvbnN0YW50XCIsXCJ2YWx1ZXNcIjpbXCJwb2ludFwiLFwibGluZVwiXSxcImRlZmF1bHRcIjpcInBvaW50XCJ9LFwic3ltYm9sLXNwYWNpbmdcIjp7XCJ0eXBlXCI6XCJudW1iZXJcIixcImRlZmF1bHRcIjoyNTAsXCJtaW5pbXVtXCI6MSxcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcInVuaXRzXCI6XCJwaXhlbHNcIixcInJlcXVpcmVzXCI6W3tcInN5bWJvbC1wbGFjZW1lbnRcIjpcImxpbmVcIn1dfSxcInN5bWJvbC1hdm9pZC1lZGdlc1wiOntcInR5cGVcIjpcImJvb2xlYW5cIixcImZ1bmN0aW9uXCI6XCJwaWVjZXdpc2UtY29uc3RhbnRcIixcImRlZmF1bHRcIjpmYWxzZX0sXCJpY29uLWFsbG93LW92ZXJsYXBcIjp7XCJ0eXBlXCI6XCJib29sZWFuXCIsXCJmdW5jdGlvblwiOlwicGllY2V3aXNlLWNvbnN0YW50XCIsXCJkZWZhdWx0XCI6ZmFsc2UsXCJyZXF1aXJlc1wiOltcImljb24taW1hZ2VcIl19LFwiaWNvbi1pZ25vcmUtcGxhY2VtZW50XCI6e1widHlwZVwiOlwiYm9vbGVhblwiLFwiZnVuY3Rpb25cIjpcInBpZWNld2lzZS1jb25zdGFudFwiLFwiZGVmYXVsdFwiOmZhbHNlLFwicmVxdWlyZXNcIjpbXCJpY29uLWltYWdlXCJdfSxcImljb24tb3B0aW9uYWxcIjp7XCJ0eXBlXCI6XCJib29sZWFuXCIsXCJmdW5jdGlvblwiOlwicGllY2V3aXNlLWNvbnN0YW50XCIsXCJkZWZhdWx0XCI6ZmFsc2UsXCJyZXF1aXJlc1wiOltcImljb24taW1hZ2VcIixcInRleHQtZmllbGRcIl19LFwiaWNvbi1yb3RhdGlvbi1hbGlnbm1lbnRcIjp7XCJ0eXBlXCI6XCJlbnVtXCIsXCJmdW5jdGlvblwiOlwicGllY2V3aXNlLWNvbnN0YW50XCIsXCJ2YWx1ZXNcIjpbXCJtYXBcIixcInZpZXdwb3J0XCJdLFwiZGVmYXVsdFwiOlwidmlld3BvcnRcIixcInJlcXVpcmVzXCI6W1wiaWNvbi1pbWFnZVwiXX0sXCJpY29uLXNpemVcIjp7XCJ0eXBlXCI6XCJudW1iZXJcIixcImRlZmF1bHRcIjoxLFwibWluaW11bVwiOjAsXCJmdW5jdGlvblwiOlwiaW50ZXJwb2xhdGVkXCIsXCJyZXF1aXJlc1wiOltcImljb24taW1hZ2VcIl19LFwiaWNvbi1pbWFnZVwiOntcInR5cGVcIjpcInN0cmluZ1wiLFwiZnVuY3Rpb25cIjpcInBpZWNld2lzZS1jb25zdGFudFwiLFwidG9rZW5zXCI6dHJ1ZX0sXCJpY29uLXJvdGF0ZVwiOntcInR5cGVcIjpcIm51bWJlclwiLFwiZGVmYXVsdFwiOjAsXCJwZXJpb2RcIjozNjAsXCJmdW5jdGlvblwiOlwiaW50ZXJwb2xhdGVkXCIsXCJ1bml0c1wiOlwiZGVncmVlc1wiLFwicmVxdWlyZXNcIjpbXCJpY29uLWltYWdlXCJdfSxcImljb24tcGFkZGluZ1wiOntcInR5cGVcIjpcIm51bWJlclwiLFwiZGVmYXVsdFwiOjIsXCJtaW5pbXVtXCI6MCxcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcInVuaXRzXCI6XCJwaXhlbHNcIixcInJlcXVpcmVzXCI6W1wiaWNvbi1pbWFnZVwiXX0sXCJpY29uLWtlZXAtdXByaWdodFwiOntcInR5cGVcIjpcImJvb2xlYW5cIixcImZ1bmN0aW9uXCI6XCJwaWVjZXdpc2UtY29uc3RhbnRcIixcImRlZmF1bHRcIjpmYWxzZSxcInJlcXVpcmVzXCI6W1wiaWNvbi1pbWFnZVwiLHtcImljb24tcm90YXRpb24tYWxpZ25tZW50XCI6XCJtYXBcIn0se1wic3ltYm9sLXBsYWNlbWVudFwiOlwibGluZVwifV19LFwiaWNvbi1vZmZzZXRcIjp7XCJ0eXBlXCI6XCJhcnJheVwiLFwidmFsdWVcIjpcIm51bWJlclwiLFwibGVuZ3RoXCI6MixcImRlZmF1bHRcIjpbMCwwXSxcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcInJlcXVpcmVzXCI6W1wiaWNvbi1pbWFnZVwiXX0sXCJ0ZXh0LXJvdGF0aW9uLWFsaWdubWVudFwiOntcInR5cGVcIjpcImVudW1cIixcImZ1bmN0aW9uXCI6XCJwaWVjZXdpc2UtY29uc3RhbnRcIixcInZhbHVlc1wiOltcIm1hcFwiLFwidmlld3BvcnRcIl0sXCJkZWZhdWx0XCI6XCJ2aWV3cG9ydFwiLFwicmVxdWlyZXNcIjpbXCJ0ZXh0LWZpZWxkXCJdfSxcInRleHQtZmllbGRcIjp7XCJ0eXBlXCI6XCJzdHJpbmdcIixcImZ1bmN0aW9uXCI6XCJwaWVjZXdpc2UtY29uc3RhbnRcIixcImRlZmF1bHRcIjpcIlwiLFwidG9rZW5zXCI6dHJ1ZX0sXCJ0ZXh0LWZvbnRcIjp7XCJ0eXBlXCI6XCJhcnJheVwiLFwidmFsdWVcIjpcInN0cmluZ1wiLFwiZnVuY3Rpb25cIjpcInBpZWNld2lzZS1jb25zdGFudFwiLFwiZGVmYXVsdFwiOltcIk9wZW4gU2FucyBSZWd1bGFyXCIsXCJBcmlhbCBVbmljb2RlIE1TIFJlZ3VsYXJcIl0sXCJyZXF1aXJlc1wiOltcInRleHQtZmllbGRcIl19LFwidGV4dC1zaXplXCI6e1widHlwZVwiOlwibnVtYmVyXCIsXCJkZWZhdWx0XCI6MTYsXCJtaW5pbXVtXCI6MCxcInVuaXRzXCI6XCJwaXhlbHNcIixcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcInJlcXVpcmVzXCI6W1widGV4dC1maWVsZFwiXX0sXCJ0ZXh0LW1heC13aWR0aFwiOntcInR5cGVcIjpcIm51bWJlclwiLFwiZGVmYXVsdFwiOjEwLFwibWluaW11bVwiOjAsXCJ1bml0c1wiOlwiZW1cIixcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcInJlcXVpcmVzXCI6W1widGV4dC1maWVsZFwiXX0sXCJ0ZXh0LWxpbmUtaGVpZ2h0XCI6e1widHlwZVwiOlwibnVtYmVyXCIsXCJkZWZhdWx0XCI6MS4yLFwidW5pdHNcIjpcImVtXCIsXCJmdW5jdGlvblwiOlwiaW50ZXJwb2xhdGVkXCIsXCJyZXF1aXJlc1wiOltcInRleHQtZmllbGRcIl19LFwidGV4dC1sZXR0ZXItc3BhY2luZ1wiOntcInR5cGVcIjpcIm51bWJlclwiLFwiZGVmYXVsdFwiOjAsXCJ1bml0c1wiOlwiZW1cIixcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcInJlcXVpcmVzXCI6W1widGV4dC1maWVsZFwiXX0sXCJ0ZXh0LWp1c3RpZnlcIjp7XCJ0eXBlXCI6XCJlbnVtXCIsXCJmdW5jdGlvblwiOlwicGllY2V3aXNlLWNvbnN0YW50XCIsXCJ2YWx1ZXNcIjpbXCJsZWZ0XCIsXCJjZW50ZXJcIixcInJpZ2h0XCJdLFwiZGVmYXVsdFwiOlwiY2VudGVyXCIsXCJyZXF1aXJlc1wiOltcInRleHQtZmllbGRcIl19LFwidGV4dC1hbmNob3JcIjp7XCJ0eXBlXCI6XCJlbnVtXCIsXCJmdW5jdGlvblwiOlwicGllY2V3aXNlLWNvbnN0YW50XCIsXCJ2YWx1ZXNcIjpbXCJjZW50ZXJcIixcImxlZnRcIixcInJpZ2h0XCIsXCJ0b3BcIixcImJvdHRvbVwiLFwidG9wLWxlZnRcIixcInRvcC1yaWdodFwiLFwiYm90dG9tLWxlZnRcIixcImJvdHRvbS1yaWdodFwiXSxcImRlZmF1bHRcIjpcImNlbnRlclwiLFwicmVxdWlyZXNcIjpbXCJ0ZXh0LWZpZWxkXCJdfSxcInRleHQtbWF4LWFuZ2xlXCI6e1widHlwZVwiOlwibnVtYmVyXCIsXCJkZWZhdWx0XCI6NDUsXCJ1bml0c1wiOlwiZGVncmVlc1wiLFwiZnVuY3Rpb25cIjpcImludGVycG9sYXRlZFwiLFwicmVxdWlyZXNcIjpbXCJ0ZXh0LWZpZWxkXCIse1wic3ltYm9sLXBsYWNlbWVudFwiOlwibGluZVwifV19LFwidGV4dC1yb3RhdGVcIjp7XCJ0eXBlXCI6XCJudW1iZXJcIixcImRlZmF1bHRcIjowLFwicGVyaW9kXCI6MzYwLFwidW5pdHNcIjpcImRlZ3JlZXNcIixcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcInJlcXVpcmVzXCI6W1widGV4dC1maWVsZFwiXX0sXCJ0ZXh0LXBhZGRpbmdcIjp7XCJ0eXBlXCI6XCJudW1iZXJcIixcImRlZmF1bHRcIjoyLFwibWluaW11bVwiOjAsXCJ1bml0c1wiOlwicGl4ZWxzXCIsXCJmdW5jdGlvblwiOlwiaW50ZXJwb2xhdGVkXCIsXCJyZXF1aXJlc1wiOltcInRleHQtZmllbGRcIl19LFwidGV4dC1rZWVwLXVwcmlnaHRcIjp7XCJ0eXBlXCI6XCJib29sZWFuXCIsXCJmdW5jdGlvblwiOlwicGllY2V3aXNlLWNvbnN0YW50XCIsXCJkZWZhdWx0XCI6dHJ1ZSxcInJlcXVpcmVzXCI6W1widGV4dC1maWVsZFwiLHtcInRleHQtcm90YXRpb24tYWxpZ25tZW50XCI6XCJtYXBcIn0se1wic3ltYm9sLXBsYWNlbWVudFwiOlwibGluZVwifV19LFwidGV4dC10cmFuc2Zvcm1cIjp7XCJ0eXBlXCI6XCJlbnVtXCIsXCJmdW5jdGlvblwiOlwicGllY2V3aXNlLWNvbnN0YW50XCIsXCJ2YWx1ZXNcIjpbXCJub25lXCIsXCJ1cHBlcmNhc2VcIixcImxvd2VyY2FzZVwiXSxcImRlZmF1bHRcIjpcIm5vbmVcIixcInJlcXVpcmVzXCI6W1widGV4dC1maWVsZFwiXX0sXCJ0ZXh0LW9mZnNldFwiOntcInR5cGVcIjpcImFycmF5XCIsXCJ2YWx1ZVwiOlwibnVtYmVyXCIsXCJ1bml0c1wiOlwiZW1zXCIsXCJmdW5jdGlvblwiOlwiaW50ZXJwb2xhdGVkXCIsXCJsZW5ndGhcIjoyLFwiZGVmYXVsdFwiOlswLDBdLFwicmVxdWlyZXNcIjpbXCJ0ZXh0LWZpZWxkXCJdfSxcInRleHQtYWxsb3ctb3ZlcmxhcFwiOntcInR5cGVcIjpcImJvb2xlYW5cIixcImZ1bmN0aW9uXCI6XCJwaWVjZXdpc2UtY29uc3RhbnRcIixcImRlZmF1bHRcIjpmYWxzZSxcInJlcXVpcmVzXCI6W1widGV4dC1maWVsZFwiXX0sXCJ0ZXh0LWlnbm9yZS1wbGFjZW1lbnRcIjp7XCJ0eXBlXCI6XCJib29sZWFuXCIsXCJmdW5jdGlvblwiOlwicGllY2V3aXNlLWNvbnN0YW50XCIsXCJkZWZhdWx0XCI6ZmFsc2UsXCJyZXF1aXJlc1wiOltcInRleHQtZmllbGRcIl19LFwidGV4dC1vcHRpb25hbFwiOntcInR5cGVcIjpcImJvb2xlYW5cIixcImZ1bmN0aW9uXCI6XCJwaWVjZXdpc2UtY29uc3RhbnRcIixcImRlZmF1bHRcIjpmYWxzZSxcInJlcXVpcmVzXCI6W1widGV4dC1maWVsZFwiLFwiaWNvbi1pbWFnZVwiXX0sXCJ2aXNpYmlsaXR5XCI6e1widHlwZVwiOlwiZW51bVwiLFwiZnVuY3Rpb25cIjpcInBpZWNld2lzZS1jb25zdGFudFwiLFwidmFsdWVzXCI6W1widmlzaWJsZVwiLFwibm9uZVwiXSxcImRlZmF1bHRcIjpcInZpc2libGVcIn19LFwibGF5b3V0X3Jhc3RlclwiOntcInZpc2liaWxpdHlcIjp7XCJ0eXBlXCI6XCJlbnVtXCIsXCJmdW5jdGlvblwiOlwicGllY2V3aXNlLWNvbnN0YW50XCIsXCJ2YWx1ZXNcIjpbXCJ2aXNpYmxlXCIsXCJub25lXCJdLFwiZGVmYXVsdFwiOlwidmlzaWJsZVwifX0sXCJmaWx0ZXJcIjp7XCJ0eXBlXCI6XCJhcnJheVwiLFwidmFsdWVcIjpcIipcIn0sXCJmaWx0ZXJfb3BlcmF0b3JcIjp7XCJ0eXBlXCI6XCJlbnVtXCIsXCJ2YWx1ZXNcIjpbXCI9PVwiLFwiIT1cIixcIj5cIixcIj49XCIsXCI8XCIsXCI8PVwiLFwiaW5cIixcIiFpblwiLFwiYWxsXCIsXCJhbnlcIixcIm5vbmVcIl19LFwiZ2VvbWV0cnlfdHlwZVwiOntcInR5cGVcIjpcImVudW1cIixcInZhbHVlc1wiOltcIlBvaW50XCIsXCJMaW5lU3RyaW5nXCIsXCJQb2x5Z29uXCJdfSxcImNvbG9yX29wZXJhdGlvblwiOntcInR5cGVcIjpcImVudW1cIixcInZhbHVlc1wiOltcImxpZ2h0ZW5cIixcInNhdHVyYXRlXCIsXCJzcGluXCIsXCJmYWRlXCIsXCJtaXhcIl19LFwiZnVuY3Rpb25cIjp7XCJzdG9wc1wiOntcInR5cGVcIjpcImFycmF5XCIsXCJyZXF1aXJlZFwiOnRydWUsXCJ2YWx1ZVwiOlwiZnVuY3Rpb25fc3RvcFwifSxcImJhc2VcIjp7XCJ0eXBlXCI6XCJudW1iZXJcIixcImRlZmF1bHRcIjoxLFwibWluaW11bVwiOjB9fSxcImZ1bmN0aW9uX3N0b3BcIjp7XCJ0eXBlXCI6XCJhcnJheVwiLFwibWluaW11bVwiOjAsXCJtYXhpbXVtXCI6MjIsXCJ2YWx1ZVwiOltcIm51bWJlclwiLFwiY29sb3JcIl0sXCJsZW5ndGhcIjoyfSxcInBhaW50XCI6W1wicGFpbnRfZmlsbFwiLFwicGFpbnRfbGluZVwiLFwicGFpbnRfY2lyY2xlXCIsXCJwYWludF9zeW1ib2xcIixcInBhaW50X3Jhc3RlclwiLFwicGFpbnRfYmFja2dyb3VuZFwiXSxcInBhaW50X2ZpbGxcIjp7XCJmaWxsLWFudGlhbGlhc1wiOntcInR5cGVcIjpcImJvb2xlYW5cIixcImZ1bmN0aW9uXCI6XCJwaWVjZXdpc2UtY29uc3RhbnRcIixcImRlZmF1bHRcIjp0cnVlfSxcImZpbGwtb3BhY2l0eVwiOntcInR5cGVcIjpcIm51bWJlclwiLFwiZnVuY3Rpb25cIjpcImludGVycG9sYXRlZFwiLFwiZGVmYXVsdFwiOjEsXCJtaW5pbXVtXCI6MCxcIm1heGltdW1cIjoxLFwidHJhbnNpdGlvblwiOnRydWV9LFwiZmlsbC1jb2xvclwiOntcInR5cGVcIjpcImNvbG9yXCIsXCJkZWZhdWx0XCI6XCIjMDAwMDAwXCIsXCJmdW5jdGlvblwiOlwiaW50ZXJwb2xhdGVkXCIsXCJ0cmFuc2l0aW9uXCI6dHJ1ZSxcInJlcXVpcmVzXCI6W3tcIiFcIjpcImZpbGwtcGF0dGVyblwifV19LFwiZmlsbC1vdXRsaW5lLWNvbG9yXCI6e1widHlwZVwiOlwiY29sb3JcIixcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcInRyYW5zaXRpb25cIjp0cnVlLFwicmVxdWlyZXNcIjpbe1wiIVwiOlwiZmlsbC1wYXR0ZXJuXCJ9LHtcImZpbGwtYW50aWFsaWFzXCI6dHJ1ZX1dfSxcImZpbGwtdHJhbnNsYXRlXCI6e1widHlwZVwiOlwiYXJyYXlcIixcInZhbHVlXCI6XCJudW1iZXJcIixcImxlbmd0aFwiOjIsXCJkZWZhdWx0XCI6WzAsMF0sXCJmdW5jdGlvblwiOlwiaW50ZXJwb2xhdGVkXCIsXCJ0cmFuc2l0aW9uXCI6dHJ1ZSxcInVuaXRzXCI6XCJwaXhlbHNcIn0sXCJmaWxsLXRyYW5zbGF0ZS1hbmNob3JcIjp7XCJ0eXBlXCI6XCJlbnVtXCIsXCJmdW5jdGlvblwiOlwicGllY2V3aXNlLWNvbnN0YW50XCIsXCJ2YWx1ZXNcIjpbXCJtYXBcIixcInZpZXdwb3J0XCJdLFwiZGVmYXVsdFwiOlwibWFwXCIsXCJyZXF1aXJlc1wiOltcImZpbGwtdHJhbnNsYXRlXCJdfSxcImZpbGwtcGF0dGVyblwiOntcInR5cGVcIjpcInN0cmluZ1wiLFwiZnVuY3Rpb25cIjpcInBpZWNld2lzZS1jb25zdGFudFwiLFwidHJhbnNpdGlvblwiOnRydWV9fSxcInBhaW50X2xpbmVcIjp7XCJsaW5lLW9wYWNpdHlcIjp7XCJ0eXBlXCI6XCJudW1iZXJcIixcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcImRlZmF1bHRcIjoxLFwibWluaW11bVwiOjAsXCJtYXhpbXVtXCI6MSxcInRyYW5zaXRpb25cIjp0cnVlfSxcImxpbmUtY29sb3JcIjp7XCJ0eXBlXCI6XCJjb2xvclwiLFwiZGVmYXVsdFwiOlwiIzAwMDAwMFwiLFwiZnVuY3Rpb25cIjpcImludGVycG9sYXRlZFwiLFwidHJhbnNpdGlvblwiOnRydWUsXCJyZXF1aXJlc1wiOlt7XCIhXCI6XCJsaW5lLXBhdHRlcm5cIn1dfSxcImxpbmUtdHJhbnNsYXRlXCI6e1widHlwZVwiOlwiYXJyYXlcIixcInZhbHVlXCI6XCJudW1iZXJcIixcImxlbmd0aFwiOjIsXCJkZWZhdWx0XCI6WzAsMF0sXCJmdW5jdGlvblwiOlwiaW50ZXJwb2xhdGVkXCIsXCJ0cmFuc2l0aW9uXCI6dHJ1ZSxcInVuaXRzXCI6XCJwaXhlbHNcIn0sXCJsaW5lLXRyYW5zbGF0ZS1hbmNob3JcIjp7XCJ0eXBlXCI6XCJlbnVtXCIsXCJmdW5jdGlvblwiOlwicGllY2V3aXNlLWNvbnN0YW50XCIsXCJ2YWx1ZXNcIjpbXCJtYXBcIixcInZpZXdwb3J0XCJdLFwiZGVmYXVsdFwiOlwibWFwXCIsXCJyZXF1aXJlc1wiOltcImxpbmUtdHJhbnNsYXRlXCJdfSxcImxpbmUtd2lkdGhcIjp7XCJ0eXBlXCI6XCJudW1iZXJcIixcImRlZmF1bHRcIjoxLFwibWluaW11bVwiOjAsXCJmdW5jdGlvblwiOlwiaW50ZXJwb2xhdGVkXCIsXCJ0cmFuc2l0aW9uXCI6dHJ1ZSxcInVuaXRzXCI6XCJwaXhlbHNcIn0sXCJsaW5lLWdhcC13aWR0aFwiOntcInR5cGVcIjpcIm51bWJlclwiLFwiZGVmYXVsdFwiOjAsXCJtaW5pbXVtXCI6MCxcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcInRyYW5zaXRpb25cIjp0cnVlLFwidW5pdHNcIjpcInBpeGVsc1wifSxcImxpbmUtb2Zmc2V0XCI6e1widHlwZVwiOlwibnVtYmVyXCIsXCJkZWZhdWx0XCI6MCxcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcInRyYW5zaXRpb25cIjp0cnVlLFwidW5pdHNcIjpcInBpeGVsc1wifSxcImxpbmUtYmx1clwiOntcInR5cGVcIjpcIm51bWJlclwiLFwiZGVmYXVsdFwiOjAsXCJtaW5pbXVtXCI6MCxcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcInRyYW5zaXRpb25cIjp0cnVlLFwidW5pdHNcIjpcInBpeGVsc1wifSxcImxpbmUtZGFzaGFycmF5XCI6e1widHlwZVwiOlwiYXJyYXlcIixcInZhbHVlXCI6XCJudW1iZXJcIixcImZ1bmN0aW9uXCI6XCJwaWVjZXdpc2UtY29uc3RhbnRcIixcIm1pbmltdW1cIjowLFwidHJhbnNpdGlvblwiOnRydWUsXCJ1bml0c1wiOlwibGluZSB3aWR0aHNcIixcInJlcXVpcmVzXCI6W3tcIiFcIjpcImxpbmUtcGF0dGVyblwifV19LFwibGluZS1wYXR0ZXJuXCI6e1widHlwZVwiOlwic3RyaW5nXCIsXCJmdW5jdGlvblwiOlwicGllY2V3aXNlLWNvbnN0YW50XCIsXCJ0cmFuc2l0aW9uXCI6dHJ1ZX19LFwicGFpbnRfY2lyY2xlXCI6e1wiY2lyY2xlLXJhZGl1c1wiOntcInR5cGVcIjpcIm51bWJlclwiLFwiZGVmYXVsdFwiOjUsXCJtaW5pbXVtXCI6MCxcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcInRyYW5zaXRpb25cIjp0cnVlLFwidW5pdHNcIjpcInBpeGVsc1wifSxcImNpcmNsZS1jb2xvclwiOntcInR5cGVcIjpcImNvbG9yXCIsXCJkZWZhdWx0XCI6XCIjMDAwMDAwXCIsXCJmdW5jdGlvblwiOlwiaW50ZXJwb2xhdGVkXCIsXCJ0cmFuc2l0aW9uXCI6dHJ1ZX0sXCJjaXJjbGUtYmx1clwiOntcInR5cGVcIjpcIm51bWJlclwiLFwiZGVmYXVsdFwiOjAsXCJmdW5jdGlvblwiOlwiaW50ZXJwb2xhdGVkXCIsXCJ0cmFuc2l0aW9uXCI6dHJ1ZX0sXCJjaXJjbGUtb3BhY2l0eVwiOntcInR5cGVcIjpcIm51bWJlclwiLFwiZGVmYXVsdFwiOjEsXCJtaW5pbXVtXCI6MCxcIm1heGltdW1cIjoxLFwiZnVuY3Rpb25cIjpcImludGVycG9sYXRlZFwiLFwidHJhbnNpdGlvblwiOnRydWV9LFwiY2lyY2xlLXRyYW5zbGF0ZVwiOntcInR5cGVcIjpcImFycmF5XCIsXCJ2YWx1ZVwiOlwibnVtYmVyXCIsXCJsZW5ndGhcIjoyLFwiZGVmYXVsdFwiOlswLDBdLFwiZnVuY3Rpb25cIjpcImludGVycG9sYXRlZFwiLFwidHJhbnNpdGlvblwiOnRydWUsXCJ1bml0c1wiOlwicGl4ZWxzXCJ9LFwiY2lyY2xlLXRyYW5zbGF0ZS1hbmNob3JcIjp7XCJ0eXBlXCI6XCJlbnVtXCIsXCJmdW5jdGlvblwiOlwicGllY2V3aXNlLWNvbnN0YW50XCIsXCJ2YWx1ZXNcIjpbXCJtYXBcIixcInZpZXdwb3J0XCJdLFwiZGVmYXVsdFwiOlwibWFwXCIsXCJyZXF1aXJlc1wiOltcImNpcmNsZS10cmFuc2xhdGVcIl19fSxcInBhaW50X3N5bWJvbFwiOntcImljb24tb3BhY2l0eVwiOntcInR5cGVcIjpcIm51bWJlclwiLFwiZGVmYXVsdFwiOjEsXCJtaW5pbXVtXCI6MCxcIm1heGltdW1cIjoxLFwiZnVuY3Rpb25cIjpcImludGVycG9sYXRlZFwiLFwidHJhbnNpdGlvblwiOnRydWUsXCJyZXF1aXJlc1wiOltcImljb24taW1hZ2VcIl19LFwiaWNvbi1jb2xvclwiOntcInR5cGVcIjpcImNvbG9yXCIsXCJkZWZhdWx0XCI6XCIjMDAwMDAwXCIsXCJmdW5jdGlvblwiOlwiaW50ZXJwb2xhdGVkXCIsXCJ0cmFuc2l0aW9uXCI6dHJ1ZSxcInJlcXVpcmVzXCI6W1wiaWNvbi1pbWFnZVwiXX0sXCJpY29uLWhhbG8tY29sb3JcIjp7XCJ0eXBlXCI6XCJjb2xvclwiLFwiZGVmYXVsdFwiOlwicmdiYSgwLCAwLCAwLCAwKVwiLFwiZnVuY3Rpb25cIjpcImludGVycG9sYXRlZFwiLFwidHJhbnNpdGlvblwiOnRydWUsXCJyZXF1aXJlc1wiOltcImljb24taW1hZ2VcIl19LFwiaWNvbi1oYWxvLXdpZHRoXCI6e1widHlwZVwiOlwibnVtYmVyXCIsXCJkZWZhdWx0XCI6MCxcIm1pbmltdW1cIjowLFwiZnVuY3Rpb25cIjpcImludGVycG9sYXRlZFwiLFwidHJhbnNpdGlvblwiOnRydWUsXCJ1bml0c1wiOlwicGl4ZWxzXCIsXCJyZXF1aXJlc1wiOltcImljb24taW1hZ2VcIl19LFwiaWNvbi1oYWxvLWJsdXJcIjp7XCJ0eXBlXCI6XCJudW1iZXJcIixcImRlZmF1bHRcIjowLFwibWluaW11bVwiOjAsXCJmdW5jdGlvblwiOlwiaW50ZXJwb2xhdGVkXCIsXCJ0cmFuc2l0aW9uXCI6dHJ1ZSxcInVuaXRzXCI6XCJwaXhlbHNcIixcInJlcXVpcmVzXCI6W1wiaWNvbi1pbWFnZVwiXX0sXCJpY29uLXRyYW5zbGF0ZVwiOntcInR5cGVcIjpcImFycmF5XCIsXCJ2YWx1ZVwiOlwibnVtYmVyXCIsXCJsZW5ndGhcIjoyLFwiZGVmYXVsdFwiOlswLDBdLFwiZnVuY3Rpb25cIjpcImludGVycG9sYXRlZFwiLFwidHJhbnNpdGlvblwiOnRydWUsXCJ1bml0c1wiOlwicGl4ZWxzXCIsXCJyZXF1aXJlc1wiOltcImljb24taW1hZ2VcIl19LFwiaWNvbi10cmFuc2xhdGUtYW5jaG9yXCI6e1widHlwZVwiOlwiZW51bVwiLFwiZnVuY3Rpb25cIjpcInBpZWNld2lzZS1jb25zdGFudFwiLFwidmFsdWVzXCI6W1wibWFwXCIsXCJ2aWV3cG9ydFwiXSxcImRlZmF1bHRcIjpcIm1hcFwiLFwicmVxdWlyZXNcIjpbXCJpY29uLWltYWdlXCIsXCJpY29uLXRyYW5zbGF0ZVwiXX0sXCJ0ZXh0LW9wYWNpdHlcIjp7XCJ0eXBlXCI6XCJudW1iZXJcIixcImRlZmF1bHRcIjoxLFwibWluaW11bVwiOjAsXCJtYXhpbXVtXCI6MSxcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcInRyYW5zaXRpb25cIjp0cnVlLFwicmVxdWlyZXNcIjpbXCJ0ZXh0LWZpZWxkXCJdfSxcInRleHQtY29sb3JcIjp7XCJ0eXBlXCI6XCJjb2xvclwiLFwiZGVmYXVsdFwiOlwiIzAwMDAwMFwiLFwiZnVuY3Rpb25cIjpcImludGVycG9sYXRlZFwiLFwidHJhbnNpdGlvblwiOnRydWUsXCJyZXF1aXJlc1wiOltcInRleHQtZmllbGRcIl19LFwidGV4dC1oYWxvLWNvbG9yXCI6e1widHlwZVwiOlwiY29sb3JcIixcImRlZmF1bHRcIjpcInJnYmEoMCwgMCwgMCwgMClcIixcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcInRyYW5zaXRpb25cIjp0cnVlLFwicmVxdWlyZXNcIjpbXCJ0ZXh0LWZpZWxkXCJdfSxcInRleHQtaGFsby13aWR0aFwiOntcInR5cGVcIjpcIm51bWJlclwiLFwiZGVmYXVsdFwiOjAsXCJtaW5pbXVtXCI6MCxcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcInRyYW5zaXRpb25cIjp0cnVlLFwidW5pdHNcIjpcInBpeGVsc1wiLFwicmVxdWlyZXNcIjpbXCJ0ZXh0LWZpZWxkXCJdfSxcInRleHQtaGFsby1ibHVyXCI6e1widHlwZVwiOlwibnVtYmVyXCIsXCJkZWZhdWx0XCI6MCxcIm1pbmltdW1cIjowLFwiZnVuY3Rpb25cIjpcImludGVycG9sYXRlZFwiLFwidHJhbnNpdGlvblwiOnRydWUsXCJ1bml0c1wiOlwicGl4ZWxzXCIsXCJyZXF1aXJlc1wiOltcInRleHQtZmllbGRcIl19LFwidGV4dC10cmFuc2xhdGVcIjp7XCJ0eXBlXCI6XCJhcnJheVwiLFwidmFsdWVcIjpcIm51bWJlclwiLFwibGVuZ3RoXCI6MixcImRlZmF1bHRcIjpbMCwwXSxcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcInRyYW5zaXRpb25cIjp0cnVlLFwidW5pdHNcIjpcInBpeGVsc1wiLFwicmVxdWlyZXNcIjpbXCJ0ZXh0LWZpZWxkXCJdfSxcInRleHQtdHJhbnNsYXRlLWFuY2hvclwiOntcInR5cGVcIjpcImVudW1cIixcImZ1bmN0aW9uXCI6XCJwaWVjZXdpc2UtY29uc3RhbnRcIixcInZhbHVlc1wiOltcIm1hcFwiLFwidmlld3BvcnRcIl0sXCJkZWZhdWx0XCI6XCJtYXBcIixcInJlcXVpcmVzXCI6W1widGV4dC1maWVsZFwiLFwidGV4dC10cmFuc2xhdGVcIl19fSxcInBhaW50X3Jhc3RlclwiOntcInJhc3Rlci1vcGFjaXR5XCI6e1widHlwZVwiOlwibnVtYmVyXCIsXCJkZWZhdWx0XCI6MSxcIm1pbmltdW1cIjowLFwibWF4aW11bVwiOjEsXCJmdW5jdGlvblwiOlwiaW50ZXJwb2xhdGVkXCIsXCJ0cmFuc2l0aW9uXCI6dHJ1ZX0sXCJyYXN0ZXItaHVlLXJvdGF0ZVwiOntcInR5cGVcIjpcIm51bWJlclwiLFwiZGVmYXVsdFwiOjAsXCJwZXJpb2RcIjozNjAsXCJmdW5jdGlvblwiOlwiaW50ZXJwb2xhdGVkXCIsXCJ0cmFuc2l0aW9uXCI6dHJ1ZSxcInVuaXRzXCI6XCJkZWdyZWVzXCJ9LFwicmFzdGVyLWJyaWdodG5lc3MtbWluXCI6e1widHlwZVwiOlwibnVtYmVyXCIsXCJmdW5jdGlvblwiOlwiaW50ZXJwb2xhdGVkXCIsXCJkZWZhdWx0XCI6MCxcIm1pbmltdW1cIjowLFwibWF4aW11bVwiOjEsXCJ0cmFuc2l0aW9uXCI6dHJ1ZX0sXCJyYXN0ZXItYnJpZ2h0bmVzcy1tYXhcIjp7XCJ0eXBlXCI6XCJudW1iZXJcIixcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcImRlZmF1bHRcIjoxLFwibWluaW11bVwiOjAsXCJtYXhpbXVtXCI6MSxcInRyYW5zaXRpb25cIjp0cnVlfSxcInJhc3Rlci1zYXR1cmF0aW9uXCI6e1widHlwZVwiOlwibnVtYmVyXCIsXCJkZWZhdWx0XCI6MCxcIm1pbmltdW1cIjotMSxcIm1heGltdW1cIjoxLFwiZnVuY3Rpb25cIjpcImludGVycG9sYXRlZFwiLFwidHJhbnNpdGlvblwiOnRydWV9LFwicmFzdGVyLWNvbnRyYXN0XCI6e1widHlwZVwiOlwibnVtYmVyXCIsXCJkZWZhdWx0XCI6MCxcIm1pbmltdW1cIjotMSxcIm1heGltdW1cIjoxLFwiZnVuY3Rpb25cIjpcImludGVycG9sYXRlZFwiLFwidHJhbnNpdGlvblwiOnRydWV9LFwicmFzdGVyLWZhZGUtZHVyYXRpb25cIjp7XCJ0eXBlXCI6XCJudW1iZXJcIixcImRlZmF1bHRcIjozMDAsXCJtaW5pbXVtXCI6MCxcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcInRyYW5zaXRpb25cIjp0cnVlLFwidW5pdHNcIjpcIm1pbGxpc2Vjb25kc1wifX0sXCJwYWludF9iYWNrZ3JvdW5kXCI6e1wiYmFja2dyb3VuZC1jb2xvclwiOntcInR5cGVcIjpcImNvbG9yXCIsXCJkZWZhdWx0XCI6XCIjMDAwMDAwXCIsXCJmdW5jdGlvblwiOlwiaW50ZXJwb2xhdGVkXCIsXCJ0cmFuc2l0aW9uXCI6dHJ1ZSxcInJlcXVpcmVzXCI6W3tcIiFcIjpcImJhY2tncm91bmQtcGF0dGVyblwifV19LFwiYmFja2dyb3VuZC1wYXR0ZXJuXCI6e1widHlwZVwiOlwic3RyaW5nXCIsXCJmdW5jdGlvblwiOlwicGllY2V3aXNlLWNvbnN0YW50XCIsXCJ0cmFuc2l0aW9uXCI6dHJ1ZX0sXCJiYWNrZ3JvdW5kLW9wYWNpdHlcIjp7XCJ0eXBlXCI6XCJudW1iZXJcIixcImRlZmF1bHRcIjoxLFwibWluaW11bVwiOjAsXCJtYXhpbXVtXCI6MSxcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcInRyYW5zaXRpb25cIjp0cnVlfX0sXCJ0cmFuc2l0aW9uXCI6e1wiZHVyYXRpb25cIjp7XCJ0eXBlXCI6XCJudW1iZXJcIixcImRlZmF1bHRcIjozMDAsXCJtaW5pbXVtXCI6MCxcInVuaXRzXCI6XCJtaWxsaXNlY29uZHNcIn0sXCJkZWxheVwiOntcInR5cGVcIjpcIm51bWJlclwiLFwiZGVmYXVsdFwiOjAsXCJtaW5pbXVtXCI6MCxcInVuaXRzXCI6XCJtaWxsaXNlY29uZHNcIn19fSIsIid1c2Ugc3RyaWN0JztcblxuLy8gbGlnaHR3ZWlnaHQgQnVmZmVyIHNoaW0gZm9yIHBiZiBicm93c2VyIGJ1aWxkXG4vLyBiYXNlZCBvbiBjb2RlIGZyb20gZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyIChNSVQtbGljZW5zZWQpXG5cbm1vZHVsZS5leHBvcnRzID0gQnVmZmVyO1xuXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKTtcblxudmFyIEJ1ZmZlck1ldGhvZHM7XG5cbmZ1bmN0aW9uIEJ1ZmZlcihsZW5ndGgpIHtcbiAgICB2YXIgYXJyO1xuICAgIGlmIChsZW5ndGggJiYgbGVuZ3RoLmxlbmd0aCkge1xuICAgICAgICBhcnIgPSBsZW5ndGg7XG4gICAgICAgIGxlbmd0aCA9IGFyci5sZW5ndGg7XG4gICAgfVxuICAgIHZhciBidWYgPSBuZXcgVWludDhBcnJheShsZW5ndGggfHwgMCk7XG4gICAgaWYgKGFycikgYnVmLnNldChhcnIpO1xuXG4gICAgYnVmLnJlYWRVSW50MzJMRSA9IEJ1ZmZlck1ldGhvZHMucmVhZFVJbnQzMkxFO1xuICAgIGJ1Zi53cml0ZVVJbnQzMkxFID0gQnVmZmVyTWV0aG9kcy53cml0ZVVJbnQzMkxFO1xuICAgIGJ1Zi5yZWFkSW50MzJMRSA9IEJ1ZmZlck1ldGhvZHMucmVhZEludDMyTEU7XG4gICAgYnVmLndyaXRlSW50MzJMRSA9IEJ1ZmZlck1ldGhvZHMud3JpdGVJbnQzMkxFO1xuICAgIGJ1Zi5yZWFkRmxvYXRMRSA9IEJ1ZmZlck1ldGhvZHMucmVhZEZsb2F0TEU7XG4gICAgYnVmLndyaXRlRmxvYXRMRSA9IEJ1ZmZlck1ldGhvZHMud3JpdGVGbG9hdExFO1xuICAgIGJ1Zi5yZWFkRG91YmxlTEUgPSBCdWZmZXJNZXRob2RzLnJlYWREb3VibGVMRTtcbiAgICBidWYud3JpdGVEb3VibGVMRSA9IEJ1ZmZlck1ldGhvZHMud3JpdGVEb3VibGVMRTtcbiAgICBidWYudG9TdHJpbmcgPSBCdWZmZXJNZXRob2RzLnRvU3RyaW5nO1xuICAgIGJ1Zi53cml0ZSA9IEJ1ZmZlck1ldGhvZHMud3JpdGU7XG4gICAgYnVmLnNsaWNlID0gQnVmZmVyTWV0aG9kcy5zbGljZTtcbiAgICBidWYuY29weSA9IEJ1ZmZlck1ldGhvZHMuY29weTtcblxuICAgIGJ1Zi5faXNCdWZmZXIgPSB0cnVlO1xuICAgIHJldHVybiBidWY7XG59XG5cbnZhciBsYXN0U3RyLCBsYXN0U3RyRW5jb2RlZDtcblxuQnVmZmVyTWV0aG9kcyA9IHtcbiAgICByZWFkVUludDMyTEU6IGZ1bmN0aW9uKHBvcykge1xuICAgICAgICByZXR1cm4gKCh0aGlzW3Bvc10pIHxcbiAgICAgICAgICAgICh0aGlzW3BvcyArIDFdIDw8IDgpIHxcbiAgICAgICAgICAgICh0aGlzW3BvcyArIDJdIDw8IDE2KSkgK1xuICAgICAgICAgICAgKHRoaXNbcG9zICsgM10gKiAweDEwMDAwMDApO1xuICAgIH0sXG5cbiAgICB3cml0ZVVJbnQzMkxFOiBmdW5jdGlvbih2YWwsIHBvcykge1xuICAgICAgICB0aGlzW3Bvc10gPSB2YWw7XG4gICAgICAgIHRoaXNbcG9zICsgMV0gPSAodmFsID4+PiA4KTtcbiAgICAgICAgdGhpc1twb3MgKyAyXSA9ICh2YWwgPj4+IDE2KTtcbiAgICAgICAgdGhpc1twb3MgKyAzXSA9ICh2YWwgPj4+IDI0KTtcbiAgICB9LFxuXG4gICAgcmVhZEludDMyTEU6IGZ1bmN0aW9uKHBvcykge1xuICAgICAgICByZXR1cm4gKCh0aGlzW3Bvc10pIHxcbiAgICAgICAgICAgICh0aGlzW3BvcyArIDFdIDw8IDgpIHxcbiAgICAgICAgICAgICh0aGlzW3BvcyArIDJdIDw8IDE2KSkgK1xuICAgICAgICAgICAgKHRoaXNbcG9zICsgM10gPDwgMjQpO1xuICAgIH0sXG5cbiAgICByZWFkRmxvYXRMRTogIGZ1bmN0aW9uKHBvcykgeyByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIHBvcywgdHJ1ZSwgMjMsIDQpOyB9LFxuICAgIHJlYWREb3VibGVMRTogZnVuY3Rpb24ocG9zKSB7IHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgcG9zLCB0cnVlLCA1MiwgOCk7IH0sXG5cbiAgICB3cml0ZUZsb2F0TEU6ICBmdW5jdGlvbih2YWwsIHBvcykgeyByZXR1cm4gaWVlZTc1NC53cml0ZSh0aGlzLCB2YWwsIHBvcywgdHJ1ZSwgMjMsIDQpOyB9LFxuICAgIHdyaXRlRG91YmxlTEU6IGZ1bmN0aW9uKHZhbCwgcG9zKSB7IHJldHVybiBpZWVlNzU0LndyaXRlKHRoaXMsIHZhbCwgcG9zLCB0cnVlLCA1MiwgOCk7IH0sXG5cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgdmFyIHN0ciA9ICcnLFxuICAgICAgICAgICAgdG1wID0gJyc7XG5cbiAgICAgICAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICAgICAgICBlbmQgPSBNYXRoLm1pbih0aGlzLmxlbmd0aCwgZW5kIHx8IHRoaXMubGVuZ3RoKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNoID0gdGhpc1tpXTtcbiAgICAgICAgICAgIGlmIChjaCA8PSAweDdGKSB7XG4gICAgICAgICAgICAgICAgc3RyICs9IGRlY29kZVVSSUNvbXBvbmVudCh0bXApICsgU3RyaW5nLmZyb21DaGFyQ29kZShjaCk7XG4gICAgICAgICAgICAgICAgdG1wID0gJyc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRtcCArPSAnJScgKyBjaC50b1N0cmluZygxNik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzdHIgKz0gZGVjb2RlVVJJQ29tcG9uZW50KHRtcCk7XG5cbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9LFxuXG4gICAgd3JpdGU6IGZ1bmN0aW9uKHN0ciwgcG9zKSB7XG4gICAgICAgIHZhciBieXRlcyA9IHN0ciA9PT0gbGFzdFN0ciA/IGxhc3RTdHJFbmNvZGVkIDogZW5jb2RlU3RyaW5nKHN0cik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXNbcG9zICsgaV0gPSBieXRlc1tpXTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBzbGljZTogZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKTtcbiAgICB9LFxuXG4gICAgY29weTogZnVuY3Rpb24oYnVmLCBwb3MpIHtcbiAgICAgICAgcG9zID0gcG9zIHx8IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYnVmW3BvcyArIGldID0gdGhpc1tpXTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbkJ1ZmZlck1ldGhvZHMud3JpdGVJbnQzMkxFID0gQnVmZmVyTWV0aG9kcy53cml0ZVVJbnQzMkxFO1xuXG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGZ1bmN0aW9uKHN0cikge1xuICAgIGxhc3RTdHIgPSBzdHI7XG4gICAgbGFzdFN0ckVuY29kZWQgPSBlbmNvZGVTdHJpbmcoc3RyKTtcbiAgICByZXR1cm4gbGFzdFN0ckVuY29kZWQubGVuZ3RoO1xufTtcblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24oYnVmKSB7XG4gICAgcmV0dXJuICEhKGJ1ZiAmJiBidWYuX2lzQnVmZmVyKTtcbn07XG5cbmZ1bmN0aW9uIGVuY29kZVN0cmluZyhzdHIpIHtcbiAgICB2YXIgbGVuZ3RoID0gc3RyLmxlbmd0aCxcbiAgICAgICAgYnl0ZXMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBjLCBsZWFkOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpOyAvLyBjb2RlIHBvaW50XG5cbiAgICAgICAgaWYgKGMgPiAweEQ3RkYgJiYgYyA8IDB4RTAwMCkge1xuXG4gICAgICAgICAgICBpZiAobGVhZCkge1xuICAgICAgICAgICAgICAgIGlmIChjIDwgMHhEQzAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRCk7XG4gICAgICAgICAgICAgICAgICAgIGxlYWQgPSBjO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGMgPSBsZWFkIC0gMHhEODAwIDw8IDEwIHwgYyAtIDB4REMwMCB8IDB4MTAwMDA7XG4gICAgICAgICAgICAgICAgICAgIGxlYWQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoYyA+IDB4REJGRiB8fCAoaSArIDEgPT09IGxlbmd0aCkpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRCk7XG4gICAgICAgICAgICAgICAgZWxzZSBsZWFkID0gYztcblxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAobGVhZCkge1xuICAgICAgICAgICAgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKTtcbiAgICAgICAgICAgIGxlYWQgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGMgPCAweDgwKSBieXRlcy5wdXNoKGMpO1xuICAgICAgICBlbHNlIGlmIChjIDwgMHg4MDApIGJ5dGVzLnB1c2goYyA+PiAweDYgfCAweEMwLCBjICYgMHgzRiB8IDB4ODApO1xuICAgICAgICBlbHNlIGlmIChjIDwgMHgxMDAwMCkgYnl0ZXMucHVzaChjID4+IDB4QyB8IDB4RTAsIGMgPj4gMHg2ICYgMHgzRiB8IDB4ODAsIGMgJiAweDNGIHwgMHg4MCk7XG4gICAgICAgIGVsc2UgYnl0ZXMucHVzaChjID4+IDB4MTIgfCAweEYwLCBjID4+IDB4QyAmIDB4M0YgfCAweDgwLCBjID4+IDB4NiAmIDB4M0YgfCAweDgwLCBjICYgMHgzRiB8IDB4ODApO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXM7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUGJmO1xuXG52YXIgQnVmZmVyID0gZ2xvYmFsLkJ1ZmZlciB8fCByZXF1aXJlKCcuL2J1ZmZlcicpO1xuXG5mdW5jdGlvbiBQYmYoYnVmKSB7XG4gICAgdGhpcy5idWYgPSAhQnVmZmVyLmlzQnVmZmVyKGJ1ZikgPyBuZXcgQnVmZmVyKGJ1ZiB8fCAwKSA6IGJ1ZjtcbiAgICB0aGlzLnBvcyA9IDA7XG4gICAgdGhpcy5sZW5ndGggPSB0aGlzLmJ1Zi5sZW5ndGg7XG59XG5cblBiZi5WYXJpbnQgID0gMDsgLy8gdmFyaW50OiBpbnQzMiwgaW50NjQsIHVpbnQzMiwgdWludDY0LCBzaW50MzIsIHNpbnQ2NCwgYm9vbCwgZW51bVxuUGJmLkZpeGVkNjQgPSAxOyAvLyA2NC1iaXQ6IGRvdWJsZSwgZml4ZWQ2NCwgc2ZpeGVkNjRcblBiZi5CeXRlcyAgID0gMjsgLy8gbGVuZ3RoLWRlbGltaXRlZDogc3RyaW5nLCBieXRlcywgZW1iZWRkZWQgbWVzc2FnZXMsIHBhY2tlZCByZXBlYXRlZCBmaWVsZHNcblBiZi5GaXhlZDMyID0gNTsgLy8gMzItYml0OiBmbG9hdCwgZml4ZWQzMiwgc2ZpeGVkMzJcblxudmFyIFNISUZUX0xFRlRfMzIgPSAoMSA8PCAxNikgKiAoMSA8PCAxNiksXG4gICAgU0hJRlRfUklHSFRfMzIgPSAxIC8gU0hJRlRfTEVGVF8zMixcbiAgICBQT1dfMl82MyA9IE1hdGgucG93KDIsIDYzKTtcblxuUGJmLnByb3RvdHlwZSA9IHtcblxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmJ1ZiA9IG51bGw7XG4gICAgfSxcblxuICAgIC8vID09PSBSRUFESU5HID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICByZWFkRmllbGRzOiBmdW5jdGlvbihyZWFkRmllbGQsIHJlc3VsdCwgZW5kKSB7XG4gICAgICAgIGVuZCA9IGVuZCB8fCB0aGlzLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAodGhpcy5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSB0aGlzLnJlYWRWYXJpbnQoKSxcbiAgICAgICAgICAgICAgICB0YWcgPSB2YWwgPj4gMyxcbiAgICAgICAgICAgICAgICBzdGFydFBvcyA9IHRoaXMucG9zO1xuXG4gICAgICAgICAgICByZWFkRmllbGQodGFnLCByZXN1bHQsIHRoaXMpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPT09IHN0YXJ0UG9zKSB0aGlzLnNraXAodmFsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICByZWFkTWVzc2FnZTogZnVuY3Rpb24ocmVhZEZpZWxkLCByZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZEZpZWxkcyhyZWFkRmllbGQsIHJlc3VsdCwgdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcyk7XG4gICAgfSxcblxuICAgIHJlYWRGaXhlZDMyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbCA9IHRoaXMuYnVmLnJlYWRVSW50MzJMRSh0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMucG9zICs9IDQ7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfSxcblxuICAgIHJlYWRTRml4ZWQzMjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWwgPSB0aGlzLmJ1Zi5yZWFkSW50MzJMRSh0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMucG9zICs9IDQ7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfSxcblxuICAgIC8vIDY0LWJpdCBpbnQgaGFuZGxpbmcgaXMgYmFzZWQgb24gZ2l0aHViLmNvbS9kcHcvbm9kZS1idWZmZXItbW9yZS1pbnRzIChNSVQtbGljZW5zZWQpXG5cbiAgICByZWFkRml4ZWQ2NDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWwgPSB0aGlzLmJ1Zi5yZWFkVUludDMyTEUodGhpcy5wb3MpICsgdGhpcy5idWYucmVhZFVJbnQzMkxFKHRoaXMucG9zICsgNCkgKiBTSElGVF9MRUZUXzMyO1xuICAgICAgICB0aGlzLnBvcyArPSA4O1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH0sXG5cbiAgICByZWFkU0ZpeGVkNjQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsID0gdGhpcy5idWYucmVhZFVJbnQzMkxFKHRoaXMucG9zKSArIHRoaXMuYnVmLnJlYWRJbnQzMkxFKHRoaXMucG9zICsgNCkgKiBTSElGVF9MRUZUXzMyO1xuICAgICAgICB0aGlzLnBvcyArPSA4O1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH0sXG5cbiAgICByZWFkRmxvYXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsID0gdGhpcy5idWYucmVhZEZsb2F0TEUodGhpcy5wb3MpO1xuICAgICAgICB0aGlzLnBvcyArPSA0O1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH0sXG5cbiAgICByZWFkRG91YmxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbCA9IHRoaXMuYnVmLnJlYWREb3VibGVMRSh0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMucG9zICs9IDg7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfSxcblxuICAgIHJlYWRWYXJpbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYnVmID0gdGhpcy5idWYsXG4gICAgICAgICAgICB2YWwsIGIsIGIwLCBiMSwgYjIsIGIzO1xuXG4gICAgICAgIGIwID0gYnVmW3RoaXMucG9zKytdOyBpZiAoYjAgPCAweDgwKSByZXR1cm4gYjA7ICAgICAgICAgICAgICAgICBiMCA9IGIwICYgMHg3ZjtcbiAgICAgICAgYjEgPSBidWZbdGhpcy5wb3MrK107IGlmIChiMSA8IDB4ODApIHJldHVybiBiMCB8IGIxIDw8IDc7ICAgICAgIGIxID0gKGIxICYgMHg3ZikgPDwgNztcbiAgICAgICAgYjIgPSBidWZbdGhpcy5wb3MrK107IGlmIChiMiA8IDB4ODApIHJldHVybiBiMCB8IGIxIHwgYjIgPDwgMTQ7IGIyID0gKGIyICYgMHg3ZikgPDwgMTQ7XG4gICAgICAgIGIzID0gYnVmW3RoaXMucG9zKytdOyBpZiAoYjMgPCAweDgwKSByZXR1cm4gYjAgfCBiMSB8IGIyIHwgYjMgPDwgMjE7XG5cbiAgICAgICAgdmFsID0gYjAgfCBiMSB8IGIyIHwgKGIzICYgMHg3ZikgPDwgMjE7XG5cbiAgICAgICAgYiA9IGJ1Zlt0aGlzLnBvcysrXTsgdmFsICs9IChiICYgMHg3ZikgKiAweDEwMDAwMDAwOyAgICAgICAgIGlmIChiIDwgMHg4MCkgcmV0dXJuIHZhbDtcbiAgICAgICAgYiA9IGJ1Zlt0aGlzLnBvcysrXTsgdmFsICs9IChiICYgMHg3ZikgKiAweDgwMDAwMDAwMDsgICAgICAgIGlmIChiIDwgMHg4MCkgcmV0dXJuIHZhbDtcbiAgICAgICAgYiA9IGJ1Zlt0aGlzLnBvcysrXTsgdmFsICs9IChiICYgMHg3ZikgKiAweDQwMDAwMDAwMDAwOyAgICAgIGlmIChiIDwgMHg4MCkgcmV0dXJuIHZhbDtcbiAgICAgICAgYiA9IGJ1Zlt0aGlzLnBvcysrXTsgdmFsICs9IChiICYgMHg3ZikgKiAweDIwMDAwMDAwMDAwMDA7ICAgIGlmIChiIDwgMHg4MCkgcmV0dXJuIHZhbDtcbiAgICAgICAgYiA9IGJ1Zlt0aGlzLnBvcysrXTsgdmFsICs9IChiICYgMHg3ZikgKiAweDEwMDAwMDAwMDAwMDAwMDsgIGlmIChiIDwgMHg4MCkgcmV0dXJuIHZhbDtcbiAgICAgICAgYiA9IGJ1Zlt0aGlzLnBvcysrXTsgdmFsICs9IChiICYgMHg3ZikgKiAweDgwMDAwMDAwMDAwMDAwMDA7IGlmIChiIDwgMHg4MCkgcmV0dXJuIHZhbDtcblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHZhcmludCBub3QgbW9yZSB0aGFuIDEwIGJ5dGVzJyk7XG4gICAgfSxcblxuICAgIHJlYWRWYXJpbnQ2NDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdGFydFBvcyA9IHRoaXMucG9zLFxuICAgICAgICAgICAgdmFsID0gdGhpcy5yZWFkVmFyaW50KCk7XG5cbiAgICAgICAgaWYgKHZhbCA8IFBPV18yXzYzKSByZXR1cm4gdmFsO1xuXG4gICAgICAgIHZhciBwb3MgPSB0aGlzLnBvcyAtIDI7XG4gICAgICAgIHdoaWxlICh0aGlzLmJ1Zltwb3NdID09PSAweGZmKSBwb3MtLTtcbiAgICAgICAgaWYgKHBvcyA8IHN0YXJ0UG9zKSBwb3MgPSBzdGFydFBvcztcblxuICAgICAgICB2YWwgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvcyAtIHN0YXJ0UG9zICsgMTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYiA9IH50aGlzLmJ1ZltzdGFydFBvcyArIGldICYgMHg3ZjtcbiAgICAgICAgICAgIHZhbCArPSBpIDwgNCA/IGIgPDwgaSAqIDcgOiBiICogTWF0aC5wb3coMiwgaSAqIDcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIC12YWwgLSAxO1xuICAgIH0sXG5cbiAgICByZWFkU1ZhcmludDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBudW0gPSB0aGlzLnJlYWRWYXJpbnQoKTtcbiAgICAgICAgcmV0dXJuIG51bSAlIDIgPT09IDEgPyAobnVtICsgMSkgLyAtMiA6IG51bSAvIDI7IC8vIHppZ3phZyBlbmNvZGluZ1xuICAgIH0sXG5cbiAgICByZWFkQm9vbGVhbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHRoaXMucmVhZFZhcmludCgpKTtcbiAgICB9LFxuXG4gICAgcmVhZFN0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLnJlYWRWYXJpbnQoKSArIHRoaXMucG9zLFxuICAgICAgICAgICAgc3RyID0gdGhpcy5idWYudG9TdHJpbmcoJ3V0ZjgnLCB0aGlzLnBvcywgZW5kKTtcbiAgICAgICAgdGhpcy5wb3MgPSBlbmQ7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfSxcblxuICAgIHJlYWRCeXRlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLnJlYWRWYXJpbnQoKSArIHRoaXMucG9zLFxuICAgICAgICAgICAgYnVmZmVyID0gdGhpcy5idWYuc2xpY2UodGhpcy5wb3MsIGVuZCk7XG4gICAgICAgIHRoaXMucG9zID0gZW5kO1xuICAgICAgICByZXR1cm4gYnVmZmVyO1xuICAgIH0sXG5cbiAgICAvLyB2ZXJib3NlIGZvciBwZXJmb3JtYW5jZSByZWFzb25zOyBkb2Vzbid0IGFmZmVjdCBnemlwcGVkIHNpemVcblxuICAgIHJlYWRQYWNrZWRWYXJpbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcywgYXJyID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLnBvcyA8IGVuZCkgYXJyLnB1c2godGhpcy5yZWFkVmFyaW50KCkpO1xuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH0sXG4gICAgcmVhZFBhY2tlZFNWYXJpbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcywgYXJyID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLnBvcyA8IGVuZCkgYXJyLnB1c2godGhpcy5yZWFkU1ZhcmludCgpKTtcbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9LFxuICAgIHJlYWRQYWNrZWRCb29sZWFuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMucmVhZFZhcmludCgpICsgdGhpcy5wb3MsIGFyciA9IFtdO1xuICAgICAgICB3aGlsZSAodGhpcy5wb3MgPCBlbmQpIGFyci5wdXNoKHRoaXMucmVhZEJvb2xlYW4oKSk7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfSxcbiAgICByZWFkUGFja2VkRmxvYXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcywgYXJyID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLnBvcyA8IGVuZCkgYXJyLnB1c2godGhpcy5yZWFkRmxvYXQoKSk7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfSxcbiAgICByZWFkUGFja2VkRG91YmxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMucmVhZFZhcmludCgpICsgdGhpcy5wb3MsIGFyciA9IFtdO1xuICAgICAgICB3aGlsZSAodGhpcy5wb3MgPCBlbmQpIGFyci5wdXNoKHRoaXMucmVhZERvdWJsZSgpKTtcbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9LFxuICAgIHJlYWRQYWNrZWRGaXhlZDMyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMucmVhZFZhcmludCgpICsgdGhpcy5wb3MsIGFyciA9IFtdO1xuICAgICAgICB3aGlsZSAodGhpcy5wb3MgPCBlbmQpIGFyci5wdXNoKHRoaXMucmVhZEZpeGVkMzIoKSk7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfSxcbiAgICByZWFkUGFja2VkU0ZpeGVkMzI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcywgYXJyID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLnBvcyA8IGVuZCkgYXJyLnB1c2godGhpcy5yZWFkU0ZpeGVkMzIoKSk7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfSxcbiAgICByZWFkUGFja2VkRml4ZWQ2NDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLnJlYWRWYXJpbnQoKSArIHRoaXMucG9zLCBhcnIgPSBbXTtcbiAgICAgICAgd2hpbGUgKHRoaXMucG9zIDwgZW5kKSBhcnIucHVzaCh0aGlzLnJlYWRGaXhlZDY0KCkpO1xuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH0sXG4gICAgcmVhZFBhY2tlZFNGaXhlZDY0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMucmVhZFZhcmludCgpICsgdGhpcy5wb3MsIGFyciA9IFtdO1xuICAgICAgICB3aGlsZSAodGhpcy5wb3MgPCBlbmQpIGFyci5wdXNoKHRoaXMucmVhZFNGaXhlZDY0KCkpO1xuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH0sXG5cbiAgICBza2lwOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdmFyIHR5cGUgPSB2YWwgJiAweDc7XG4gICAgICAgIGlmICh0eXBlID09PSBQYmYuVmFyaW50KSB3aGlsZSAodGhpcy5idWZbdGhpcy5wb3MrK10gPiAweDdmKSB7fVxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSBQYmYuQnl0ZXMpIHRoaXMucG9zID0gdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcztcbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gUGJmLkZpeGVkMzIpIHRoaXMucG9zICs9IDQ7XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IFBiZi5GaXhlZDY0KSB0aGlzLnBvcyArPSA4O1xuICAgICAgICBlbHNlIHRocm93IG5ldyBFcnJvcignVW5pbXBsZW1lbnRlZCB0eXBlOiAnICsgdHlwZSk7XG4gICAgfSxcblxuICAgIC8vID09PSBXUklUSU5HID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICB3cml0ZVRhZzogZnVuY3Rpb24odGFnLCB0eXBlKSB7XG4gICAgICAgIHRoaXMud3JpdGVWYXJpbnQoKHRhZyA8PCAzKSB8IHR5cGUpO1xuICAgIH0sXG5cbiAgICByZWFsbG9jOiBmdW5jdGlvbihtaW4pIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHx8IDE2O1xuXG4gICAgICAgIHdoaWxlIChsZW5ndGggPCB0aGlzLnBvcyArIG1pbikgbGVuZ3RoICo9IDI7XG5cbiAgICAgICAgaWYgKGxlbmd0aCAhPT0gdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBidWYgPSBuZXcgQnVmZmVyKGxlbmd0aCk7XG4gICAgICAgICAgICB0aGlzLmJ1Zi5jb3B5KGJ1Zik7XG4gICAgICAgICAgICB0aGlzLmJ1ZiA9IGJ1ZjtcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy5wb3M7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmLnNsaWNlKDAsIHRoaXMubGVuZ3RoKTtcbiAgICB9LFxuXG4gICAgd3JpdGVGaXhlZDMyOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdGhpcy5yZWFsbG9jKDQpO1xuICAgICAgICB0aGlzLmJ1Zi53cml0ZVVJbnQzMkxFKHZhbCwgdGhpcy5wb3MpO1xuICAgICAgICB0aGlzLnBvcyArPSA0O1xuICAgIH0sXG5cbiAgICB3cml0ZVNGaXhlZDMyOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdGhpcy5yZWFsbG9jKDQpO1xuICAgICAgICB0aGlzLmJ1Zi53cml0ZUludDMyTEUodmFsLCB0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMucG9zICs9IDQ7XG4gICAgfSxcblxuICAgIHdyaXRlRml4ZWQ2NDogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHRoaXMucmVhbGxvYyg4KTtcbiAgICAgICAgdGhpcy5idWYud3JpdGVJbnQzMkxFKHZhbCAmIC0xLCB0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMuYnVmLndyaXRlVUludDMyTEUoTWF0aC5mbG9vcih2YWwgKiBTSElGVF9SSUdIVF8zMiksIHRoaXMucG9zICsgNCk7XG4gICAgICAgIHRoaXMucG9zICs9IDg7XG4gICAgfSxcblxuICAgIHdyaXRlU0ZpeGVkNjQ6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICB0aGlzLnJlYWxsb2MoOCk7XG4gICAgICAgIHRoaXMuYnVmLndyaXRlSW50MzJMRSh2YWwgJiAtMSwgdGhpcy5wb3MpO1xuICAgICAgICB0aGlzLmJ1Zi53cml0ZUludDMyTEUoTWF0aC5mbG9vcih2YWwgKiBTSElGVF9SSUdIVF8zMiksIHRoaXMucG9zICsgNCk7XG4gICAgICAgIHRoaXMucG9zICs9IDg7XG4gICAgfSxcblxuICAgIHdyaXRlVmFyaW50OiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdmFsID0gK3ZhbDtcblxuICAgICAgICBpZiAodmFsIDw9IDB4N2YpIHtcbiAgICAgICAgICAgIHRoaXMucmVhbGxvYygxKTtcbiAgICAgICAgICAgIHRoaXMuYnVmW3RoaXMucG9zKytdID0gdmFsO1xuXG4gICAgICAgIH0gZWxzZSBpZiAodmFsIDw9IDB4M2ZmZikge1xuICAgICAgICAgICAgdGhpcy5yZWFsbG9jKDIpO1xuICAgICAgICAgICAgdGhpcy5idWZbdGhpcy5wb3MrK10gPSAoKHZhbCA+Pj4gMCkgJiAweDdmKSB8IDB4ODA7XG4gICAgICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9ICgodmFsID4+PiA3KSAmIDB4N2YpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAodmFsIDw9IDB4MWZmZmZmKSB7XG4gICAgICAgICAgICB0aGlzLnJlYWxsb2MoMyk7XG4gICAgICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9ICgodmFsID4+PiAwKSAmIDB4N2YpIHwgMHg4MDtcbiAgICAgICAgICAgIHRoaXMuYnVmW3RoaXMucG9zKytdID0gKCh2YWwgPj4+IDcpICYgMHg3ZikgfCAweDgwO1xuICAgICAgICAgICAgdGhpcy5idWZbdGhpcy5wb3MrK10gPSAoKHZhbCA+Pj4gMTQpICYgMHg3Zik7XG5cbiAgICAgICAgfSBlbHNlIGlmICh2YWwgPD0gMHhmZmZmZmZmKSB7XG4gICAgICAgICAgICB0aGlzLnJlYWxsb2MoNCk7XG4gICAgICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9ICgodmFsID4+PiAwKSAmIDB4N2YpIHwgMHg4MDtcbiAgICAgICAgICAgIHRoaXMuYnVmW3RoaXMucG9zKytdID0gKCh2YWwgPj4+IDcpICYgMHg3ZikgfCAweDgwO1xuICAgICAgICAgICAgdGhpcy5idWZbdGhpcy5wb3MrK10gPSAoKHZhbCA+Pj4gMTQpICYgMHg3ZikgfCAweDgwO1xuICAgICAgICAgICAgdGhpcy5idWZbdGhpcy5wb3MrK10gPSAoKHZhbCA+Pj4gMjEpICYgMHg3Zik7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwb3MgPSB0aGlzLnBvcztcbiAgICAgICAgICAgIHdoaWxlICh2YWwgPj0gMHg4MCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVhbGxvYygxKTtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9ICh2YWwgJiAweGZmKSB8IDB4ODA7XG4gICAgICAgICAgICAgICAgdmFsIC89IDB4ODA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlYWxsb2MoMSk7XG4gICAgICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9IHZhbCB8IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgLSBwb3MgPiAxMCkgdGhyb3cgbmV3IEVycm9yKCdHaXZlbiB2YXJpbnQgZG9lc25cXCd0IGZpdCBpbnRvIDEwIGJ5dGVzJyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgd3JpdGVTVmFyaW50OiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdGhpcy53cml0ZVZhcmludCh2YWwgPCAwID8gLXZhbCAqIDIgLSAxIDogdmFsICogMik7XG4gICAgfSxcblxuICAgIHdyaXRlQm9vbGVhbjogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHRoaXMud3JpdGVWYXJpbnQoQm9vbGVhbih2YWwpKTtcbiAgICB9LFxuXG4gICAgd3JpdGVTdHJpbmc6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgICAgICAgdmFyIGJ5dGVzID0gQnVmZmVyLmJ5dGVMZW5ndGgoc3RyKTtcbiAgICAgICAgdGhpcy53cml0ZVZhcmludChieXRlcyk7XG4gICAgICAgIHRoaXMucmVhbGxvYyhieXRlcyk7XG4gICAgICAgIHRoaXMuYnVmLndyaXRlKHN0ciwgdGhpcy5wb3MpO1xuICAgICAgICB0aGlzLnBvcyArPSBieXRlcztcbiAgICB9LFxuXG4gICAgd3JpdGVGbG9hdDogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHRoaXMucmVhbGxvYyg0KTtcbiAgICAgICAgdGhpcy5idWYud3JpdGVGbG9hdExFKHZhbCwgdGhpcy5wb3MpO1xuICAgICAgICB0aGlzLnBvcyArPSA0O1xuICAgIH0sXG5cbiAgICB3cml0ZURvdWJsZTogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHRoaXMucmVhbGxvYyg4KTtcbiAgICAgICAgdGhpcy5idWYud3JpdGVEb3VibGVMRSh2YWwsIHRoaXMucG9zKTtcbiAgICAgICAgdGhpcy5wb3MgKz0gODtcbiAgICB9LFxuXG4gICAgd3JpdGVCeXRlczogZnVuY3Rpb24oYnVmZmVyKSB7XG4gICAgICAgIHZhciBsZW4gPSBidWZmZXIubGVuZ3RoO1xuICAgICAgICB0aGlzLndyaXRlVmFyaW50KGxlbik7XG4gICAgICAgIHRoaXMucmVhbGxvYyhsZW4pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9IGJ1ZmZlcltpXTtcbiAgICB9LFxuXG4gICAgd3JpdGVSYXdNZXNzYWdlOiBmdW5jdGlvbihmbiwgb2JqKSB7XG4gICAgICAgIHRoaXMucG9zKys7IC8vIHJlc2VydmUgMSBieXRlIGZvciBzaG9ydCBtZXNzYWdlIGxlbmd0aFxuXG4gICAgICAgIC8vIHdyaXRlIHRoZSBtZXNzYWdlIGRpcmVjdGx5IHRvIHRoZSBidWZmZXIgYW5kIHNlZSBob3cgbXVjaCB3YXMgd3JpdHRlblxuICAgICAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnBvcztcbiAgICAgICAgZm4ob2JqLCB0aGlzKTtcbiAgICAgICAgdmFyIGxlbiA9IHRoaXMucG9zIC0gc3RhcnRQb3M7XG5cbiAgICAgICAgdmFyIHZhcmludExlbiA9XG4gICAgICAgICAgICBsZW4gPD0gMHg3ZiA/IDEgOlxuICAgICAgICAgICAgbGVuIDw9IDB4M2ZmZiA/IDIgOlxuICAgICAgICAgICAgbGVuIDw9IDB4MWZmZmZmID8gMyA6XG4gICAgICAgICAgICBsZW4gPD0gMHhmZmZmZmZmID8gNCA6IE1hdGguY2VpbChNYXRoLmxvZyhsZW4pIC8gKE1hdGguTE4yICogNykpO1xuXG4gICAgICAgIC8vIGlmIDEgYnl0ZSBpc24ndCBlbm91Z2ggZm9yIGVuY29kaW5nIG1lc3NhZ2UgbGVuZ3RoLCBzaGlmdCB0aGUgZGF0YSB0byB0aGUgcmlnaHRcbiAgICAgICAgaWYgKHZhcmludExlbiA+IDEpIHtcbiAgICAgICAgICAgIHRoaXMucmVhbGxvYyh2YXJpbnRMZW4gLSAxKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLnBvcyAtIDE7IGkgPj0gc3RhcnRQb3M7IGktLSkgdGhpcy5idWZbaSArIHZhcmludExlbiAtIDFdID0gdGhpcy5idWZbaV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmaW5hbGx5LCB3cml0ZSB0aGUgbWVzc2FnZSBsZW5ndGggaW4gdGhlIHJlc2VydmVkIHBsYWNlIGFuZCByZXN0b3JlIHRoZSBwb3NpdGlvblxuICAgICAgICB0aGlzLnBvcyA9IHN0YXJ0UG9zIC0gMTtcbiAgICAgICAgdGhpcy53cml0ZVZhcmludChsZW4pO1xuICAgICAgICB0aGlzLnBvcyArPSBsZW47XG4gICAgfSxcblxuICAgIHdyaXRlTWVzc2FnZTogZnVuY3Rpb24odGFnLCBmbiwgb2JqKSB7XG4gICAgICAgIHRoaXMud3JpdGVUYWcodGFnLCBQYmYuQnl0ZXMpO1xuICAgICAgICB0aGlzLndyaXRlUmF3TWVzc2FnZShmbiwgb2JqKTtcbiAgICB9LFxuXG4gICAgd3JpdGVQYWNrZWRWYXJpbnQ6ICAgZnVuY3Rpb24odGFnLCBhcnIpIHsgdGhpcy53cml0ZU1lc3NhZ2UodGFnLCB3cml0ZVBhY2tlZFZhcmludCwgYXJyKTsgICB9LFxuICAgIHdyaXRlUGFja2VkU1ZhcmludDogIGZ1bmN0aW9uKHRhZywgYXJyKSB7IHRoaXMud3JpdGVNZXNzYWdlKHRhZywgd3JpdGVQYWNrZWRTVmFyaW50LCBhcnIpOyAgfSxcbiAgICB3cml0ZVBhY2tlZEJvb2xlYW46ICBmdW5jdGlvbih0YWcsIGFycikgeyB0aGlzLndyaXRlTWVzc2FnZSh0YWcsIHdyaXRlUGFja2VkQm9vbGVhbiwgYXJyKTsgIH0sXG4gICAgd3JpdGVQYWNrZWRGbG9hdDogICAgZnVuY3Rpb24odGFnLCBhcnIpIHsgdGhpcy53cml0ZU1lc3NhZ2UodGFnLCB3cml0ZVBhY2tlZEZsb2F0LCBhcnIpOyAgICB9LFxuICAgIHdyaXRlUGFja2VkRG91YmxlOiAgIGZ1bmN0aW9uKHRhZywgYXJyKSB7IHRoaXMud3JpdGVNZXNzYWdlKHRhZywgd3JpdGVQYWNrZWREb3VibGUsIGFycik7ICAgfSxcbiAgICB3cml0ZVBhY2tlZEZpeGVkMzI6ICBmdW5jdGlvbih0YWcsIGFycikgeyB0aGlzLndyaXRlTWVzc2FnZSh0YWcsIHdyaXRlUGFja2VkRml4ZWQzMiwgYXJyKTsgIH0sXG4gICAgd3JpdGVQYWNrZWRTRml4ZWQzMjogZnVuY3Rpb24odGFnLCBhcnIpIHsgdGhpcy53cml0ZU1lc3NhZ2UodGFnLCB3cml0ZVBhY2tlZFNGaXhlZDMyLCBhcnIpOyB9LFxuICAgIHdyaXRlUGFja2VkRml4ZWQ2NDogIGZ1bmN0aW9uKHRhZywgYXJyKSB7IHRoaXMud3JpdGVNZXNzYWdlKHRhZywgd3JpdGVQYWNrZWRGaXhlZDY0LCBhcnIpOyAgfSxcbiAgICB3cml0ZVBhY2tlZFNGaXhlZDY0OiBmdW5jdGlvbih0YWcsIGFycikgeyB0aGlzLndyaXRlTWVzc2FnZSh0YWcsIHdyaXRlUGFja2VkU0ZpeGVkNjQsIGFycik7IH0sXG5cbiAgICB3cml0ZUJ5dGVzRmllbGQ6IGZ1bmN0aW9uKHRhZywgYnVmZmVyKSB7XG4gICAgICAgIHRoaXMud3JpdGVUYWcodGFnLCBQYmYuQnl0ZXMpO1xuICAgICAgICB0aGlzLndyaXRlQnl0ZXMoYnVmZmVyKTtcbiAgICB9LFxuICAgIHdyaXRlRml4ZWQzMkZpZWxkOiBmdW5jdGlvbih0YWcsIHZhbCkge1xuICAgICAgICB0aGlzLndyaXRlVGFnKHRhZywgUGJmLkZpeGVkMzIpO1xuICAgICAgICB0aGlzLndyaXRlRml4ZWQzMih2YWwpO1xuICAgIH0sXG4gICAgd3JpdGVTRml4ZWQzMkZpZWxkOiBmdW5jdGlvbih0YWcsIHZhbCkge1xuICAgICAgICB0aGlzLndyaXRlVGFnKHRhZywgUGJmLkZpeGVkMzIpO1xuICAgICAgICB0aGlzLndyaXRlU0ZpeGVkMzIodmFsKTtcbiAgICB9LFxuICAgIHdyaXRlRml4ZWQ2NEZpZWxkOiBmdW5jdGlvbih0YWcsIHZhbCkge1xuICAgICAgICB0aGlzLndyaXRlVGFnKHRhZywgUGJmLkZpeGVkNjQpO1xuICAgICAgICB0aGlzLndyaXRlRml4ZWQ2NCh2YWwpO1xuICAgIH0sXG4gICAgd3JpdGVTRml4ZWQ2NEZpZWxkOiBmdW5jdGlvbih0YWcsIHZhbCkge1xuICAgICAgICB0aGlzLndyaXRlVGFnKHRhZywgUGJmLkZpeGVkNjQpO1xuICAgICAgICB0aGlzLndyaXRlU0ZpeGVkNjQodmFsKTtcbiAgICB9LFxuICAgIHdyaXRlVmFyaW50RmllbGQ6IGZ1bmN0aW9uKHRhZywgdmFsKSB7XG4gICAgICAgIHRoaXMud3JpdGVUYWcodGFnLCBQYmYuVmFyaW50KTtcbiAgICAgICAgdGhpcy53cml0ZVZhcmludCh2YWwpO1xuICAgIH0sXG4gICAgd3JpdGVTVmFyaW50RmllbGQ6IGZ1bmN0aW9uKHRhZywgdmFsKSB7XG4gICAgICAgIHRoaXMud3JpdGVUYWcodGFnLCBQYmYuVmFyaW50KTtcbiAgICAgICAgdGhpcy53cml0ZVNWYXJpbnQodmFsKTtcbiAgICB9LFxuICAgIHdyaXRlU3RyaW5nRmllbGQ6IGZ1bmN0aW9uKHRhZywgc3RyKSB7XG4gICAgICAgIHRoaXMud3JpdGVUYWcodGFnLCBQYmYuQnl0ZXMpO1xuICAgICAgICB0aGlzLndyaXRlU3RyaW5nKHN0cik7XG4gICAgfSxcbiAgICB3cml0ZUZsb2F0RmllbGQ6IGZ1bmN0aW9uKHRhZywgdmFsKSB7XG4gICAgICAgIHRoaXMud3JpdGVUYWcodGFnLCBQYmYuRml4ZWQzMik7XG4gICAgICAgIHRoaXMud3JpdGVGbG9hdCh2YWwpO1xuICAgIH0sXG4gICAgd3JpdGVEb3VibGVGaWVsZDogZnVuY3Rpb24odGFnLCB2YWwpIHtcbiAgICAgICAgdGhpcy53cml0ZVRhZyh0YWcsIFBiZi5GaXhlZDY0KTtcbiAgICAgICAgdGhpcy53cml0ZURvdWJsZSh2YWwpO1xuICAgIH0sXG4gICAgd3JpdGVCb29sZWFuRmllbGQ6IGZ1bmN0aW9uKHRhZywgdmFsKSB7XG4gICAgICAgIHRoaXMud3JpdGVWYXJpbnRGaWVsZCh0YWcsIEJvb2xlYW4odmFsKSk7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gd3JpdGVQYWNrZWRWYXJpbnQoYXJyLCBwYmYpICAgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlVmFyaW50KGFycltpXSk7ICAgfVxuZnVuY3Rpb24gd3JpdGVQYWNrZWRTVmFyaW50KGFyciwgcGJmKSAgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlU1ZhcmludChhcnJbaV0pOyAgfVxuZnVuY3Rpb24gd3JpdGVQYWNrZWRGbG9hdChhcnIsIHBiZikgICAgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlRmxvYXQoYXJyW2ldKTsgICAgfVxuZnVuY3Rpb24gd3JpdGVQYWNrZWREb3VibGUoYXJyLCBwYmYpICAgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlRG91YmxlKGFycltpXSk7ICAgfVxuZnVuY3Rpb24gd3JpdGVQYWNrZWRCb29sZWFuKGFyciwgcGJmKSAgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlQm9vbGVhbihhcnJbaV0pOyAgfVxuZnVuY3Rpb24gd3JpdGVQYWNrZWRGaXhlZDMyKGFyciwgcGJmKSAgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlRml4ZWQzMihhcnJbaV0pOyAgfVxuZnVuY3Rpb24gd3JpdGVQYWNrZWRTRml4ZWQzMihhcnIsIHBiZikgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlU0ZpeGVkMzIoYXJyW2ldKTsgfVxuZnVuY3Rpb24gd3JpdGVQYWNrZWRGaXhlZDY0KGFyciwgcGJmKSAgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlRml4ZWQ2NChhcnJbaV0pOyAgfVxuZnVuY3Rpb24gd3JpdGVQYWNrZWRTRml4ZWQ2NChhcnIsIHBiZikgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlU0ZpeGVkNjQoYXJyW2ldKTsgfVxuIiwiZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUG9pbnQ7XG5cbmZ1bmN0aW9uIFBvaW50KHgsIHkpIHtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG59XG5cblBvaW50LnByb3RvdHlwZSA9IHtcbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7IHJldHVybiBuZXcgUG9pbnQodGhpcy54LCB0aGlzLnkpOyB9LFxuXG4gICAgYWRkOiAgICAgZnVuY3Rpb24ocCkgeyByZXR1cm4gdGhpcy5jbG9uZSgpLl9hZGQocCk7ICAgICB9LFxuICAgIHN1YjogICAgIGZ1bmN0aW9uKHApIHsgcmV0dXJuIHRoaXMuY2xvbmUoKS5fc3ViKHApOyAgICAgfSxcbiAgICBtdWx0OiAgICBmdW5jdGlvbihrKSB7IHJldHVybiB0aGlzLmNsb25lKCkuX211bHQoayk7ICAgIH0sXG4gICAgZGl2OiAgICAgZnVuY3Rpb24oaykgeyByZXR1cm4gdGhpcy5jbG9uZSgpLl9kaXYoayk7ICAgICB9LFxuICAgIHJvdGF0ZTogIGZ1bmN0aW9uKGEpIHsgcmV0dXJuIHRoaXMuY2xvbmUoKS5fcm90YXRlKGEpOyAgfSxcbiAgICBtYXRNdWx0OiBmdW5jdGlvbihtKSB7IHJldHVybiB0aGlzLmNsb25lKCkuX21hdE11bHQobSk7IH0sXG4gICAgdW5pdDogICAgZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmNsb25lKCkuX3VuaXQoKTsgfSxcbiAgICBwZXJwOiAgICBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuY2xvbmUoKS5fcGVycCgpOyB9LFxuICAgIHJvdW5kOiAgIGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5jbG9uZSgpLl9yb3VuZCgpOyB9LFxuXG4gICAgbWFnOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkpO1xuICAgIH0sXG5cbiAgICBlcXVhbHM6IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueCA9PT0gcC54ICYmXG4gICAgICAgICAgICAgICB0aGlzLnkgPT09IHAueTtcbiAgICB9LFxuXG4gICAgZGlzdDogZnVuY3Rpb24ocCkge1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMuZGlzdFNxcihwKSk7XG4gICAgfSxcblxuICAgIGRpc3RTcXI6IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgdmFyIGR4ID0gcC54IC0gdGhpcy54LFxuICAgICAgICAgICAgZHkgPSBwLnkgLSB0aGlzLnk7XG4gICAgICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICB9LFxuXG4gICAgYW5nbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5hdGFuMih0aGlzLnksIHRoaXMueCk7XG4gICAgfSxcblxuICAgIGFuZ2xlVG86IGZ1bmN0aW9uKGIpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguYXRhbjIodGhpcy55IC0gYi55LCB0aGlzLnggLSBiLngpO1xuICAgIH0sXG5cbiAgICBhbmdsZVdpdGg6IGZ1bmN0aW9uKGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYW5nbGVXaXRoU2VwKGIueCwgYi55KTtcbiAgICB9LFxuXG4gICAgLy8gRmluZCB0aGUgYW5nbGUgb2YgdGhlIHR3byB2ZWN0b3JzLCBzb2x2aW5nIHRoZSBmb3JtdWxhIGZvciB0aGUgY3Jvc3MgcHJvZHVjdCBhIHggYiA9IHxhfHxifHNpbijOuCkgZm9yIM64LlxuICAgIGFuZ2xlV2l0aFNlcDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICByZXR1cm4gTWF0aC5hdGFuMihcbiAgICAgICAgICAgIHRoaXMueCAqIHkgLSB0aGlzLnkgKiB4LFxuICAgICAgICAgICAgdGhpcy54ICogeCArIHRoaXMueSAqIHkpO1xuICAgIH0sXG5cbiAgICBfbWF0TXVsdDogZnVuY3Rpb24obSkge1xuICAgICAgICB2YXIgeCA9IG1bMF0gKiB0aGlzLnggKyBtWzFdICogdGhpcy55LFxuICAgICAgICAgICAgeSA9IG1bMl0gKiB0aGlzLnggKyBtWzNdICogdGhpcy55O1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX2FkZDogZnVuY3Rpb24ocCkge1xuICAgICAgICB0aGlzLnggKz0gcC54O1xuICAgICAgICB0aGlzLnkgKz0gcC55O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX3N1YjogZnVuY3Rpb24ocCkge1xuICAgICAgICB0aGlzLnggLT0gcC54O1xuICAgICAgICB0aGlzLnkgLT0gcC55O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX211bHQ6IGZ1bmN0aW9uKGspIHtcbiAgICAgICAgdGhpcy54ICo9IGs7XG4gICAgICAgIHRoaXMueSAqPSBrO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX2RpdjogZnVuY3Rpb24oaykge1xuICAgICAgICB0aGlzLnggLz0gaztcbiAgICAgICAgdGhpcy55IC89IGs7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfdW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX2Rpdih0aGlzLm1hZygpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF9wZXJwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHkgPSB0aGlzLnk7XG4gICAgICAgIHRoaXMueSA9IHRoaXMueDtcbiAgICAgICAgdGhpcy54ID0gLXk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfcm90YXRlOiBmdW5jdGlvbihhbmdsZSkge1xuICAgICAgICB2YXIgY29zID0gTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICAgICAgc2luID0gTWF0aC5zaW4oYW5nbGUpLFxuICAgICAgICAgICAgeCA9IGNvcyAqIHRoaXMueCAtIHNpbiAqIHRoaXMueSxcbiAgICAgICAgICAgIHkgPSBzaW4gKiB0aGlzLnggKyBjb3MgKiB0aGlzLnk7XG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfcm91bmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnggPSBNYXRoLnJvdW5kKHRoaXMueCk7XG4gICAgICAgIHRoaXMueSA9IE1hdGgucm91bmQodGhpcy55KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufTtcblxuLy8gY29uc3RydWN0cyBQb2ludCBmcm9tIGFuIGFycmF5IGlmIG5lY2Vzc2FyeVxuUG9pbnQuY29udmVydCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgaWYgKGEgaW5zdGFuY2VvZiBQb2ludCkge1xuICAgICAgICByZXR1cm4gYTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludChhWzBdLCBhWzFdKTtcbiAgICB9XG4gICAgcmV0dXJuIGE7XG59O1xuIiwiLypcbiAoYykgMjAxNSwgVmxhZGltaXIgQWdhZm9ua2luXG4gUkJ1c2gsIGEgSmF2YVNjcmlwdCBsaWJyYXJ5IGZvciBoaWdoLXBlcmZvcm1hbmNlIDJEIHNwYXRpYWwgaW5kZXhpbmcgb2YgcG9pbnRzIGFuZCByZWN0YW5nbGVzLlxuIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3VybmVyL3JidXNoXG4qL1xuXG4oZnVuY3Rpb24gKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiByYnVzaChtYXhFbnRyaWVzLCBmb3JtYXQpIHtcblxuICAgIC8vIGpzaGludCBuZXdjYXA6IGZhbHNlLCB2YWxpZHRoaXM6IHRydWVcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgcmJ1c2gpKSByZXR1cm4gbmV3IHJidXNoKG1heEVudHJpZXMsIGZvcm1hdCk7XG5cbiAgICAvLyBtYXggZW50cmllcyBpbiBhIG5vZGUgaXMgOSBieSBkZWZhdWx0OyBtaW4gbm9kZSBmaWxsIGlzIDQwJSBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoaXMuX21heEVudHJpZXMgPSBNYXRoLm1heCg0LCBtYXhFbnRyaWVzIHx8IDkpO1xuICAgIHRoaXMuX21pbkVudHJpZXMgPSBNYXRoLm1heCgyLCBNYXRoLmNlaWwodGhpcy5fbWF4RW50cmllcyAqIDAuNCkpO1xuXG4gICAgaWYgKGZvcm1hdCkge1xuICAgICAgICB0aGlzLl9pbml0Rm9ybWF0KGZvcm1hdCk7XG4gICAgfVxuXG4gICAgdGhpcy5jbGVhcigpO1xufVxuXG5yYnVzaC5wcm90b3R5cGUgPSB7XG5cbiAgICBhbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FsbCh0aGlzLmRhdGEsIFtdKTtcbiAgICB9LFxuXG4gICAgc2VhcmNoOiBmdW5jdGlvbiAoYmJveCkge1xuXG4gICAgICAgIHZhciBub2RlID0gdGhpcy5kYXRhLFxuICAgICAgICAgICAgcmVzdWx0ID0gW10sXG4gICAgICAgICAgICB0b0JCb3ggPSB0aGlzLnRvQkJveDtcblxuICAgICAgICBpZiAoIWludGVyc2VjdHMoYmJveCwgbm9kZS5iYm94KSkgcmV0dXJuIHJlc3VsdDtcblxuICAgICAgICB2YXIgbm9kZXNUb1NlYXJjaCA9IFtdLFxuICAgICAgICAgICAgaSwgbGVuLCBjaGlsZCwgY2hpbGRCQm94O1xuXG4gICAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cbiAgICAgICAgICAgICAgICBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgY2hpbGRCQm94ID0gbm9kZS5sZWFmID8gdG9CQm94KGNoaWxkKSA6IGNoaWxkLmJib3g7XG5cbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJzZWN0cyhiYm94LCBjaGlsZEJCb3gpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmxlYWYpIHJlc3VsdC5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY29udGFpbnMoYmJveCwgY2hpbGRCQm94KSkgdGhpcy5fYWxsKGNoaWxkLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIG5vZGVzVG9TZWFyY2gucHVzaChjaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZSA9IG5vZGVzVG9TZWFyY2gucG9wKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBjb2xsaWRlczogZnVuY3Rpb24gKGJib3gpIHtcblxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuZGF0YSxcbiAgICAgICAgICAgIHRvQkJveCA9IHRoaXMudG9CQm94O1xuXG4gICAgICAgIGlmICghaW50ZXJzZWN0cyhiYm94LCBub2RlLmJib3gpKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgdmFyIG5vZGVzVG9TZWFyY2ggPSBbXSxcbiAgICAgICAgICAgIGksIGxlbiwgY2hpbGQsIGNoaWxkQkJveDtcblxuICAgICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXG4gICAgICAgICAgICAgICAgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGNoaWxkQkJveCA9IG5vZGUubGVhZiA/IHRvQkJveChjaGlsZCkgOiBjaGlsZC5iYm94O1xuXG4gICAgICAgICAgICAgICAgaWYgKGludGVyc2VjdHMoYmJveCwgY2hpbGRCQm94KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5sZWFmIHx8IGNvbnRhaW5zKGJib3gsIGNoaWxkQkJveCkpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBub2Rlc1RvU2VhcmNoLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUgPSBub2Rlc1RvU2VhcmNoLnBvcCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICBsb2FkOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBpZiAoIShkYXRhICYmIGRhdGEubGVuZ3RoKSkgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoIDwgdGhpcy5fbWluRW50cmllcykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRhdGEubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluc2VydChkYXRhW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVjdXJzaXZlbHkgYnVpbGQgdGhlIHRyZWUgd2l0aCB0aGUgZ2l2ZW4gZGF0YSBmcm9tIHN0cmF0Y2ggdXNpbmcgT01UIGFsZ29yaXRobVxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuX2J1aWxkKGRhdGEuc2xpY2UoKSwgMCwgZGF0YS5sZW5ndGggLSAxLCAwKTtcblxuICAgICAgICBpZiAoIXRoaXMuZGF0YS5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIHNhdmUgYXMgaXMgaWYgdHJlZSBpcyBlbXB0eVxuICAgICAgICAgICAgdGhpcy5kYXRhID0gbm9kZTtcblxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZGF0YS5oZWlnaHQgPT09IG5vZGUuaGVpZ2h0KSB7XG4gICAgICAgICAgICAvLyBzcGxpdCByb290IGlmIHRyZWVzIGhhdmUgdGhlIHNhbWUgaGVpZ2h0XG4gICAgICAgICAgICB0aGlzLl9zcGxpdFJvb3QodGhpcy5kYXRhLCBub2RlKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGF0YS5oZWlnaHQgPCBub2RlLmhlaWdodCkge1xuICAgICAgICAgICAgICAgIC8vIHN3YXAgdHJlZXMgaWYgaW5zZXJ0ZWQgb25lIGlzIGJpZ2dlclxuICAgICAgICAgICAgICAgIHZhciB0bXBOb2RlID0gdGhpcy5kYXRhO1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgbm9kZSA9IHRtcE5vZGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGluc2VydCB0aGUgc21hbGwgdHJlZSBpbnRvIHRoZSBsYXJnZSB0cmVlIGF0IGFwcHJvcHJpYXRlIGxldmVsXG4gICAgICAgICAgICB0aGlzLl9pbnNlcnQobm9kZSwgdGhpcy5kYXRhLmhlaWdodCAtIG5vZGUuaGVpZ2h0IC0gMSwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgaW5zZXJ0OiBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBpZiAoaXRlbSkgdGhpcy5faW5zZXJ0KGl0ZW0sIHRoaXMuZGF0YS5oZWlnaHQgLSAxKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICAgICAgICAgIGhlaWdodDogMSxcbiAgICAgICAgICAgIGJib3g6IGVtcHR5KCksXG4gICAgICAgICAgICBsZWFmOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICByZW1vdmU6IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIGlmICghaXRlbSkgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmRhdGEsXG4gICAgICAgICAgICBiYm94ID0gdGhpcy50b0JCb3goaXRlbSksXG4gICAgICAgICAgICBwYXRoID0gW10sXG4gICAgICAgICAgICBpbmRleGVzID0gW10sXG4gICAgICAgICAgICBpLCBwYXJlbnQsIGluZGV4LCBnb2luZ1VwO1xuXG4gICAgICAgIC8vIGRlcHRoLWZpcnN0IGl0ZXJhdGl2ZSB0cmVlIHRyYXZlcnNhbFxuICAgICAgICB3aGlsZSAobm9kZSB8fCBwYXRoLmxlbmd0aCkge1xuXG4gICAgICAgICAgICBpZiAoIW5vZGUpIHsgLy8gZ28gdXBcbiAgICAgICAgICAgICAgICBub2RlID0gcGF0aC5wb3AoKTtcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaSA9IGluZGV4ZXMucG9wKCk7XG4gICAgICAgICAgICAgICAgZ29pbmdVcCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChub2RlLmxlYWYpIHsgLy8gY2hlY2sgY3VycmVudCBub2RlXG4gICAgICAgICAgICAgICAgaW5kZXggPSBub2RlLmNoaWxkcmVuLmluZGV4T2YoaXRlbSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGl0ZW0gZm91bmQsIHJlbW92ZSB0aGUgaXRlbSBhbmQgY29uZGVuc2UgdHJlZSB1cHdhcmRzXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgcGF0aC5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb25kZW5zZShwYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWdvaW5nVXAgJiYgIW5vZGUubGVhZiAmJiBjb250YWlucyhub2RlLmJib3gsIGJib3gpKSB7IC8vIGdvIGRvd25cbiAgICAgICAgICAgICAgICBwYXRoLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgaW5kZXhlcy5wdXNoKGkpO1xuICAgICAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgICAgIHBhcmVudCA9IG5vZGU7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGRyZW5bMF07XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyZW50KSB7IC8vIGdvIHJpZ2h0XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJlbnQuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgZ29pbmdVcCA9IGZhbHNlO1xuXG4gICAgICAgICAgICB9IGVsc2Ugbm9kZSA9IG51bGw7IC8vIG5vdGhpbmcgZm91bmRcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICB0b0JCb3g6IGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBpdGVtOyB9LFxuXG4gICAgY29tcGFyZU1pblg6IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhWzBdIC0gYlswXTsgfSxcbiAgICBjb21wYXJlTWluWTogZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGFbMV0gLSBiWzFdOyB9LFxuXG4gICAgdG9KU09OOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmRhdGE7IH0sXG5cbiAgICBmcm9tSlNPTjogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF9hbGw6IGZ1bmN0aW9uIChub2RlLCByZXN1bHQpIHtcbiAgICAgICAgdmFyIG5vZGVzVG9TZWFyY2ggPSBbXTtcbiAgICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgICAgIGlmIChub2RlLmxlYWYpIHJlc3VsdC5wdXNoLmFwcGx5KHJlc3VsdCwgbm9kZS5jaGlsZHJlbik7XG4gICAgICAgICAgICBlbHNlIG5vZGVzVG9TZWFyY2gucHVzaC5hcHBseShub2Rlc1RvU2VhcmNoLCBub2RlLmNoaWxkcmVuKTtcblxuICAgICAgICAgICAgbm9kZSA9IG5vZGVzVG9TZWFyY2gucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgX2J1aWxkOiBmdW5jdGlvbiAoaXRlbXMsIGxlZnQsIHJpZ2h0LCBoZWlnaHQpIHtcblxuICAgICAgICB2YXIgTiA9IHJpZ2h0IC0gbGVmdCArIDEsXG4gICAgICAgICAgICBNID0gdGhpcy5fbWF4RW50cmllcyxcbiAgICAgICAgICAgIG5vZGU7XG5cbiAgICAgICAgaWYgKE4gPD0gTSkge1xuICAgICAgICAgICAgLy8gcmVhY2hlZCBsZWFmIGxldmVsOyByZXR1cm4gbGVhZlxuICAgICAgICAgICAgbm9kZSA9IHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogaXRlbXMuc2xpY2UobGVmdCwgcmlnaHQgKyAxKSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDEsXG4gICAgICAgICAgICAgICAgYmJveDogbnVsbCxcbiAgICAgICAgICAgICAgICBsZWFmOiB0cnVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FsY0JCb3gobm9kZSwgdGhpcy50b0JCb3gpO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWhlaWdodCkge1xuICAgICAgICAgICAgLy8gdGFyZ2V0IGhlaWdodCBvZiB0aGUgYnVsay1sb2FkZWQgdHJlZVxuICAgICAgICAgICAgaGVpZ2h0ID0gTWF0aC5jZWlsKE1hdGgubG9nKE4pIC8gTWF0aC5sb2coTSkpO1xuXG4gICAgICAgICAgICAvLyB0YXJnZXQgbnVtYmVyIG9mIHJvb3QgZW50cmllcyB0byBtYXhpbWl6ZSBzdG9yYWdlIHV0aWxpemF0aW9uXG4gICAgICAgICAgICBNID0gTWF0aC5jZWlsKE4gLyBNYXRoLnBvdyhNLCBoZWlnaHQgLSAxKSk7XG4gICAgICAgIH1cblxuICAgICAgICBub2RlID0ge1xuICAgICAgICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgICAgICBiYm94OiBudWxsLFxuICAgICAgICAgICAgbGVhZjogZmFsc2VcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBzcGxpdCB0aGUgaXRlbXMgaW50byBNIG1vc3RseSBzcXVhcmUgdGlsZXNcblxuICAgICAgICB2YXIgTjIgPSBNYXRoLmNlaWwoTiAvIE0pLFxuICAgICAgICAgICAgTjEgPSBOMiAqIE1hdGguY2VpbChNYXRoLnNxcnQoTSkpLFxuICAgICAgICAgICAgaSwgaiwgcmlnaHQyLCByaWdodDM7XG5cbiAgICAgICAgbXVsdGlTZWxlY3QoaXRlbXMsIGxlZnQsIHJpZ2h0LCBOMSwgdGhpcy5jb21wYXJlTWluWCk7XG5cbiAgICAgICAgZm9yIChpID0gbGVmdDsgaSA8PSByaWdodDsgaSArPSBOMSkge1xuXG4gICAgICAgICAgICByaWdodDIgPSBNYXRoLm1pbihpICsgTjEgLSAxLCByaWdodCk7XG5cbiAgICAgICAgICAgIG11bHRpU2VsZWN0KGl0ZW1zLCBpLCByaWdodDIsIE4yLCB0aGlzLmNvbXBhcmVNaW5ZKTtcblxuICAgICAgICAgICAgZm9yIChqID0gaTsgaiA8PSByaWdodDI7IGogKz0gTjIpIHtcblxuICAgICAgICAgICAgICAgIHJpZ2h0MyA9IE1hdGgubWluKGogKyBOMiAtIDEsIHJpZ2h0Mik7XG5cbiAgICAgICAgICAgICAgICAvLyBwYWNrIGVhY2ggZW50cnkgcmVjdXJzaXZlbHlcbiAgICAgICAgICAgICAgICBub2RlLmNoaWxkcmVuLnB1c2godGhpcy5fYnVpbGQoaXRlbXMsIGosIHJpZ2h0MywgaGVpZ2h0IC0gMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY2FsY0JCb3gobm9kZSwgdGhpcy50b0JCb3gpO1xuXG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH0sXG5cbiAgICBfY2hvb3NlU3VidHJlZTogZnVuY3Rpb24gKGJib3gsIG5vZGUsIGxldmVsLCBwYXRoKSB7XG5cbiAgICAgICAgdmFyIGksIGxlbiwgY2hpbGQsIHRhcmdldE5vZGUsIGFyZWEsIGVubGFyZ2VtZW50LCBtaW5BcmVhLCBtaW5FbmxhcmdlbWVudDtcblxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgcGF0aC5wdXNoKG5vZGUpO1xuXG4gICAgICAgICAgICBpZiAobm9kZS5sZWFmIHx8IHBhdGgubGVuZ3RoIC0gMSA9PT0gbGV2ZWwpIGJyZWFrO1xuXG4gICAgICAgICAgICBtaW5BcmVhID0gbWluRW5sYXJnZW1lbnQgPSBJbmZpbml0eTtcblxuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBhcmVhID0gYmJveEFyZWEoY2hpbGQuYmJveCk7XG4gICAgICAgICAgICAgICAgZW5sYXJnZW1lbnQgPSBlbmxhcmdlZEFyZWEoYmJveCwgY2hpbGQuYmJveCkgLSBhcmVhO1xuXG4gICAgICAgICAgICAgICAgLy8gY2hvb3NlIGVudHJ5IHdpdGggdGhlIGxlYXN0IGFyZWEgZW5sYXJnZW1lbnRcbiAgICAgICAgICAgICAgICBpZiAoZW5sYXJnZW1lbnQgPCBtaW5FbmxhcmdlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBtaW5FbmxhcmdlbWVudCA9IGVubGFyZ2VtZW50O1xuICAgICAgICAgICAgICAgICAgICBtaW5BcmVhID0gYXJlYSA8IG1pbkFyZWEgPyBhcmVhIDogbWluQXJlYTtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Tm9kZSA9IGNoaWxkO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlbmxhcmdlbWVudCA9PT0gbWluRW5sYXJnZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGNob29zZSBvbmUgd2l0aCB0aGUgc21hbGxlc3QgYXJlYVxuICAgICAgICAgICAgICAgICAgICBpZiAoYXJlYSA8IG1pbkFyZWEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbkFyZWEgPSBhcmVhO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Tm9kZSA9IGNoaWxkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBub2RlID0gdGFyZ2V0Tm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH0sXG5cbiAgICBfaW5zZXJ0OiBmdW5jdGlvbiAoaXRlbSwgbGV2ZWwsIGlzTm9kZSkge1xuXG4gICAgICAgIHZhciB0b0JCb3ggPSB0aGlzLnRvQkJveCxcbiAgICAgICAgICAgIGJib3ggPSBpc05vZGUgPyBpdGVtLmJib3ggOiB0b0JCb3goaXRlbSksXG4gICAgICAgICAgICBpbnNlcnRQYXRoID0gW107XG5cbiAgICAgICAgLy8gZmluZCB0aGUgYmVzdCBub2RlIGZvciBhY2NvbW1vZGF0aW5nIHRoZSBpdGVtLCBzYXZpbmcgYWxsIG5vZGVzIGFsb25nIHRoZSBwYXRoIHRvb1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuX2Nob29zZVN1YnRyZWUoYmJveCwgdGhpcy5kYXRhLCBsZXZlbCwgaW5zZXJ0UGF0aCk7XG5cbiAgICAgICAgLy8gcHV0IHRoZSBpdGVtIGludG8gdGhlIG5vZGVcbiAgICAgICAgbm9kZS5jaGlsZHJlbi5wdXNoKGl0ZW0pO1xuICAgICAgICBleHRlbmQobm9kZS5iYm94LCBiYm94KTtcblxuICAgICAgICAvLyBzcGxpdCBvbiBub2RlIG92ZXJmbG93OyBwcm9wYWdhdGUgdXB3YXJkcyBpZiBuZWNlc3NhcnlcbiAgICAgICAgd2hpbGUgKGxldmVsID49IDApIHtcbiAgICAgICAgICAgIGlmIChpbnNlcnRQYXRoW2xldmVsXS5jaGlsZHJlbi5sZW5ndGggPiB0aGlzLl9tYXhFbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3BsaXQoaW5zZXJ0UGF0aCwgbGV2ZWwpO1xuICAgICAgICAgICAgICAgIGxldmVsLS07XG4gICAgICAgICAgICB9IGVsc2UgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGp1c3QgYmJveGVzIGFsb25nIHRoZSBpbnNlcnRpb24gcGF0aFxuICAgICAgICB0aGlzLl9hZGp1c3RQYXJlbnRCQm94ZXMoYmJveCwgaW5zZXJ0UGF0aCwgbGV2ZWwpO1xuICAgIH0sXG5cbiAgICAvLyBzcGxpdCBvdmVyZmxvd2VkIG5vZGUgaW50byB0d29cbiAgICBfc3BsaXQ6IGZ1bmN0aW9uIChpbnNlcnRQYXRoLCBsZXZlbCkge1xuXG4gICAgICAgIHZhciBub2RlID0gaW5zZXJ0UGF0aFtsZXZlbF0sXG4gICAgICAgICAgICBNID0gbm9kZS5jaGlsZHJlbi5sZW5ndGgsXG4gICAgICAgICAgICBtID0gdGhpcy5fbWluRW50cmllcztcblxuICAgICAgICB0aGlzLl9jaG9vc2VTcGxpdEF4aXMobm9kZSwgbSwgTSk7XG5cbiAgICAgICAgdmFyIHNwbGl0SW5kZXggPSB0aGlzLl9jaG9vc2VTcGxpdEluZGV4KG5vZGUsIG0sIE0pO1xuXG4gICAgICAgIHZhciBuZXdOb2RlID0ge1xuICAgICAgICAgICAgY2hpbGRyZW46IG5vZGUuY2hpbGRyZW4uc3BsaWNlKHNwbGl0SW5kZXgsIG5vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gc3BsaXRJbmRleCksXG4gICAgICAgICAgICBoZWlnaHQ6IG5vZGUuaGVpZ2h0LFxuICAgICAgICAgICAgYmJveDogbnVsbCxcbiAgICAgICAgICAgIGxlYWY6IGZhbHNlXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKG5vZGUubGVhZikgbmV3Tm9kZS5sZWFmID0gdHJ1ZTtcblxuICAgICAgICBjYWxjQkJveChub2RlLCB0aGlzLnRvQkJveCk7XG4gICAgICAgIGNhbGNCQm94KG5ld05vZGUsIHRoaXMudG9CQm94KTtcblxuICAgICAgICBpZiAobGV2ZWwpIGluc2VydFBhdGhbbGV2ZWwgLSAxXS5jaGlsZHJlbi5wdXNoKG5ld05vZGUpO1xuICAgICAgICBlbHNlIHRoaXMuX3NwbGl0Um9vdChub2RlLCBuZXdOb2RlKTtcbiAgICB9LFxuXG4gICAgX3NwbGl0Um9vdDogZnVuY3Rpb24gKG5vZGUsIG5ld05vZGUpIHtcbiAgICAgICAgLy8gc3BsaXQgcm9vdCBub2RlXG4gICAgICAgIHRoaXMuZGF0YSA9IHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbbm9kZSwgbmV3Tm9kZV0sXG4gICAgICAgICAgICBoZWlnaHQ6IG5vZGUuaGVpZ2h0ICsgMSxcbiAgICAgICAgICAgIGJib3g6IG51bGwsXG4gICAgICAgICAgICBsZWFmOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICBjYWxjQkJveCh0aGlzLmRhdGEsIHRoaXMudG9CQm94KTtcbiAgICB9LFxuXG4gICAgX2Nob29zZVNwbGl0SW5kZXg6IGZ1bmN0aW9uIChub2RlLCBtLCBNKSB7XG5cbiAgICAgICAgdmFyIGksIGJib3gxLCBiYm94Miwgb3ZlcmxhcCwgYXJlYSwgbWluT3ZlcmxhcCwgbWluQXJlYSwgaW5kZXg7XG5cbiAgICAgICAgbWluT3ZlcmxhcCA9IG1pbkFyZWEgPSBJbmZpbml0eTtcblxuICAgICAgICBmb3IgKGkgPSBtOyBpIDw9IE0gLSBtOyBpKyspIHtcbiAgICAgICAgICAgIGJib3gxID0gZGlzdEJCb3gobm9kZSwgMCwgaSwgdGhpcy50b0JCb3gpO1xuICAgICAgICAgICAgYmJveDIgPSBkaXN0QkJveChub2RlLCBpLCBNLCB0aGlzLnRvQkJveCk7XG5cbiAgICAgICAgICAgIG92ZXJsYXAgPSBpbnRlcnNlY3Rpb25BcmVhKGJib3gxLCBiYm94Mik7XG4gICAgICAgICAgICBhcmVhID0gYmJveEFyZWEoYmJveDEpICsgYmJveEFyZWEoYmJveDIpO1xuXG4gICAgICAgICAgICAvLyBjaG9vc2UgZGlzdHJpYnV0aW9uIHdpdGggbWluaW11bSBvdmVybGFwXG4gICAgICAgICAgICBpZiAob3ZlcmxhcCA8IG1pbk92ZXJsYXApIHtcbiAgICAgICAgICAgICAgICBtaW5PdmVybGFwID0gb3ZlcmxhcDtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGk7XG5cbiAgICAgICAgICAgICAgICBtaW5BcmVhID0gYXJlYSA8IG1pbkFyZWEgPyBhcmVhIDogbWluQXJlYTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmIChvdmVybGFwID09PSBtaW5PdmVybGFwKSB7XG4gICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGNob29zZSBkaXN0cmlidXRpb24gd2l0aCBtaW5pbXVtIGFyZWFcbiAgICAgICAgICAgICAgICBpZiAoYXJlYSA8IG1pbkFyZWEpIHtcbiAgICAgICAgICAgICAgICAgICAgbWluQXJlYSA9IGFyZWE7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfSxcblxuICAgIC8vIHNvcnRzIG5vZGUgY2hpbGRyZW4gYnkgdGhlIGJlc3QgYXhpcyBmb3Igc3BsaXRcbiAgICBfY2hvb3NlU3BsaXRBeGlzOiBmdW5jdGlvbiAobm9kZSwgbSwgTSkge1xuXG4gICAgICAgIHZhciBjb21wYXJlTWluWCA9IG5vZGUubGVhZiA/IHRoaXMuY29tcGFyZU1pblggOiBjb21wYXJlTm9kZU1pblgsXG4gICAgICAgICAgICBjb21wYXJlTWluWSA9IG5vZGUubGVhZiA/IHRoaXMuY29tcGFyZU1pblkgOiBjb21wYXJlTm9kZU1pblksXG4gICAgICAgICAgICB4TWFyZ2luID0gdGhpcy5fYWxsRGlzdE1hcmdpbihub2RlLCBtLCBNLCBjb21wYXJlTWluWCksXG4gICAgICAgICAgICB5TWFyZ2luID0gdGhpcy5fYWxsRGlzdE1hcmdpbihub2RlLCBtLCBNLCBjb21wYXJlTWluWSk7XG5cbiAgICAgICAgLy8gaWYgdG90YWwgZGlzdHJpYnV0aW9ucyBtYXJnaW4gdmFsdWUgaXMgbWluaW1hbCBmb3IgeCwgc29ydCBieSBtaW5YLFxuICAgICAgICAvLyBvdGhlcndpc2UgaXQncyBhbHJlYWR5IHNvcnRlZCBieSBtaW5ZXG4gICAgICAgIGlmICh4TWFyZ2luIDwgeU1hcmdpbikgbm9kZS5jaGlsZHJlbi5zb3J0KGNvbXBhcmVNaW5YKTtcbiAgICB9LFxuXG4gICAgLy8gdG90YWwgbWFyZ2luIG9mIGFsbCBwb3NzaWJsZSBzcGxpdCBkaXN0cmlidXRpb25zIHdoZXJlIGVhY2ggbm9kZSBpcyBhdCBsZWFzdCBtIGZ1bGxcbiAgICBfYWxsRGlzdE1hcmdpbjogZnVuY3Rpb24gKG5vZGUsIG0sIE0sIGNvbXBhcmUpIHtcblxuICAgICAgICBub2RlLmNoaWxkcmVuLnNvcnQoY29tcGFyZSk7XG5cbiAgICAgICAgdmFyIHRvQkJveCA9IHRoaXMudG9CQm94LFxuICAgICAgICAgICAgbGVmdEJCb3ggPSBkaXN0QkJveChub2RlLCAwLCBtLCB0b0JCb3gpLFxuICAgICAgICAgICAgcmlnaHRCQm94ID0gZGlzdEJCb3gobm9kZSwgTSAtIG0sIE0sIHRvQkJveCksXG4gICAgICAgICAgICBtYXJnaW4gPSBiYm94TWFyZ2luKGxlZnRCQm94KSArIGJib3hNYXJnaW4ocmlnaHRCQm94KSxcbiAgICAgICAgICAgIGksIGNoaWxkO1xuXG4gICAgICAgIGZvciAoaSA9IG07IGkgPCBNIC0gbTsgaSsrKSB7XG4gICAgICAgICAgICBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgICAgICBleHRlbmQobGVmdEJCb3gsIG5vZGUubGVhZiA/IHRvQkJveChjaGlsZCkgOiBjaGlsZC5iYm94KTtcbiAgICAgICAgICAgIG1hcmdpbiArPSBiYm94TWFyZ2luKGxlZnRCQm94KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IE0gLSBtIC0gMTsgaSA+PSBtOyBpLS0pIHtcbiAgICAgICAgICAgIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGV4dGVuZChyaWdodEJCb3gsIG5vZGUubGVhZiA/IHRvQkJveChjaGlsZCkgOiBjaGlsZC5iYm94KTtcbiAgICAgICAgICAgIG1hcmdpbiArPSBiYm94TWFyZ2luKHJpZ2h0QkJveCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWFyZ2luO1xuICAgIH0sXG5cbiAgICBfYWRqdXN0UGFyZW50QkJveGVzOiBmdW5jdGlvbiAoYmJveCwgcGF0aCwgbGV2ZWwpIHtcbiAgICAgICAgLy8gYWRqdXN0IGJib3hlcyBhbG9uZyB0aGUgZ2l2ZW4gdHJlZSBwYXRoXG4gICAgICAgIGZvciAodmFyIGkgPSBsZXZlbDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGV4dGVuZChwYXRoW2ldLmJib3gsIGJib3gpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9jb25kZW5zZTogZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgLy8gZ28gdGhyb3VnaCB0aGUgcGF0aCwgcmVtb3ZpbmcgZW1wdHkgbm9kZXMgYW5kIHVwZGF0aW5nIGJib3hlc1xuICAgICAgICBmb3IgKHZhciBpID0gcGF0aC5sZW5ndGggLSAxLCBzaWJsaW5nczsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGlmIChwYXRoW2ldLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBzaWJsaW5ncyA9IHBhdGhbaSAtIDFdLmNoaWxkcmVuO1xuICAgICAgICAgICAgICAgICAgICBzaWJsaW5ncy5zcGxpY2Uoc2libGluZ3MuaW5kZXhPZihwYXRoW2ldKSwgMSk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgdGhpcy5jbGVhcigpO1xuXG4gICAgICAgICAgICB9IGVsc2UgY2FsY0JCb3gocGF0aFtpXSwgdGhpcy50b0JCb3gpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9pbml0Rm9ybWF0OiBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIC8vIGRhdGEgZm9ybWF0IChtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZIGFjY2Vzc29ycylcblxuICAgICAgICAvLyB1c2VzIGV2YWwtdHlwZSBmdW5jdGlvbiBjb21waWxhdGlvbiBpbnN0ZWFkIG9mIGp1c3QgYWNjZXB0aW5nIGEgdG9CQm94IGZ1bmN0aW9uXG4gICAgICAgIC8vIGJlY2F1c2UgdGhlIGFsZ29yaXRobXMgYXJlIHZlcnkgc2Vuc2l0aXZlIHRvIHNvcnRpbmcgZnVuY3Rpb25zIHBlcmZvcm1hbmNlLFxuICAgICAgICAvLyBzbyB0aGV5IHNob3VsZCBiZSBkZWFkIHNpbXBsZSBhbmQgd2l0aG91dCBpbm5lciBjYWxsc1xuXG4gICAgICAgIC8vIGpzaGludCBldmlsOiB0cnVlXG5cbiAgICAgICAgdmFyIGNvbXBhcmVBcnIgPSBbJ3JldHVybiBhJywgJyAtIGInLCAnOyddO1xuXG4gICAgICAgIHRoaXMuY29tcGFyZU1pblggPSBuZXcgRnVuY3Rpb24oJ2EnLCAnYicsIGNvbXBhcmVBcnIuam9pbihmb3JtYXRbMF0pKTtcbiAgICAgICAgdGhpcy5jb21wYXJlTWluWSA9IG5ldyBGdW5jdGlvbignYScsICdiJywgY29tcGFyZUFyci5qb2luKGZvcm1hdFsxXSkpO1xuXG4gICAgICAgIHRoaXMudG9CQm94ID0gbmV3IEZ1bmN0aW9uKCdhJywgJ3JldHVybiBbYScgKyBmb3JtYXQuam9pbignLCBhJykgKyAnXTsnKTtcbiAgICB9XG59O1xuXG5cbi8vIGNhbGN1bGF0ZSBub2RlJ3MgYmJveCBmcm9tIGJib3hlcyBvZiBpdHMgY2hpbGRyZW5cbmZ1bmN0aW9uIGNhbGNCQm94KG5vZGUsIHRvQkJveCkge1xuICAgIG5vZGUuYmJveCA9IGRpc3RCQm94KG5vZGUsIDAsIG5vZGUuY2hpbGRyZW4ubGVuZ3RoLCB0b0JCb3gpO1xufVxuXG4vLyBtaW4gYm91bmRpbmcgcmVjdGFuZ2xlIG9mIG5vZGUgY2hpbGRyZW4gZnJvbSBrIHRvIHAtMVxuZnVuY3Rpb24gZGlzdEJCb3gobm9kZSwgaywgcCwgdG9CQm94KSB7XG4gICAgdmFyIGJib3ggPSBlbXB0eSgpO1xuXG4gICAgZm9yICh2YXIgaSA9IGssIGNoaWxkOyBpIDwgcDsgaSsrKSB7XG4gICAgICAgIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgZXh0ZW5kKGJib3gsIG5vZGUubGVhZiA/IHRvQkJveChjaGlsZCkgOiBjaGlsZC5iYm94KTtcbiAgICB9XG5cbiAgICByZXR1cm4gYmJveDtcbn1cblxuZnVuY3Rpb24gZW1wdHkoKSB7IHJldHVybiBbSW5maW5pdHksIEluZmluaXR5LCAtSW5maW5pdHksIC1JbmZpbml0eV07IH1cblxuZnVuY3Rpb24gZXh0ZW5kKGEsIGIpIHtcbiAgICBhWzBdID0gTWF0aC5taW4oYVswXSwgYlswXSk7XG4gICAgYVsxXSA9IE1hdGgubWluKGFbMV0sIGJbMV0pO1xuICAgIGFbMl0gPSBNYXRoLm1heChhWzJdLCBiWzJdKTtcbiAgICBhWzNdID0gTWF0aC5tYXgoYVszXSwgYlszXSk7XG4gICAgcmV0dXJuIGE7XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVOb2RlTWluWChhLCBiKSB7IHJldHVybiBhLmJib3hbMF0gLSBiLmJib3hbMF07IH1cbmZ1bmN0aW9uIGNvbXBhcmVOb2RlTWluWShhLCBiKSB7IHJldHVybiBhLmJib3hbMV0gLSBiLmJib3hbMV07IH1cblxuZnVuY3Rpb24gYmJveEFyZWEoYSkgICB7IHJldHVybiAoYVsyXSAtIGFbMF0pICogKGFbM10gLSBhWzFdKTsgfVxuZnVuY3Rpb24gYmJveE1hcmdpbihhKSB7IHJldHVybiAoYVsyXSAtIGFbMF0pICsgKGFbM10gLSBhWzFdKTsgfVxuXG5mdW5jdGlvbiBlbmxhcmdlZEFyZWEoYSwgYikge1xuICAgIHJldHVybiAoTWF0aC5tYXgoYlsyXSwgYVsyXSkgLSBNYXRoLm1pbihiWzBdLCBhWzBdKSkgKlxuICAgICAgICAgICAoTWF0aC5tYXgoYlszXSwgYVszXSkgLSBNYXRoLm1pbihiWzFdLCBhWzFdKSk7XG59XG5cbmZ1bmN0aW9uIGludGVyc2VjdGlvbkFyZWEoYSwgYikge1xuICAgIHZhciBtaW5YID0gTWF0aC5tYXgoYVswXSwgYlswXSksXG4gICAgICAgIG1pblkgPSBNYXRoLm1heChhWzFdLCBiWzFdKSxcbiAgICAgICAgbWF4WCA9IE1hdGgubWluKGFbMl0sIGJbMl0pLFxuICAgICAgICBtYXhZID0gTWF0aC5taW4oYVszXSwgYlszXSk7XG5cbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgbWF4WCAtIG1pblgpICpcbiAgICAgICAgICAgTWF0aC5tYXgoMCwgbWF4WSAtIG1pblkpO1xufVxuXG5mdW5jdGlvbiBjb250YWlucyhhLCBiKSB7XG4gICAgcmV0dXJuIGFbMF0gPD0gYlswXSAmJlxuICAgICAgICAgICBhWzFdIDw9IGJbMV0gJiZcbiAgICAgICAgICAgYlsyXSA8PSBhWzJdICYmXG4gICAgICAgICAgIGJbM10gPD0gYVszXTtcbn1cblxuZnVuY3Rpb24gaW50ZXJzZWN0cyhhLCBiKSB7XG4gICAgcmV0dXJuIGJbMF0gPD0gYVsyXSAmJlxuICAgICAgICAgICBiWzFdIDw9IGFbM10gJiZcbiAgICAgICAgICAgYlsyXSA+PSBhWzBdICYmXG4gICAgICAgICAgIGJbM10gPj0gYVsxXTtcbn1cblxuLy8gc29ydCBhbiBhcnJheSBzbyB0aGF0IGl0ZW1zIGNvbWUgaW4gZ3JvdXBzIG9mIG4gdW5zb3J0ZWQgaXRlbXMsIHdpdGggZ3JvdXBzIHNvcnRlZCBiZXR3ZWVuIGVhY2ggb3RoZXI7XG4vLyBjb21iaW5lcyBzZWxlY3Rpb24gYWxnb3JpdGhtIHdpdGggYmluYXJ5IGRpdmlkZSAmIGNvbnF1ZXIgYXBwcm9hY2hcblxuZnVuY3Rpb24gbXVsdGlTZWxlY3QoYXJyLCBsZWZ0LCByaWdodCwgbiwgY29tcGFyZSkge1xuICAgIHZhciBzdGFjayA9IFtsZWZ0LCByaWdodF0sXG4gICAgICAgIG1pZDtcblxuICAgIHdoaWxlIChzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgcmlnaHQgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgbGVmdCA9IHN0YWNrLnBvcCgpO1xuXG4gICAgICAgIGlmIChyaWdodCAtIGxlZnQgPD0gbikgY29udGludWU7XG5cbiAgICAgICAgbWlkID0gbGVmdCArIE1hdGguY2VpbCgocmlnaHQgLSBsZWZ0KSAvIG4gLyAyKSAqIG47XG4gICAgICAgIHNlbGVjdChhcnIsIGxlZnQsIHJpZ2h0LCBtaWQsIGNvbXBhcmUpO1xuXG4gICAgICAgIHN0YWNrLnB1c2gobGVmdCwgbWlkLCBtaWQsIHJpZ2h0KTtcbiAgICB9XG59XG5cbi8vIEZsb3lkLVJpdmVzdCBzZWxlY3Rpb24gYWxnb3JpdGhtOlxuLy8gc29ydCBhbiBhcnJheSBiZXR3ZWVuIGxlZnQgYW5kIHJpZ2h0IChpbmNsdXNpdmUpIHNvIHRoYXQgdGhlIHNtYWxsZXN0IGsgZWxlbWVudHMgY29tZSBmaXJzdCAodW5vcmRlcmVkKVxuZnVuY3Rpb24gc2VsZWN0KGFyciwgbGVmdCwgcmlnaHQsIGssIGNvbXBhcmUpIHtcbiAgICB2YXIgbiwgaSwgeiwgcywgc2QsIG5ld0xlZnQsIG5ld1JpZ2h0LCB0LCBqO1xuXG4gICAgd2hpbGUgKHJpZ2h0ID4gbGVmdCkge1xuICAgICAgICBpZiAocmlnaHQgLSBsZWZ0ID4gNjAwKSB7XG4gICAgICAgICAgICBuID0gcmlnaHQgLSBsZWZ0ICsgMTtcbiAgICAgICAgICAgIGkgPSBrIC0gbGVmdCArIDE7XG4gICAgICAgICAgICB6ID0gTWF0aC5sb2cobik7XG4gICAgICAgICAgICBzID0gMC41ICogTWF0aC5leHAoMiAqIHogLyAzKTtcbiAgICAgICAgICAgIHNkID0gMC41ICogTWF0aC5zcXJ0KHogKiBzICogKG4gLSBzKSAvIG4pICogKGkgLSBuIC8gMiA8IDAgPyAtMSA6IDEpO1xuICAgICAgICAgICAgbmV3TGVmdCA9IE1hdGgubWF4KGxlZnQsIE1hdGguZmxvb3IoayAtIGkgKiBzIC8gbiArIHNkKSk7XG4gICAgICAgICAgICBuZXdSaWdodCA9IE1hdGgubWluKHJpZ2h0LCBNYXRoLmZsb29yKGsgKyAobiAtIGkpICogcyAvIG4gKyBzZCkpO1xuICAgICAgICAgICAgc2VsZWN0KGFyciwgbmV3TGVmdCwgbmV3UmlnaHQsIGssIGNvbXBhcmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdCA9IGFycltrXTtcbiAgICAgICAgaSA9IGxlZnQ7XG4gICAgICAgIGogPSByaWdodDtcblxuICAgICAgICBzd2FwKGFyciwgbGVmdCwgayk7XG4gICAgICAgIGlmIChjb21wYXJlKGFycltyaWdodF0sIHQpID4gMCkgc3dhcChhcnIsIGxlZnQsIHJpZ2h0KTtcblxuICAgICAgICB3aGlsZSAoaSA8IGopIHtcbiAgICAgICAgICAgIHN3YXAoYXJyLCBpLCBqKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGotLTtcbiAgICAgICAgICAgIHdoaWxlIChjb21wYXJlKGFycltpXSwgdCkgPCAwKSBpKys7XG4gICAgICAgICAgICB3aGlsZSAoY29tcGFyZShhcnJbal0sIHQpID4gMCkgai0tO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbXBhcmUoYXJyW2xlZnRdLCB0KSA9PT0gMCkgc3dhcChhcnIsIGxlZnQsIGopO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgIHN3YXAoYXJyLCBqLCByaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaiA8PSBrKSBsZWZ0ID0gaiArIDE7XG4gICAgICAgIGlmIChrIDw9IGopIHJpZ2h0ID0gaiAtIDE7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzd2FwKGFyciwgaSwgaikge1xuICAgIHZhciB0bXAgPSBhcnJbaV07XG4gICAgYXJyW2ldID0gYXJyW2pdO1xuICAgIGFycltqXSA9IHRtcDtcbn1cblxuXG4vLyBleHBvcnQgYXMgQU1EL0NvbW1vbkpTIG1vZHVsZSBvciBnbG9iYWwgdmFyaWFibGVcbmlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIGRlZmluZSgncmJ1c2gnLCBmdW5jdGlvbiAoKSB7IHJldHVybiByYnVzaDsgfSk7XG5lbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykgbW9kdWxlLmV4cG9ydHMgPSByYnVzaDtcbmVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykgc2VsZi5yYnVzaCA9IHJidXNoO1xuZWxzZSB3aW5kb3cucmJ1c2ggPSByYnVzaDtcblxufSkoKTtcbiIsIi8vIENvcHlyaWdodCAyMDE0IFNpbW9uIEx5ZGVsbFxyXG4vLyBYMTEgKOKAnE1JVOKAnSkgTGljZW5zZWQuIChTZWUgTElDRU5TRS4pXHJcblxyXG52b2lkIChmdW5jdGlvbihyb290LCBmYWN0b3J5KSB7XHJcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICBkZWZpbmUoZmFjdG9yeSlcclxuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKVxyXG4gIH0gZWxzZSB7XHJcbiAgICByb290LnJlc29sdmVVcmwgPSBmYWN0b3J5KClcclxuICB9XHJcbn0odGhpcywgZnVuY3Rpb24oKSB7XHJcblxyXG4gIGZ1bmN0aW9uIHJlc29sdmVVcmwoLyogLi4udXJscyAqLykge1xyXG4gICAgdmFyIG51bVVybHMgPSBhcmd1bWVudHMubGVuZ3RoXHJcblxyXG4gICAgaWYgKG51bVVybHMgPT09IDApIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwicmVzb2x2ZVVybCByZXF1aXJlcyBhdCBsZWFzdCBvbmUgYXJndW1lbnQ7IGdvdCBub25lLlwiKVxyXG4gICAgfVxyXG5cclxuICAgIHZhciBiYXNlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJhc2VcIilcclxuICAgIGJhc2UuaHJlZiA9IGFyZ3VtZW50c1swXVxyXG5cclxuICAgIGlmIChudW1VcmxzID09PSAxKSB7XHJcbiAgICAgIHJldHVybiBiYXNlLmhyZWZcclxuICAgIH1cclxuXHJcbiAgICB2YXIgaGVhZCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXVxyXG4gICAgaGVhZC5pbnNlcnRCZWZvcmUoYmFzZSwgaGVhZC5maXJzdENoaWxkKVxyXG5cclxuICAgIHZhciBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIilcclxuICAgIHZhciByZXNvbHZlZFxyXG5cclxuICAgIGZvciAodmFyIGluZGV4ID0gMTsgaW5kZXggPCBudW1VcmxzOyBpbmRleCsrKSB7XHJcbiAgICAgIGEuaHJlZiA9IGFyZ3VtZW50c1tpbmRleF1cclxuICAgICAgcmVzb2x2ZWQgPSBhLmhyZWZcclxuICAgICAgYmFzZS5ocmVmID0gcmVzb2x2ZWRcclxuICAgIH1cclxuXHJcbiAgICBoZWFkLnJlbW92ZUNoaWxkKGJhc2UpXHJcblxyXG4gICAgcmV0dXJuIHJlc29sdmVkXHJcbiAgfVxyXG5cclxuICByZXR1cm4gcmVzb2x2ZVVybFxyXG5cclxufSkpO1xyXG4iLCIvKlxuICogQ29weXJpZ2h0IChDKSAyMDA4IEFwcGxlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uc1xuICogYXJlIG1ldDpcbiAqIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKiAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICogICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIEFQUExFIElOQy4gYGBBUyBJUycnIEFORCBBTllcbiAqIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gKiBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVJcbiAqIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuICBJTiBOTyBFVkVOVCBTSEFMTCBBUFBMRSBJTkMuIE9SXG4gKiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCxcbiAqIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTyxcbiAqIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxuICogUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWVxuICogT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4gKiAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0VcbiAqIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKlxuICogUG9ydGVkIGZyb20gV2Via2l0XG4gKiBodHRwOi8vc3ZuLndlYmtpdC5vcmcvcmVwb3NpdG9yeS93ZWJraXQvdHJ1bmsvU291cmNlL1dlYkNvcmUvcGxhdGZvcm0vZ3JhcGhpY3MvVW5pdEJlemllci5oXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBVbml0QmV6aWVyO1xuXG5mdW5jdGlvbiBVbml0QmV6aWVyKHAxeCwgcDF5LCBwMngsIHAyeSkge1xuICAgIC8vIENhbGN1bGF0ZSB0aGUgcG9seW5vbWlhbCBjb2VmZmljaWVudHMsIGltcGxpY2l0IGZpcnN0IGFuZCBsYXN0IGNvbnRyb2wgcG9pbnRzIGFyZSAoMCwwKSBhbmQgKDEsMSkuXG4gICAgdGhpcy5jeCA9IDMuMCAqIHAxeDtcbiAgICB0aGlzLmJ4ID0gMy4wICogKHAyeCAtIHAxeCkgLSB0aGlzLmN4O1xuICAgIHRoaXMuYXggPSAxLjAgLSB0aGlzLmN4IC0gdGhpcy5ieDtcblxuICAgIHRoaXMuY3kgPSAzLjAgKiBwMXk7XG4gICAgdGhpcy5ieSA9IDMuMCAqIChwMnkgLSBwMXkpIC0gdGhpcy5jeTtcbiAgICB0aGlzLmF5ID0gMS4wIC0gdGhpcy5jeSAtIHRoaXMuYnk7XG5cbiAgICB0aGlzLnAxeCA9IHAxeDtcbiAgICB0aGlzLnAxeSA9IHAyeTtcbiAgICB0aGlzLnAyeCA9IHAyeDtcbiAgICB0aGlzLnAyeSA9IHAyeTtcbn1cblxuVW5pdEJlemllci5wcm90b3R5cGUuc2FtcGxlQ3VydmVYID0gZnVuY3Rpb24odCkge1xuICAgIC8vIGBheCB0XjMgKyBieCB0XjIgKyBjeCB0JyBleHBhbmRlZCB1c2luZyBIb3JuZXIncyBydWxlLlxuICAgIHJldHVybiAoKHRoaXMuYXggKiB0ICsgdGhpcy5ieCkgKiB0ICsgdGhpcy5jeCkgKiB0O1xufTtcblxuVW5pdEJlemllci5wcm90b3R5cGUuc2FtcGxlQ3VydmVZID0gZnVuY3Rpb24odCkge1xuICAgIHJldHVybiAoKHRoaXMuYXkgKiB0ICsgdGhpcy5ieSkgKiB0ICsgdGhpcy5jeSkgKiB0O1xufTtcblxuVW5pdEJlemllci5wcm90b3R5cGUuc2FtcGxlQ3VydmVEZXJpdmF0aXZlWCA9IGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gKDMuMCAqIHRoaXMuYXggKiB0ICsgMi4wICogdGhpcy5ieCkgKiB0ICsgdGhpcy5jeDtcbn07XG5cblVuaXRCZXppZXIucHJvdG90eXBlLnNvbHZlQ3VydmVYID0gZnVuY3Rpb24oeCwgZXBzaWxvbikge1xuICAgIGlmICh0eXBlb2YgZXBzaWxvbiA9PT0gJ3VuZGVmaW5lZCcpIGVwc2lsb24gPSAxZS02O1xuXG4gICAgdmFyIHQwLCB0MSwgdDIsIHgyLCBpO1xuXG4gICAgLy8gRmlyc3QgdHJ5IGEgZmV3IGl0ZXJhdGlvbnMgb2YgTmV3dG9uJ3MgbWV0aG9kIC0tIG5vcm1hbGx5IHZlcnkgZmFzdC5cbiAgICBmb3IgKHQyID0geCwgaSA9IDA7IGkgPCA4OyBpKyspIHtcblxuICAgICAgICB4MiA9IHRoaXMuc2FtcGxlQ3VydmVYKHQyKSAtIHg7XG4gICAgICAgIGlmIChNYXRoLmFicyh4MikgPCBlcHNpbG9uKSByZXR1cm4gdDI7XG5cbiAgICAgICAgdmFyIGQyID0gdGhpcy5zYW1wbGVDdXJ2ZURlcml2YXRpdmVYKHQyKTtcbiAgICAgICAgaWYgKE1hdGguYWJzKGQyKSA8IDFlLTYpIGJyZWFrO1xuXG4gICAgICAgIHQyID0gdDIgLSB4MiAvIGQyO1xuICAgIH1cblxuICAgIC8vIEZhbGwgYmFjayB0byB0aGUgYmlzZWN0aW9uIG1ldGhvZCBmb3IgcmVsaWFiaWxpdHkuXG4gICAgdDAgPSAwLjA7XG4gICAgdDEgPSAxLjA7XG4gICAgdDIgPSB4O1xuXG4gICAgaWYgKHQyIDwgdDApIHJldHVybiB0MDtcbiAgICBpZiAodDIgPiB0MSkgcmV0dXJuIHQxO1xuXG4gICAgd2hpbGUgKHQwIDwgdDEpIHtcblxuICAgICAgICB4MiA9IHRoaXMuc2FtcGxlQ3VydmVYKHQyKTtcbiAgICAgICAgaWYgKE1hdGguYWJzKHgyIC0geCkgPCBlcHNpbG9uKSByZXR1cm4gdDI7XG5cbiAgICAgICAgaWYgKHggPiB4Mikge1xuICAgICAgICAgICAgdDAgPSB0MjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHQxID0gdDI7XG4gICAgICAgIH1cblxuICAgICAgICB0MiA9ICh0MSAtIHQwKSAqIDAuNSArIHQwO1xuICAgIH1cblxuICAgIC8vIEZhaWx1cmUuXG4gICAgcmV0dXJuIHQyO1xufTtcblxuVW5pdEJlemllci5wcm90b3R5cGUuc29sdmUgPSBmdW5jdGlvbih4LCBlcHNpbG9uKSB7XG4gICAgcmV0dXJuIHRoaXMuc2FtcGxlQ3VydmVZKHRoaXMuc29sdmVDdXJ2ZVgoeCwgZXBzaWxvbikpO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzLlZlY3RvclRpbGUgPSByZXF1aXJlKCcuL2xpYi92ZWN0b3J0aWxlLmpzJyk7XG5tb2R1bGUuZXhwb3J0cy5WZWN0b3JUaWxlRmVhdHVyZSA9IHJlcXVpcmUoJy4vbGliL3ZlY3RvcnRpbGVmZWF0dXJlLmpzJyk7XG5tb2R1bGUuZXhwb3J0cy5WZWN0b3JUaWxlTGF5ZXIgPSByZXF1aXJlKCcuL2xpYi92ZWN0b3J0aWxlbGF5ZXIuanMnKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFZlY3RvclRpbGVMYXllciA9IHJlcXVpcmUoJy4vdmVjdG9ydGlsZWxheWVyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gVmVjdG9yVGlsZTtcblxuZnVuY3Rpb24gVmVjdG9yVGlsZShwYmYsIGVuZCkge1xuICAgIHRoaXMubGF5ZXJzID0gcGJmLnJlYWRGaWVsZHMocmVhZFRpbGUsIHt9LCBlbmQpO1xufVxuXG5mdW5jdGlvbiByZWFkVGlsZSh0YWcsIGxheWVycywgcGJmKSB7XG4gICAgaWYgKHRhZyA9PT0gMykge1xuICAgICAgICB2YXIgbGF5ZXIgPSBuZXcgVmVjdG9yVGlsZUxheWVyKHBiZiwgcGJmLnJlYWRWYXJpbnQoKSArIHBiZi5wb3MpO1xuICAgICAgICBpZiAobGF5ZXIubGVuZ3RoKSBsYXllcnNbbGF5ZXIubmFtZV0gPSBsYXllcjtcbiAgICB9XG59XG5cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFBvaW50ID0gcmVxdWlyZSgncG9pbnQtZ2VvbWV0cnknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBWZWN0b3JUaWxlRmVhdHVyZTtcblxuZnVuY3Rpb24gVmVjdG9yVGlsZUZlYXR1cmUocGJmLCBlbmQsIGV4dGVudCwga2V5cywgdmFsdWVzKSB7XG4gICAgLy8gUHVibGljXG4gICAgdGhpcy5wcm9wZXJ0aWVzID0ge307XG4gICAgdGhpcy5leHRlbnQgPSBleHRlbnQ7XG4gICAgdGhpcy50eXBlID0gMDtcblxuICAgIC8vIFByaXZhdGVcbiAgICB0aGlzLl9wYmYgPSBwYmY7XG4gICAgdGhpcy5fZ2VvbWV0cnkgPSAtMTtcbiAgICB0aGlzLl9rZXlzID0ga2V5cztcbiAgICB0aGlzLl92YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgICBwYmYucmVhZEZpZWxkcyhyZWFkRmVhdHVyZSwgdGhpcywgZW5kKTtcbn1cblxuZnVuY3Rpb24gcmVhZEZlYXR1cmUodGFnLCBmZWF0dXJlLCBwYmYpIHtcbiAgICBpZiAodGFnID09IDEpIGZlYXR1cmUuX2lkID0gcGJmLnJlYWRWYXJpbnQoKTtcbiAgICBlbHNlIGlmICh0YWcgPT0gMikgcmVhZFRhZyhwYmYsIGZlYXR1cmUpO1xuICAgIGVsc2UgaWYgKHRhZyA9PSAzKSBmZWF0dXJlLnR5cGUgPSBwYmYucmVhZFZhcmludCgpO1xuICAgIGVsc2UgaWYgKHRhZyA9PSA0KSBmZWF0dXJlLl9nZW9tZXRyeSA9IHBiZi5wb3M7XG59XG5cbmZ1bmN0aW9uIHJlYWRUYWcocGJmLCBmZWF0dXJlKSB7XG4gICAgdmFyIGVuZCA9IHBiZi5yZWFkVmFyaW50KCkgKyBwYmYucG9zO1xuXG4gICAgd2hpbGUgKHBiZi5wb3MgPCBlbmQpIHtcbiAgICAgICAgdmFyIGtleSA9IGZlYXR1cmUuX2tleXNbcGJmLnJlYWRWYXJpbnQoKV0sXG4gICAgICAgICAgICB2YWx1ZSA9IGZlYXR1cmUuX3ZhbHVlc1twYmYucmVhZFZhcmludCgpXTtcbiAgICAgICAgZmVhdHVyZS5wcm9wZXJ0aWVzW2tleV0gPSB2YWx1ZTtcbiAgICB9XG59XG5cblZlY3RvclRpbGVGZWF0dXJlLnR5cGVzID0gWydVbmtub3duJywgJ1BvaW50JywgJ0xpbmVTdHJpbmcnLCAnUG9seWdvbiddO1xuXG5WZWN0b3JUaWxlRmVhdHVyZS5wcm90b3R5cGUubG9hZEdlb21ldHJ5ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHBiZiA9IHRoaXMuX3BiZjtcbiAgICBwYmYucG9zID0gdGhpcy5fZ2VvbWV0cnk7XG5cbiAgICB2YXIgZW5kID0gcGJmLnJlYWRWYXJpbnQoKSArIHBiZi5wb3MsXG4gICAgICAgIGNtZCA9IDEsXG4gICAgICAgIGxlbmd0aCA9IDAsXG4gICAgICAgIHggPSAwLFxuICAgICAgICB5ID0gMCxcbiAgICAgICAgbGluZXMgPSBbXSxcbiAgICAgICAgbGluZTtcblxuICAgIHdoaWxlIChwYmYucG9zIDwgZW5kKSB7XG4gICAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgY21kTGVuID0gcGJmLnJlYWRWYXJpbnQoKTtcbiAgICAgICAgICAgIGNtZCA9IGNtZExlbiAmIDB4NztcbiAgICAgICAgICAgIGxlbmd0aCA9IGNtZExlbiA+PiAzO1xuICAgICAgICB9XG5cbiAgICAgICAgbGVuZ3RoLS07XG5cbiAgICAgICAgaWYgKGNtZCA9PT0gMSB8fCBjbWQgPT09IDIpIHtcbiAgICAgICAgICAgIHggKz0gcGJmLnJlYWRTVmFyaW50KCk7XG4gICAgICAgICAgICB5ICs9IHBiZi5yZWFkU1ZhcmludCgpO1xuXG4gICAgICAgICAgICBpZiAoY21kID09PSAxKSB7IC8vIG1vdmVUb1xuICAgICAgICAgICAgICAgIGlmIChsaW5lKSBsaW5lcy5wdXNoKGxpbmUpO1xuICAgICAgICAgICAgICAgIGxpbmUgPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGluZS5wdXNoKG5ldyBQb2ludCh4LCB5KSk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjbWQgPT09IDcpIHtcblxuICAgICAgICAgICAgLy8gV29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL21hcGJveC9tYXBuaWstdmVjdG9yLXRpbGUvaXNzdWVzLzkwXG4gICAgICAgICAgICBpZiAobGluZSkge1xuICAgICAgICAgICAgICAgIGxpbmUucHVzaChsaW5lWzBdLmNsb25lKCkpOyAvLyBjbG9zZVBvbHlnb25cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGNvbW1hbmQgJyArIGNtZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobGluZSkgbGluZXMucHVzaChsaW5lKTtcblxuICAgIHJldHVybiBsaW5lcztcbn07XG5cblZlY3RvclRpbGVGZWF0dXJlLnByb3RvdHlwZS5iYm94ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHBiZiA9IHRoaXMuX3BiZjtcbiAgICBwYmYucG9zID0gdGhpcy5fZ2VvbWV0cnk7XG5cbiAgICB2YXIgZW5kID0gcGJmLnJlYWRWYXJpbnQoKSArIHBiZi5wb3MsXG4gICAgICAgIGNtZCA9IDEsXG4gICAgICAgIGxlbmd0aCA9IDAsXG4gICAgICAgIHggPSAwLFxuICAgICAgICB5ID0gMCxcbiAgICAgICAgeDEgPSBJbmZpbml0eSxcbiAgICAgICAgeDIgPSAtSW5maW5pdHksXG4gICAgICAgIHkxID0gSW5maW5pdHksXG4gICAgICAgIHkyID0gLUluZmluaXR5O1xuXG4gICAgd2hpbGUgKHBiZi5wb3MgPCBlbmQpIHtcbiAgICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBjbWRMZW4gPSBwYmYucmVhZFZhcmludCgpO1xuICAgICAgICAgICAgY21kID0gY21kTGVuICYgMHg3O1xuICAgICAgICAgICAgbGVuZ3RoID0gY21kTGVuID4+IDM7XG4gICAgICAgIH1cblxuICAgICAgICBsZW5ndGgtLTtcblxuICAgICAgICBpZiAoY21kID09PSAxIHx8IGNtZCA9PT0gMikge1xuICAgICAgICAgICAgeCArPSBwYmYucmVhZFNWYXJpbnQoKTtcbiAgICAgICAgICAgIHkgKz0gcGJmLnJlYWRTVmFyaW50KCk7XG4gICAgICAgICAgICBpZiAoeCA8IHgxKSB4MSA9IHg7XG4gICAgICAgICAgICBpZiAoeCA+IHgyKSB4MiA9IHg7XG4gICAgICAgICAgICBpZiAoeSA8IHkxKSB5MSA9IHk7XG4gICAgICAgICAgICBpZiAoeSA+IHkyKSB5MiA9IHk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjbWQgIT09IDcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBjb21tYW5kICcgKyBjbWQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFt4MSwgeTEsIHgyLCB5Ml07XG59O1xuXG5WZWN0b3JUaWxlRmVhdHVyZS5wcm90b3R5cGUudG9HZW9KU09OID0gZnVuY3Rpb24oeCwgeSwgeikge1xuICAgIHZhciBzaXplID0gdGhpcy5leHRlbnQgKiBNYXRoLnBvdygyLCB6KSxcbiAgICAgICAgeDAgPSB0aGlzLmV4dGVudCAqIHgsXG4gICAgICAgIHkwID0gdGhpcy5leHRlbnQgKiB5LFxuICAgICAgICBjb29yZHMgPSB0aGlzLmxvYWRHZW9tZXRyeSgpLFxuICAgICAgICB0eXBlID0gVmVjdG9yVGlsZUZlYXR1cmUudHlwZXNbdGhpcy50eXBlXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29vcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBsaW5lID0gY29vcmRzW2ldO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxpbmUubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBwID0gbGluZVtqXSwgeTIgPSAxODAgLSAocC55ICsgeTApICogMzYwIC8gc2l6ZTtcbiAgICAgICAgICAgIGxpbmVbal0gPSBbXG4gICAgICAgICAgICAgICAgKHAueCArIHgwKSAqIDM2MCAvIHNpemUgLSAxODAsXG4gICAgICAgICAgICAgICAgMzYwIC8gTWF0aC5QSSAqIE1hdGguYXRhbihNYXRoLmV4cCh5MiAqIE1hdGguUEkgLyAxODApKSAtIDkwXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09ICdQb2ludCcgJiYgY29vcmRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBjb29yZHMgPSBjb29yZHNbMF1bMF07XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnUG9pbnQnKSB7XG4gICAgICAgIGNvb3JkcyA9IGNvb3Jkc1swXTtcbiAgICAgICAgdHlwZSA9ICdNdWx0aVBvaW50JztcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdMaW5lU3RyaW5nJyAmJiBjb29yZHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGNvb3JkcyA9IGNvb3Jkc1swXTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdMaW5lU3RyaW5nJykge1xuICAgICAgICB0eXBlID0gJ011bHRpTGluZVN0cmluZyc7XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgdHlwZTogXCJGZWF0dXJlXCIsXG4gICAgICAgIGdlb21ldHJ5OiB7XG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgY29vcmRpbmF0ZXM6IGNvb3Jkc1xuICAgICAgICB9LFxuICAgICAgICBwcm9wZXJ0aWVzOiB0aGlzLnByb3BlcnRpZXNcbiAgICB9O1xuXG4gICAgaWYgKCdfaWQnIGluIHRoaXMpIHtcbiAgICAgICAgcmVzdWx0LmlkID0gdGhpcy5faWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBWZWN0b3JUaWxlRmVhdHVyZSA9IHJlcXVpcmUoJy4vdmVjdG9ydGlsZWZlYXR1cmUuanMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBWZWN0b3JUaWxlTGF5ZXI7XG5cbmZ1bmN0aW9uIFZlY3RvclRpbGVMYXllcihwYmYsIGVuZCkge1xuICAgIC8vIFB1YmxpY1xuICAgIHRoaXMudmVyc2lvbiA9IDE7XG4gICAgdGhpcy5uYW1lID0gbnVsbDtcbiAgICB0aGlzLmV4dGVudCA9IDQwOTY7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuXG4gICAgLy8gUHJpdmF0ZVxuICAgIHRoaXMuX3BiZiA9IHBiZjtcbiAgICB0aGlzLl9rZXlzID0gW107XG4gICAgdGhpcy5fdmFsdWVzID0gW107XG4gICAgdGhpcy5fZmVhdHVyZXMgPSBbXTtcblxuICAgIHBiZi5yZWFkRmllbGRzKHJlYWRMYXllciwgdGhpcywgZW5kKTtcblxuICAgIHRoaXMubGVuZ3RoID0gdGhpcy5fZmVhdHVyZXMubGVuZ3RoO1xufVxuXG5mdW5jdGlvbiByZWFkTGF5ZXIodGFnLCBsYXllciwgcGJmKSB7XG4gICAgaWYgKHRhZyA9PT0gMTUpIGxheWVyLnZlcnNpb24gPSBwYmYucmVhZFZhcmludCgpO1xuICAgIGVsc2UgaWYgKHRhZyA9PT0gMSkgbGF5ZXIubmFtZSA9IHBiZi5yZWFkU3RyaW5nKCk7XG4gICAgZWxzZSBpZiAodGFnID09PSA1KSBsYXllci5leHRlbnQgPSBwYmYucmVhZFZhcmludCgpO1xuICAgIGVsc2UgaWYgKHRhZyA9PT0gMikgbGF5ZXIuX2ZlYXR1cmVzLnB1c2gocGJmLnBvcyk7XG4gICAgZWxzZSBpZiAodGFnID09PSAzKSBsYXllci5fa2V5cy5wdXNoKHBiZi5yZWFkU3RyaW5nKCkpO1xuICAgIGVsc2UgaWYgKHRhZyA9PT0gNCkgbGF5ZXIuX3ZhbHVlcy5wdXNoKHJlYWRWYWx1ZU1lc3NhZ2UocGJmKSk7XG59XG5cbmZ1bmN0aW9uIHJlYWRWYWx1ZU1lc3NhZ2UocGJmKSB7XG4gICAgdmFyIHZhbHVlID0gbnVsbCxcbiAgICAgICAgZW5kID0gcGJmLnJlYWRWYXJpbnQoKSArIHBiZi5wb3M7XG5cbiAgICB3aGlsZSAocGJmLnBvcyA8IGVuZCkge1xuICAgICAgICB2YXIgdGFnID0gcGJmLnJlYWRWYXJpbnQoKSA+PiAzO1xuXG4gICAgICAgIHZhbHVlID0gdGFnID09PSAxID8gcGJmLnJlYWRTdHJpbmcoKSA6XG4gICAgICAgICAgICB0YWcgPT09IDIgPyBwYmYucmVhZEZsb2F0KCkgOlxuICAgICAgICAgICAgdGFnID09PSAzID8gcGJmLnJlYWREb3VibGUoKSA6XG4gICAgICAgICAgICB0YWcgPT09IDQgPyBwYmYucmVhZFZhcmludDY0KCkgOlxuICAgICAgICAgICAgdGFnID09PSA1ID8gcGJmLnJlYWRWYXJpbnQoKSA6XG4gICAgICAgICAgICB0YWcgPT09IDYgPyBwYmYucmVhZFNWYXJpbnQoKSA6XG4gICAgICAgICAgICB0YWcgPT09IDcgPyBwYmYucmVhZEJvb2xlYW4oKSA6IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG4vLyByZXR1cm4gZmVhdHVyZSBgaWAgZnJvbSB0aGlzIGxheWVyIGFzIGEgYFZlY3RvclRpbGVGZWF0dXJlYFxuVmVjdG9yVGlsZUxheWVyLnByb3RvdHlwZS5mZWF0dXJlID0gZnVuY3Rpb24oaSkge1xuICAgIGlmIChpIDwgMCB8fCBpID49IHRoaXMuX2ZlYXR1cmVzLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdmZWF0dXJlIGluZGV4IG91dCBvZiBib3VuZHMnKTtcblxuICAgIHRoaXMuX3BiZi5wb3MgPSB0aGlzLl9mZWF0dXJlc1tpXTtcblxuICAgIHZhciBlbmQgPSB0aGlzLl9wYmYucmVhZFZhcmludCgpICsgdGhpcy5fcGJmLnBvcztcbiAgICByZXR1cm4gbmV3IFZlY3RvclRpbGVGZWF0dXJlKHRoaXMuX3BiZiwgZW5kLCB0aGlzLmV4dGVudCwgdGhpcy5fa2V5cywgdGhpcy5fdmFsdWVzKTtcbn07XG4iLCJ2YXIgYnVuZGxlRm4gPSBhcmd1bWVudHNbM107XG52YXIgc291cmNlcyA9IGFyZ3VtZW50c1s0XTtcbnZhciBjYWNoZSA9IGFyZ3VtZW50c1s1XTtcblxudmFyIHN0cmluZ2lmeSA9IEpTT04uc3RyaW5naWZ5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbikge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgdmFyIHdrZXk7XG4gICAgdmFyIGNhY2hlS2V5cyA9IE9iamVjdC5rZXlzKGNhY2hlKTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2FjaGVLZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIga2V5ID0gY2FjaGVLZXlzW2ldO1xuICAgICAgICB2YXIgZXhwID0gY2FjaGVba2V5XS5leHBvcnRzO1xuICAgICAgICAvLyBVc2luZyBiYWJlbCBhcyBhIHRyYW5zcGlsZXIgdG8gdXNlIGVzbW9kdWxlLCB0aGUgZXhwb3J0IHdpbGwgYWx3YXlzXG4gICAgICAgIC8vIGJlIGFuIG9iamVjdCB3aXRoIHRoZSBkZWZhdWx0IGV4cG9ydCBhcyBhIHByb3BlcnR5IG9mIGl0LiBUbyBlbnN1cmVcbiAgICAgICAgLy8gdGhlIGV4aXN0aW5nIGFwaSBhbmQgYmFiZWwgZXNtb2R1bGUgZXhwb3J0cyBhcmUgYm90aCBzdXBwb3J0ZWQgd2VcbiAgICAgICAgLy8gY2hlY2sgZm9yIGJvdGhcbiAgICAgICAgaWYgKGV4cCA9PT0gZm4gfHwgZXhwLmRlZmF1bHQgPT09IGZuKSB7XG4gICAgICAgICAgICB3a2V5ID0ga2V5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXdrZXkpIHtcbiAgICAgICAgd2tleSA9IE1hdGguZmxvb3IoTWF0aC5wb3coMTYsIDgpICogTWF0aC5yYW5kb20oKSkudG9TdHJpbmcoMTYpO1xuICAgICAgICB2YXIgd2NhY2hlID0ge307XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2FjaGVLZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgdmFyIGtleSA9IGNhY2hlS2V5c1tpXTtcbiAgICAgICAgICAgIHdjYWNoZVtrZXldID0ga2V5O1xuICAgICAgICB9XG4gICAgICAgIHNvdXJjZXNbd2tleV0gPSBbXG4gICAgICAgICAgICBGdW5jdGlvbihbJ3JlcXVpcmUnLCdtb2R1bGUnLCdleHBvcnRzJ10sICcoJyArIGZuICsgJykoc2VsZiknKSxcbiAgICAgICAgICAgIHdjYWNoZVxuICAgICAgICBdO1xuICAgIH1cbiAgICB2YXIgc2tleSA9IE1hdGguZmxvb3IoTWF0aC5wb3coMTYsIDgpICogTWF0aC5yYW5kb20oKSkudG9TdHJpbmcoMTYpO1xuXG4gICAgdmFyIHNjYWNoZSA9IHt9OyBzY2FjaGVbd2tleV0gPSB3a2V5O1xuICAgIHNvdXJjZXNbc2tleV0gPSBbXG4gICAgICAgIEZ1bmN0aW9uKFsncmVxdWlyZSddLCAoXG4gICAgICAgICAgICAvLyB0cnkgdG8gY2FsbCBkZWZhdWx0IGlmIGRlZmluZWQgdG8gYWxzbyBzdXBwb3J0IGJhYmVsIGVzbW9kdWxlXG4gICAgICAgICAgICAvLyBleHBvcnRzXG4gICAgICAgICAgICAndmFyIGYgPSByZXF1aXJlKCcgKyBzdHJpbmdpZnkod2tleSkgKyAnKTsnICtcbiAgICAgICAgICAgICcoZi5kZWZhdWx0ID8gZi5kZWZhdWx0IDogZikoc2VsZik7J1xuICAgICAgICApKSxcbiAgICAgICAgc2NhY2hlXG4gICAgXTtcblxuICAgIHZhciBzcmMgPSAnKCcgKyBidW5kbGVGbiArICcpKHsnXG4gICAgICAgICsgT2JqZWN0LmtleXMoc291cmNlcykubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmdpZnkoa2V5KSArICc6WydcbiAgICAgICAgICAgICAgICArIHNvdXJjZXNba2V5XVswXVxuICAgICAgICAgICAgICAgICsgJywnICsgc3RyaW5naWZ5KHNvdXJjZXNba2V5XVsxXSkgKyAnXSdcbiAgICAgICAgICAgIDtcbiAgICAgICAgfSkuam9pbignLCcpXG4gICAgICAgICsgJ30se30sWycgKyBzdHJpbmdpZnkoc2tleSkgKyAnXSknXG4gICAgO1xuXG4gICAgdmFyIFVSTCA9IHdpbmRvdy5VUkwgfHwgd2luZG93LndlYmtpdFVSTCB8fCB3aW5kb3cubW96VVJMIHx8IHdpbmRvdy5tc1VSTDtcblxuICAgIHJldHVybiBuZXcgV29ya2VyKFVSTC5jcmVhdGVPYmplY3RVUkwoXG4gICAgICAgIG5ldyBCbG9iKFtzcmNdLCB7IHR5cGU6ICd0ZXh0L2phdmFzY3JpcHQnIH0pXG4gICAgKSk7XG59O1xuIl19
